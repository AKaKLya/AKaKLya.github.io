[{"content":"蘸豆 爽！ 生命值 = 当前生命值 - 即将到来的伤害.\nAttributeSet Class\n1 2 3 UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } } 受击反馈 1 2 3 4 5 6 7 8 9 10 11 12 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } 这是上文的伤害血量计算. 如果不是致命伤害，就播放 受击动画.\n被打也是一种技能. 受到伤害后 触发GA. 被打的GA要在角色生成时 就要GiveAbility. 作为天生技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } } } 受击 → 触发GA → 应用GE，添加Effect.HitReact标签 → 播放受击动画 → 动画结束 → 移除GE添加的标签 → 结束技能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void AAuraEnemy::BeginPlay() { Super::BeginPlay(); InitAbilityActorInfo(); GetCharacterMovement()-\u0026gt;MaxWalkSpeed = BaseWalkSpeed; UAuraAbilitySystemLibrary::GiveStartupAbilities(this,AbilitySystemComponent); if (UAuraUserWidget* AuraUserWidget = Cast\u0026lt;UAuraUserWidget\u0026gt;(HealthBar-\u0026gt;GetUserWidgetObject())) { AuraUserWidget-\u0026gt;SetWidgetController(this); } if (UAuraAttributeSet* AuraAS = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet)) { AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetMaxHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); OnHealthChanged.Broadcast(AuraAS-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAS-\u0026gt;GetMaxHealth()); } } void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 1 2 3 4 5 6 7 8 9 FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 如果Effect_HitReact标签数量大于0，移动速度设置为0，否则就是正常移动速度.\n1 2 3 4 5 6 7 8 9 10 11 12 13 UENUM(BlueprintType) namespace EGameplayTagEventType { /** Rather a tag was added or removed, used in callbacks */ enum Type : int { /** Event only happens when tag is new or completely removed */ NewOrRemoved, /** Event happens any time tag \u0026#34;count\u0026#34; changes */ AnyCountChange }; } 死亡？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(Props.TargetAvatarActor); if (CombatInterface) { CombatInterface-\u0026gt;Die(); } } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } // 显示伤害数字 ShowFloatingText(Props,LocalIncomingDamage); } } 血量小于0，就调用Die，怎么写？ 随便.\n加了一个 显示伤害数字 的功能， 调用到了 玩家控制器 的函数 ， 把 伤害值 和 受击Actor 的位置 传过去了\n1 2 3 4 5 6 7 8 9 10 11 void UAuraAttributeSet::ShowFloatingText(const FEffectProperites\u0026amp; Props, float Damage) { if (Props.SourceCharacter != Props.TargetCharacter) { AAuraPlayerController* PC = Cast\u0026lt;AAuraPlayerController\u0026gt;(UGameplayStatics::GetPlayerController(this, 0)); if (PC) { PC-\u0026gt;ShowDamageNumber(Damage,Props.TargetCharacter); } } } 玩家控制器 创建一个 DamageText 组件. 根据 传入的位置 设置组件的位置， 把伤害值 传给组件内部.\n1 2 3 4 5 6 7 8 9 10 11 void AAuraPlayerController::ShowDamageNumber_Implementation(float DamageAmount,ACharacter* TargetCharacter) { if (IsValid(TargetCharacter) \u0026amp;\u0026amp; DamageTextComponentClass) { UDamageTextComponent* DamageText = NewObject\u0026lt;UDamageTextComponent\u0026gt;(TargetCharacter,DamageTextComponentClass); DamageText-\u0026gt;RegisterComponent(); DamageText-\u0026gt;AttachToComponent(TargetCharacter-\u0026gt;GetRootComponent(),FAttachmentTransformRules::KeepRelativeTransform); DamageText-\u0026gt;DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform); DamageText-\u0026gt;SetDamageText(DamageAmount); } } SetDamageText是个蓝图实现的函数\n1 2 3 4 5 6 7 8 9 UCLASS() class AURA_API UDamageTextComponent : public UWidgetComponent { GENERATED_BODY() public: UFUNCTION(BlueprintImplementableEvent,BlueprintCallable) void SetDamageText(float Damage); }; UMG在构造函数里 播放这个K出来的数字动画，完事.\n计算伤害 头晕 不想写\nGameplayEffectContext 谁设置了这些Context？\n1 2 UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); ↓\n1 2 3 4 5 6 7 8 9 10 11 12 FGameplayEffectContextHandle UAbilitySystemComponent::MakeEffectContext() const { FGameplayEffectContextHandle Context = FGameplayEffectContextHandle(UAbilitySystemGlobals::Get().AllocGameplayEffectContext()); // By default use the owner and avatar as the instigator and causer if (ensureMsgf(AbilityActorInfo.IsValid(), TEXT(\u0026#34;Unable to make effect context because AbilityActorInfo is not valid.\u0026#34;))) { Context.AddInstigator(AbilityActorInfo-\u0026gt;OwnerActor.Get(), AbilityActorInfo-\u0026gt;AvatarActor.Get()); } return Context; } ↓\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { if (IsValid()) { Data-\u0026gt;AddInstigator(InInstigator, InEffectCauser); } } void FGameplayEffectContext::AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { Instigator = InInstigator; bReplicateInstigator = CanActorReferenceBeReplicated(InInstigator); SetEffectCauser(InEffectCauser); InstigatorAbilitySystemComponent = NULL; // Cache off the AbilitySystemComponent. InstigatorAbilitySystemComponent = UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(Instigator.Get()); } MakeEffectContext最终调用到了AddInstigator，设置Instigator、EffectCauser、InstigatorASC\n以及 MakeEffectContext 调用的构造函数，初始化了一些变量.\n1 2 3 4 5 6 7 8 9 FGameplayEffectContext() : AbilityLevel(1) , WorldOrigin(ForceInitToZero) , bHasWorldOrigin(false) , bReplicateSourceObject(false) , bReplicateInstigator(false) , bReplicateEffectCauser(false) { } 其它属性还没有设置，剩下的属性应该怎么用？\n以火球技能为例，void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); Context.SetAbility(this); Context.AddSourceObject(Projectile); FHitResult HitResult; HitResult.Location = TargetLocation; Context.AddHitResult(HitResult); TArray\u0026lt;TWeakObjectPtr\u0026lt;AActor\u0026gt;\u0026gt; Actors; Actors.Add(Projectile); Context.AddActors(Actors); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); Custom 扩展Context\n","date":"2025-01-16T17:07:49+08:00","permalink":"https://akaklya.github.io/p/gas-a-%E6%88%98%E6%96%97/","title":"GAS A - 战斗"},{"content":"TODO:属性菜单 没写，太他妈长了，以后再填.\nUI获取GE的GameplayTag消息 应用GE时，获得GE的AssetTag，并且根据这个Tag 做点事情，\n例如：捡到血瓶时，如果GE里面有 Message.xx.xx 的Tag，就通知UI显示“捡到一个血瓶” 之类的文字.\n整体框架:\nOverlayWidgetController.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void UAuraAbilitySystemComponent::AbilityInfoSet() { OnGameplayEffectAppliedDelegateToSelf.AddUObject(this,\u0026amp;UAuraAbilitySystemComponent::ClientEffectApplied); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;EffectAssetTags.AddLambda( [this](const FGameplayTagContainer\u0026amp; AssetTags) { for (const FGameplayTag\u0026amp; Tag : AssetTags) { auto MessageTag = FGameplayTag::RequestGameplayTag(FName(\u0026#34;Message\u0026#34;)); if (Tag.MatchesTag(MessageTag)) { FUIWidgetRow* Row = GetDataTableRowByTag\u0026lt;FUIWidgetRow\u0026gt;(MessageWidgetDataTable,Tag); MessageWidgetRowDelegate.Broadcast(*Row); } } } ); } WidgetController绑定ASC的生命值等属性变化后，再追加一个委托的订阅，ASC在GE应用时 能获得GE的AssetTag，这里只筛选Message的Tag，把它广播出来，WidgetController就能收到ASC应用的GE的标签.\n1 2 3 4 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Messages\u0026#34;) FMessageWidgetRowSignature MessageWidgetRowDelegate; WidgetController里面再来一个委托，让UMG在蓝图里面订阅，把接收到的GE标签广播出去，让UMG订阅接收.\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 USTRUCT() struct FUIWidgetRow : public FTableRowBase { GENERATED_BODY() UPROPERTY(EditAnywhere,BlueprintReadOnly) FGameplayTag AssetTag = FGameplayTag(); UPROPERTY(EditAnywhere,BlueprintReadOnly) FText Message = FText(); UPROPERTY(EditAnywhere,BlueprintReadOnly) TSubclassOf\u0026lt;class UAuraUserWidget\u0026gt; MessageWidget; UPROPERTY(EditAnywhere,BlueprintReadOnly) UTexture2D* Image = nullptr; }; //-------------------------------------// template\u0026lt;typename T\u0026gt; T* GetDataTableRowByTag(UDataTable* DataTable,const FGameplayTag\u0026amp; Tag); template \u0026lt;typename T\u0026gt; T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag\u0026amp; Tag) { return DataTable-\u0026gt;FindRow\u0026lt;T\u0026gt;(Tag.GetTagName(),TEXT(\u0026#34;\u0026#34;)); } //---------------------------------------// 查表，通过Tag获得Message，并广播给蓝图\nMMC 根据等级设置血量\n角色基类AAuraCharacterBase添加一个ICombatInterface接口，Enemy和AAuraCharacter都重写一下GetPlayerLeve函数.Enemy的Level就在Enemy类里面，玩家的Level在PlayerState里面，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 UINTERFACE(MinimalAPI,BlueprintType) class UCombatInterface : public UInterface { GENERATED_BODY() }; /** * */ class AURA_API ICombatInterface { GENERATED_BODY() // Add interface functions to this class. This is the class that will be inherited to implement this interface. public: virtual int32 GetPlayerLeve(); }; //---------------------------// class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface,public ICombatInterface //--------------------------// 1 2 3 4 5 6 7 8 9 10 11 12 int32 AAuraEnemy::GetPlayerLeve() { return Level; } int32 AAuraCharacter::GetPlayerLeve() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState) return AuraPlayerState-\u0026gt;GetPlayerLeve(); } MMC 自定义计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 UCLASS() class AURA_API UMMC_MaxHealth : public UGameplayModMagnitudeCalculation { GENERATED_BODY() public: UMMC_MaxHealth(); virtual float CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const override; private: FGameplayEffectAttributeCaptureDefinition VigorDef; }; UMMC_MaxHealth::UMMC_MaxHealth() { VigorDef.AttributeToCapture = UAuraAttributeSet::GetVigorAttribute(); VigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target; VigorDef.bSnapshot = false; RelevantAttributesToCapture.Add(VigorDef); } float UMMC_MaxHealth::CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const { const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags(); const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags(); FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = SourceTags; EvaluateParameters.TargetTags = TargetTags; float Vigor = 0 ; GetCapturedAttributeMagnitude(VigorDef,Spec,EvaluateParameters,Vigor); Vigor = FMath::Max\u0026lt;float\u0026gt;(Vigor,0.0f); ICombatInterface* Interface = Cast\u0026lt;ICombatInterface\u0026gt;(Spec.GetContext().GetSourceObject()); const int32 PlayerLevel = Interface-\u0026gt;GetPlayerLeve(); return 80 + 2.5 * Vigor + 10.0 * PlayerLevel; } GameplayAbility 1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA里的StartupInputTag是用来绑定输入的，参见后文的 “绑定EnhancedInput“\nASC类里的AddCharacterAbility函数，根据角色类传过来的技能Array赋予技能从StartupAbility里面创建FGameplayAbilitySpec，并且用StartupInputTag作为动态Tag，传入Spec.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 1 2 3 4 5 6 7 /*GameplayAbilitySpec* * An activatable ability spec, hosted on the ability system component. This defines both what the ability is (what class, what level, input binding etc) * and also holds runtime state that must be kept outside of the ability being instanced/activated. */ * 可激活的能力规范，托管在能力系统组件上。这既定义了能力是什么（什么类别、什么级别、输入绑定等） * 也保存了必须保留在实例化/激活的能力之外的运行时状态。 角色基类里用一个TArray保存初始技能，基类AddCharacterAbility函数赋予技能.在玩家类的PossessedBy函数里调用AddCharacterAbility.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 UPROPERTY(EditAnywhere,Category=\u0026#34;Ability\u0026#34;) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; StartupAbility; void AAuraCharacterBase::AddCharacterAbility() { UAuraAbilitySystemComponent* AuraASC = CastChecked\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent); if (!HasAuthority()) return; AuraASC-\u0026gt;AddCharacterAbility(StartupAbility); } void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); AddCharacterAbility(); } GATag Activation Owned Tags 当技能激活时，将设置的Tag应用给技能所有者，在结束时删除。如果将AbilitySystemGlobals里面的配置ReplicateActivationOwnedTags开启，Tag还将会被复制。 Activation Required Tags 当技能激活者拥有设置的所有的Tag时，此技能才能够被激活。 Activation Blocked Tags 当技能激活者有一项设置的Tag，技能就无法被激活 Source Required Tags 当技能所有者拥有设置的所有的Tag时，此技能才能够被激活 Source Blocked Tags 当技能所有者有一项设置的Tag，技能就无法被激活 Target Required Tags 当技能目标者拥有设置的所有的Tag时，此技能才能够被激活 Target Blocked Tags 当技能目标者有一项设置的Tag，技能就无法被激活 绑定EnhancedInput 增强输入\n绑定GameplayTag和InputAction 这是一个用来关联 GameplayTag 和 InputAction的资产 UAuraInputConfig\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 USTRUCT(BlueprintType) struct FAuraInputAction { GENERATED_BODY() UPROPERTY(EditDefaultsOnly) class UInputAction* InputAction = nullptr; UPROPERTY(EditDefaultsOnly) FGameplayTag InputTag = FGameplayTag(); }; UCLASS() class AURA_API UAuraInputConfig : public UDataAsset { GENERATED_BODY() public: const UInputAction* FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag,bool bLogNotFound = false); UPROPERTY(EditDefaultsOnly,BlueprintReadOnly) TArray\u0026lt;FAuraInputAction\u0026gt; AbilityInputActions; }; //------------------------------------// const UInputAction* UAuraInputConfig::FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag, bool bLogNotFound) { for (const auto\u0026amp; Action : AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag == InputTag) { return Action.InputAction; } } if (bLogNotFound) { UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Can Not Found AbilityInputAction for InputTag [%s] on InputConfig [%s]\u0026#34;), *InputTag.ToString(),*GetNameSafe(this)); } return nullptr; } 创建增强输入组件，继承自UEnhancedInputComponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 UCLASS() class AURA_API UAuraInputComponent : public UEnhancedInputComponent { GENERATED_BODY() public: template\u0026lt;class UserClass,typename PressedFuncType,typename ReleasedFuncType,typename HeldFuncType\u0026gt; void BindAbilityActions(const UAuraInputConfig* InputConfig,UserClass* Object, PressedFuncType PressedFunc,ReleasedFuncType ReleasedFunc,HeldFuncType HeldFunc); }; template \u0026lt;class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\u0026gt; void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) { check(InputConfig); for (const auto\u0026amp; Action : InputConfig-\u0026gt;AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag.IsValid()) { if (PressedFunc) { BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); } if (ReleasedFunc) { BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); } if (HeldFunc) { BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); } } } } typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\n这3个参数 传入函数时，编译器会自动推导其类型可以把 \u0026amp;AAuraPlayerController::AbilityInputTagPressed 这样的参数传入进去.\n在玩家控制器里调用这个BindAbilityActions函数， 来绑定GameplayTag和InputAction.\n准备3个输入函数，分别是 Pressed、Released、Held 状态下的输入， 按下、释放、按住.\n并且这3个函数可以接收传来的FGameplayTag InputTag，因为上面的增强输入在绑定时，就可以把参数传到函数里.\n1 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction的最后两个参数 - PressedFunc函数被调用时，会把Action.InputTag传给这个函数. 所以可以使用AbilityInputTagPressed(FGameplayTag InputTag) 这样的函数 去接收传来的InputTag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { } 使用准备好的UAuraInputConfig资产 绑定输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //AuraPlayerController.h\tUPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) TObjectPtr\u0026lt;UAuraInputConfig\u0026gt; InputConfig; void AAuraPlayerController::SetupInputComponent() { Super::SetupInputComponent(); UAuraInputComponent* AuraInputComponent = CastChecked\u0026lt;UAuraInputComponent\u0026gt;(InputComponent); AuraInputComponent-\u0026gt;BindAction(MoveAction,ETriggerEvent::Triggered,this,\u0026amp;AAuraPlayerController::Move); AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); } 注意执行输入的参数顺序Press,Released,Held\n1 2 3 4 5 void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); 现在就把 GameplayTag 和 玩家控制器 里面的函数绑定上了，\n总结 回顾整个流程，\n1.首先创建了一个资产UAuraInputConfig，这个资产定义了 GameplayTag 和 InputAction 绑定关系，2.在 玩家控制器 里面，指定了UAuraInputConfig，再调用 增强输入 的函数，使用这个资产进行 GameplayTag和InputAction的绑定.3.增强输入 利用InputAction绑定一个要执行的函数，按下按键时 执行哪一个函数.4.绑定完了函数 还不够， 按下按键时执行函数 并且函数还要接收到对应的那个 GameplayTag.\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); 第4个条件 就是用这个BindAction绑定起来的，当按下按键时、松开按键时、持续按住按键时、都会把 Action.InputTag 传给对应的 响应函数.\n这样就实现了 按下按键时，还能获得对应按键的GameplayTag.\n1 2 3 4 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } 这个函数就能接收到 GameplayTag 的值.\n1 2 3 4 5 6 7 8 template\u0026lt;class UserClass, typename... VarTypes\u0026gt;\t\\ FEnhancedInputActionEventBinding\u0026amp; BindAction(const UInputAction* Action, ETriggerEvent TriggerEvent, UserClass* Object, typename HANDLER_SIG::template TMethodPtr\u0026lt; UserClass, VarTypes... \u0026gt; Func, VarTypes... Vars) \\ {\t\\ TUniquePtr\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt; AB = MakeUnique\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt;(Action, TriggerEvent);\t\\ AB-\u0026gt;Delegate.BindDelegate\u0026lt;UserClass\u0026gt;(Object, Func, Vars...);\t\\ AB-\u0026gt;Delegate.SetShouldFireWithEditorScriptGuard(bShouldFireDelegatesInEditor);\t\\ return *EnhancedActionEventBindings.Add_GetRef(MoveTemp(AB));\t\\ } 这是增强输入里使用的变参模板，应该是可以让按下按键时 触发的那个响应函数 接收任意数量的参数. 随便接.例如:\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc, Action.InputTag,floatA,floatB,floatC,floatD); void Pressed(FGameplayTag InputTag,float a,float b,float c,float d); 激活技能 前面的 GameplayAbility 片段，在GA里面定义了一个变量StartupInputTag\n1 2 UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; 并且在ASC里面GiveAbility时，把这个StartupInputTag传给 GameplayAbilitySpec 作为动态Tag.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 现在 就使用这个Tag条件 作为 按键输入 和 激活技能 之间的桥梁.\n在ASC里创建下面两个函数，接收一个GameplayTag，按下按键时 就调用这两个函数，激活技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void UAuraAbilitySystemComponent::AbilityInputHeld(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputPressed(AbilitySpec); if (!AbilitySpec.IsActive()) { TryActivateAbility(AbilitySpec.Handle); } } } } void UAuraAbilitySystemComponent::AbilityInputReleased(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputReleased(AbilitySpec); } } } 玩家控制器 绑定了GameplayTag 和 按键响应的函数， 在按键响应的函数里能够接收到 那个按键对应的GameplayTag， 现在要做的是: 这个接收到的 GameplayTag 只要和某个 GA 的GameplayTag 匹配成功，就激活那个GA.\n按键响应的函数 在玩家控制器里，激活技能需要角色身上的ASC，AbilitySystemComponent玩家控制器 能够获得角色，从角色身上获得ASC， 好了 这就是思路.\n玩家控制器里面用一个指针存放 ASC，如果ASC有效 就使用存储的ASC，如果无效 则重新获得角色以及ASC.\n1 2 UPROPERTY() TObjectPtr\u0026lt;UAuraAbilitySystemComponent\u0026gt; AuraAbilitySystemComponent; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputReleased(InputTag); } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputHeld(InputTag); } UAuraAbilitySystemComponent* AAuraPlayerController::GetASC() { if (AuraAbilitySystemComponent == nullptr) { AuraAbilitySystemComponent =Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn\u0026lt;APawn\u0026gt;())); } return AuraAbilitySystemComponent; } 投射物 从人物手上发射一个火球，撞到敌人造成伤害\n前面在 GameplayAbility 这一片段创建了自定义的GA，\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; 一个GA，一个火球Actor.GA播放角色发射火球的动作蒙太奇，GA等待GameplayEvent， 当Event触发时 才发射火球，动画蒙太奇在执行到指定帧时，通过动画通知触发Event，让GA发射火球GA在生成火球Actor时，把GE传给Actor，Actor撞到敌人，对敌人应用GE 造成伤害，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void UAuraProjectileSpell::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); } void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) { AActor* AvartarActor = GetAvatarActorFromActorInfo(); bool bIsServer = AvartarActor-\u0026gt;HasAuthority(); if (!bIsServer) return; ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(AvartarActor); if (CombatInterface) { const FVector SockLocation = CombatInterface-\u0026gt;GetCombatSocketLocation(); FRotator Rotation = (TargetLocation - SockLocation).Rotation(); Rotation.Pitch = 0 ; AActor* OwningActor = GetOwningActorFromActorInfo(); FTransform SpawnTransform; SpawnTransform.SetLocation(SockLocation); SpawnTransform.SetRotation(Rotation.Quaternion()); AAuraProjectile* Projectile = GetWorld()-\u0026gt;SpawnActorDeferred\u0026lt;AAuraProjectile\u0026gt;( ProjectileClass, SpawnTransform, OwningActor, Cast\u0026lt;APawn\u0026gt;(OwningActor), ESpawnActorCollisionHandlingMethod::AlwaysSpawn); UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get(); const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel()); UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpeceHandle,GameplayTags.Damage,ScaledDamage); Projectile-\u0026gt;DamaeEffectSpecHandle = SpeceHandle; Projectile-\u0026gt;FinishSpawning(SpawnTransform); } } SetByCaller - AssignTagSetByCallerMagnitude\nSetByCaller，在GA里设置伤害，GE里配置Tag，GA通过Tag把数值传给GE.\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA能获得AvatarActor，这就是角色，但不直接Cast到玩家角色，而是使用一个接口去做，没有硬绑定为某个具体角色类.接口的GetCombatSocketLocation函数，只是一个获取骨骼插槽位置的，返回一个Vector. 有起始位置和目标位置 就能设置火球Actor的朝向，让火球对准过去.\n1 void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) TargetLocation是在蓝图里设置的\n1 2 3 4 5 FVector AAuraCharacterBase::GetCombatSocketLocation() { check(Weapon); return Weapon-\u0026gt;GetSocketLocation(WeaponTipSocketName); } AuraProjectile.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 UCLASS() class AURA_API AAuraProjectile : public AActor { GENERATED_BODY() public:\tAAuraProjectile(); UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;UProjectileMovementComponent\u0026gt; ProjectileMovement; UPROPERTY(BlueprintReadWrite,meta = (ExposeOnSpawn = true)) FGameplayEffectSpecHandle DamaeEffectSpecHandle; protected: virtual void BeginPlay() override; UFUNCTION() void OnSphereOverlap( UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult \u0026amp; SweepResult); private: UPROPERTY(EditAnywhere) float LifeSpan = 10; UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;USphereComponent\u0026gt; Sphere; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UNiagaraSystem\u0026gt; ImpactEffect; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; ImpactSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; LoopingSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UAudioComponent\u0026gt; LoopingSoundComponent; }; AuraProjectile.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 AAuraProjectile::AAuraProjectile() { PrimaryActorTick.bCanEverTick = false; bReplicates =true; Sphere = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(\u0026#34;Sphere\u0026#34;); SetRootComponent(Sphere); Sphere-\u0026gt;SetCollisionObjectType(ECC_Projectile); Sphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); Sphere-\u0026gt;SetCollisionResponseToAllChannels(ECR_Ignore); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldDynamic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldStatic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_Pawn,ECR_Overlap); ProjectileMovement = CreateDefaultSubobject\u0026lt;UProjectileMovementComponent\u0026gt;(\u0026#34;ProjectileMovement\u0026#34;); ProjectileMovement-\u0026gt;InitialSpeed = 550; ProjectileMovement-\u0026gt;MaxSpeed = 550; ProjectileMovement-\u0026gt;ProjectileGravityScale = 0; } void AAuraProjectile::BeginPlay() { Super::BeginPlay(); SetLifeSpan(LifeSpan); Sphere-\u0026gt;OnComponentBeginOverlap.AddDynamic(this,\u0026amp;ThisClass::OnSphereOverlap); LoopingSoundComponent = UGameplayStatics::SpawnSoundAttached(LoopingSound,GetRootComponent()); } void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult\u0026amp; SweepResult) { UGameplayStatics::PlaySoundAtLocation(this,ImpactSound,GetActorLocation()); UNiagaraFunctionLibrary::SpawnSystemAtLocation(this,ImpactEffect,GetActorLocation()); LoopingSoundComponent-\u0026gt;Stop(); if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor)) { TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*DamaeEffectSpecHandle.Data.Get()); } Destroy(); } AbilityTask 技能任务（C++类\u0026quot;UAbilityTask\u0026quot;）是更常规的技能任务类的特殊形式，旨在使用游戏性技能。使用游戏性技能系统的游戏通常包括各种自定义技能任务，这些任务实施其独特的游戏功能。它们在游戏性技能执行过程中执行异步工作，并且能够通过调用委托（Delegate） （在本地C++代码中）或移经一个或多个输出执行引脚（在蓝图中）来影响执行流。这使技能能够跨多个帧执行，并可在同一帧内执行多个不同的函数。大部分技能任务都有一个即时触发的执行引脚，使蓝图能够在任务开始后继续执行。此外，通常还有一些特定于任务的引脚，它们会在延迟后或在可能发生或不发生的某个事件之后触发。\n技能任务可以通过调用\u0026quot;EndTask\u0026quot;函数自行终止，或者等待运行它的游戏性技能结束，此时它会自动终止。这可以防止幻影技能任务运行，有效地泄漏CPU周期和内存。例如，某个技能任务可能播放一个施法动画，而另一个任务则在玩家的瞄准点处放置一个靶向标线。如果玩家点击确认输入来施放该法术，或者等待动画结束而未确认该法术，游戏性技能就会结束。虽然它们可以在任何时候自动终止，但是技能任务保证最晚在主要技能结束时终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMouseTargetDataSignature,const FVector\u0026amp;,Data); UCLASS() class AURA_API UTargetDataUnderMouse : public UAbilityTask { GENERATED_BODY() public: UFUNCTION(BlueprintCallable,Category=\u0026#34;Ability|Tasks\u0026#34;,meta = (DisplayName = \u0026#34;TargetDataUnderMouse\u0026#34;,HidePin=\u0026#34;OwningAbility\u0026#34;,DefaultToSelf = \u0026#34;OwningAbility\u0026#34;,BlueprintInternalUseOnly)) static UTargetDataUnderMouse* CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility); UPROPERTY(BlueprintAssignable) FMouseTargetDataSignature ValidData; private: virtual void Activate() override; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 UTargetDataUnderMouse* UTargetDataUnderMouse::CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility) { UTargetDataUnderMouse* Myobj = NewAbilityTask\u0026lt;UTargetDataUnderMouse\u0026gt;(OwningAbility); return Myobj; } void UTargetDataUnderMouse::Activate() { APlayerController* PC = Ability-\u0026gt;GetCurrentActorInfo()-\u0026gt;PlayerController.Get(); FHitResult HitResult; PC-\u0026gt;GetHitResultUnderCursor(ECC_Visibility,false,HitResult); ValidData.Broadcast(HitResult.Location); } 蓝图调用UTargetDataUnderMouse的static函数 创建UTargetDataUnderMouse，创建之后调用Activate函数.\nBlueprintAssignable\n写在AbilityTask.h里的说明: 点击查看大图UnrealEngine/Engine/Plugins/Runtime/GameplayAbilities/Source/GameplayAbilities/Public/Abilities/Tasks\nGithub上的AbilityTask.h\nGameplayEvent 等待指定的游戏标记事件触发。默认情况下，这将查看此功能的所有者。可以设置 OptionalExternalTarget 以使其查看另一个参与者的标记以进行更改 只要 OnlyTriggerOnce = false，它就会继续监听 如果 OnlyMatchExact = false，它将触发嵌套标记 WaitGameplayEvent与ASC有关. 或许 ASC就是连接Send和Wait之间的桥梁. 所以在动画通知里要GetOwnerActor 给Owner发Event.\nSendGameplayEventToActor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload) { if (::IsValid(Actor)) { UAbilitySystemComponent* AbilitySystemComponent = GetAbilitySystemComponent(Actor); if (AbilitySystemComponent != nullptr \u0026amp;\u0026amp; IsValidChecked(AbilitySystemComponent)) { using namespace UE::AbilitySystem::Private; if (EnumHasAnyFlags(static_cast\u0026lt;EAllowPredictiveGEFlags\u0026gt;(CVarAllowPredictiveGEFlagsValue), EAllowPredictiveGEFlags::AllowGameplayEventToApplyGE)) { FScopedPredictionWindow NewScopedWindow(AbilitySystemComponent, true); AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } else { AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } } else { ABILITY_LOG(Error, TEXT(\u0026#34;UAbilitySystemBlueprintLibrary::SendGameplayEventToActor: Invalid ability system component retrieved from Actor %s. EventTag was %s\u0026#34;), *Actor-\u0026gt;GetName(), *EventTag.ToString()); } } } 在HandleGameplayEvent里面 引用到一个AbilitySystemComponent里面的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int32 UAbilitySystemComponent::HandleGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload) { int32 TriggeredCount = 0; FGameplayTag CurrentTag = EventTag; ABILITYLIST_SCOPE_LOCK(); // 省略 if (FGameplayEventMulticastDelegate* Delegate = GenericGameplayEventCallbacks.Find(EventTag)) { // Make a copy before broadcasting to prevent memory stomping FGameplayEventMulticastDelegate DelegateCopy = *Delegate; DelegateCopy.Broadcast(Payload); } // 省略 return TriggeredCount; } AbilityTask_WaitGameplayEvent\n这里面就用到了上面提到的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void UAbilityTask_WaitGameplayEvent::Activate() { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC) { if (OnlyMatchExact) { MyHandle = ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).AddUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventCallback); } else { MyHandle = ASC-\u0026gt;AddGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), FGameplayEventTagMulticastDelegate::FDelegate::CreateUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventContainerCallback)); }\t} Super::Activate(); } void UAbilityTask_WaitGameplayEvent::OnDestroy(bool AbilityEnding) { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC \u0026amp;\u0026amp; MyHandle.IsValid()) { if (OnlyMatchExact) { ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).Remove(MyHandle); } else { ASC-\u0026gt;RemoveGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), MyHandle); } } Super::OnDestroy(AbilityEnding); } 大胆猜想，GamepalyEvent就是ASC运作的WaitGameplayEvent 把要监听的GameplayTag发给ASC，当SendGameplayEvent给ASC发送Tag时，如果监听的和接收到的Tag一样，ASC就会激活触发GameplayTagEvent，\n使用数据表初始化敌人属性 不想写了，看别人写的吧\n","date":"2025-01-11T12:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-gega%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/","title":"GAS A - GE、GA、输入绑定"},{"content":"官方文档\nGit文档\nGameplayEffect 函数名称 用途 PreAttributeChange / PreAttributeBaseChange 这些函数在即将修改属性之前调用。函数旨在实施关于属性值的规则，例如，\u0026ldquo;生命值必须介于0和最大生命值\u0026quot;之间，并且不得对属性更改触发游戏内响应。 PreGameplayEffectExecute 在即将修改属性值之前，此函数可以拒绝或更改拟定修改。 PostGameplayEffectExecute 在修改属性值后，此函数可立即对更改做出响应。这通常包括限制属性的最终值或触发对新值的游戏内响应，例如当\u0026quot;生命值\u0026quot;属性降至零时死亡。 Gameplay效果组件 说明 UChanceToApplyGameplayEffectComponent 应用Gameplay效果的概率。 UBlockAbilityTagsGameplayEffectComponent 根据所有者Gameplay效果目标Actor的Gameplay标签，进行Gameplay技能激活阻止处理。 UAssetTagsGameplayEffectComponent Gameplay效果资产拥有的标签。这些标签 不会 转移到Actor。 UAdditionalEffectsGameplayEffectComponent 添加尝试在特定条件下激活（或任何条件下都不激活）的其他Gameplay效果。 UTargetTagsGameplayEffectComponent 将标签授予Gameplay效果的目标（有时指所有者）。 UTargetTagRequirementsGameplayEffectComponent 指定如果此GE须应用或继续执行，目标（Gameplay效果的拥有者）必须具备的标签要求。 URemoveOtherGameplayEffectComponent 基于某些条件移除其他Gameplay效果。 UCustomCanApplyGameplayEffectComponent 处理CustomApplicationRequirement函数的配置，以查看是否应该应用此Gameplay效果。 UImmunityGameplayEffectComponent 免疫会阻止其他GameplayEffectSpecs的应用。 新版本的GE效果组件\nAbilities Gameplay Effect component 这个组件主要是在GameplayEffect激活时，可以向目标添加的GameplayAbility\nAddtional Effects Gameplay Effect Component 当此效果添加时或完成时，需要额外添加的效果。 On Appliaciton Gameplay Effects 在添加此效果时，额外添加的效果 On Complete Always 当此效果完成时，不管正常结束还是不正常结束时，添加的效果 On Complete Normal 当此效果正常结束时，添加的额外的效果 On Complete Prematurely 当此效果提前结束时，添加的额外的效果\nGameplay效果组件 说明 Asset Tags Gameplay Effect Component 在添加此GE时，需要额外处理的标签（添加 和 删除），这个标签将放置在GE上面，只是作为一个GE的标记 Block Ability Tags Gameplay Component 添加或删除能够阻挡技能的Tags的组件，这些Tags会在GE运行时添加到Actor身上，用于阻挡其它拥有此Tag的GE或者GA的激活。 Chance to Apply Gameplay Effect Component 当前GE应用到Actor身上的几率，0为百分之0几率，1为百分之百几率 Custom Can Apply Gameplay Effect Component 自定义能够应用GE的组件，可以自定义条件来设置应用是否成功。 Immunity Gameplay Effect Component 配置角色免疫其它GE的条件 Remove Other Gameplay Effect Component 配置移除其它的GE，满足设置的标签或者资源满足条件的GE都会被移除掉。 Target Tag Requirements Gameplay Effect Component 根据目标的Tag设置当前的GE的状态Appliaction 为GE添加到目标身上时Tag的状态Ongoing 为GE激活时Tag的状态Removal 为GE被删除时Tag的状态 Target Tags Gameplay Effect Component 添加此GE后，对Actor身上带有的Tag进行操作（添加或删除），这个会随着GE的添加修改，在GE失效时移除。非Instant使用。 GameplayEffectSpec GameplayEffectSpec(GESpec)可以看作是GameplayEffect的实例, 它保存了一个其所代表的GameplayEffect类引用, 创建时的等级和创建者, 它在应用之前可以在运行时(Runtime)自由的创建和修改, 不像GameplayEffect应该由设计师在运行前创建. 当应用GameplayEffect时, GameplayEffectSpec会自GameplayEffect创建并且会实际应用到目标(Target).\nGameplayEffectSpec是由UAbilitySystemComponent::MakeOutgoingSpec()(BlueprintCallable)自GameplayEffect创建的. GameplayEffectSpec不必立即应用. 通常是将GameplayEffectSpec传递给创建自Ability的投掷物, 该投掷物可以应用到它之后击中的目标. 当GameplayEffectSpec成功应用后, 就会返回一个名为FActiveGameplayEffect的新结构体.\nGameplayEffectSpec的重要内容:\n创建该GameplayEffectSpec的GameplayEffect类. 该GameplayEffectSpec的等级. 通常和创建GameplayEffectSpec的Ability的等级一样, 但是可以是不同的. GameplayEffectSpec的持续时间. 默认是GameplayEffect的持续时间, 但是可以是不同的. 对于周期性Effect中GameplayEffectSpec的周期, 默认是GameplayEffect的周期, 但是可以是不同的. 该GameplayEffectSpec的当前堆栈数. 堆栈限制取决于GameplayEffect. GameplayEffectContextHandle表明该GameplayEffectSpec由谁创建. Attribute在GameplayEffectSpec创建时由Snapshot捕获. 除了GameplayEffect授予的GameplayTags, GameplayEffectSpec还会授予目标(Target)DynamicGrantedTags. 除了GameplayEffect拥有的AssetTags, GameplayEffectSpec还会拥有DynamicAssetTags. SetByCaller TMaps. 1 2 3 4 5 6 7 8 9 10 11 12 void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); } Stack堆栈 GameplayEffect默认会应用新的GameplayEffectSpec实例, 而不明确或不关心之前已经应用过的尚且存在的GameplayEffectSpec实例. GameplayEffect可以设置到堆栈中, 新的GameplayEffectSpec实例不会添加到堆栈中, 而是修改当前已经存在的GameplayEffectSpec堆栈数. 堆栈只适用于持续(Duration)和无限(Infinite)GameplayEffect.\nSource就是AbilitySystemComponent\n堆栈类型 描述 Aggregate by Source 目标(Target)上的每个源(Source)ASC都有一个单独的堆栈实例, 每个源(Source)可以应用堆栈中的X个GameplayEffect. Aggregate by Target 目标(Target)上只有一个堆栈实例而不管源(Source)如何, 每个源(Source)都可以在共享堆栈限制(Shared Stack Limit)内应用堆栈. By Source ，每个Source对象拥有一个计数，计数达到限制时 不能再对Target应用GE.Source1的Stack达到2后，再次应用会失效. 这时再起一个Source2对象 就可以应用GE，因为它的Stack没有达到限制\nBy Target，只要Target的Stack达到限制，不管有多少个Source 都不能对Target应用GE.\n详细解释\n————————————————\nInfinite GE的添加、移除 当GameplayEffectSpec成功应用后, 就会返回一个FActiveGameplayEffectHandle.\n在应用GESpec后，把TargetASC和GEHandle加入到Map里这是针对区域效果的操作，如果有2个玩家进入伤害区域，在他们离开区域时 要通过 \u0026lt;离开的Acotr\u0026gt; 这个条件去Map寻找他对应的GEHandle，从而根据GEHandle移除他身上的GE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TMap\u0026lt;FActiveGameplayEffectHandle,UAbilitySystemComponent*\u0026gt; ActiveEffectHandls; void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); const bool bIsInfinite = EffectSpecHandle.Data.Get()-\u0026gt;Def.Get()-\u0026gt;DurationPolicy == EGameplayEffectDurationType::Infinite; if (bIsInfinite \u0026amp;\u0026amp; InfiniteEffectRemovePolicy == EEffectRemovePolicy::RemoveOnEndOverlap) { ActiveEffectHandls.Add(ActiveEffectHandle,TargetASC); } } 移除通过Actor的ASC查找Map里对应的GEHandle，使用Handle移除Actor的ASC上面的GE后，还要在Map里移除这一对元素.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void AAuraEffectActor::RemoveGE(AActor* TargetActor) { UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (!IsValid(ASC)) return; // TArray\u0026lt;FActiveGameplayEffectHandle\u0026gt; HandlesToRemove; for (TTuple\u0026lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*\u0026gt; HandlePair : ActiveEffectHandls) { if (HandlePair.Value == ASC) { ASC-\u0026gt;RemoveActiveGameplayEffect(HandlePair.Key,1); HandlesToRemove.Add(HandlePair.Key); } } for (FActiveGameplayEffectHandle\u0026amp; Handle : HandlesToRemove) { ActiveEffectHandls.FindAndRemoveChecked(Handle); } // /*使用迭代器遍历 TMap for (auto It = ActiveEffectHandls.CreateIterator(); It; ++It) { if (It-\u0026gt;Value == ASC) { // 删除 ActiveGameplayEffect ASC-\u0026gt;RemoveActiveGameplayEffect(It-\u0026gt;Key); // 删除 TMap 中的元素 It.RemoveCurrent(); } }*/ } 数值的限制 与 响应 生命值等属性在应用GE后 可能会变成负数，或者超出最大生命值，\nPreAttributeChange PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue)是AttributeSet中的主要函数之一, 其在修改发生前响应Attribute的CurrentValue变化, 其是通过引用参数NewValue限制(Clamp)CurrentValue即将进行的修改的理想位置.\n例如像样例项目那样限制移动速度Modifier:\n1 2 3 4 5 if (Attribute == GetMoveSpeedAttribute()) { // Cannot slow less than 150 units/s and cannot boost more than 1000 units/s NewValue = FMath::Clamp\u0026lt;float\u0026gt;(NewValue, 150, 1000); } GetMoveSpeedAttribute()函数是由我们在AttributeSet.h中添加的宏块创建的(定义Attribute).\nPreAttributeChange()可以被Attribute的任何修改触发, 无论是使用Attribute的setter(由AttributeSet.h中的宏块定义(定义Attribute))还是使用GameplayEffect.\nNote: 在这里做的任何限制都不会永久性地修改ASC中的Modifier, 只会修改查询Modifier的返回值, 这意味着像GameplayEffectExecutionCalculations和ModifierMagnitudeCalculations这种自所有Modifier重新计算CurrentValue的函数需要再次执行限制(Clamp)操作.\nNote: Epic对于PreAttributeChange()的注释说明不要将该函数用于游戏逻辑事件, 而主要在其中做限制操作. 对于修改Attribute的游戏逻辑事件的建议位置是UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)(响应Attribute变化).\n限制生命值示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue) { Super::PreAttributeChange(Attribute, NewValue); if (Attribute == GetHealthAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxHealth()); } if (Attribute == GetManaAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxMana()); } } ·当前值的变化 - 在变化发生之前 ·由属性的变化触发 - 属性访问器 - GameplayEffects ·不会永久更改修饰符，只会更改查询修饰符返回的值 ·后续操作会重新计算所有修饰符的当前值 - 我们需要再次限制\nPostGameplayEffectExecute PostGameplayEffectExecute(const FGameplayEffectModCallbackData \u0026amp; Data)仅在即刻(Instant)GameplayEffect对Attribute的BaseValue修改之后触发, 当GameplayEffect对其修改时, 这就是一个处理更多Attribute操作的有效位置.\n例如, 在样例项目中, 我们在这里从生命值Attribute中减去了最终的伤害值Meta Attribute, 如果有护盾值Attribute的话, 我们也会在减除生命值之前从护盾值中减除伤害值. 样例项目也在这里应用了被击打反应动画, 显示浮动的伤害数值和为击杀者分配经验值和赏金. 通过设计, 伤害值Meta Attribute总是会传递给即刻(Instant)GameplayEffect而不是Attribute Setter.\n其他只会由即刻(Instant)GameplayEffect修改BaseValue的Attribute, 像魔法值和耐力值, 也可以在这里被限制为其相应的最大值Attribute.\nNote: 当PostGameplayEffectExecute()被调用时, 对Attribute的修改已经发生, 但是还没有被同步回客户端, 因此在这里限制值不会造成对客户端的二次同步, 客户端只会接收到限制后的值.\n限制生命值:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } } PreAttributeChange 和 PostGameplayEffectExecute 一起使用，这样才是真正的限制住了\nFGameplayEffectModCallbackData PostGameplayEffectExecute的参数FGameplayEffectModCallbackData\u0026amp; Data，它包含了很多信息，\n下面这个 FEffectProperites 结构体里的信息 都能从Data里面获得.Source开头 指的是 “属性的改变是谁打过来的”，Target开头 指的是“受害者”例如: 泽拉斯Q了一下诺手， 这个Q的伤害是泽拉斯造成的，Source是泽拉斯.诺手接收到Q的伤害之后，要在PostGameplayEffectExecute里面一通计算 响应伤害，Target是诺手.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 USTRUCT() struct FEffectProperites { GENERATED_BODY() FEffectProperites(){}; FGameplayEffectContextHandle EffectContextHandle; UPROPERTY() UAbilitySystemComponent* SourceASC = nullptr; UPROPERTY() AActor* SourceAvatarActor = nullptr; UPROPERTY() AController* SourceController = nullptr; UPROPERTY() ACharacter* SourceCharacter = nullptr; //////////////////////////////////////////// UPROPERTY() UAbilitySystemComponent* TargetASC = nullptr; UPROPERTY() AActor* TargetAvatarActor = nullptr; UPROPERTY() AController* TargetController = nullptr; UPROPERTY() ACharacter* TargetCharacter = nullptr; }; FGameplayEffectModCallbackData\u0026amp; Data的使用方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); } void UAuraAttributeSet::SetEffectProperties(const struct FGameplayEffectModCallbackData\u0026amp; Data,FEffectProperites\u0026amp; Props) { Props.EffectContextHandle = Data.EffectSpec.GetContext(); Props.SourceASC = Props.EffectContextHandle.GetOriginalInstigatorAbilitySystemComponent(); if (IsValid(Props.SourceASC) \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.SourceAvatarActor = Props.SourceASC-\u0026gt;GetAvatarActor(); Props.SourceController = Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;PlayerController.Get(); if (Props.SourceController == nullptr \u0026amp;\u0026amp; Props.SourceAvatarActor!=nullptr) { if (APawn* Pawn = Cast\u0026lt;APawn\u0026gt;(Props.SourceAvatarActor)) { Props.SourceController = Pawn-\u0026gt;GetController(); } } if (Props.SourceController) { Props.SourceCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.SourceController-\u0026gt;GetPawn()); } } if (Data.Target.AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.TargetAvatarActor = Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.Get(); Props.TargetController = Data.Target.AbilityActorInfo-\u0026gt;PlayerController.Get(); Props.TargetCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.TargetAvatarActor); Props.TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Props.TargetAvatarActor); } } 使用Prop:\n1 2 3 4 5 6 if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } 诺手接收到伤害后，打印诺手的名字和血量，所以需要TargetAvatarActor来获得名字.\n","date":"2025-01-11T11:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-gameplayeffect/","title":"GAS A - GameplayEffect"},{"content":"MVC 插播一条：UE5中 有一套MVVM插件 可以与UMG联动。创建MVVM对象，在这个对象里面创建一些变量什么的，当变量改变时 它自己就会发出广播通知\nhttps://www.bilibili.com/video/BV1Dj411N735/\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/umg-viewmodel\n下面开始视频教程的内容：\n将应用程序分为三个核心组件：模型（Model）、视图（View）和控制器（Controller），以实现关注点分离。\n在这个系列课程中，使用这个架构来更新UMG， 玩家属性发生变化\u0026mdash;\u0026gt;通知Controller\u0026mdash;\u0026gt;Controller发出消息广播，UMG订阅Controller的消息广播，这样就把 玩家和UMG 联系起来了.\n直观上看的话，也就是 玩家大喊一声“该更新了”，具体去更新谁，玩家并不关心。\n在整个过程中，只关注一个中介者—Controller，需要更新自己数据的UMG界面 自己去订阅消息通知，变化事件发生时，Controller发出通知消息， UMG自己去查看是 生命值变化了，还是魔法值变化了，去做它自己该做的事情。\n套用MVC模式，View = UMG，Model = 玩家属性，Controller就是这两个之间的中间件. Controller可以是一个UObject. (这里的Controller不是引擎中的 AI控制器 / 玩家控制器，只是一个U类对象)\n这是最终要实现的结构，UMG内部需要Controller的指针，用来订阅Controller的消息，\nUMG和Controller都集中在HUD里面，HUD同时创建UMG、Controller，并且当场就把Controller与UMG 关联起来。 GameMode管理HUD，GameMode会自动创建HUD. 而HUD内部管理UMG、Controller，HUD对外公开一个函数，用来接收玩家相关的信息 以及 创建UMG、Controller\n1 InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) 这个函数接收4个参数 用来获得玩家信息，只需要一个合适的时机调用这个HUD的函数，一切就能关联起来。\n对于人类玩家角色来说，GAS相关组件都放在PlayerState里面，当角色死亡时 死的只是Actor 不是PlaeyrState，所以这些组件不会丢失角色的属性信息，角色复活时 就得重新获得PlayerState里面的GAS组件信息。复活 就可以视为是初始化了，游戏刚开始时，角色也算是“复活”，即调用 PossessedBy 函数，在PossessedBy 函数里面获得GAS信息的同时，就通知UI去更新信息。\n这就是InitOverlay调用的时机，即在 PossessedBy 里面调用. PossessedBy 拿到 PC、PS、ASC、AS 之后 传给HUD::InitOverlay，让HUD拿着这些信息去构造Controller\n有了这些指导思想，接下来的内容就容易看懂了.\n整这么一大堆，其实就是 本来UMG能直接GetPlayerCharacter，Cast到AuraCharacter，角色身上的所有东西都能获取，GetPlayerState ，Cast到AuraPlayerState也能获取GAS组件。这已经可以运行了，只是多了一个中间件，原本是 角色\u0026mdash;\u0026gt;UMG，一站直达的， 现在需要 角色\u0026ndash;\u0026gt;中间件\u0026mdash;\u0026gt;UMG于是乎，就要想办法把这一串逻辑 重新打通，就仅此而已.\nController \u0026amp; Widget 粗糙的结构图，WidgetController只是个继承自UObject的类，需要4个变量，PC、PS、ASC、AS，UserWidget 也就是UMG的父类， 有WidgetController的Getter、Setter，在代码里面调用SetWidgetController()，SetWidgetController内部又调用WidgetControllerSet()，这是用来调用蓝图事件的，绑定的事件在UMG的蓝图里做，这样就打通了C++和蓝图的通信.\n创建UMG 后面只是在蓝图里创建了几个UMG，这是结构图， WBP_Overlay是主界面，里面有小UI，WBP_HealthGlobe等等.\nHUD 在哪里创建主UI？Controller存放到哪里？又如何初始化？\nHUD的目的是 告知玩家当前游戏状态，即分数、生命值、游戏剩余时间等。\n这个课程把Controller放到了HUD里，UMG也由HUD来创建。\n1 2 3 4 5 6 7 AuraHUD UPROPERTY() TObjectPtr\u0026lt;UAuraUserWidget\u0026gt; OverlayWidget; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UAuraUserWidget\u0026gt; OverlayWidgetClass; 这是常用的操作，在蓝图里指定OverlayWidgetClass 选择使用哪一个蓝图，在C++中使用这个class创建对象.\n把BP_AuraHUD放到GameMode里面，用于创建BP_AuraHUD\nWidget Controller HUD能创建出UMG了，还剩下Controller没有初始化，AuraWidgetController里面还有4个变量需要初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState; TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; ———————————————————————————————————————————————————————————————————— USTRUCT(BlueprintType) struct FWidgetControllerParams { GENERATED_BODY() FWidgetControllerParams(){}; FWidgetControllerParams(APlayerController* PC,APlayerState* PS,UAbilitySystemComponent* ASC,UAttributeSet* AS) : PlayerController(PC),PlayerState(PS),AbilitySystemComponent(ASC),AttributeSet(AS) {}; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet = nullptr; }; void UAuraWidgetController::SetWidgetControllerParams(const FWidgetControllerParams\u0026amp; WCParams) { PlayerController = WCParams.PlayerController; PlayerState = WCParams.PlayerState; AbilitySystemComponent = WCParams.AbilitySystemComponent; AttributeSet = WCParams.AttributeSet; } 看着比较长，实际上只是定义一个结构体，函数接收这个结构体来初始化这些变量， 思考题：为什么要用结构体？ WidgetController里面的变量初始化完了，那么WidgetController本体在哪里初始化？\n创建OverlayWidgetController ，它继承自 UAuraWidgetController，用来更新主UI.\n在AuraHUD里添加两个变量，前面的UMG在HUD里初始化了，WidgetController也在HUD初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY() TObjectPtr\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetController; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetControllerClass; UOverlayWidgetController* AAuraHUD::GetOverlayWidgetController(const FWidgetControllerParams\u0026amp; WCParams) { if (OverlayWidgetController == nullptr) { OverlayWidgetController = NewObject\u0026lt;UOverlayWidgetController\u0026gt;(this,OverlayWidgetControllerClass); OverlayWidgetController-\u0026gt;SetWidgetControllerParams(WCParams); OverlayWidgetController-\u0026gt;BindCallbacksToDependencies(); return OverlayWidgetController; } return OverlayWidgetController; } GetOverlayWidgetController() 如果OverlayWidgetController没有值 则创建并返回，有值 直接返回。\n初始化函数有了，调用时机呢？\n1 2 3 4 5 这个函数是后文 消息广播 定义的函数，在Controller初始化时 广播一次属性值 总不能是空血条开局吧 WidgetController-\u0026gt;BroadcastInitialValues(); 这也是后文的函数，用来订阅 属性更改通知 的委托 BindCallbacksToDependencies() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) { checkf(OverlayWidgetClass,TEXT(\u0026#34;OverlayWidgetClass uninitialized,fill out BP_AurhHUD\u0026#34;)); checkf(OverlayWidgetControllerClass,TEXT(\u0026#34;OverlayWidgetControllerClass uninitialized,fill out BP_AurhHUD\u0026#34;)); OverlayWidget = CreateWidget\u0026lt;UAuraUserWidget\u0026gt;(GetWorld(), OverlayWidgetClass); const FWidgetControllerParams WidgetControllerParams(PC,PS,ASC,AS); UOverlayWidgetController* WidgetController = GetOverlayWidgetController(WidgetControllerParams); OverlayWidget-\u0026gt;SetWidgetController(WidgetController); WidgetController-\u0026gt;BroadcastInitialValues(); OverlayWidget-\u0026gt;AddToViewport(); } InitOverlay AAuraHUD::InitOverlay 是HUD公开出去的函数，是一切故事发生的入口.\n至此，HUD把UMG和WidgetController收集了起来. 在HUD中通过 InitOverlay() 创建UMG、WidgetController，并且在创建现场就把UMG和WidgetController关联起来.\n1 OverlayWidget-\u0026gt;SetWidgetController(WidgetController); 只要调用对外公开的 InitOverlay() 函数，所有东西都能链接起来，那么 在哪里调用才合适？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;AbilityInfoSet(); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); if (AAuraPlayerController* AuraPlayerController = Cast\u0026lt;AAuraPlayerController\u0026gt;(GetController())) { if (AAuraHUD* AuraHud = Cast\u0026lt;AAuraHUD\u0026gt;(AuraPlayerController-\u0026gt;GetHUD())) { AuraHud-\u0026gt;InitOverlay(AuraPlayerController,AuraPlayerState,AbilitySystemComponent,AttributeSet); } } } 最终如图所示，完成整个流程。\nCharacter::PossessedBy是入口，在这里获得 玩家控制器、玩家状态、技能组件、属性Set.初始化角色自己的GAS组件 的同时 ，传给HUD 让HUD也用用，HUD在创建Controller时，把 玩家控制器、玩家状态、技能组件、属性集 传给Controller，HUD在创建UMG时，把Controller 传给UMG.\n消息广播 GAS对外公开有委托事件，当属性变化时 这个委托就会广播，Controller订阅GAS的广播 就可以在属性变化时 获得属性的最新值。\n当Controller被HUD初始化时，就要广播一次 用来初始化UMG里的内容，总不能开局血条是空的吧。\nUAuraWidgetController追加空函数，在OverlayWidgetController进行override.\n1 2 3 UFUNCTION(BlueprintCallable) virtual void BroadcastInitialValues(){}; virtual void BindCallbacksToDependencies(){}; 还要在OverlayWidgetController里面定义委托 和 委托变量\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewValue); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); —————————————————————————————————————————————————————————————————————————— UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnHealthChanged; UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnMaxHealthChanged; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void UOverlayWidgetController::BroadcastInitialValues() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); OnHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxHealth()); OnManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMana()); OnMaxManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxMana()); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); } MVVM GAS B系列使用MVVM框架更新UMG.\n(有一个漏掉的操作 → 没有手动调用一次广播，开局血条是空的，)\nELMVVMPlayer.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 UCLASS(BlueprintType) class ELEMENTAL_III_API UELMVVMPlayer : public UMVVMViewModelBase { GENERATED_BODY() public: UFUNCTION(BlueprintCallable) void SetMvvmParams(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); protected: UPROPERTY() TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Health; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxHealth; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Mana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxMana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter=GetIsBattleMode,Setter=SetIsBattleMode) bool bIsBattleMode = false; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) int32 KillNumber; void SetHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Health,Value);} float GetHealth() const {return Health;}; void SetMaxHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxHealth,Value);} float GetMaxHealth() const {return MaxHealth;}; void SetMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Mana,Value);} float GetMana() const {return Mana;}; void SetMaxMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxMana,Value);} float GetMaxMana() const {return MaxMana;}; void SetIsBattleMode(const bool Value) {UE_MVVM_SET_PROPERTY_VALUE(bIsBattleMode,Value);} bool GetIsBattleMode() const {return bIsBattleMode;}; void SetKillNumber(const int32 Value) {UE_MVVM_SET_PROPERTY_VALUE(KillNumber,Value);} int32 GetKillNumber() const {return KillNumber;}; }; ELMVVMPlayer.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // AELCharacterBase::InitAbilityInfo ---\u0026gt; AELHUD::InitMVVM ---\u0026gt; ThisClass::SetMvvmParams void UELMVVMPlayer::SetMvvmParams(APlayerController* PC, UAbilitySystemComponent* ASC, UAttributeSet* AS) { PlayerController = PC; AbilitySystemComponent = ASC; AttributeSet = AS; AELPlayerController* ELPlayerController = Cast\u0026lt;AELPlayerController\u0026gt;(PlayerController); ELPlayerController-\u0026gt;OnBattleModeChange.AddLambda( [this](bool InBattleMode) { SetIsBattleMode(InBattleMode); }); const UELAttributeSet* ELAttributeSet = Cast\u0026lt;UELAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetKillNumberAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetKillNumber(Data.NewValue); }); } ELHUD.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 UCLASS() class ELEMENTAL_III_API AELHUD : public AHUD { GENERATED_BODY() public: void InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;ACharacter\u0026gt; Character; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, EditDefaultsOnly) FMVVMViewModelContext MVVMContext; UPROPERTY(BlueprintReadOnly) class UELMVVMPlayer* MVVMPlayer; }; ELHUD.cpp\n在这里创建MvvmPlayer并且添加到Mvvm全局子系统里. UMG里根据Context从全局获取MvvmPlayer.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void AELHUD::InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS) { AbilitySystemComponent = ASC; PlayerController = PC; Character = Cast\u0026lt;ACharacter\u0026gt;(PlayerController-\u0026gt;GetPawn()); AttributeSet = AS; MVVMPlayer = NewObject\u0026lt;UELMVVMPlayer\u0026gt;(PC); UGameInstance* GameInstance = UGameplayStatics::GetGameInstance(this); UMVVMGameSubsystem* MvvmGameSubsystem = GameInstance-\u0026gt;GetSubsystem\u0026lt;UMVVMGameSubsystem\u0026gt;(); MvvmGameSubsystem-\u0026gt;GetViewModelCollection()-\u0026gt;AddViewModelInstance(MVVMContext,MVVMPlayer); MVVMPlayer-\u0026gt;SetMvvmParams(PC,ASC,AS); } CharacterBase\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AELCharacterBase::InitAbilityInfo() { AHUD* HUD = Cast\u0026lt;AELPlayerController\u0026gt;(GetController())-\u0026gt;GetHUD(); if (AELHUD* ELHud = Cast\u0026lt;AELHUD\u0026gt;(HUD)) { ELHud-\u0026gt;InitMvvm(Cast\u0026lt;AELPlayerController\u0026gt;(GetController()),AbilitySystemComponent,AttributeSet); } } void AELCharacterBase::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); InitAbilityInfo(); } 调用顺序: AELCharacterBase::PossessedBy\u0026mdash;\u0026gt;AELCharacterBase::InitAbilityInfo \u0026mdash;\u0026gt; AELHUD::InitMVVM \u0026mdash;\u0026gt; UELMVVMPlayer::SetMvvmParams\n","date":"2025-01-11T11:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-ui-mvc-or-mvvm/","title":"GAS A - UI - MVC or MVVM"},{"content":"起手式 网页图片模糊 点击图片预览高清大图\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/gameplay-ability-system-for-unreal-engine↑首先看一遍官方文档↑\nGAS学习资料:https://github.com/BillEliot/GASDocumentation_Chinese\n官方的ActionRPG项目，\nGAS A系列是由 \u0026lt; Gameplay Ability System - Top Down RPG\u0026gt; 这一套教程来的,简单的细枝末节不记录https://www.bilibili.com/video/BV1JD421E7yC\n与GameplayAbilitySystem交互的Actor须拥有 GameplayAbilitySystemComponent。此组件将激活技能、存储属性、更新效果，和处理Actor间的交互。\n角色类拥有UAbilitySystemComponent 和 UAttributeSet 两个组件，AttributeSet保存角色的属性值，例如:生命值、魔法值、生命回复、攻击力、法术强度，而这些属性由GameplayEffect来修改，不应手动修改.尽管AttributeSet提供了Setter方法，也不该手动调用它去做一些事情.\nGameplayAbility执行技能任务，被动、Q、W、E、R、D、F都可以是GameplayAbility.技能(GameplayAbility) 可以配置CD、Cost，也就是冷却时长，耗费多少蓝量. CD和Cost都由GamePlayEffect定义. CD、Cost的信息都可以在GA的蓝图面板中配置，选择对应的GE蓝图即可.\n技能执行流程 先描述最感兴趣的一集吧，开局就写难懂的东西 只会让脑子开局就过载，作文首先要引起读者的兴趣。 这把先开\u0026lt;泽拉斯\u0026gt;奥兄弟们，最会空技能的一个英雄。\n冷却时间 泽拉斯的Q技能一级有9秒CD，释放技能时 如果在冷却中 就不让释放，这个流程如何使用GAS来执行？GE可以选择 \u0026lt;立即生效 | 持续一段时间 | 无限时间\u0026gt; 三个策略。假设这个技能是GA_Q，它拥有标签TAG_Q，那么就让GE_Q_CD使用 \u0026lt;持续一段时间\u0026gt; 这个策略，并且让GE_Q_CD去阻挡TAG_Q，等到GE的持续时间结束才会取消阻挡。 这样就实现了技能的冷却。执行流程为:GA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;不在CD中\u0026mdash;\u0026gt;执行技能\u0026mdash;\u0026gt;技能结束，开始CDGA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;正在CD中\u0026mdash;\u0026gt;技能结束\n技能耗费 泽拉斯的Q技能需要耗费80蓝量，这就要求Attribute里面拥有\u0026lt;魔法值\u0026gt;这个属性，在GA_Q执行时扣除相应的魔法值，如果蓝量不够 就不能执行技能.GE_Q_Cost 使用 \u0026lt;立即生效\u0026gt; 策略，(瞪眼观察法可知 另外两个策略一看就不对)Q需要耗费80蓝量，GE_Q_Cost就得让 \u0026lt;魔法值\u0026gt; 减80，魔法值够减的话 那么就能执行技能. 不够减 就不执行.\n执行流程与 冷却时间 相似.\n技能伤害 有了上面使用GE去做CD 耗蓝，那么伤害如何去做？ 直接减掉目标的血量值？NO ，Attribute中定义 \u0026lt;即将到来的伤害\u0026gt;， 如果伤害值是50， 那么就使用GE 让敌人的 \u0026lt;即将到来的伤害\u0026gt; +50。 在Attribute中去执行减掉生命值的操作.\n这把开一局\u0026lt;爆破鬼才\u0026gt;，假如我发射一个火球，那么在火球滑行的途中，它撞到了地面 触发爆炸伤害. 这里就得范围检测Enemy，并且获得它们身上的 AbilitySystemComponent 并且对这个组件应用GE，造成伤害\n技能蓝图 被动技能 生命回复、法力回复 这些都是自动运行的， 每秒回复1点生命值 回复1点魔法值， 可以用GE做一个 无限时间 的效果，持续一段时间 | 无限时间 ， 这两个策略都可以设置触发周期，比如每1秒触发一次，每0.5秒触发一次 等等。\n自动回复就使用 无限时间 ，每秒触发一次，每次触发添加1点生命值，1点魔法值。就叫它 GE_Regeneration ，在BeginPlay时 对AbilitySystemComponent应用这个GE即可。那死亡时 不想要自动回复了怎么办？ GE可以被Apply，也可以被Remove，死亡时只要移除这个GE就行了,这是手动移除的案例.\nBuff也可以用一个GE完成，例如 增加50攻击力，并且持续90秒，那么就使用一个 持续一段时间的GE，让攻击力+50，时间结束后 GE自动取消. 这是自动移除的案例.手动移除方法：\nGameplayAbilitySystem 初始化技能组件 ASC附加的Actor被引用作为该ASC的OwnerActor, 该ASC的物理代表Actor被称为AvatarActor. OwnerActor和AvatarActor可以是同一个 Actor, 比如MOBA游戏中的一个简单AI小兵; 它们也可以是不同的Actor, 比如MOBA游戏中玩家控制的英雄, 其中OwnerActor是PlayerState, AvatarActor是英雄的Character类. 绝大多数Actor的ASC都附加在其自身, 如果你的Actor会重生并且重生时需要持久化Attribute或GameplayEffect(比如MOBA中的英雄), 那么ASC理想的位置就是PlayerState.\nGAS要求添加 AbilitySystemComponent (ASC) 和 AttributeSet (AS)，那么往角色身上添加 是否可行？\n如果角色可以被摧毁、可以死亡，当CharacterActor死亡时 在它身上挂载的 ASC、AS 全都没有了，一起跟着销毁再次复活时 技能信息会丢失。 这就要求把ASC、AS放到一个可靠的地方，在这个教程里 放到了PlayerState里面。\n问题:如何放？ 还要把玩家角色与PlayerState里的ASC、AS连接起来，这样在场景里才能通过玩家角色获得玩家的ASC、AS，如何连接？ ACharacter -\u0026gt; AuraCharacterBase -\u0026gt;Enemy / AuraCharacter , AuraCharacter 是玩家角色\n【Enemy 和 AuraCharacter 都继承自AuraCharacterBase 】\n在AuraCharacterBase 和 PlayerStae 中定义GAS的两个组件的指针，但是实体在Enemy 和 PlayerState 中创建.因为玩家角色的GAS组件要放在PlayerState里，而敌人AI就放在它自己的角色类里面.\n下面的内容就是解决上面的两个问题:如何放 如何连接。定义组件指针、初始化组件、连接 玩家角色 与 PlayerState 的组件.(玩家角色 被玩家控制器 控制后，就要获得PlayerState里面的ASC、AS组件)思路不清晰 可以看小节结尾的流程图.\n1 2 3 4 5 UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 AAuraEnemy::AAuraEnemy() { GetMesh()-\u0026gt;SetCollisionResponseToChannel(ECC_Visibility,ECR_Block); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); HealthBar = CreateDefaultSubobject\u0026lt;UWidgetComponent\u0026gt;(\u0026#34;HealthBar\u0026#34;); HealthBar-\u0026gt;SetupAttachment(GetRootComponent()); } AAuraPlayerState::AAuraPlayerState() { //NetUpdateFrequency = 100.f; SetNetUpdateFrequency(100.f); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); } 完了还要在AuraCharacterBase继承一个接口，用来获得ASC，因为要与ASC通信，不管是哪个类，只要调用这个接口就能得到它的ASC组件.\n1 2 3 4 5 6 7 8 9 10 class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraCharacterBase::GetAbilitySystemComponent() const { return AbilitySystemComponent; } 现在Enemy的组件注册完了，玩家角色的还没有结束，它的组件都在PlayerState里面，还要再手动从PS里获取组件.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AURA_API AAuraPlayerState : public APlayerState,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraPlayerState::GetAbilitySystemComponent() const { return AbilitySystemComponent; } —————————————————————————————————————————————————————————————————————————————————————— void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); } 这样就把玩家角色和AuraPlayerState链接起来了，AbilitySystemComponent 和 AttributeSet 都初始化了.\nAttribute https://github.com/BillEliot/GASDocumentation_Chinese?tab=readme-ov-file#43-attribute\nAttribute里定义生命值，FGameplayAttributeData Health; FGameplayAttributeData 是一个结构体，其数值是浮点型，结构体里面有一个BaseValue和一个CurrentValue，假如当前生命值是100，BaseValue = CurrentValue = 100 ， 有一个持续10秒的加50生命值的buff，一个NPC吃了一个buff 这是他生命值发生的变化， BaseValue = 100 ， CurrentValue = 100 + 50 = 150，10秒后 buff结束，CurrentValue就会变回BaseValue， 此时 BaseValue = CurrentValue = 100.\n即刻(Instant)GameplayEffect可以永久性的修改BaseValue, 而持续(Duration)和无限(Infinite)GameplayEffect可以修改CurrentValue. 周期性(Periodic)GameplayEffect被视为即刻(Instant)GameplayEffect并且可以修改BaseValue.\nAttributeSet.h里提供了一个Help宏，它被注释了，这个宏提供4个函数，Getter、Setter、Init以及一个静态的GetAttribute\n1 2 3 4 5 #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName) 将它复制到自己的类里面使用，定义一个Health属性，并且初始化为100.\n1 2 3 UPROPERTY(BlueprintReadOnly\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); 药瓶 Effect Actor 这个Actor这样修改属性只是为了简单测试，属性修改要使用GE. 当角色碰到这个Actor时 角色的Health会增加50.\n附 教程里因为版本不同 名称不同的对照，一些属性名称 , 还有打起来贼他妈麻烦的代码片段， 都可以到这复制\nGameplayEffectAssetTag 【=】 Tags This Effect Has GrantedTags 【=】 Grant Tags to Target Actor Ongoing Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Application Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Removal Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Remove Gameplay Effect With Tags 【=】 Remove Other Effects\nArmor,ArmorPenetration,BlockChance,\nCriticalHitChance,CriticalHitDamage,CriticalHitResistance,\nHealthRegeneration,ManaRegeneration\nAttribute.Primary.Intelligence Row_Strength Row_Intelligence Row_Resilience Row_Vigor\nRow_Armor Row_ArmorPenetration Row_BlockChance Row_CriticalHitChance Row_CriticalHitDamage Row_CriticalHitResistance Row_HealthRegeneration Row_ManaRegeneration Row_MaxHealth Row_MaxMana\nAuraGameplayTags.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;GameplayTagContainer.h\u0026#34; struct FAuraGameplayTags { public: static const FAuraGameplayTags\u0026amp; Get() {return GameplayTags;} static void InitializeNativeGameplayTags(); FGameplayTag Attribute_Primary_Strength; FGameplayTag Attribute_Primary_Intelligence; FGameplayTag Attribute_Primary_Resilience; FGameplayTag Attribute_Primary_Vigor; FGameplayTag Attribute_Secondary_Armor; FGameplayTag Attribute_Secondary_ArmorPenetration; FGameplayTag Attribute_Secondary_BlockChance; FGameplayTag Attribute_Secondary_CriticalHitChance; FGameplayTag Attribute_Secondary_CriticalHitDamage; FGameplayTag Attribute_Secondary_CriticalHitResistance; FGameplayTag Attribute_Secondary_HealthRegeneration; FGameplayTag Attribute_Secondary_ManaRegeneration; FGameplayTag Attribute_Secondary_MaxHealth; FGameplayTag Attribute_Secondary_MaxMana; FGameplayTag InputTag_LMB; FGameplayTag InputTag_RMB; FGameplayTag InputTag_1; FGameplayTag InputTag_2; FGameplayTag InputTag_3; FGameplayTag InputTag_4; FGameplayTag Damage; FGameplayTag Effect_HitReact; private: static FAuraGameplayTags GameplayTags; }; AuraGameplayTags.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026#34;AuraGameplayTags.h\u0026#34; #include \u0026#34;GameplayTagsManager.h\u0026#34; FAuraGameplayTags FAuraGameplayTags::GameplayTags; void FAuraGameplayTags::InitializeNativeGameplayTags() { GameplayTags.Attribute_Primary_Strength = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Strength\u0026#34;), FString(\u0026#34;Increases physical damage\u0026#34;)); GameplayTags.Attribute_Primary_Intelligence = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Intelligence\u0026#34;), FString(\u0026#34;Increases magical damage\u0026#34;)); GameplayTags.Attribute_Primary_Resilience = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Resilience\u0026#34;), FString(\u0026#34;Increases Armor and ArmorPenetration\u0026#34;)); GameplayTags.Attribute_Primary_Vigor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Vigor\u0026#34;), FString(\u0026#34;Increases Health\u0026#34;)); //////////////////// GameplayTags.Attribute_Secondary_Armor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.Armor\u0026#34;), FString(\u0026#34;Reduce damage taken\u0026#34;)); GameplayTags.Attribute_Secondary_ArmorPenetration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ArmorPenetration\u0026#34;), FString(\u0026#34;Ignore percentage of enemy\u0026#34;)); GameplayTags.Attribute_Secondary_BlockChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.BlockChance\u0026#34;), FString(\u0026#34;Chance to cut incoming damage in half\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitChance\u0026#34;), FString(\u0026#34;Chance to double damage plus critical hit bonus\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitDamage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitDamage\u0026#34;), FString(\u0026#34;Bonus damage added when a critical hit is scored\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitResistance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitResistance\u0026#34;), FString(\u0026#34;Reduces critical hit chance of attacking enemies\u0026#34;)); GameplayTags.Attribute_Secondary_HealthRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.HealthRegeneration\u0026#34;), FString(\u0026#34;Amount of Health regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_ManaRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ManaRegeneration\u0026#34;), FString(\u0026#34;Amount of Mana regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_MaxHealth = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxHealth\u0026#34;), FString(\u0026#34;Maximum amount of Health\u0026#34;)); GameplayTags.Attribute_Secondary_MaxMana = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxMana\u0026#34;), FString(\u0026#34;Maximum amount of Mana\u0026#34;)); ///////////// GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.LMB\u0026#34;), FString(\u0026#34;Input Tag for Left Mouse Button\u0026#34;)); GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.RMB\u0026#34;), FString(\u0026#34;Input Tag for Right Mouse Button\u0026#34;)); GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.1\u0026#34;), FString(\u0026#34;Input Tag for Key 1\u0026#34;)); GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.2\u0026#34;), FString(\u0026#34;Input Tag for Key 2\u0026#34;)); GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.3\u0026#34;), FString(\u0026#34;Input Tag for Key 3\u0026#34;)); GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.4\u0026#34;), FString(\u0026#34;Input Tag for Key 4\u0026#34;)); //////////////////// GameplayTags.Damage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Damage\u0026#34;), FString(\u0026#34;Damage\u0026#34;)); GameplayTags.Effect_HitReact = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Effect.HitReact\u0026#34;), FString(\u0026#34;Tag granted when Hit Reacting\u0026#34;)); } AuraAttributeSet.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Strength, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Strength; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Strength); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Intelligence, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Intelligence; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Intelligence); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Resilience, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Resilience; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Resilience); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Vigor, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Vigor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Vigor); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxHealth, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxHealth; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxHealth); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxMana, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxMana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxMana); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Armor, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData Armor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Armor); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ArmorPenetration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ArmorPenetration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ArmorPenetration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_BlockChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData BlockChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,BlockChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitDamage, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitDamage); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitResistance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitResistance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitResistance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_HealthRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData HealthRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,HealthRegeneration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ManaRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ManaRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ManaRegeneration); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Health, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Mana, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Mana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Mana); ///////////////// UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); //////////////////// UFUNCTION() void OnRep_Strength(const FGameplayAttributeData\u0026amp; OldStrength)const; UFUNCTION() void OnRep_Intelligence(const FGameplayAttributeData\u0026amp; OldIntelligence)const; UFUNCTION() void OnRep_Resilience(const FGameplayAttributeData\u0026amp; OldResilience)const; UFUNCTION()\tvoid OnRep_Vigor(const FGameplayAttributeData\u0026amp; OldVigor)const; UFUNCTION()\tvoid OnRep_MaxHealth(const FGameplayAttributeData\u0026amp; OldMaxHealth)const; UFUNCTION()\tvoid OnRep_MaxMana(const FGameplayAttributeData\u0026amp; OldMaxMana)const; UFUNCTION()\tvoid OnRep_Armor(const FGameplayAttributeData\u0026amp; OldArmor)const; UFUNCTION()\tvoid OnRep_ArmorPenetration(const FGameplayAttributeData\u0026amp; OldArmorPenetration)const; UFUNCTION()\tvoid OnRep_BlockChance(const FGameplayAttributeData\u0026amp; OldBlockChance)const; UFUNCTION()\tvoid OnRep_CriticalHitChance(const FGameplayAttributeData\u0026amp; OldCriticalHitChance)const; UFUNCTION()\tvoid OnRep_CriticalHitDamage(const FGameplayAttributeData\u0026amp; OldCriticalHitDamage)const; UFUNCTION()\tvoid OnRep_CriticalHitResistance(const FGameplayAttributeData\u0026amp; OldCriticalHitResistance)const; UFUNCTION()\tvoid OnRep_HealthRegeneration(const FGameplayAttributeData\u0026amp; OldHealthRegeneration)const; UFUNCTION()\tvoid OnRep_ManaRegeneration(const FGameplayAttributeData\u0026amp; OldManaRegeneration)const; UFUNCTION()\tvoid OnRep_Health(const FGameplayAttributeData\u0026amp; OldHealth)const; UFUNCTION()\tvoid OnRep_Mana(const FGameplayAttributeData\u0026amp; OldMana)const; AuraAttributeSet.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 UAuraAttributeSet::UAuraAttributeSet() { const FAuraGameplayTags\u0026amp; GameplayTags = FAuraGameplayTags::Get(); TagToAttribute.Add(GameplayTags.Attribute_Primary_Strength,\tGetStrengthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Intelligence,\tGetIntelligenceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Resilience,\tGetResilienceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Vigor,\tGetVigorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_Armor,\tGetArmorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ArmorPenetration,\tGetArmorPenetrationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_BlockChance,\tGetBlockChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitChance,\tGetCriticalHitChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitDamage,\tGetCriticalHitDamageAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitResistance,\tGetCriticalHitResistanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_HealthRegeneration,\tGetHealthRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ManaRegeneration,\tGetManaRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxHealth,\tGetMaxHealthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxMana,\tGetMaxManaAttribute); } AuraAttributeSet.cpp 这是一个宏，那些属性的网络同步函数写起来真逆天，用这个宏去写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define ATTRIBUTE_REP(Name)\\ void UAuraAttributeSet::OnRep_##Name(const FGameplayAttributeData\u0026amp; Old##Name)const\\ {\\ GAMEPLAYATTRIBUTE_REPNOTIFY(UAuraAttributeSet,Name,Old##Name);\\ }; #define ATTRIBUTE_NOTIFY(Name)\\ DOREPLIFETIME_CONDITION_NOTIFY(UAuraAttributeSet,Name,COND_None,REPNOTIFY_Always); #pragma region Net ATTRIBUTE_REP(Health)\tATTRIBUTE_REP(Mana) ATTRIBUTE_REP(Strength)\tATTRIBUTE_REP(Intelligence)\tATTRIBUTE_REP(Resilience)\tATTRIBUTE_REP(Vigor) ATTRIBUTE_REP(Armor)\tATTRIBUTE_REP(ArmorPenetration)\tATTRIBUTE_REP(BlockChance)\tATTRIBUTE_REP(CriticalHitChance) ATTRIBUTE_REP(MaxHealth)\tATTRIBUTE_REP(MaxMana)\tATTRIBUTE_REP(CriticalHitDamage)ATTRIBUTE_REP(CriticalHitResistance) ATTRIBUTE_REP(HealthRegeneration)\tATTRIBUTE_REP(ManaRegeneration) void UAuraAttributeSet::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); ATTRIBUTE_NOTIFY(Health)\tATTRIBUTE_NOTIFY(Mana) ATTRIBUTE_NOTIFY(Strength)\tATTRIBUTE_NOTIFY(Intelligence)\tATTRIBUTE_NOTIFY(Resilience)\tATTRIBUTE_NOTIFY(Vigor) ATTRIBUTE_NOTIFY(Armor)\tATTRIBUTE_NOTIFY(ArmorPenetration)\tATTRIBUTE_NOTIFY(BlockChance)\tATTRIBUTE_NOTIFY(CriticalHitChance) ATTRIBUTE_NOTIFY(MaxHealth)\tATTRIBUTE_NOTIFY(MaxMana)\tATTRIBUTE_NOTIFY(CriticalHitDamage)\tATTRIBUTE_NOTIFY(CriticalHitResistance) ATTRIBUTE_NOTIFY(HealthRegeneration)\tATTRIBUTE_NOTIFY(ManaRegeneration) } #pragma endregion ","date":"2025-01-10T11:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88/","title":"GAS A - 技能系统总览"},{"content":"示例 点击按钮自动创建GE，并且避免重名\n修改LOGO图标，要手动把svg文件放到Shader文件夹里(示例代码是这样写的)\n可以修改代码 放到别的位置去，\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #define RootToContentDir Style-\u0026gt;RootToContentDir void FElemental_EditorModule::StartupModule() { const FString ProjectShaderDir = FPaths::Combine(FPaths::ProjectDir(), TEXT(\u0026#34;Shaders\u0026#34;)); //[const ISlateStyle*] -\u0026gt; [ISlateStyle*] -\u0026gt; [FSlateStyleSet*] FSlateStyleSet* Style = static_cast\u0026lt;FSlateStyleSet*\u0026gt;(const_cast\u0026lt;ISlateStyle*\u0026gt;(\u0026amp;FAppStyle::Get())); Style-\u0026gt;SetContentRoot(ProjectShaderDir); Style-\u0026gt;Set(\u0026#34;AppIcon\u0026#34;, new IMAGE_BRUSH_SVG(\u0026#34;ELIcon\u0026#34;, FVector2f(50.f, 50.f), FStyleColors::White)); RegisterMenus(); } static void CreateBP() { UEditorAssetSubsystem* EditorAssetSubsystem = GEditor-\u0026gt;GetEditorSubsystem\u0026lt;UEditorAssetSubsystem\u0026gt;(); IContentBrowserSingleton\u0026amp; CB = IContentBrowserSingleton::Get(); const auto Path = CB.GetCurrentPath(); int32 RandName = 0; FString BaseName; FString PackageName; do { RandName++; BaseName = FString::Printf(TEXT(\u0026#34;MyGameplayEffect%d\u0026#34;), RandName); PackageName = FPaths::Combine(Path.GetInternalPathString(), BaseName); } while (EditorAssetSubsystem-\u0026gt;DoesAssetExist(PackageName)); UPackage * Package = CreatePackage(*PackageName); UBlueprint* Blueprint = FKismetEditorUtilities::CreateBlueprint(UGameplayEffect::StaticClass(), Package, *BaseName, BPTYPE_Normal, UBlueprint::StaticClass(), UBlueprintGeneratedClass::StaticClass()); if (Blueprint) { FAssetRegistryModule::AssetCreated(Blueprint); Package-\u0026gt;MarkPackageDirty(); } } void FElemental_EditorModule::RegisterMenus() { auto Visible = [](){return GEditor-\u0026gt;PlayWorld == nullptr;}; UToolMenu* Menu = UToolMenus::Get()-\u0026gt;ExtendMenu(\u0026#34;LevelEditor.LevelEditorToolBar.PlayToolBar\u0026#34;); FToolMenuSection\u0026amp; Section = Menu-\u0026gt;AddSection(\u0026#34;PlayGameExtensions\u0026#34;, TAttribute\u0026lt;FText\u0026gt;(), FToolMenuInsert(\u0026#34;Play\u0026#34;, EToolMenuInsertType::After)); const FUIAction UIAction = FUIAction(FExecuteAction::CreateStatic(CreateBP), FCanExecuteAction::CreateLambda(Visible),FIsActionChecked(),FIsActionButtonVisible::CreateLambda(Visible)); const FToolMenuEntry CommonMapEntry = FToolMenuEntry::InitToolBarButton( \u0026#34;CreateGE\u0026#34;,UIAction,FText::FromString(\u0026#34;GE\u0026#34;),FText::FromString(\u0026#34;Create GameplayEffect\u0026#34;), FSlateIcon(FAppStyle::GetAppStyleSetName(), \u0026#34;Icons.Blueprint\u0026#34;)); Section.AddEntry(CommonMapEntry); } Build.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PublicDependencyModuleNames.AddRange( new string[] { \u0026#34;Core\u0026#34;,\u0026#34;AssetDefinition\u0026#34;, \u0026#34;GameplayAbilities\u0026#34;, \u0026#34;EngineAssetDefinitions\u0026#34;,\u0026#34;ToolMenus\u0026#34;,\u0026#34;ContentBrowser\u0026#34;,\u0026#34;ContentBrowserData\u0026#34; } ); PrivateDependencyModuleNames.AddRange( new string[] { \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;Slate\u0026#34;, \u0026#34;SlateCore\u0026#34; } ","date":"2025-01-09T21:38:46+08:00","permalink":"https://akaklya.github.io/p/%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91-%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%93%9D%E5%9B%BE-%E4%BF%AE%E6%94%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%9B%BE%E6%A0%87/","title":"编辑器开发 - 创建指定类型蓝图 - 修改编辑器图标"},{"content":"https://ue5wiki.com/\nUObject 反射系统 反射文档 反射知识库\nC++ 编译为 CPU 机器码，而 CPU 并不了解类或变量的概念。类只是为编译器提供如何设置 CPU 代码的信息，变量最终只转化为内存地址，因此CPU并不知道类的存在，这些信息是由软件自身来跟踪的。在虚幻引擎4（UE4）中，这是通过反射系统实现的，所以你的代码可以“反映”其自身。\nUE4 拥有一个特别的工具叫做 UnrealHeaderTool，它收集你创建的那些宏，比如 UPROPERTY、UCLASS、USTRUCT，并生成额外的 C++ 代码，这些代码将类、函数和属性注册到反射系统中，这样引擎就能识别这些元素并跟踪它们。反射系统注册表中的每个元素都有一个对应的 UField 对象被创建，用来表示代码中的事物并存储有关它的信息。每个UObject类都有一个UClass对象，你可以通过调用GetClass()或StaticClass()来获取这个对象\nCDO 它的主要功能是存储类对象的默认状态并保存默认变量状态。在 C++ 中创建的每个标有 UCLASS() 的 UObject 类都会注册到反射系统。\n在C++创建一个Actor \u0026ndash;\u0026gt; AXActor，int32 K = 1 , 但是在构造函数里重新赋值 K=2，那么它的默认对象(CDO)的值就是2，\n1 2 3 4 UClass* XActor = AXActorStaticClass(); Uobject* XAObj = XActor-\u0026gt;GetDefaultObject(); AXACtor* CDO = Cast\u0026lt;AXActor\u0026gt;(XAObj); //CDO-\u0026gt;K 得到的值是2 1 StaticClass\u0026lt;UObject\u0026gt;` 或者 `UObject::StaticClass() 当UClass的 类默认对象（CDO）更改，引擎将尝试在加载类的所有实例时对这些实例应用这些更改。对于给定Object实例，如果更新的变量值与旧CDO中的值相匹配，则将更新为它在新CDO中保存的值。如果变量包含任何其他值，系统会假设这个值是故意设置的，这些更改将会被保留。\n例如，假设你在一个关卡中放置了多个 AEnemy Object并保存，然后将 AEnemy 构造函数中的默认Health值设置为100。再假设将Enemy_3的Health值设置为500，因为它们特别难对付。现在，假设你改变注意了，将Health的默认值增加到150。下次加载关卡时，虚幻意识到你更改了CDO，并将使用旧默认Health值（100）的所有AEnemy实例更新为使用Health值150。Enemy_3的Health将保持在500，因为它不使用旧的默认值。\n因为构造函数是在引擎和对象自身的初始化早期阶段调用的，你不应该在其中执行任何游戏逻辑代码，否则很可能会导致崩溃。你应该使用类中的其他事件，如PostInitProperties（在蓝图系统对对象所做的更改应用后调用）、PostInitComponents（在Actor中的组件被初始化后调用）或BeginPlay（当Actor被完全初始化时）。请注意，前两个事件也在你将Actor放置在关卡编辑器时被调用。\n总结来说，CDO的主要作用是在引擎中保持类的默认状态，使得即使是在C++中，也可以方便地获取到类的默认属性和行为。由于CDO是在引擎初始化期间创建的，因此在这个时候调用构造函数可能会导致不稳定的行为，所以开发者应该避免在构造函数中进行依赖于其他尚未初始化对象的操作。\n乱七八糟 Log 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;, Package-\u0026gt;GetName(), ErrorCode); 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;,(\u0026#34;Name\u0026#34;, Package-\u0026gt;GetName()), (\u0026#34;Error\u0026#34;, ErrorCode),(\u0026#34;Flags\u0026#34;, LoadFlags)); 1 GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT(\u0026#34;This is an Example on-screen debug message.\u0026#34;)); 1 2 3 std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Hello, {}!\\n\u0026#34;, \u0026#34;World\u0026#34;); // std::format printf(\u0026#34;Hello, %s!\\n\u0026#34;, \u0026#34;World\u0026#34;); // printf std::cout \u0026lt;\u0026lt; \u0026#34;Hello, \u0026#34; \u0026lt;\u0026lt; \u0026#34;World\u0026#34; \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; // iostreams 反射宏 其实 GENERATED_BODY 与GENERATED_UCLASS_BODY的区别在于：GENERATED_BODY声明并定义 了一个接收 const FObjectInitializer\u0026amp; 的构造函数，GENERATED_UCLASS_BODY只声明 了该构造函数，需要用户自己提供一个定义。\n","date":"2000-01-20T20:37:57+08:00","permalink":"https://akaklya.github.io/p/u-/","title":"U++"},{"content":"并发编程 A系列 使用的书 → C++并发编程实战（第2版）\n下载PDF\n启程上路 每个线程都需要一个起始函数(initial function), 新线程从这个函数开始执行。起始线程从main()开始执行，新线程则从hello()开始执行新线程启动后，起始线程继续执行。 如果起始线程不等待新线程结束， 就会一路执行， 直到main()结束，甚至很可能直接终止整个程序，新线程根本没有机会启动。 这正是要调用join()的原因,该调用会令主线程等待子线程.\n线程管控 确定采用多线程技术，从何入手？ 怎么启动线程？怎么查验它们是否已经结束？怎么监测其运行状态？如果给定一个线程, 只要令 std::thread 对象与之关联,就能管控该线程的几乎每个细节。 在本章中,从基础开始: 发起线程, 然后等待它结束, 或让它在后台运行。接着,将学习在启动时向线程函数传递参数,以及如何把线程的归属权从某个 std: :thread 对象转移给另一个.最后,会探讨怎样选择合适数量的线程,以及怎样识别特定的线程.\n线程调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void Hello() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;; } class task { public: void operator()() const { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Hello!\\n\u0026#34;; } }; int main() { task q; std::thread t1(q); t1.join(); std::thread t2((task())); t2.join(); std::thread t3([]() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Lambda!\\n\u0026#34;; }); t3.join(); } 输出: Hello Hello! Hello Hello! Hello Lambda! 主线程的局部变量被销毁后，分离的线程仍会访问局部变量，导致未定义行为.意图在函数中创建线程，并让线程访问函数的局部变量身。除非线程肯定会在该函数退出前结束，否则切勿这么做。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; class MyClass { public: int T_Time = 0; std::string Name = \u0026#34;Manba out\u0026#34;; }; void GetName(MyClass Class) { while (true) { Class.T_Time +=1 ; std::cout \u0026lt;\u0026lt; Class.T_Time \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; Class.Name \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; class Thread_guard { std::thread\u0026amp; t; public: Thread_guard(std::thread\u0026amp; t1) : t(t1){} ~Thread_guard() { if (t.joinable()) { t.join(); } } }; int main() { MyClass Manba; std::thread t1(GetName,Manba); Thread_guard tg(t1); std::this_thread::sleep_for(std::chrono::seconds(1)); } join? detach? join 使用 join 场景: 当你需要确保主线程等待子线程完成其任务后再继续执行时。 当子线程的结果或副作用对主线程很重要时。 优点: 确保线程资源被正确释放。 可以获取子线程的返回值（通过 std::future 和 std::promise）。 避免数据竞争和未定义行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void workerFunction(int id) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; finished\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(workerFunction, 1); std::thread t2(workerFunction, 2); t1.join(); // 主线程等待 t1 完成 t2.join(); // 主线程等待 t2 完成 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } detach 使用 detach 场景: 当你希望子线程独立运行，不需要主线程等待其完成时。 当子线程执行的任务是后台任务，且不需要与主线程交互时。 优点: 子线程可以独立运行，主线程可以继续执行其他任务。 适用于不需要等待结果的任务，如日志记录、监控等。 注意事项: 使用 detach 后，线程对象将不再与实际线程关联。 必须确保线程使用的资源（如动态分配的内存）在主线程结束前仍然有效，否则可能导致悬空指针或资源泄漏。 一旦线程被分离，无法再通过线程对象与其通信或等待其完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;memory\u0026gt; void backgroundTask(std::shared_ptr\u0026lt;int\u0026gt; data) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Background task finished with data: \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } int main() { auto data = std::make_shared\u0026lt;int\u0026gt;(42); std::thread t(backgroundTask, data); t.detach(); // 主线程不等待 t 完成 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 若要分离线程，则需在 std::thread对象上调用其成员函数 detach()。调用完成后， std::thread 对象不再关联实际的执行线程，故它变得从此不可汇合( 不可join)。如果要把std::thread 对象和线程分离，就必须存在与其关联的执行线程：若没有与 其关联的执行线程，便不能在std::thread对象上凭空调用 detach()。 这与调用join()的前 提条件毫无二致，检查方法完全相同，只有当t.joinable()返回true 时，我们才能调用 t.detach() .\n考虑一个应用程序，如文字处理软件。为了令它同时编辑多个文件，在用户界面层面和内部层面都有多种实现方式。一种常见的做法是,创建多个独立的顶层窗 口,分别与正在编辑的文件逐一对应。尽管这些窗口看起来完全独立， 各有自己的选项单,但它们其实都在同一应用程序的实例中运行。相应的内部处理是, 每个文件的编辑窗口都在各自线程内运行；每个线程运行的代码相同，而处理的数据有别， 因为这些数据与各文件和对应窗口的属性关联。按此，打开一个新文件就需启动一 个新线程。新线程只处理打开新文件的请求，并不牵涉等待其他线程的运行和结束。 对其他线程而言，该文件由新线程负责，与它们无关。综上，运行分离线程就成了首选方案。\n移交线程归属权 首先，我们启动新线程①,并使之关联t1。接着，构建t2.在其初始化过程中调用 std:;move()), 将新线程的归属权显式地转移给t2 ②。在②之前，t1关联着执行线程， some_function()函数在其上运行；及至②处，新线程关联的变换为t2。然后,启动另一新线程③，它与一个std::thread类型的临时对象关联。新线程的归属权随即转移给t1.这里无须显式调用std::move(), 因为新线程本来就由临时变量持有， 而源自临时变量的移动操作会自动地隐式进行。 t3按默认方式构造④，换言之，在创建时，它并未关联任何执行线程。在⑤处，t2 原本关联的线程的归属权会转移给t3，而t2是具名变量，故需再次显式调用 std::move(), 先将其转换为右值。经过这些转移，t1与运行 some_other_ function()的线程关联，t2没有关联线程，而t3与运行some_ function()的线程关联。在最后一次转移中⑥，运行some_function()的线程的归属权转移到t1. 该线程最初由t1启动。但在转移之时，t1已经关联运行 some_other_ function()的线程。因此 std: :terminate()会被调用，终止整个程序。\n从函数内部返回std::thread对象 std::thread 支持移动操作的意义是，函数可以便捷地向外部转移线程的归属权.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void Hello() { while (true) { std::cout\u0026lt;\u0026lt;\u0026#34;Hello \\n\u0026#34;; } } std::thread F() { std::thread t1(Hello); return t1; } int main() { std::thread MyThread = F(); MyThread.join(); std::this_thread::sleep_for(std::chrono::seconds(1)); } 输出: 很多Hello 类似地，若归属权可以转移到函数内部，函数就能够接收std::thread实例作为按右值传递的参数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Hello() { while (true) { std::cout\u0026lt;\u0026lt;\u0026#34;Hello \\n\u0026#34;; } } std::thread F() { std::thread t1(Hello); return t1; } void JoinThread(std::thread InThread) { InThread.join(); } int main() { std::thread MyThread = F(); JoinThread(std::move(MyThread)); std::this_thread::sleep_for(std::chrono::seconds(1)); } std::thead 支持移动语义给我们带来了不少好处。一个好处是，对 Thread_guard 类稍作修改，我们就能用其构建线程，并将线程交由该类掌管。另一个好处是，只要线程归属权转移给某个Thread_guard 对象，其他对象就无法执行汇合或分离操作。反之,假设std::thread 不支待移动语义，那么万一 Thread_guard 对象的生存期超出它管控的线程，将导致种种不良后果，事实上支持移动语义免除了这些麻烦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void do_work(unsigned id); void f() { std::vector\u0026lt;std::thread\u0026gt; threads; for(unsigned i = 0; i\u0026lt;20;++i) { threads.emplace_back(do_work,i); } for(auto\u0026amp; entry : threads) { entry.join(); } } 把std::thread对象存放到 std::vector容器内，向线程管控的自动化迈进了一步：若要为多个线程分别直接创建独立变量，还不如将它们集结成组，统一处理。\nstd::thread::hardware_concurrency() 函数，返回值表示程序在运行中可真正并发的线程数量。若信息无法获取，函数可能返回0.\n识别线程 线程ID 所属型别是 std::thread::id,\n1 2 3 void f(); std::thread t(f); std::thread::id ID = t.get_id(); 在与线程关联的 std: :thread 对象上调用成员函数get_idQ,即可得到该线程的 ID如果 std::thread 对象没有关联任何执行线程，调用get_id则会返回一个 std::thread::id 对象，它按默认构造方 式生成，表示“线程不存在＂。\n线程 ID, 可随意进行复制操作或比较运算。如果两个std::thread::id型别的对象相等，则它们表示相同的线程，或者它们的值都表示“线程不存在＂；如果不相等,它们就表示不同的线程，或者当中一个表示某个线程，而另一个表示\u0026quot;线程不存在“.\n主线程负责发起其他线程，它可能需要承担稍微不一样的工作。若需在该例中识别主线程，我们可以在发起其他线程之前， 在主线程中预先保存std::this_thread::get_id()的结果.只要对比各线程预存的值和自身的线程ID, 就能做出判断.\n1 2 3 4 5 6 7 8 9 std::thread::id master_thread; void some_core_part_of_algorithm() { if(std::this_thread::get_id() == master_thread) { do_master_thread_work(); } do_common_work(); } 线程间共享数据 运用多线程实现并发，其中一个好处是，它具备潜能，可以简单、直接地共享数据。\n设想你有一段时间和朋友合租公寓，公寓只有一个厨房和一个浴室。除非你们的感情格外深厚， 否则不可能同时使用浴室。另外,假若朋友占用浴室很久,而你恰好也需要,便会感到不方便。类似地,假设你们使用的是组合烤箱,尽管可以同时烹任,但若一人要烤香肠,同时另一人却要烘蛋糕, 结果应该不会太好。 并且,我们也清楚共用办公空间的烦恼:事情还没做完,有人却借走了工作所需之物,或者半成品被别人擅自更改。线程亦如此,若在线程之间共享数据，我们需要遵循规范:具体哪个线程按何种方式访问什么数据；还有，一旦改动了数据,如果牵涉到其他线程, 它们要在何时以什么通信方式获得通知。 同一进程内的多个线程之间，虽然可以简单易行地共享数据， 但这不是绝对的优势，有时甚至是很大的劣势。 不正确地使用共享数据，是产生与并发有关的错误的一个很大的诱因，其后果远比“香肠口味的蛋糕“严重。\n线程间共享数据的问题 如果多个线程共享数据,只要一个线程开始改动数据,就会带来很多隐患,产生麻烦。\n条件竞争 设想你去电影院购票看电影。大型影院有几位收银员同时收款,以便多人同时购票。 别人也在其他柜台购买电影票,倘若有人选择的场次与你相同, 那么,供选择的座位取决于你们谁先下单。如果只剩少量座位,事实上就形成了竞争,谁能买到最后几张票,下单的先后顺序至关重要。以上事例即为条件竞争:你得到什么座位 (甚至是否能买到票) 取决于购票的相对次序。\n诱发恶性条件竞争的典型场景是，要完成一项操作，却需改动两份或多份不同的数据.因为操作涉及两份独立的数据,而它们只能用单独的指令改动,当其中一份数据完成改动时,别的线程有可能不期而访。因为满足条件的时间窗口短小，所以条件竞争往往既难察觉又难复现。\n恶性条件竞争普遇“挑剔”出现的时机，当应用程序在调试环境下运行时,它们常常会完全消失,因为调试工具影响了程序的内部执行时序,哪怕只影响一点点。\n编写多线程程序，恶性条件竞争很可能成为致命伤；采用并发技术的软件会涉及许多复杂的逻辑，其目的正是避开恶性条件竞争。\n用互斥保护共享数据 访问一个数据结构前， 先锁住与数据相关的互斥；访问结束后， 再解锁互斥。 C++线程库保证了， 一旦有线程锁住了某个互斥，若其他线程试图再给它加锁, 则须等待,直至最初成功加锁的线程把该互斥解锁。互斥是C++最通用的共享数据保护措施之一，但非万能的灵丹妙药。互斥本身也有问题，表现形式是死锁、对数据的过保护或欠保护.\n在C＋＋中使用互斥 通过构造 std::mutex 的实例来创建互斥， 调用成员函数 lock()对其加锁，调用unlock()解锁。\n不推荐直接调用成员函数的做法。 原因是, 若按此处理, 那我们就必须记住,在函数以外的每条代码路径上都要调用 unlock(), 包括由于异常导致退出的路径。 取而代之， C++-标准库提供了类模板 std::lock_guard\u0026lt;\u0026gt;， 针对互斥类融合实现了 RAII 手法:在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int T_Value = 0; void func() { for (int i = 0;i\u0026lt;10000000 ; i++) { T_Value = T_Value + 1; T_Value = T_Value - 1; } } int main() { std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout\u0026lt;\u0026lt;T_Value\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } 输出：完全随机的数 T_Value总是 +1 再-1，最终结果应该为0才对，这就是线程不上锁的结果，导致乱序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int T_Value = 0; std::mutex T_Mutex; void func() { for (int i = 0;i\u0026lt;10000000 ; i++) { std::lock_guard guard(T_Mutex); T_Value = T_Value + 1; T_Value = T_Value - 1; } } 手动使用锁的方法 for (int i = 0;i\u0026lt;10000000 ; i++) { T_Mutex.lock(); T_Value = T_Value + 1; T_Value = T_Value - 1; T_Mutex.unlock(); } 利用互斥保护共享数据并不太简单，我们不能把std::lock_guard对象化作“铁拳”，对准每个成员函数施予“重击“。一旦出现游离的指针或引用，这种保护就全部形同虚设。不管成员函数通过什么”形式”——无论是返回值，还是输出参数(out parameter) ——向调用者返回指针或引用，指向受保护的共享数据，就会危及共享数据安全。\n死锁:问题和解决方法 假设一件玩具由两部分组成，需要同时配合才能玩，譬如玩具鼓和鼓槌； 又假设有两个小孩都喜欢这件玩具。倘若其中一个孩子拿到了玩具鼓和鼓槌，那他就能尽兴地一直敲鼓，敲烦了才停止。如果另一个孩子也想玩，便须等待，即使感到难受也没办法。 再想象一下，玩具鼓和鼓槌分散在玩具箱里，两个小孩同时都想玩。于是，他们翻遍玩具箱， 其中一人找到了玩具鼓，另一人找到了鼓槌， 除非当中一位割爱让对方先玩，否则，他们只会僵待不下，各自都紧抓手中的部件不放，还要求对方＂缴械＂，结果都玩不成。\n我们面对的并非小孩争抢玩具，而是线程在互斥上争抢锁：有两个线程，都需要同时锁住两个互斥，才可以进行某项操作，但它们分别都只锁住了一个互 斥，都等着再给另一个互斥加锁。于是，双方毫无进展，因为它们同在苦苦等待对方解 锁互斥。上述情形称为死锁（deadlock)。为了进行某项操作而对多个互斥加锁， 由此诱发的最大的问题之一正是死锁。\n防范死锁的建议通常是，始终按相同顺序对两个互斥加锁。若我们总是先锁互斥A 再锁互斥B，则永远不会发生死锁。有时候，这直观、易懂，因为诸多互斥的用途各异。 但也会出现棘手的状况，例如，运用多个互斥分别保护多个独立的实例， 这些实例属于同一个类。考虑一个函数，其操作同一个类的两个实例，互相交换它们的内部数据。为了保证互换正确完成，免受并发改动的不良影响，两个实例上的互斥都必须加锁。可是， 如果选用了固定的次序（两个对象通过参数传入，我们总是先给第一个实例的互斥加锁， 再轮到第二个实例的互斥），前面的建议就适得其反：针对两个相同的实例，若两个线程都通过该函数在它们之间互换数据，只是两次调用的参数顺序相反，会导致它们陷入死锁.\n所幸， C++标准库提供了 std::lock()函数，专门解决这一问题。它可以同时锁住多个互斥，而没有发生死锁的风险。\n下列代码中，传入构造函数的两个互斥都被加锁，机制与std::lock()函数相同， 因此，当构造函数完成时，它们就都被锁定，而后，在析构函数内一起被解锁。我们可以重写代码清单3.6 的swap()函数，其内部操作代码如下\n1 2 3 4 5 6 7 8 9 void swap(X\u0026amp; lhs,X\u0026amp; rhs) { if(\u0026amp;lhs==rhs) { return; } std::scoped_lock guard(lhs.m,rhs.m); swap(lhs.some_detail,rhs.some_detail); } 上例利用了C++17加入的另一个新特性：类模板参数推导.依据传入构造函数的参数对象自动匹配 选择正确的互斥型别。 等价于:\n1 std::scoped_lock\u0026lt;std::mutex,std::mutex\u0026gt; guard(lhs.m,rhs.m) 在C++17 之前，我们采用std::lock()编写代码。 现在有了 std::scoped_lock, 于是那些代码绝大多数可以改用这个编写，从而降低出错的概率。\n防范死锁的补充准则 虽然死锁的最常见诱因之一是锁操作,但即使没有牵涉锁,也会发生死锁现象。假定有两个线程， 各自关联了 std; :thread 实例，若它们同时在对方的 std::thread实例上 调用join(),就能制造出死锁现象却不涉及锁操作。 如果线程甲正等待线程乙完成某一动作， 同时线程乙却在等待线程甲完成某一动作， 便会构成简单的循环等待.引起死锁.防范死锁的准则最终可归纳成一个思想:只要另一线程有可能正在等待当前线程，那么当前线程千万不能反过来 等待它。\n避免嵌套锁 第一条准则最简单：假如已经持有锁，就不要试图获取第二个锁。若能恪守这点， 每个线程便最多只能持有唯一一个锁，仅锁的使用本身不可能导致死锁。但是还存在其他可能引起死锁的场景（譬如,多个线程彼此等待）,而操作多个互斥锁很可能就是最常见的死锁诱因。万一确有需要获取多个锁，我们应采用 std::lock()函数，借单独的调用动作一次获取全部锁来避免死锁。\n一旦持锁，就须避免调用由用户提供的程序接口 依从固定顺序获取锁 B: 原子性 原子性:一段代码独占整个计算机系统单处理器多线程: 线程在运行时可能被中断，切换到另一个线程运行.多处理器多线程: 线程根本就是并行执行的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void thread1() { while (1){printf(\u0026#34;a\u0026#34;);} } void thread2() { while (1) { printf(\u0026#34;b\u0026#34;);} } int main() { std::thread s1(thread1); std::thread s2(thread2); s1.join(); s2.join(); } printf没有打印出乱码，一直是a或b，因为它线程安全，保证多线程的原子性.\n","date":"1573-01-01T17:59:51+08:00","permalink":"https://akaklya.github.io/p/c-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-a-1/","title":"C++ 并发编程 A - 1"},{"content":"设计模式专题\n构造 赋值 析构 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { String s1(); String s2(\u0026#34;Hello\u0026#34;); // 拷贝构造 String s3(s1); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; // 拷贝赋值 s3 = s2; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; } 不写这些函数，编译器自动写.\n构造 析构 String类，手动定义 构造、赋值、析构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 String::String(const char* cstr = 0) { if(cstr) { // 字符长度+1 的+1 是结尾符号\u0026#39;\\0\u0026#39; m_data = new char[strlen(cstr)+1]; strcpy(m_data,cstr); } else { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } } String::~String() { //清理动态分配的数组内存[] delete[] m_data; } { String s1(); String s2(\u0026#34;hello\u0026#34;); String* p = new String(\u0026#34;hello\u0026#34;); delete p; } // 离开作用域，s1 s2自动释放 析构，p要delete. 拷贝构造 b=a 浅拷贝， b的data指向a的data的区域，导致b原本的\u0026quot;World\\0\u0026quot;内存泄露， 当a的data修改后，b跟着受影响.\n深拷贝，空间创建出以后 把内容拷贝过去.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 String::String(const String\u0026amp; str) { m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); } { String s1(\u0026#34;hello\u0026#34;); 下面两行意思相同 String s2(s1); //String s2 = s1; 忽略上面一行，s2是新创建出的对象，调用构造函数 } 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）.按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。\n深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）\n拷贝赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String\u0026amp; String::operator=(const String\u0026amp; str) { // 必写 检测自我赋值 if(this == \u0026amp;str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); return *this; } { String s1(\u0026#34;hello\u0026#34;); String s2(s1); s2 = s1; } 检测自我赋值，避免delete自杀\n流重载要写到类外\n1 2 3 4 5 6 7 8 9 10 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const string\u0026amp; str) { os \u0026lt;\u0026lt; str.get_c_str(); return os; } { String s1(\u0026#34;hello\u0026#34;); cout \u0026lt;\u0026lt; s1; } stack 栈 heap堆 stack是存在于某作用域的一块内存空间。调用函数时 函数本身会形成一个stack用来存放它接收的参数 和 返回地址在函数本体内声明的任何变量，其所使用的内存块都取自stack.heap 或 system heap ,是操作系统提供的一块 global内存空间，程序可动态分配从其中获得区块. new出来的东西必须手动delete\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Complex{...}; { Complex c1(1,2); Complex* p = new Complex(3); static Complex c3(1,2); //释放p，否则p离开作用域后就死亡了，会对内存失去控制，导致内存泄露，无法把内存还给系统 delete p; } //c1占用的空间来自stack. //Complex(3)是临时对象，占用的空间是以new自heap动态分配来的，并由p指向. //c1是stack object，生命在作用域结束的时候结束， //在作用域内的object 又称为 auto object，因为会被自动清理. //c3是static object,生命在作用域结束后仍然存在，直到整个程序结束. 1 2 3 4 5 6 7 8 9 10 class Complex{...}; Complex c4(1,2) int main() { } //C4是global object,生命在整个程序结束才结束。其作用域是 整个系统. new : 先分配内存，再调用构造 。 new内部调用malloc(n)\n1 2 3 4 5 6 Complex* pc = new Complex(1,2); //编译器转化为: void* mem = operator new( sizeof(Complex) ); pc = static_cast\u0026lt;Complex*\u0026gt;(mem); pc-\u0026gt;Complex::Complex(1,2); //实际是Complex::Complex(pc,1,2); delete:先调用析构， 再释放内存\n1 2 3 4 5 6 String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 1 2 3 4 5 6 7 8 9 10 class Complex { double A; double B; } class String { char* m_data; } VC内存 Complex、String被 new 出来之后的内存\n调试模式下的Complex的头尾都有 00000041 这一串数据，称为 cookie，这一个东西在delete时要用到. 末尾的1 表示内存以及分配出去，4表示其大小64，绿色块用来把内存大小从52填充为64Release模式下的Complex头尾有00000011,1表示大小为16. 当Complex被回收后，这一串数值会变成00000010，末尾的0表示已经被回收的内存.00000000 和 00000001 分别是0和16，只差一位，但十进制上差的是16，由于对象的内存大小必须是16的倍数，所以16以及16以下的数据 都是没有用到的，可以拿来做内存 分配出去 与 回收 的状态标记.\nnew Array的内存:\n8x3 ，一个Complex有2个double，2个double是8.32+4是debug的块, 4x2是头尾的51h， 4是用一个整数记录有3个Complex.String里面只有一个指针，所以图中有一个箭头去表示这个指针指向一个地方.\nArray 的new 与 delete delete要看内存头尾的cookie，cookie 记录了一整块的大小，如 图中的两个21h，delete根据它们可以把内存删掉. 此时 delete 和 delete[]不会造成内存泄露，使用delete[] 编译器才知道要删除的是数组，数组里有3个String，调用3次析构，再回收整块内存.不写delete[] 会造成内存泄露，但泄露的不是这一块内存，而是String里的指针，如图中右边的红色 ?! 块 是String里面指针指向的地方. 这里会发生内存泄露.\n1 2 3 4 5 6 7 8 9 10 11 class String { char* m_data; } String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 如果new的是Complex，里面只有double 没有指针， 即便是用 delete 也可以.\n用了array new 就必须搭配 delete[] 才可万无一失.\n阶段A 复习String.\nString使用char*指针，动态分配大小. 不使用数组 如果用数组，数组大小不确定 太大太小都不好.\nString里面有指针，要关注3个重要函数: 拷贝构造、拷贝赋值、析构.\n在这里不会修改来源端的数据，函数参数用const\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class String { public: // C - Style String(const char* cstr = 0); // 拷贝构造 String(const String\u0026amp; str); // 拷贝赋值 String\u0026amp; operator=(const String\u0026amp; str); //析构 ~String(); char* get_c_str() const {return m_data;} private: char* m_data; } static、cout 所有Account实例共用一份m_rate数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Account { public: static double m_rate; static void set_rate(const double\u0026amp; x){m_rate = x;} }; // 定义初始值 double Account::m_rate = 8.0; int main() { // 调用static函数的两个方式 Account::set_rate(5.0); Account a; a.set_rate(7.0); } Singleton ， 把构造函数放在private\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); static A a; } A::GetInstance.setup(); 有人调用GetInstance时，A才会出现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); } A\u0026amp; A::GetInstance() { static A a; return a; } Cout为了打印出一些不同类型的数据 ， 做了一堆重载\n复合、继承、委托 复合 Adapter适配器设计模式\ndeque的功能很强，拿过来改造一下，只开放部分函数 成为queue.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template\u0026lt;class T\u0026gt; class queue { ... protected: deque\u0026lt;T\u0026gt; c; public: // 使用c的操作函数完成. bool empty() const {return c.empty();} size_type size() const {return c.size();} reference front() {return c.front();} reference back() {return c.back();} // void push(const value_type\u0026amp; x) {c.push_back(x);} void pop() {c.pop_front();} }; 构造由内而外，析构由外而内.\n构造： queue的构造函数首先调用deque的默认构造函数，然后才执行自己析构： queue的析构函数首先执行自己，然后才次调用deque的析构函数.\n委托 用指针指向实现功能的那个类，指针可以指向不同的实现类，右边的变动不影响左边.编译防火墙：左边不用再编译，要编译的是右边.\n继承 1 2 3 4 5 6 7 8 9 10 11 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; } template\u0026lt;typename _Tp\u0026gt; struct _List_node : public _List_node_base { _Tp _M_Data } 构造由内而外，析构由外而内\n子类的构造函数首先调用父类的默认构造函数，然后才执行自己析构首先执行自己，然后才调用父类的析构函数.\n继承搭配虚函数才是更强的.\nnon-virtual：不希望子类重新定义(override)virtual:希望子类重新定义，并且它已有默认定义pure virtual:希望子类一定要重新定义，它没有默认定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Shape { public: // pure virtual virtual void draw() const = 0; // impure virtual virtual void error(const std::string\u0026amp; msg); // non - virtual int objectID()const; } class Rectangle : public Shape { ... } 转换函数 分母默认为1，Fraction(3) 就是3/1 = 3；只需要一个参数够了，one-argument\nnon-explicit-one-argument\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); // 调用operator double将f转换为0.6 double d=4+f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; Fraction重载了+号，但是f+4时 4是int，不是Fraction类型，调用non-explicit ctor将4转换为Fraction(4,1)，然后调用operator+\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; //[Error] operator double() 可以把Fraction转为double， Fraction(int num,int den=1) 可以把4转为Fraction\n此时有两条路线可以走，编译器报错.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: explicit Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; 构造加上explicit，防止隐式转换，不可以把3变成3/1了，不能把3变成Fraction类型，\nf+4 , 4不会变成Fraction，而operator+(const Fraction\u0026amp; f) 要的参数是Fraction类型，所以4转不到Fraction,会转换失败.\nC++11 变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\nrange-based for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for(int i : {2,3,5,7,9,13,17,19}) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } vector\u0026lt;double\u0026gt; vec; // pass by value for(auto elem: vec) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt;endl; } // pass by reference for(auto\u0026amp; elem:vec) { elem *=3 ; } auto lambda 1 2 3 4 5 6 7 8 9 10 11 12 auto i = 42; double f(); auto d = f(); vector\u0026lt;string\u0026gt; v; ... auto pos = v.begin(); auto I = [](int x) -\u0026gt; bool { ...; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; } //call: []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }(); // print \u0026#34;hello lambda\u0026#34; auto I = []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }; I(); // print \u0026#34;hello lambda\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 [...](...)-\u0026gt;returnType{...} ()参数 {}函数体 [=] 外部变量值传递 [\u0026amp;] 外部变量引用传递 int id = 0; //mutable []里的东西是可变的，不写 就不能++id auto f = [id]()mutable{ std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } { id = 42; f(); f(); f(); std::cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; } //输出 id:0; id:1; id:2; 42 //内部的id变了，外部的还是42. // class Functor { private: int id;//copy of outside id public: void operator() { std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } }; Functor f; Uniform Initialization 1 2 3 4 int values[] {1,2,3}; vector\u0026lt;int\u0026gt; v{2,3,5,7}; vector\u0026lt;string\u0026gt; cities{\u0026#34;New York\u0026#34;,\u0026#34;Berlin\u0026#34;}; complex\u0026lt;double\u0026gt; c{4.0,3.0}; 编译器在幕后做出一个 initializer_list 进行构造.\ninitializer_list 1 2 3 4 int i;\ti拥有未定义值 int j{}; j = 0 int* p; p未定义值 int* q{}; q = nullptr 1 2 3 4 5 6 7 8 void print(std::initializer_list\u0026lt;int\u0026gt; vals) { for(auto p=vals.bee();p!=vals.end;++p) { std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } print({12,3,5,7,11,13,17}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } P(initializer_list\u0026lt;int\u0026gt; initlist) { cout \u0026lt;\u0026lt; \u0026#34;P(initializer_list\u0026lt;int\u0026gt;) ,values =\u0026#34;; for(auto i : initlist) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\u0026#39;; } cout \u0026lt;\u0026lt; endl; } } P p(77,5); //P(int,int) a=77,b=5 P q{77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 P r{77,5,42}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 42 P s={77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 1 2 3 4 5 6 7 8 9 10 11 12 13 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } } P p(77,5); P q{77,5}; P r{77,5,42}; P s={77,5}; 没有initializer_list构造时，编译器会把{}里面的一包内容拆解出来，q{77,5} 和 s={77,5} 有两个数，符合P(int,int)r里面有3个数，不符合P(int,int)，失败.\ninitializer_list背后是个array，编译器能够调用initializer_list的私有构造函数.编译器看到 {} 时就制造一个initializer_list，\n=default , =delete 如果自行定义了一个构造函数，那么编译器就不会再给你一个默认构造函数。如果强制加上 = default，就可以重新获得并使用默认构造函数。 =delete告诉编译器不要定义它。必须出现在声明式。适用于任何成员函数。也适用于构造函数，但后果自负。\n1 2 3 4 5 6 7 8 9 10 11 12 class Zoo { public: Zoo(int i1,inti2) : d1(i1),d2(i2){} Zoo(const Zoo\u0026amp;) = delete; Zoo(Zoo\u0026amp;\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;\u0026amp;)=delete; virtual ~Zoo(){} private: int d1,d2; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A { public: // A user-defined // parameterized constructor A(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is a parameterized constructor\u0026#34;; } // Using the default specifier to instruct // the compiler to create the default // implementation of the constructor. A() = default; }; int main() { // executes using defaulted constructor A a; // uses parameterized constructor A x(1); return 0; } 在上述情况下，我们不必指定构造函数 A() 的主体，因为通过附加说明符 \u0026lsquo;=default\u0026rsquo;，编译器将创建此函数的默认实现。\n默认函数需要是特殊成员函数（默认构造函数、复制构造函数、析构函数等），或者没有默认参数。例如，以下代码说明非特殊成员函数不能为默认值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class B { public: // Error, func is not a special member function. int func() = default; // Error, constructor B(int, int) is not // a special member function. B(int, int) = default; // Error, constructor B(int=0) // has a default argument. B(int = 0) = default; }; // driver program int main() { return 0; } 禁用复制构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class A { public: A(int x): m(x) { } // Delete the copy constructor A(const A\u0026amp;) = delete; // Delete the copy assignment operator A\u0026amp; operator=(const A\u0026amp;) = delete; int m; }; int main() { A a1(1), a2(2), a3(3); // Error, the usage of the copy // assignment operator is disabled a1 = a2; // Error, the usage of the // copy constructor is disabled a3 = A(a2); return 0; } 禁用不需要的参数转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class A { public: A(int) {} // Declare the conversion constructor as a // deleted function. Without this step, // even though A(double) isn\u0026#39;t defined, // the A(int) would accept any double value // for it\u0026#39;s argumentand convert it to an int A(double) = delete; }; int main() { A A1(1); // Error, conversion from // double to class A is disabled. A A2(100.1); return 0; } 删除特殊成员函数提供了一种更清晰的方法来防止编译器生成我们不需要的特殊成员函数。\n删除普通成员函数或非成员函数可以防止有问题的类型提升导致意外调用函数(如“禁用不需要的参数转换”示例所示)。\nAlias Template 别名: 李白 字太白\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; using Vec = std::vector\u0026lt;T,MyAlloc\u0026lt;T\u0026gt;\u0026gt;; Vec\u0026lt;int\u0026gt; coll; std::vector\u0026lt;int,MyAlloc\u0026lt;int\u0026gt;\u0026gt; coll; //TODO::模板内容很多，不止这些\nRvalue and Move Semantics 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //解决非必要的拷贝，右边是右值时，左边可以偷右边的资源 //而不需要执行allocation重新分配内存 //Lvalue:可以出现在operator=左侧者 //Rvalue:只能出现在operator=右侧者 //临时对象一定被当作右值 //————————————————————————————————————————————————————————————// int a = 9; int b = 4; a=b; //ok b=a;\t//ok a=a+b;\t//ok //a+b是右值 a+b=42 //Error , lvalue required as left operand of assignment //————————————————————————————————————————————————————————————// string s1(\u0026#34;hello\u0026#34;); string s2(\u0026#34;world\u0026#34;); s1 + s2 = s2; //通过编译 cout \u0026lt;\u0026lt; \u0026#34;s1:\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;s2:\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt;endl; string() = \u0026#34;world\u0026#34;; //对临时对象赋值？ //————————————————————————————————————————————————————————————// 1 2 3 4 5 int foo(){return 5;} int x = foo(); //ok int* p = \u0026amp;foo(); //Error，不能对右值取地址 foo() = 7\t//Error 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyString { private: char* _data; public: //copy ctor MyString(const MyString\u0026amp; str):initialization_list{...} //move ctor MyString(MyString\u0026amp;\u0026amp; str) noexcept : initialization_list{...} } //---------------- M c1(c); M c2(std::move(c1));//要确保后续不再使用c1. Perfect Forwarding 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 template\u0026lt;typename T1,typename T2\u0026gt; void functionA(T1\u0026amp;\u0026amp;t1,T2\u0026amp;\u0026amp;t2) { functionB(std::forward\u0026lt;T1\u0026gt;(t1),std::forward\u0026lt;T2\u0026gt;(t2)); } //-------------------------------------// void _init_data(const char* s) { _data = new char[_len+1]; memcpy(_data,s,_len); _data[_len] = \u0026#39;\\0\u0026#39;; } // copy constructor MyString(const MyString\u0026amp; str) :_len(str.len) { _init_data(str._data); } // move constructor MyString(MyString\u0026amp;\u0026amp; str) noexcept :_data(str._data),_len(str._len) { str._len = 0; str._data=null; } //----------------------------------------------// //copy assignment MyString\u0026amp; operator=(const MyString\u0026amp; str) { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str.len; _init_data(str.data); // Copy } else { } return *this; } //move assignment MyString\u0026amp; operator=(MyString\u0026amp;\u0026amp; str) noexcept { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str._len; //Move _data = str.data; //Move str._len = 0; //重要 str._data = null; //重要 } } //----------------------------------------------// virtual ~MyString() { if(_data) { delete _data; } } 模板 模板函数 模板函数Max，不管是什么样的类型 都可以调用这个模板，模板函数在使用时实例化，只有使用 Max(float,float) 时 才会生成对于float的Max函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; template \u0026lt;typename T\u0026gt; T Max(const T\u0026amp; T1, const T\u0026amp; T2) { return T1 \u0026gt; T2 ? T1 : T2; } class VNumber { public: float A; float B; std::string Name; VNumber(float InA , float InB,std::string InName) : A(InA),B(InB),Name(InName) {} bool operator\u0026lt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026lt; (Ohter.A + Ohter.B); } bool operator\u0026gt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026gt; (Ohter.A + Ohter.B); } }; int main() { int A = Max(2,3); double B = Max(2.2,3.3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;float Max - A:{} B:{} \\n\u0026#34;,A,B); //float Max - A:3 B:3.3 VNumber V1(1,2,\u0026#34;V1\u0026#34;); VNumber V2(3,5,\u0026#34;V2\u0026#34;); auto MaxVNumber = Max(V1,V2); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber.Name,MaxVNumber.A,MaxVNumber.B); // MaxName:V2 A:3 B:5 VNumber V3(10,5,\u0026#34;V3\u0026#34;); auto MaxVNumber2 = Max(V2,V3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber2.Name,MaxVNumber2.A,MaxVNumber2.B); // MaxName:V3 A:10 B:5 } 特化 针对Object类 ，调用Add时 只会把它们内部的Name变量加起来.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format,std::string; template\u0026lt;typename T\u0026gt; void Add(T\u0026amp; T1, T\u0026amp; T2) { T1 += T2; } struct Object { Object(string InName) : Name(InName){} string Name; }; template\u0026lt;\u0026gt; void Add(Object\u0026amp; T1,Object\u0026amp; T2) { T1.Name = T1.Name + T2.Name; } int main() { int A = 5; int B = 6; Add(A,B); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,A,B); //A:11 B:6 Object Obj1(\u0026#34;Manba\u0026#34;); Object Obj2(\u0026#34;Out\u0026#34;); Add(Obj1,Obj2); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,Obj1.Name,Obj2.Name); //A:ManbaOut B:Out } 模板类 模板类可以做数据结构的容器什么的. 比如在一个模板类里面搞一个数组，在使用时 可以定义数组存放什么样的类型， 或者 搞个链表，放一串int / float / string 等等类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template\u0026lt;typename T\u0026gt; class SimpleContainer { public: SimpleContainer(T InContent) : Content(InContent){} T GetContent() { return Content; } void SetContent(T InContent) { Content = InContent; } private: T Content; }; int main() { SimpleContainer SC(5); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} ,type:{} \\n\u0026#34;,SC.GetContent(),typeid(SC.GetContent()).name()); //SC Content:5 ,type:int SC.SetContent(10); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} , Is String? : {}\\n\u0026#34;, SC.GetContent(), std::is_same\u0026lt;decltype(SC.GetContent()),string\u0026gt;::value); //SC Content:10 , Is String? : false SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); cout\u0026lt;\u0026lt;format(\u0026#34;SC1 Content:{}, Is String? : {} \\n\u0026#34;, SC1.GetContent(), std::is_same\u0026lt;decltype(SC1.GetContent()),string\u0026gt;::value); //SC1 Content:Manba out, Is String? : true } C++17 模板参数自动推导\n1 2 3 SimpleContainer SC(string(\u0026#34;Fuck\u0026#34;)); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} ,String Type?:{} \\n\u0026#34;,SC.GetContent(),std::is_same\u0026lt;decltype(SC.GetContent()),string\u0026gt;::value); //SC Content:Fuck ,String Type?:true 类型萃取 1 2 3 4 5 6 7 // int,double,char,T*, 传入Show 依然是本身 // 其它类型转化成 const T\u0026amp; template\u0026lt;typename T\u0026gt; void Show(T t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // int,double,char,T*, 传入Show 依然是本身 // 其它类型转化成 const T\u0026amp; // 模板特例 template\u0026lt;typename T\u0026gt; struct ArgType { using type = const T\u0026amp;; }; // 针对指针偏特化 template\u0026lt;typename T\u0026gt; struct ArgType\u0026lt;T*\u0026gt; { using type = T*; }; template\u0026lt;\u0026gt; struct ArgType\u0026lt;int\u0026gt; { using type = int; }; template\u0026lt;\u0026gt; struct ArgType\u0026lt;double\u0026gt; { using type = double; }; template\u0026lt;\u0026gt; struct ArgType\u0026lt;char\u0026gt; { using type = char; }; template\u0026lt;typename T\u0026gt; void Show(typename ArgType\u0026lt;T\u0026gt;::type t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { //复制传递 Show\u0026lt;int\u0026gt;(3); //const引用传递 std::string str = \u0026#34;123\u0026#34;; Show\u0026lt;std::string\u0026gt;(str); string* p = \u0026amp;str; Show\u0026lt;string*\u0026gt;(p); } 简化:\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; using ArgType_t = typename ArgType\u0026lt;T\u0026gt;::type; template\u0026lt;typename T\u0026gt; void Show(ArgType_t\u0026lt;T\u0026gt; t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } SFINAE Substitution failure is not an error\n对于小于指针大小的类型 采用值传递，其它类型引用传递.64位环境 指针大小是8\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 template\u0026lt;bool Cond,typename T\u0026gt; struct enable_if{}; template\u0026lt;typename T\u0026gt; struct enable_if\u0026lt;true,T\u0026gt; { using type = T; }; template\u0026lt;typename T\u0026gt; void f(typename enable_if\u0026lt; sizeof(T)\u0026lt;= sizeof(void*),T \u0026gt;::type t) { cout \u0026lt;\u0026lt; sizeof(t) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; template\u0026lt;typename T\u0026gt; void f(typename enable_if\u0026lt; (sizeof(T) \u0026gt; sizeof(void*)), T \u0026gt;::type const\u0026amp; t) { cout \u0026lt;\u0026lt; sizeof(t) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; class big { public: double a1 = 3; double a2 = 3; double a3 = 3; double a4 = 3; double a5 = 3; double a6 = 3; double a7 = 3; }; int main() { int a = 3; double b = 5; float c = 3; const char* str = \u0026#34;hello world\u0026#34;; string str2 = \u0026#34;hello world\u0026#34;; string* strp = \u0026amp;str2; big b1; f\u0026lt;big\u0026gt;(b1); //cout 56 2 f\u0026lt;int\u0026gt;(a); //cout 4 1 f\u0026lt;double\u0026gt;(b); //cout 8 1 f\u0026lt;float\u0026gt;(c); //cout 4 1 f\u0026lt;const char*\u0026gt;(str); //cout 8 1 f\u0026lt;string*\u0026gt;(strp); //cout 8 1 }; int类型的大小 小于 指针类型的大小， 匹配到这个模板\n1 2 3 4 5 6 7 8 9 10 //匹配void f(int t) sizeof(int)\u0026lt;= sizeof(void*)，结果为true template\u0026lt;typename T\u0026gt; struct enable_if\u0026lt;true,T\u0026gt; { using type = T; }; enable_if\u0026lt; true,int \u0026gt;::type = int; //匹配成功，使用 void f(int t) 如果 big类的大小 大于 指针类型的大小，匹配到第一个模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 匹配void f(int t) sizeof(big)\u0026lt;= sizeof(void*)，结果为false // enable_if 没有对应false的偏特化，于是匹配到通用模板 template\u0026lt;bool Cond,typename T\u0026gt; struct enable_if{}; //这个模板并没有 type类型 ， enable_if\u0026lt; false,big \u0026gt;::type // 错误 //void f(int t)匹配失败 //尝试匹配第二个f(const\u0026amp; t)函数 sizeof(big)\u0026gt;sizeof(void*)，结果为true enable_if\u0026lt; true,int \u0026gt;::type = big // 使用 void f(const\u0026amp; t) 函数 设计模式 如果你只有一把铁锤， 那么任何东西看上去都像是钉子。这个问题常常会给初学模式的人们带来困扰： 在学习了某个模式后， 他们会在所有地方使用该模式， 即便是在较为简单的代码也能胜任的地方也是如此。\n创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性。 如:工厂方法、抽象工厂、生成器、原型、单例 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 如:适配器、桥接、组合、装饰、外观、享元、代理 行为模式负责对象间的高效沟通和职责委派。 如:职责链、命令、备忘录、观察者、模板方法、访问者、迭代器、中介者、状态、策略 面向对象设计原则 代码与技巧不重要，要在这个学习的过程中 建立抽象思维模型\n封装，隐藏内部实现\n继承，复用现有代码\n多态，改写对象行为\n解决复杂性：1.分解，大问题切分成小问题，复杂问题转为多个简单问题2.抽象，使用通用的技术，忽略事物非本质的细节，处理理想的对象模型.\n变化是复用的天敌，面向对象的优势在于抵御变化.\n依赖倒置原则 (DIP)\n高层模块(稳定) 不应该依赖于 低层模块(变化)，二者应该依赖于 抽象(稳定)抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape类有Draw函数 用来画东西，画家类可以使用Shape类画出各种形状，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Shape { public: virtual void Draw() = 0; } class Sphere : public Shape { public: virtual void Draw() override { //画一个圆形.... } } class Box : public Shape { .... } class Painter { public: TArray\u0026lt;Shape*\u0026gt; Shapes; void DrawSomething() { for(auto Shape : Shapes) { Shape-\u0026gt;Draw(); } } } int main() { Shape* SphereDrawer = new Sphere(); Shape* BoxDrawer = new Box(); Painter Painter; Painter.Shapes.add(SphereDrawer,BoxDrawer); // 开始画 Painter.DrawSomething(); //.... } 当Sphere的Draw函数需要变化时，例如 添加或者删掉一点东西，或是因为其它原因，函数需要修改，此时Painter并没有被影响到，它的代码不会发生变动，只需要关注Sphere::Draw的修改即可.\n高层模块(稳定) 不应该依赖于 底层模块(变化)\nPainter可看做是 高层模块，应该稳定，不依赖于 低层模块，Painter没有因为Sphere的变化而变化.\n抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape作为 抽象(稳定) 层，它的Draw没有依赖于具体的实现细节，使用子类来实现Draw.\n最终隔离变化，在Painter、Shape、Sphere中，变化的部分只有Sphere一个.\n通过这个画画的例子可以理解这句话了 \u0026mdash;\u0026gt; 现代软件设计的特征是“需求的频繁变化”，设计模式的要点是 “寻找变化点，在变化点处应用设计模式”，何时何地使用设计模式，比理解设计模式结构本身更重要.\n开放封闭原则 (OCP)\n对扩展开放，对更改封闭类模块应该是可扩展的，但是不可修改.\n单一职责原则(SRP)\n一个类应该仅有一个变化的原因.变化的方向隐含着类的责任.\nLiskov替换原则(LSP)\n子类必须能够替换它的基类（IS-A)\n继承表达类型抽象。\n接口隔离原则(ISP)\n不应该强迫客户程序依赖它们不用的方法\n接口应该小而完备\n优先使用对象组合，而不是类继承\n继承通常为“白箱复用”，对象组合通常为“黑箱复用”继承在某种程度上破坏了封装性，子类父类耦合度高对象组合则只要求被组合的对象具有良好定义的接口，耦合度低.\n封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响.\n针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某个接口\n客户程序无需知道对象的具体类型，只需要知道对象所具有的接口减少系统中各部分的依赖关系.\n产业强盛的标志 — 接口标准化\n秦始皇车同轨 书同文，统一度量衡\n雕版印刷：雕版印刷是在一定厚度的平滑的木板上，粘贴上抄写工整的书稿，薄而近乎透明的稿纸正面和木板相贴，字就成了反体，刻工人用刻刀把版面没有字迹的部分削去，印刷的时候，在凸起的字体上涂上墨汁，然后把纸覆在它的上面，轻轻拂拭纸背，字迹就留在纸上了。\n雕版印刷一版能印几百部甚至几千部书，但是制版很慢，而且有错字不容易更正。\n活字印刷：活字印刷术是一种印刷方法，使用可以移动的木刻字、金属或胶泥字块，用来取代传统的抄写，或是无法重复使用的雕版印刷。活字印刷的方法是先制成单字的阳文反文字模，然后按照稿件把单字挑选出来，排列在字盘内，涂墨印刷，印完后再将字模拆出，留待下次排印时再次使用。\n只印二三本，活字印刷并不比雕版印刷快。如果印成百上千份，工作效率就极其可观了，不仅能够节约大量的人力物力，而且可以大大提高印刷的速度和质量。\n模板方法 现代软件专业分工后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式.\n典型模式：Template Method 模板方法、Strategy 策略模式、Observer/Event 观察者模式\n对于某一项任务，有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或由于固有原因无法和任务的整体结构同时实现，(出现 一个早一个晚 的关系)，如何在确定稳定操作的前提下，灵活应对各个子步骤的变化或晚期实现需求？即 稳定中有变化\n在UE中，使用某些类时，往往需要玩家手动去重写某个函数. 其余的事情玩家不用管，交给引擎去管理流程.你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n下面的代码 基类里的Run函数是稳定的，执行了一套固定的流程，但是其中的某些步骤可以变化， 可以或必须被子类重写，才能完成整个流程. 总之就是 完形填空\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * 抽象类定义了一个模板方法，该方法包含了一些算法的框架， * 具体的子类应当实现这些操作，但应保持模板方法本身不变。 */ class AbstractClass { public: void Run() const { BaseOperation1(); RequiredOperations1();//必须重写 BaseOperation2(); Hook1();//可重写 RequiredOperation2();//必须重写 BaseOperation3(); Hook2();//可重写 } protected: void BaseOperation1() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: I am doing the bulk of the work\\n\u0026#34;; } void BaseOperation2() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I let subclasses override some operations\\n\u0026#34;; } void BaseOperation3() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I am doing the bulk of the work anyway\\n\u0026#34;; } virtual void RequiredOperations1() const = 0; virtual void RequiredOperation2() const = 0; virtual void Hook1() const {} virtual void Hook2() const {} }; //////////////////////////////////// class ConcreteClass1 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation2\\n\u0026#34;; } }; //////////////////////////////////////// class ConcreteClass2 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation2\\n\u0026#34;; } void Hook1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Overridden Hook1\\n\u0026#34;; } }; /////////////////////////////// void ClientCode(AbstractClass *class_) { class_-\u0026gt;Run(); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass1 *concreteClass1 = new ConcreteClass1; ClientCode(concreteClass1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass2 *concreteClass2 = new ConcreteClass2; ClientCode(concreteClass2); delete concreteClass1; delete concreteClass2; return 0; } 输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Same client code can work with different subclasses: AbstractClass says: I am doing the bulk of the work ConcreteClass1 says: Implemented Operation1 AbstractClass says: But I let subclasses override some operations ConcreteClass1 says: Implemented Operation2 AbstractClass says: But I am doing the bulk of the work anyway Same client code can work with different subclasses: AbstractClass says: I am doing the bulk of the work ConcreteClass2 says: Implemented Operation1 AbstractClass says: But I let subclasses override some operations ConcreteClass2 says: Overridden Hook1 ConcreteClass2 says: Implemented Operation2 AbstractClass says: But I am doing the bulk of the work anyway 策略模式 策略是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。\n方便应对多重switch case 或 if else，随时间推移，switch 或 if中的代码需要扩展，写的越来越多，代码很长.\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n计算税，每个国家的税不同，计算方法不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 enum TaxBase { CN_Tax; US_Tax; DE_Tax }; class SalesOrder { TexBase Tax; public: double CalcTax() { if(Tex == CN_Tex) { } else if(Tex == US_Tax) { } else if(Tex == DE_Tax) { } //..... } } 每增加一个国家的计算方法，enum TexBase就要扩充一个枚举值，CalcTax要多一套if else.如果随着时间推移，后续增加的计算方法越多，代码越来越长，极端情况下 Cache甚至放不下代码，一部分代码需要放到内存 甚至是虚拟内存(硬盘)中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class TexStrategy { public: virtual double Calc(const Context\u0026amp; context) = 0; virtual ~TexStrategy(){} } class CNTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class USTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class DETax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class SalesOrder { private: TexStrategy* Strategy; public: SalesOrder(TexStrategy* InStrategy) : Strategy(InStrategy){} ~SalesOrder() { delete Strategy; } double CalcTex() { //.... Context context; double Tex = Strategy-\u0026gt;Calc(context); //..... return Tex; } } 需要扩充计算方法时，只要继承TexStrategy 写一个新的类即可，就能完成新的税种计算.SalesOrder是不需要修改的. 对于新增的类，甚至可以使用增量编译 单独编译一个dll.\n以上代码只是说明一个大概情况，下面的代码是可运行的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Strategy { public: virtual ~Strategy() = default; virtual std::string doAlgorithm(std::string_view data) const = 0; }; class Context { private: std::unique_ptr\u0026lt;Strategy\u0026gt; strategy_; public: explicit Context(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy = {}) : strategy_(std::move(strategy)) { } void set_strategy(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy) { strategy_ = std::move(strategy); } void doSomeBusinessLogic() const { if (strategy_) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = strategy_-\u0026gt;doAlgorithm(\u0026#34;aecbd\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Strategy isn\u0026#39;t set\\n\u0026#34;; } } }; class ConcreteStrategyA : public Strategy { public: std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result), std::greater\u0026lt;\u0026gt;()); return result; } }; void clientCode() { Context context(std::make_unique\u0026lt;ConcreteStrategyA\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context.doSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context.set_strategy(std::make_unique\u0026lt;ConcreteStrategyB\u0026gt;()); context.doSomeBusinessLogic(); } int main() { clientCode(); return 0; } 输出结果\n1 2 3 4 5 6 7 Client: Strategy is set to normal sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) abcde Client: Strategy is set to reverse sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) edcba 这种设计模式 可以在运行时更改对象的算法，将算法和对象本身解耦. 对于这个例子，分辨出哪里是稳定的，哪里是变化的，算法可以通过扩展子类的方式 独立出来进行变化.\n有时候支持不使用的算法也是负担，例如 在计算税的if else版本的代码里，程序安装在America 只需要使用America部分，其它的if都是不必要的，代码在运行时 要加载到Cache、内存， 但是要使用的代码只有其中一小部分，所以其余的代码都是多余加载的。 使用策略模式可以顺便缓解这个情况.\n观察者模式 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n定义对象间的一种一对多(变化)的依赖关系，以便当对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\n例如：UE中的委托、事件分发器、MVC模式\n上图中 中间站的那个小人Player，他拥有一个List容器，存放台下的观察者People，一场表演结束，中途休息， 观众都去外面转悠去了，他们告诉小人 表演的时候给他们发QQ当小人要表演时，遍历List容器 给每个观察者发送一个QQ消息，但是有些观众临时有事，就不再回来看表演了，\n假如A类观众 收到通知还要回来看表演，其中某些观众临时有事，不能回去看表演，所以反手告诉Player不用给他发消息了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; class IPeople { public: virtual void ReceiveNotify() = 0; }; class Player { std::list\u0026lt;IPeople*\u0026gt; Peoples; public: void AddNotify(IPeople* InPeople) { Peoples.push_back(InPeople); } void RemoveNotify(IPeople* InPeople) { Peoples.remove(InPeople); std::cout \u0026lt;\u0026lt; \u0026#34;Player 有一位观众取消接收表演通知 \\n\u0026#34;; } void Notify() { std::cout \u0026lt;\u0026lt; \u0026#34;Player 开播通知 \\n\u0026#34;; for (auto People : Peoples) { People-\u0026gt;ReceiveNotify(); } } }; class PeopleA : public IPeople { public: PeopleA(Player* InPlayer) :Player(InPlayer) { Player-\u0026gt;AddNotify(this); } void GoBack() { //回去看表演 std::cout \u0026lt;\u0026lt; \u0026#34;People 回去看表演 \\n\u0026#34;; } virtual void ReceiveNotify() override { GoBack(); } void RemoveMeFromTheList() { std::cout \u0026lt;\u0026lt; \u0026#34;People 临时有事 \\n\u0026#34;; Player-\u0026gt;RemoveNotify(this); } private: Player* Player; }; int main() { Player* PlayerA = new Player; PeopleA* PeopleA1 = new PeopleA(PlayerA); PeopleA* PeopleA2 = new PeopleA(PlayerA); PeopleA* PeopleA3 = new PeopleA(PlayerA); //中场休息 //临时有事，并告诉Player 表演时不用通知他 PeopleA3-\u0026gt;RemoveMeFromTheList(); //休息结束，要表演了，通知观众表演开始 PlayerA-\u0026gt;Notify(); } 1 2 3 4 5 People 临时有事 Player 有一位观众取消接收表演通知 Player 开播通知 People 回去看表演 People 回去看表演 装饰模式 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n穿衣服是使用装饰的一个例子.觉得冷时， 你可以穿一件毛衣, 如果穿毛衣还觉得冷， 你可以再套上一件夹克。 如果遇到下雨， 你还可以再穿一件雨衣。 所有这些衣物都 “扩展” 了你的基本行为,但它们并不是你的一部分,如果你不再需要某件衣物,可以方便地随时脱掉。\n","date":"1073-01-13T14:39:23+08:00","permalink":"https://akaklya.github.io/p/%E6%88%90%E4%B8%BA%E5%96%9C%E5%8A%A0%E5%8A%A0%E9%AB%98%E6%89%8B/","title":"成为喜加加高手"}]