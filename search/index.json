[{"content":"","date":"2025-02-05T19:29:37+08:00","permalink":"http://localhost:1313/p/cstruct/","title":"Cstruct"},{"content":"蘸豆 爽！ 生命值 = 当前生命值 - 即将到来的伤害.\nAttributeSet Class\n1 2 3 UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } } 受击反馈 1 2 3 4 5 6 7 8 9 10 11 12 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } 这是上文的伤害血量计算. 如果不是致命伤害，就播放 受击动画.\n被打也是一种技能. 受到伤害后 触发GA. 被打的GA要在角色生成时 就要GiveAbility. 作为天生技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } } } 受击 → 触发GA → 应用GE，添加Effect.HitReact标签 → 播放受击动画 → 动画结束 → 移除GE添加的标签 → 结束技能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void AAuraEnemy::BeginPlay() { Super::BeginPlay(); InitAbilityActorInfo(); GetCharacterMovement()-\u0026gt;MaxWalkSpeed = BaseWalkSpeed; UAuraAbilitySystemLibrary::GiveStartupAbilities(this,AbilitySystemComponent); if (UAuraUserWidget* AuraUserWidget = Cast\u0026lt;UAuraUserWidget\u0026gt;(HealthBar-\u0026gt;GetUserWidgetObject())) { AuraUserWidget-\u0026gt;SetWidgetController(this); } if (UAuraAttributeSet* AuraAS = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet)) { AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetMaxHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); OnHealthChanged.Broadcast(AuraAS-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAS-\u0026gt;GetMaxHealth()); } } void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 1 2 3 4 5 6 7 8 9 FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 如果Effect_HitReact标签数量大于0，移动速度设置为0，否则就是正常移动速度.\n1 2 3 4 5 6 7 8 9 10 11 12 13 UENUM(BlueprintType) namespace EGameplayTagEventType { /** Rather a tag was added or removed, used in callbacks */ enum Type : int { /** Event only happens when tag is new or completely removed */ NewOrRemoved, /** Event happens any time tag \u0026#34;count\u0026#34; changes */ AnyCountChange }; } 死亡？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(Props.TargetAvatarActor); if (CombatInterface) { CombatInterface-\u0026gt;Die(); } } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } // 显示伤害数字 ShowFloatingText(Props,LocalIncomingDamage); } } 血量小于0，就调用Die，怎么写？ 随便.\n加了一个 显示伤害数字 的功能， 调用到了 玩家控制器 的函数 ， 把 伤害值 和 受击Actor 的位置 传过去了\n1 2 3 4 5 6 7 8 9 10 11 void UAuraAttributeSet::ShowFloatingText(const FEffectProperites\u0026amp; Props, float Damage) { if (Props.SourceCharacter != Props.TargetCharacter) { AAuraPlayerController* PC = Cast\u0026lt;AAuraPlayerController\u0026gt;(UGameplayStatics::GetPlayerController(this, 0)); if (PC) { PC-\u0026gt;ShowDamageNumber(Damage,Props.TargetCharacter); } } } 玩家控制器 创建一个 DamageText 组件. 根据 传入的位置 设置组件的位置， 把伤害值 传给组件内部.\n1 2 3 4 5 6 7 8 9 10 11 void AAuraPlayerController::ShowDamageNumber_Implementation(float DamageAmount,ACharacter* TargetCharacter) { if (IsValid(TargetCharacter) \u0026amp;\u0026amp; DamageTextComponentClass) { UDamageTextComponent* DamageText = NewObject\u0026lt;UDamageTextComponent\u0026gt;(TargetCharacter,DamageTextComponentClass); DamageText-\u0026gt;RegisterComponent(); DamageText-\u0026gt;AttachToComponent(TargetCharacter-\u0026gt;GetRootComponent(),FAttachmentTransformRules::KeepRelativeTransform); DamageText-\u0026gt;DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform); DamageText-\u0026gt;SetDamageText(DamageAmount); } } SetDamageText是个蓝图实现的函数\n1 2 3 4 5 6 7 8 9 UCLASS() class AURA_API UDamageTextComponent : public UWidgetComponent { GENERATED_BODY() public: UFUNCTION(BlueprintImplementableEvent,BlueprintCallable) void SetDamageText(float Damage); }; UMG在构造函数里 播放这个K出来的数字动画，完事.\n计算伤害 头晕 不想写\nGameplayEffectContext 谁设置了这些Context？\n1 2 UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); ↓\n1 2 3 4 5 6 7 8 9 10 11 12 FGameplayEffectContextHandle UAbilitySystemComponent::MakeEffectContext() const { FGameplayEffectContextHandle Context = FGameplayEffectContextHandle(UAbilitySystemGlobals::Get().AllocGameplayEffectContext()); // By default use the owner and avatar as the instigator and causer if (ensureMsgf(AbilityActorInfo.IsValid(), TEXT(\u0026#34;Unable to make effect context because AbilityActorInfo is not valid.\u0026#34;))) { Context.AddInstigator(AbilityActorInfo-\u0026gt;OwnerActor.Get(), AbilityActorInfo-\u0026gt;AvatarActor.Get()); } return Context; } ↓\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { if (IsValid()) { Data-\u0026gt;AddInstigator(InInstigator, InEffectCauser); } } void FGameplayEffectContext::AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { Instigator = InInstigator; bReplicateInstigator = CanActorReferenceBeReplicated(InInstigator); SetEffectCauser(InEffectCauser); InstigatorAbilitySystemComponent = NULL; // Cache off the AbilitySystemComponent. InstigatorAbilitySystemComponent = UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(Instigator.Get()); } MakeEffectContext最终调用到了AddInstigator，设置Instigator、EffectCauser、InstigatorASC\n以及 MakeEffectContext 调用的构造函数，初始化了一些变量.\n1 2 3 4 5 6 7 8 9 FGameplayEffectContext() : AbilityLevel(1) , WorldOrigin(ForceInitToZero) , bHasWorldOrigin(false) , bReplicateSourceObject(false) , bReplicateInstigator(false) , bReplicateEffectCauser(false) { } 其它属性还没有设置，剩下的属性应该怎么用？\n以火球技能为例，void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); Context.SetAbility(this); Context.AddSourceObject(Projectile); FHitResult HitResult; HitResult.Location = TargetLocation; Context.AddHitResult(HitResult); TArray\u0026lt;TWeakObjectPtr\u0026lt;AActor\u0026gt;\u0026gt; Actors; Actors.Add(Projectile); Context.AddActors(Actors); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); Custom 扩展Context\n","date":"2025-01-16T17:07:49+08:00","permalink":"http://localhost:1313/p/gas-a-%E6%88%98%E6%96%97/","title":"GAS A - 战斗"},{"content":"TODO:属性菜单 没写，太他妈长了，以后再填.\nUI获取GE的GameplayTag消息 应用GE时，获得GE的AssetTag，并且根据这个Tag 做点事情，\n例如：捡到血瓶时，如果GE里面有 Message.xx.xx 的Tag，就通知UI显示“捡到一个血瓶” 之类的文字.\n整体框架:\nOverlayWidgetController.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void UAuraAbilitySystemComponent::AbilityInfoSet() { OnGameplayEffectAppliedDelegateToSelf.AddUObject(this,\u0026amp;UAuraAbilitySystemComponent::ClientEffectApplied); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;EffectAssetTags.AddLambda( [this](const FGameplayTagContainer\u0026amp; AssetTags) { for (const FGameplayTag\u0026amp; Tag : AssetTags) { auto MessageTag = FGameplayTag::RequestGameplayTag(FName(\u0026#34;Message\u0026#34;)); if (Tag.MatchesTag(MessageTag)) { FUIWidgetRow* Row = GetDataTableRowByTag\u0026lt;FUIWidgetRow\u0026gt;(MessageWidgetDataTable,Tag); MessageWidgetRowDelegate.Broadcast(*Row); } } } ); } WidgetController绑定ASC的生命值等属性变化后，再追加一个委托的订阅，ASC在GE应用时 能获得GE的AssetTag，这里只筛选Message的Tag，把它广播出来，WidgetController就能收到ASC应用的GE的标签.\n1 2 3 4 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Messages\u0026#34;) FMessageWidgetRowSignature MessageWidgetRowDelegate; WidgetController里面再来一个委托，让UMG在蓝图里面订阅，把接收到的GE标签广播出去，让UMG订阅接收.\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 USTRUCT() struct FUIWidgetRow : public FTableRowBase { GENERATED_BODY() UPROPERTY(EditAnywhere,BlueprintReadOnly) FGameplayTag AssetTag = FGameplayTag(); UPROPERTY(EditAnywhere,BlueprintReadOnly) FText Message = FText(); UPROPERTY(EditAnywhere,BlueprintReadOnly) TSubclassOf\u0026lt;class UAuraUserWidget\u0026gt; MessageWidget; UPROPERTY(EditAnywhere,BlueprintReadOnly) UTexture2D* Image = nullptr; }; //-------------------------------------// template\u0026lt;typename T\u0026gt; T* GetDataTableRowByTag(UDataTable* DataTable,const FGameplayTag\u0026amp; Tag); template \u0026lt;typename T\u0026gt; T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag\u0026amp; Tag) { return DataTable-\u0026gt;FindRow\u0026lt;T\u0026gt;(Tag.GetTagName(),TEXT(\u0026#34;\u0026#34;)); } //---------------------------------------// 查表，通过Tag获得Message，并广播给蓝图\nMMC 根据等级设置血量\n角色基类AAuraCharacterBase添加一个ICombatInterface接口，Enemy和AAuraCharacter都重写一下GetPlayerLeve函数.Enemy的Level就在Enemy类里面，玩家的Level在PlayerState里面，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 UINTERFACE(MinimalAPI,BlueprintType) class UCombatInterface : public UInterface { GENERATED_BODY() }; /** * */ class AURA_API ICombatInterface { GENERATED_BODY() // Add interface functions to this class. This is the class that will be inherited to implement this interface. public: virtual int32 GetPlayerLeve(); }; //---------------------------// class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface,public ICombatInterface //--------------------------// 1 2 3 4 5 6 7 8 9 10 11 12 int32 AAuraEnemy::GetPlayerLeve() { return Level; } int32 AAuraCharacter::GetPlayerLeve() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState) return AuraPlayerState-\u0026gt;GetPlayerLeve(); } MMC 自定义计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 UCLASS() class AURA_API UMMC_MaxHealth : public UGameplayModMagnitudeCalculation { GENERATED_BODY() public: UMMC_MaxHealth(); virtual float CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const override; private: FGameplayEffectAttributeCaptureDefinition VigorDef; }; UMMC_MaxHealth::UMMC_MaxHealth() { VigorDef.AttributeToCapture = UAuraAttributeSet::GetVigorAttribute(); VigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target; VigorDef.bSnapshot = false; RelevantAttributesToCapture.Add(VigorDef); } float UMMC_MaxHealth::CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const { const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags(); const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags(); FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = SourceTags; EvaluateParameters.TargetTags = TargetTags; float Vigor = 0 ; GetCapturedAttributeMagnitude(VigorDef,Spec,EvaluateParameters,Vigor); Vigor = FMath::Max\u0026lt;float\u0026gt;(Vigor,0.0f); ICombatInterface* Interface = Cast\u0026lt;ICombatInterface\u0026gt;(Spec.GetContext().GetSourceObject()); const int32 PlayerLevel = Interface-\u0026gt;GetPlayerLeve(); return 80 + 2.5 * Vigor + 10.0 * PlayerLevel; } GameplayAbility 1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA里的StartupInputTag是用来绑定输入的，参见后文的 “绑定EnhancedInput“\nASC类里的AddCharacterAbility函数，根据角色类传过来的技能Array赋予技能从StartupAbility里面创建FGameplayAbilitySpec，并且用StartupInputTag作为动态Tag，传入Spec.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 1 2 3 4 5 6 7 /*GameplayAbilitySpec* * An activatable ability spec, hosted on the ability system component. This defines both what the ability is (what class, what level, input binding etc) * and also holds runtime state that must be kept outside of the ability being instanced/activated. */ * 可激活的能力规范，托管在能力系统组件上。这既定义了能力是什么（什么类别、什么级别、输入绑定等） * 也保存了必须保留在实例化/激活的能力之外的运行时状态。 角色基类里用一个TArray保存初始技能，基类AddCharacterAbility函数赋予技能.在玩家类的PossessedBy函数里调用AddCharacterAbility.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 UPROPERTY(EditAnywhere,Category=\u0026#34;Ability\u0026#34;) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; StartupAbility; void AAuraCharacterBase::AddCharacterAbility() { UAuraAbilitySystemComponent* AuraASC = CastChecked\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent); if (!HasAuthority()) return; AuraASC-\u0026gt;AddCharacterAbility(StartupAbility); } void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); AddCharacterAbility(); } GATag Activation Owned Tags 当技能激活时，将设置的Tag应用给技能所有者，在结束时删除。如果将AbilitySystemGlobals里面的配置ReplicateActivationOwnedTags开启，Tag还将会被复制。 Activation Required Tags 当技能激活者拥有设置的所有的Tag时，此技能才能够被激活。 Activation Blocked Tags 当技能激活者有一项设置的Tag，技能就无法被激活 Source Required Tags 当技能所有者拥有设置的所有的Tag时，此技能才能够被激活 Source Blocked Tags 当技能所有者有一项设置的Tag，技能就无法被激活 Target Required Tags 当技能目标者拥有设置的所有的Tag时，此技能才能够被激活 Target Blocked Tags 当技能目标者有一项设置的Tag，技能就无法被激活 绑定EnhancedInput 增强输入\n绑定GameplayTag和InputAction 这是一个用来关联 GameplayTag 和 InputAction的资产 UAuraInputConfig\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 USTRUCT(BlueprintType) struct FAuraInputAction { GENERATED_BODY() UPROPERTY(EditDefaultsOnly) class UInputAction* InputAction = nullptr; UPROPERTY(EditDefaultsOnly) FGameplayTag InputTag = FGameplayTag(); }; UCLASS() class AURA_API UAuraInputConfig : public UDataAsset { GENERATED_BODY() public: const UInputAction* FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag,bool bLogNotFound = false); UPROPERTY(EditDefaultsOnly,BlueprintReadOnly) TArray\u0026lt;FAuraInputAction\u0026gt; AbilityInputActions; }; //------------------------------------// const UInputAction* UAuraInputConfig::FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag, bool bLogNotFound) { for (const auto\u0026amp; Action : AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag == InputTag) { return Action.InputAction; } } if (bLogNotFound) { UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Can Not Found AbilityInputAction for InputTag [%s] on InputConfig [%s]\u0026#34;), *InputTag.ToString(),*GetNameSafe(this)); } return nullptr; } 创建增强输入组件，继承自UEnhancedInputComponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 UCLASS() class AURA_API UAuraInputComponent : public UEnhancedInputComponent { GENERATED_BODY() public: template\u0026lt;class UserClass,typename PressedFuncType,typename ReleasedFuncType,typename HeldFuncType\u0026gt; void BindAbilityActions(const UAuraInputConfig* InputConfig,UserClass* Object, PressedFuncType PressedFunc,ReleasedFuncType ReleasedFunc,HeldFuncType HeldFunc); }; template \u0026lt;class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\u0026gt; void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) { check(InputConfig); for (const auto\u0026amp; Action : InputConfig-\u0026gt;AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag.IsValid()) { if (PressedFunc) { BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); } if (ReleasedFunc) { BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); } if (HeldFunc) { BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); } } } } typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\n这3个参数 传入函数时，编译器会自动推导其类型可以把 \u0026amp;AAuraPlayerController::AbilityInputTagPressed 这样的参数传入进去.\n在玩家控制器里调用这个BindAbilityActions函数， 来绑定GameplayTag和InputAction.\n准备3个输入函数，分别是 Pressed、Released、Held 状态下的输入， 按下、释放、按住.\n并且这3个函数可以接收传来的FGameplayTag InputTag，因为上面的增强输入在绑定时，就可以把参数传到函数里.\n1 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction的最后两个参数 - PressedFunc函数被调用时，会把Action.InputTag传给这个函数. 所以可以使用AbilityInputTagPressed(FGameplayTag InputTag) 这样的函数 去接收传来的InputTag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { } 使用准备好的UAuraInputConfig资产 绑定输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //AuraPlayerController.h\tUPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) TObjectPtr\u0026lt;UAuraInputConfig\u0026gt; InputConfig; void AAuraPlayerController::SetupInputComponent() { Super::SetupInputComponent(); UAuraInputComponent* AuraInputComponent = CastChecked\u0026lt;UAuraInputComponent\u0026gt;(InputComponent); AuraInputComponent-\u0026gt;BindAction(MoveAction,ETriggerEvent::Triggered,this,\u0026amp;AAuraPlayerController::Move); AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); } 注意执行输入的参数顺序Press,Released,Held\n1 2 3 4 5 void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); 现在就把 GameplayTag 和 玩家控制器 里面的函数绑定上了，\n总结 回顾整个流程，\n1.首先创建了一个资产UAuraInputConfig，这个资产定义了 GameplayTag 和 InputAction 绑定关系，2.在 玩家控制器 里面，指定了UAuraInputConfig，再调用 增强输入 的函数，使用这个资产进行 GameplayTag和InputAction的绑定.3.增强输入 利用InputAction绑定一个要执行的函数，按下按键时 执行哪一个函数.4.绑定完了函数 还不够， 按下按键时执行函数 并且函数还要接收到对应的那个 GameplayTag.\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); 第4个条件 就是用这个BindAction绑定起来的，当按下按键时、松开按键时、持续按住按键时、都会把 Action.InputTag 传给对应的 响应函数.\n这样就实现了 按下按键时，还能获得对应按键的GameplayTag.\n1 2 3 4 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } 这个函数就能接收到 GameplayTag 的值.\n1 2 3 4 5 6 7 8 template\u0026lt;class UserClass, typename... VarTypes\u0026gt;\t\\ FEnhancedInputActionEventBinding\u0026amp; BindAction(const UInputAction* Action, ETriggerEvent TriggerEvent, UserClass* Object, typename HANDLER_SIG::template TMethodPtr\u0026lt; UserClass, VarTypes... \u0026gt; Func, VarTypes... Vars) \\ {\t\\ TUniquePtr\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt; AB = MakeUnique\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt;(Action, TriggerEvent);\t\\ AB-\u0026gt;Delegate.BindDelegate\u0026lt;UserClass\u0026gt;(Object, Func, Vars...);\t\\ AB-\u0026gt;Delegate.SetShouldFireWithEditorScriptGuard(bShouldFireDelegatesInEditor);\t\\ return *EnhancedActionEventBindings.Add_GetRef(MoveTemp(AB));\t\\ } 这是增强输入里使用的变参模板，应该是可以让按下按键时 触发的那个响应函数 接收任意数量的参数. 随便接.例如:\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc, Action.InputTag,floatA,floatB,floatC,floatD); void Pressed(FGameplayTag InputTag,float a,float b,float c,float d); 激活技能 前面的 GameplayAbility 片段，在GA里面定义了一个变量StartupInputTag\n1 2 UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; 并且在ASC里面GiveAbility时，把这个StartupInputTag传给 GameplayAbilitySpec 作为动态Tag.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 现在 就使用这个Tag条件 作为 按键输入 和 激活技能 之间的桥梁.\n在ASC里创建下面两个函数，接收一个GameplayTag，按下按键时 就调用这两个函数，激活技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void UAuraAbilitySystemComponent::AbilityInputHeld(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputPressed(AbilitySpec); if (!AbilitySpec.IsActive()) { TryActivateAbility(AbilitySpec.Handle); } } } } void UAuraAbilitySystemComponent::AbilityInputReleased(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputReleased(AbilitySpec); } } } 玩家控制器 绑定了GameplayTag 和 按键响应的函数， 在按键响应的函数里能够接收到 那个按键对应的GameplayTag， 现在要做的是: 这个接收到的 GameplayTag 只要和某个 GA 的GameplayTag 匹配成功，就激活那个GA.\n按键响应的函数 在玩家控制器里，激活技能需要角色身上的ASC，AbilitySystemComponent玩家控制器 能够获得角色，从角色身上获得ASC， 好了 这就是思路.\n玩家控制器里面用一个指针存放 ASC，如果ASC有效 就使用存储的ASC，如果无效 则重新获得角色以及ASC.\n1 2 UPROPERTY() TObjectPtr\u0026lt;UAuraAbilitySystemComponent\u0026gt; AuraAbilitySystemComponent; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputReleased(InputTag); } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputHeld(InputTag); } UAuraAbilitySystemComponent* AAuraPlayerController::GetASC() { if (AuraAbilitySystemComponent == nullptr) { AuraAbilitySystemComponent =Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn\u0026lt;APawn\u0026gt;())); } return AuraAbilitySystemComponent; } 投射物 从人物手上发射一个火球，撞到敌人造成伤害\n前面在 GameplayAbility 这一片段创建了自定义的GA，\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; 一个GA，一个火球Actor.GA播放角色发射火球的动作蒙太奇，GA等待GameplayEvent， 当Event触发时 才发射火球，动画蒙太奇在执行到指定帧时，通过动画通知触发Event，让GA发射火球GA在生成火球Actor时，把GE传给Actor，Actor撞到敌人，对敌人应用GE 造成伤害，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void UAuraProjectileSpell::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); } void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) { AActor* AvartarActor = GetAvatarActorFromActorInfo(); bool bIsServer = AvartarActor-\u0026gt;HasAuthority(); if (!bIsServer) return; ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(AvartarActor); if (CombatInterface) { const FVector SockLocation = CombatInterface-\u0026gt;GetCombatSocketLocation(); FRotator Rotation = (TargetLocation - SockLocation).Rotation(); Rotation.Pitch = 0 ; AActor* OwningActor = GetOwningActorFromActorInfo(); FTransform SpawnTransform; SpawnTransform.SetLocation(SockLocation); SpawnTransform.SetRotation(Rotation.Quaternion()); AAuraProjectile* Projectile = GetWorld()-\u0026gt;SpawnActorDeferred\u0026lt;AAuraProjectile\u0026gt;( ProjectileClass, SpawnTransform, OwningActor, Cast\u0026lt;APawn\u0026gt;(OwningActor), ESpawnActorCollisionHandlingMethod::AlwaysSpawn); UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get(); const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel()); UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpeceHandle,GameplayTags.Damage,ScaledDamage); Projectile-\u0026gt;DamaeEffectSpecHandle = SpeceHandle; Projectile-\u0026gt;FinishSpawning(SpawnTransform); } } SetByCaller - AssignTagSetByCallerMagnitude\nSetByCaller，在GA里设置伤害，GE里配置Tag，GA通过Tag把数值传给GE.\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA能获得AvatarActor，这就是角色，但不直接Cast到玩家角色，而是使用一个接口去做，没有硬绑定为某个具体角色类.接口的GetCombatSocketLocation函数，只是一个获取骨骼插槽位置的，返回一个Vector. 有起始位置和目标位置 就能设置火球Actor的朝向，让火球对准过去.\n1 void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) TargetLocation是在蓝图里设置的\n1 2 3 4 5 FVector AAuraCharacterBase::GetCombatSocketLocation() { check(Weapon); return Weapon-\u0026gt;GetSocketLocation(WeaponTipSocketName); } AuraProjectile.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 UCLASS() class AURA_API AAuraProjectile : public AActor { GENERATED_BODY() public:\tAAuraProjectile(); UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;UProjectileMovementComponent\u0026gt; ProjectileMovement; UPROPERTY(BlueprintReadWrite,meta = (ExposeOnSpawn = true)) FGameplayEffectSpecHandle DamaeEffectSpecHandle; protected: virtual void BeginPlay() override; UFUNCTION() void OnSphereOverlap( UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult \u0026amp; SweepResult); private: UPROPERTY(EditAnywhere) float LifeSpan = 10; UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;USphereComponent\u0026gt; Sphere; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UNiagaraSystem\u0026gt; ImpactEffect; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; ImpactSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; LoopingSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UAudioComponent\u0026gt; LoopingSoundComponent; }; AuraProjectile.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 AAuraProjectile::AAuraProjectile() { PrimaryActorTick.bCanEverTick = false; bReplicates =true; Sphere = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(\u0026#34;Sphere\u0026#34;); SetRootComponent(Sphere); Sphere-\u0026gt;SetCollisionObjectType(ECC_Projectile); Sphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); Sphere-\u0026gt;SetCollisionResponseToAllChannels(ECR_Ignore); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldDynamic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldStatic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_Pawn,ECR_Overlap); ProjectileMovement = CreateDefaultSubobject\u0026lt;UProjectileMovementComponent\u0026gt;(\u0026#34;ProjectileMovement\u0026#34;); ProjectileMovement-\u0026gt;InitialSpeed = 550; ProjectileMovement-\u0026gt;MaxSpeed = 550; ProjectileMovement-\u0026gt;ProjectileGravityScale = 0; } void AAuraProjectile::BeginPlay() { Super::BeginPlay(); SetLifeSpan(LifeSpan); Sphere-\u0026gt;OnComponentBeginOverlap.AddDynamic(this,\u0026amp;ThisClass::OnSphereOverlap); LoopingSoundComponent = UGameplayStatics::SpawnSoundAttached(LoopingSound,GetRootComponent()); } void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult\u0026amp; SweepResult) { UGameplayStatics::PlaySoundAtLocation(this,ImpactSound,GetActorLocation()); UNiagaraFunctionLibrary::SpawnSystemAtLocation(this,ImpactEffect,GetActorLocation()); LoopingSoundComponent-\u0026gt;Stop(); if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor)) { TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*DamaeEffectSpecHandle.Data.Get()); } Destroy(); } AbilityTask 技能任务（C++类\u0026quot;UAbilityTask\u0026quot;）是更常规的技能任务类的特殊形式，旨在使用游戏性技能。使用游戏性技能系统的游戏通常包括各种自定义技能任务，这些任务实施其独特的游戏功能。它们在游戏性技能执行过程中执行异步工作，并且能够通过调用委托（Delegate） （在本地C++代码中）或移经一个或多个输出执行引脚（在蓝图中）来影响执行流。这使技能能够跨多个帧执行，并可在同一帧内执行多个不同的函数。大部分技能任务都有一个即时触发的执行引脚，使蓝图能够在任务开始后继续执行。此外，通常还有一些特定于任务的引脚，它们会在延迟后或在可能发生或不发生的某个事件之后触发。\n技能任务可以通过调用\u0026quot;EndTask\u0026quot;函数自行终止，或者等待运行它的游戏性技能结束，此时它会自动终止。这可以防止幻影技能任务运行，有效地泄漏CPU周期和内存。例如，某个技能任务可能播放一个施法动画，而另一个任务则在玩家的瞄准点处放置一个靶向标线。如果玩家点击确认输入来施放该法术，或者等待动画结束而未确认该法术，游戏性技能就会结束。虽然它们可以在任何时候自动终止，但是技能任务保证最晚在主要技能结束时终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMouseTargetDataSignature,const FVector\u0026amp;,Data); UCLASS() class AURA_API UTargetDataUnderMouse : public UAbilityTask { GENERATED_BODY() public: UFUNCTION(BlueprintCallable,Category=\u0026#34;Ability|Tasks\u0026#34;,meta = (DisplayName = \u0026#34;TargetDataUnderMouse\u0026#34;,HidePin=\u0026#34;OwningAbility\u0026#34;,DefaultToSelf = \u0026#34;OwningAbility\u0026#34;,BlueprintInternalUseOnly)) static UTargetDataUnderMouse* CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility); UPROPERTY(BlueprintAssignable) FMouseTargetDataSignature ValidData; private: virtual void Activate() override; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 UTargetDataUnderMouse* UTargetDataUnderMouse::CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility) { UTargetDataUnderMouse* Myobj = NewAbilityTask\u0026lt;UTargetDataUnderMouse\u0026gt;(OwningAbility); return Myobj; } void UTargetDataUnderMouse::Activate() { APlayerController* PC = Ability-\u0026gt;GetCurrentActorInfo()-\u0026gt;PlayerController.Get(); FHitResult HitResult; PC-\u0026gt;GetHitResultUnderCursor(ECC_Visibility,false,HitResult); ValidData.Broadcast(HitResult.Location); } 蓝图调用UTargetDataUnderMouse的static函数 创建UTargetDataUnderMouse，创建之后调用Activate函数.\nBlueprintAssignable\n写在AbilityTask.h里的说明: 点击查看大图UnrealEngine/Engine/Plugins/Runtime/GameplayAbilities/Source/GameplayAbilities/Public/Abilities/Tasks\nGithub上的AbilityTask.h\nGameplayEvent 等待指定的游戏标记事件触发。默认情况下，这将查看此功能的所有者。可以设置 OptionalExternalTarget 以使其查看另一个参与者的标记以进行更改 只要 OnlyTriggerOnce = false，它就会继续监听 如果 OnlyMatchExact = false，它将触发嵌套标记 WaitGameplayEvent与ASC有关. 或许 ASC就是连接Send和Wait之间的桥梁. 所以在动画通知里要GetOwnerActor 给Owner发Event.\nSendGameplayEventToActor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload) { if (::IsValid(Actor)) { UAbilitySystemComponent* AbilitySystemComponent = GetAbilitySystemComponent(Actor); if (AbilitySystemComponent != nullptr \u0026amp;\u0026amp; IsValidChecked(AbilitySystemComponent)) { using namespace UE::AbilitySystem::Private; if (EnumHasAnyFlags(static_cast\u0026lt;EAllowPredictiveGEFlags\u0026gt;(CVarAllowPredictiveGEFlagsValue), EAllowPredictiveGEFlags::AllowGameplayEventToApplyGE)) { FScopedPredictionWindow NewScopedWindow(AbilitySystemComponent, true); AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } else { AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } } else { ABILITY_LOG(Error, TEXT(\u0026#34;UAbilitySystemBlueprintLibrary::SendGameplayEventToActor: Invalid ability system component retrieved from Actor %s. EventTag was %s\u0026#34;), *Actor-\u0026gt;GetName(), *EventTag.ToString()); } } } 在HandleGameplayEvent里面 引用到一个AbilitySystemComponent里面的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int32 UAbilitySystemComponent::HandleGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload) { int32 TriggeredCount = 0; FGameplayTag CurrentTag = EventTag; ABILITYLIST_SCOPE_LOCK(); // 省略 if (FGameplayEventMulticastDelegate* Delegate = GenericGameplayEventCallbacks.Find(EventTag)) { // Make a copy before broadcasting to prevent memory stomping FGameplayEventMulticastDelegate DelegateCopy = *Delegate; DelegateCopy.Broadcast(Payload); } // 省略 return TriggeredCount; } AbilityTask_WaitGameplayEvent\n这里面就用到了上面提到的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void UAbilityTask_WaitGameplayEvent::Activate() { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC) { if (OnlyMatchExact) { MyHandle = ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).AddUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventCallback); } else { MyHandle = ASC-\u0026gt;AddGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), FGameplayEventTagMulticastDelegate::FDelegate::CreateUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventContainerCallback)); }\t} Super::Activate(); } void UAbilityTask_WaitGameplayEvent::OnDestroy(bool AbilityEnding) { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC \u0026amp;\u0026amp; MyHandle.IsValid()) { if (OnlyMatchExact) { ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).Remove(MyHandle); } else { ASC-\u0026gt;RemoveGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), MyHandle); } } Super::OnDestroy(AbilityEnding); } 大胆猜想，GamepalyEvent就是ASC运作的WaitGameplayEvent 把要监听的GameplayTag发给ASC，当SendGameplayEvent给ASC发送Tag时，如果监听的和接收到的Tag一样，ASC就会激活触发GameplayTagEvent，\n使用数据表初始化敌人属性 不想写了，看别人写的吧\n","date":"2025-01-11T12:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-gega%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/","title":"GAS A - GE、GA、输入绑定"},{"content":"官方文档\nGit文档\nGameplayEffect 函数名称 用途 PreAttributeChange / PreAttributeBaseChange 这些函数在即将修改属性之前调用。函数旨在实施关于属性值的规则，例如，\u0026ldquo;生命值必须介于0和最大生命值\u0026quot;之间，并且不得对属性更改触发游戏内响应。 PreGameplayEffectExecute 在即将修改属性值之前，此函数可以拒绝或更改拟定修改。 PostGameplayEffectExecute 在修改属性值后，此函数可立即对更改做出响应。这通常包括限制属性的最终值或触发对新值的游戏内响应，例如当\u0026quot;生命值\u0026quot;属性降至零时死亡。 Gameplay效果组件 说明 UChanceToApplyGameplayEffectComponent 应用Gameplay效果的概率。 UBlockAbilityTagsGameplayEffectComponent 根据所有者Gameplay效果目标Actor的Gameplay标签，进行Gameplay技能激活阻止处理。 UAssetTagsGameplayEffectComponent Gameplay效果资产拥有的标签。这些标签 不会 转移到Actor。 UAdditionalEffectsGameplayEffectComponent 添加尝试在特定条件下激活（或任何条件下都不激活）的其他Gameplay效果。 UTargetTagsGameplayEffectComponent 将标签授予Gameplay效果的目标（有时指所有者）。 UTargetTagRequirementsGameplayEffectComponent 指定如果此GE须应用或继续执行，目标（Gameplay效果的拥有者）必须具备的标签要求。 URemoveOtherGameplayEffectComponent 基于某些条件移除其他Gameplay效果。 UCustomCanApplyGameplayEffectComponent 处理CustomApplicationRequirement函数的配置，以查看是否应该应用此Gameplay效果。 UImmunityGameplayEffectComponent 免疫会阻止其他GameplayEffectSpecs的应用。 新版本的GE效果组件\nAbilities Gameplay Effect component 这个组件主要是在GameplayEffect激活时，可以向目标添加的GameplayAbility\nAddtional Effects Gameplay Effect Component 当此效果添加时或完成时，需要额外添加的效果。 On Appliaciton Gameplay Effects 在添加此效果时，额外添加的效果 On Complete Always 当此效果完成时，不管正常结束还是不正常结束时，添加的效果 On Complete Normal 当此效果正常结束时，添加的额外的效果 On Complete Prematurely 当此效果提前结束时，添加的额外的效果\nGameplay效果组件 说明 Asset Tags Gameplay Effect Component 在添加此GE时，需要额外处理的标签（添加 和 删除），这个标签将放置在GE上面，只是作为一个GE的标记 Block Ability Tags Gameplay Component 添加或删除能够阻挡技能的Tags的组件，这些Tags会在GE运行时添加到Actor身上，用于阻挡其它拥有此Tag的GE或者GA的激活。 Chance to Apply Gameplay Effect Component 当前GE应用到Actor身上的几率，0为百分之0几率，1为百分之百几率 Custom Can Apply Gameplay Effect Component 自定义能够应用GE的组件，可以自定义条件来设置应用是否成功。 Immunity Gameplay Effect Component 配置角色免疫其它GE的条件 Remove Other Gameplay Effect Component 配置移除其它的GE，满足设置的标签或者资源满足条件的GE都会被移除掉。 Target Tag Requirements Gameplay Effect Component 根据目标的Tag设置当前的GE的状态Appliaction 为GE添加到目标身上时Tag的状态Ongoing 为GE激活时Tag的状态Removal 为GE被删除时Tag的状态 Target Tags Gameplay Effect Component 添加此GE后，对Actor身上带有的Tag进行操作（添加或删除），这个会随着GE的添加修改，在GE失效时移除。非Instant使用。 GameplayEffectSpec GameplayEffectSpec(GESpec)可以看作是GameplayEffect的实例, 它保存了一个其所代表的GameplayEffect类引用, 创建时的等级和创建者, 它在应用之前可以在运行时(Runtime)自由的创建和修改, 不像GameplayEffect应该由设计师在运行前创建. 当应用GameplayEffect时, GameplayEffectSpec会自GameplayEffect创建并且会实际应用到目标(Target).\nGameplayEffectSpec是由UAbilitySystemComponent::MakeOutgoingSpec()(BlueprintCallable)自GameplayEffect创建的. GameplayEffectSpec不必立即应用. 通常是将GameplayEffectSpec传递给创建自Ability的投掷物, 该投掷物可以应用到它之后击中的目标. 当GameplayEffectSpec成功应用后, 就会返回一个名为FActiveGameplayEffect的新结构体.\nGameplayEffectSpec的重要内容:\n创建该GameplayEffectSpec的GameplayEffect类. 该GameplayEffectSpec的等级. 通常和创建GameplayEffectSpec的Ability的等级一样, 但是可以是不同的. GameplayEffectSpec的持续时间. 默认是GameplayEffect的持续时间, 但是可以是不同的. 对于周期性Effect中GameplayEffectSpec的周期, 默认是GameplayEffect的周期, 但是可以是不同的. 该GameplayEffectSpec的当前堆栈数. 堆栈限制取决于GameplayEffect. GameplayEffectContextHandle表明该GameplayEffectSpec由谁创建. Attribute在GameplayEffectSpec创建时由Snapshot捕获. 除了GameplayEffect授予的GameplayTags, GameplayEffectSpec还会授予目标(Target)DynamicGrantedTags. 除了GameplayEffect拥有的AssetTags, GameplayEffectSpec还会拥有DynamicAssetTags. SetByCaller TMaps. 1 2 3 4 5 6 7 8 9 10 11 12 void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); } Stack堆栈 GameplayEffect默认会应用新的GameplayEffectSpec实例, 而不明确或不关心之前已经应用过的尚且存在的GameplayEffectSpec实例. GameplayEffect可以设置到堆栈中, 新的GameplayEffectSpec实例不会添加到堆栈中, 而是修改当前已经存在的GameplayEffectSpec堆栈数. 堆栈只适用于持续(Duration)和无限(Infinite)GameplayEffect.\nSource就是AbilitySystemComponent\n堆栈类型 描述 Aggregate by Source 目标(Target)上的每个源(Source)ASC都有一个单独的堆栈实例, 每个源(Source)可以应用堆栈中的X个GameplayEffect. Aggregate by Target 目标(Target)上只有一个堆栈实例而不管源(Source)如何, 每个源(Source)都可以在共享堆栈限制(Shared Stack Limit)内应用堆栈. By Source ，每个Source对象拥有一个计数，计数达到限制时 不能再对Target应用GE.Source1的Stack达到2后，再次应用会失效. 这时再起一个Source2对象 就可以应用GE，因为它的Stack没有达到限制\nBy Target，只要Target的Stack达到限制，不管有多少个Source 都不能对Target应用GE.\n详细解释\n————————————————\nInfinite GE的添加、移除 当GameplayEffectSpec成功应用后, 就会返回一个FActiveGameplayEffectHandle.\n在应用GESpec后，把TargetASC和GEHandle加入到Map里这是针对区域效果的操作，如果有2个玩家进入伤害区域，在他们离开区域时 要通过 \u0026lt;离开的Acotr\u0026gt; 这个条件去Map寻找他对应的GEHandle，从而根据GEHandle移除他身上的GE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TMap\u0026lt;FActiveGameplayEffectHandle,UAbilitySystemComponent*\u0026gt; ActiveEffectHandls; void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); const bool bIsInfinite = EffectSpecHandle.Data.Get()-\u0026gt;Def.Get()-\u0026gt;DurationPolicy == EGameplayEffectDurationType::Infinite; if (bIsInfinite \u0026amp;\u0026amp; InfiniteEffectRemovePolicy == EEffectRemovePolicy::RemoveOnEndOverlap) { ActiveEffectHandls.Add(ActiveEffectHandle,TargetASC); } } 移除通过Actor的ASC查找Map里对应的GEHandle，使用Handle移除Actor的ASC上面的GE后，还要在Map里移除这一对元素.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void AAuraEffectActor::RemoveGE(AActor* TargetActor) { UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (!IsValid(ASC)) return; // TArray\u0026lt;FActiveGameplayEffectHandle\u0026gt; HandlesToRemove; for (TTuple\u0026lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*\u0026gt; HandlePair : ActiveEffectHandls) { if (HandlePair.Value == ASC) { ASC-\u0026gt;RemoveActiveGameplayEffect(HandlePair.Key,1); HandlesToRemove.Add(HandlePair.Key); } } for (FActiveGameplayEffectHandle\u0026amp; Handle : HandlesToRemove) { ActiveEffectHandls.FindAndRemoveChecked(Handle); } // /*使用迭代器遍历 TMap for (auto It = ActiveEffectHandls.CreateIterator(); It; ++It) { if (It-\u0026gt;Value == ASC) { // 删除 ActiveGameplayEffect ASC-\u0026gt;RemoveActiveGameplayEffect(It-\u0026gt;Key); // 删除 TMap 中的元素 It.RemoveCurrent(); } }*/ } 数值的限制 与 响应 生命值等属性在应用GE后 可能会变成负数，或者超出最大生命值，\nPreAttributeChange PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue)是AttributeSet中的主要函数之一, 其在修改发生前响应Attribute的CurrentValue变化, 其是通过引用参数NewValue限制(Clamp)CurrentValue即将进行的修改的理想位置.\n例如像样例项目那样限制移动速度Modifier:\n1 2 3 4 5 if (Attribute == GetMoveSpeedAttribute()) { // Cannot slow less than 150 units/s and cannot boost more than 1000 units/s NewValue = FMath::Clamp\u0026lt;float\u0026gt;(NewValue, 150, 1000); } GetMoveSpeedAttribute()函数是由我们在AttributeSet.h中添加的宏块创建的(定义Attribute).\nPreAttributeChange()可以被Attribute的任何修改触发, 无论是使用Attribute的setter(由AttributeSet.h中的宏块定义(定义Attribute))还是使用GameplayEffect.\nNote: 在这里做的任何限制都不会永久性地修改ASC中的Modifier, 只会修改查询Modifier的返回值, 这意味着像GameplayEffectExecutionCalculations和ModifierMagnitudeCalculations这种自所有Modifier重新计算CurrentValue的函数需要再次执行限制(Clamp)操作.\nNote: Epic对于PreAttributeChange()的注释说明不要将该函数用于游戏逻辑事件, 而主要在其中做限制操作. 对于修改Attribute的游戏逻辑事件的建议位置是UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)(响应Attribute变化).\n限制生命值示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue) { Super::PreAttributeChange(Attribute, NewValue); if (Attribute == GetHealthAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxHealth()); } if (Attribute == GetManaAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxMana()); } } ·当前值的变化 - 在变化发生之前 ·由属性的变化触发 - 属性访问器 - GameplayEffects ·不会永久更改修饰符，只会更改查询修饰符返回的值 ·后续操作会重新计算所有修饰符的当前值 - 我们需要再次限制\nPostGameplayEffectExecute PostGameplayEffectExecute(const FGameplayEffectModCallbackData \u0026amp; Data)仅在即刻(Instant)GameplayEffect对Attribute的BaseValue修改之后触发, 当GameplayEffect对其修改时, 这就是一个处理更多Attribute操作的有效位置.\n例如, 在样例项目中, 我们在这里从生命值Attribute中减去了最终的伤害值Meta Attribute, 如果有护盾值Attribute的话, 我们也会在减除生命值之前从护盾值中减除伤害值. 样例项目也在这里应用了被击打反应动画, 显示浮动的伤害数值和为击杀者分配经验值和赏金. 通过设计, 伤害值Meta Attribute总是会传递给即刻(Instant)GameplayEffect而不是Attribute Setter.\n其他只会由即刻(Instant)GameplayEffect修改BaseValue的Attribute, 像魔法值和耐力值, 也可以在这里被限制为其相应的最大值Attribute.\nNote: 当PostGameplayEffectExecute()被调用时, 对Attribute的修改已经发生, 但是还没有被同步回客户端, 因此在这里限制值不会造成对客户端的二次同步, 客户端只会接收到限制后的值.\n限制生命值:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } } PreAttributeChange 和 PostGameplayEffectExecute 一起使用，这样才是真正的限制住了\nFGameplayEffectModCallbackData PostGameplayEffectExecute的参数FGameplayEffectModCallbackData\u0026amp; Data，它包含了很多信息，\n下面这个 FEffectProperites 结构体里的信息 都能从Data里面获得.Source开头 指的是 “属性的改变是谁打过来的”，Target开头 指的是“受害者”例如: 泽拉斯Q了一下诺手， 这个Q的伤害是泽拉斯造成的，Source是泽拉斯.诺手接收到Q的伤害之后，要在PostGameplayEffectExecute里面一通计算 响应伤害，Target是诺手.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 USTRUCT() struct FEffectProperites { GENERATED_BODY() FEffectProperites(){}; FGameplayEffectContextHandle EffectContextHandle; UPROPERTY() UAbilitySystemComponent* SourceASC = nullptr; UPROPERTY() AActor* SourceAvatarActor = nullptr; UPROPERTY() AController* SourceController = nullptr; UPROPERTY() ACharacter* SourceCharacter = nullptr; //////////////////////////////////////////// UPROPERTY() UAbilitySystemComponent* TargetASC = nullptr; UPROPERTY() AActor* TargetAvatarActor = nullptr; UPROPERTY() AController* TargetController = nullptr; UPROPERTY() ACharacter* TargetCharacter = nullptr; }; FGameplayEffectModCallbackData\u0026amp; Data的使用方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); } void UAuraAttributeSet::SetEffectProperties(const struct FGameplayEffectModCallbackData\u0026amp; Data,FEffectProperites\u0026amp; Props) { Props.EffectContextHandle = Data.EffectSpec.GetContext(); Props.SourceASC = Props.EffectContextHandle.GetOriginalInstigatorAbilitySystemComponent(); if (IsValid(Props.SourceASC) \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.SourceAvatarActor = Props.SourceASC-\u0026gt;GetAvatarActor(); Props.SourceController = Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;PlayerController.Get(); if (Props.SourceController == nullptr \u0026amp;\u0026amp; Props.SourceAvatarActor!=nullptr) { if (APawn* Pawn = Cast\u0026lt;APawn\u0026gt;(Props.SourceAvatarActor)) { Props.SourceController = Pawn-\u0026gt;GetController(); } } if (Props.SourceController) { Props.SourceCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.SourceController-\u0026gt;GetPawn()); } } if (Data.Target.AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.TargetAvatarActor = Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.Get(); Props.TargetController = Data.Target.AbilityActorInfo-\u0026gt;PlayerController.Get(); Props.TargetCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.TargetAvatarActor); Props.TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Props.TargetAvatarActor); } } 使用Prop:\n1 2 3 4 5 6 if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } 诺手接收到伤害后，打印诺手的名字和血量，所以需要TargetAvatarActor来获得名字.\n","date":"2025-01-11T11:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-gameplayeffect/","title":"GAS A - GameplayEffect"},{"content":"MVC 插播一条：UE5中 有一套MVVM插件 可以与UMG联动。创建MVVM对象，在这个对象里面创建一些变量什么的，当变量改变时 它自己就会发出广播通知\nhttps://www.bilibili.com/video/BV1Dj411N735/\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/umg-viewmodel\n下面开始视频教程的内容：\n将应用程序分为三个核心组件：模型（Model）、视图（View）和控制器（Controller），以实现关注点分离。\n在这个系列课程中，使用这个架构来更新UMG， 玩家属性发生变化\u0026mdash;\u0026gt;通知Controller\u0026mdash;\u0026gt;Controller发出消息广播，UMG订阅Controller的消息广播，这样就把 玩家和UMG 联系起来了.\n直观上看的话，也就是 玩家大喊一声“该更新了”，具体去更新谁，玩家并不关心。\n在整个过程中，只关注一个中介者—Controller，需要更新自己数据的UMG界面 自己去订阅消息通知，变化事件发生时，Controller发出通知消息， UMG自己去查看是 生命值变化了，还是魔法值变化了，去做它自己该做的事情。\n套用MVC模式，View = UMG，Model = 玩家属性，Controller就是这两个之间的中间件. Controller可以是一个UObject. (这里的Controller不是引擎中的 AI控制器 / 玩家控制器，只是一个U类对象)\n这是最终要实现的结构，UMG内部需要Controller的指针，用来订阅Controller的消息，\nUMG和Controller都集中在HUD里面，HUD同时创建UMG、Controller，并且当场就把Controller与UMG 关联起来。 GameMode管理HUD，GameMode会自动创建HUD. 而HUD内部管理UMG、Controller，HUD对外公开一个函数，用来接收玩家相关的信息 以及 创建UMG、Controller\n1 InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) 这个函数接收4个参数 用来获得玩家信息，只需要一个合适的时机调用这个HUD的函数，一切就能关联起来。\n对于人类玩家角色来说，GAS相关组件都放在PlayerState里面，当角色死亡时 死的只是Actor 不是PlaeyrState，所以这些组件不会丢失角色的属性信息，角色复活时 就得重新获得PlayerState里面的GAS组件信息。复活 就可以视为是初始化了，游戏刚开始时，角色也算是“复活”，即调用 PossessedBy 函数，在PossessedBy 函数里面获得GAS信息的同时，就通知UI去更新信息。\n这就是InitOverlay调用的时机，即在 PossessedBy 里面调用. PossessedBy 拿到 PC、PS、ASC、AS 之后 传给HUD::InitOverlay，让HUD拿着这些信息去构造Controller\n有了这些指导思想，接下来的内容就容易看懂了.\n整这么一大堆，其实就是 本来UMG能直接GetPlayerCharacter，Cast到AuraCharacter，角色身上的所有东西都能获取，GetPlayerState ，Cast到AuraPlayerState也能获取GAS组件。这已经可以运行了，只是多了一个中间件，原本是 角色\u0026mdash;\u0026gt;UMG，一站直达的， 现在需要 角色\u0026ndash;\u0026gt;中间件\u0026mdash;\u0026gt;UMG于是乎，就要想办法把这一串逻辑 重新打通，就仅此而已.\nController \u0026amp; Widget 粗糙的结构图，WidgetController只是个继承自UObject的类，需要4个变量，PC、PS、ASC、AS，UserWidget 也就是UMG的父类， 有WidgetController的Getter、Setter，在代码里面调用SetWidgetController()，SetWidgetController内部又调用WidgetControllerSet()，这是用来调用蓝图事件的，绑定的事件在UMG的蓝图里做，这样就打通了C++和蓝图的通信.\n创建UMG 后面只是在蓝图里创建了几个UMG，这是结构图， WBP_Overlay是主界面，里面有小UI，WBP_HealthGlobe等等.\nHUD 在哪里创建主UI？Controller存放到哪里？又如何初始化？\nHUD的目的是 告知玩家当前游戏状态，即分数、生命值、游戏剩余时间等。\n这个课程把Controller放到了HUD里，UMG也由HUD来创建。\n1 2 3 4 5 6 7 AuraHUD UPROPERTY() TObjectPtr\u0026lt;UAuraUserWidget\u0026gt; OverlayWidget; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UAuraUserWidget\u0026gt; OverlayWidgetClass; 这是常用的操作，在蓝图里指定OverlayWidgetClass 选择使用哪一个蓝图，在C++中使用这个class创建对象.\n把BP_AuraHUD放到GameMode里面，用于创建BP_AuraHUD\nWidget Controller HUD能创建出UMG了，还剩下Controller没有初始化，AuraWidgetController里面还有4个变量需要初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState; TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; ———————————————————————————————————————————————————————————————————— USTRUCT(BlueprintType) struct FWidgetControllerParams { GENERATED_BODY() FWidgetControllerParams(){}; FWidgetControllerParams(APlayerController* PC,APlayerState* PS,UAbilitySystemComponent* ASC,UAttributeSet* AS) : PlayerController(PC),PlayerState(PS),AbilitySystemComponent(ASC),AttributeSet(AS) {}; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet = nullptr; }; void UAuraWidgetController::SetWidgetControllerParams(const FWidgetControllerParams\u0026amp; WCParams) { PlayerController = WCParams.PlayerController; PlayerState = WCParams.PlayerState; AbilitySystemComponent = WCParams.AbilitySystemComponent; AttributeSet = WCParams.AttributeSet; } 看着比较长，实际上只是定义一个结构体，函数接收这个结构体来初始化这些变量， 思考题：为什么要用结构体？ WidgetController里面的变量初始化完了，那么WidgetController本体在哪里初始化？\n创建OverlayWidgetController ，它继承自 UAuraWidgetController，用来更新主UI.\n在AuraHUD里添加两个变量，前面的UMG在HUD里初始化了，WidgetController也在HUD初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY() TObjectPtr\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetController; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetControllerClass; UOverlayWidgetController* AAuraHUD::GetOverlayWidgetController(const FWidgetControllerParams\u0026amp; WCParams) { if (OverlayWidgetController == nullptr) { OverlayWidgetController = NewObject\u0026lt;UOverlayWidgetController\u0026gt;(this,OverlayWidgetControllerClass); OverlayWidgetController-\u0026gt;SetWidgetControllerParams(WCParams); OverlayWidgetController-\u0026gt;BindCallbacksToDependencies(); return OverlayWidgetController; } return OverlayWidgetController; } GetOverlayWidgetController() 如果OverlayWidgetController没有值 则创建并返回，有值 直接返回。\n初始化函数有了，调用时机呢？\n1 2 3 4 5 这个函数是后文 消息广播 定义的函数，在Controller初始化时 广播一次属性值 总不能是空血条开局吧 WidgetController-\u0026gt;BroadcastInitialValues(); 这也是后文的函数，用来订阅 属性更改通知 的委托 BindCallbacksToDependencies() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) { checkf(OverlayWidgetClass,TEXT(\u0026#34;OverlayWidgetClass uninitialized,fill out BP_AurhHUD\u0026#34;)); checkf(OverlayWidgetControllerClass,TEXT(\u0026#34;OverlayWidgetControllerClass uninitialized,fill out BP_AurhHUD\u0026#34;)); OverlayWidget = CreateWidget\u0026lt;UAuraUserWidget\u0026gt;(GetWorld(), OverlayWidgetClass); const FWidgetControllerParams WidgetControllerParams(PC,PS,ASC,AS); UOverlayWidgetController* WidgetController = GetOverlayWidgetController(WidgetControllerParams); OverlayWidget-\u0026gt;SetWidgetController(WidgetController); WidgetController-\u0026gt;BroadcastInitialValues(); OverlayWidget-\u0026gt;AddToViewport(); } InitOverlay AAuraHUD::InitOverlay 是HUD公开出去的函数，是一切故事发生的入口.\n至此，HUD把UMG和WidgetController收集了起来. 在HUD中通过 InitOverlay() 创建UMG、WidgetController，并且在创建现场就把UMG和WidgetController关联起来.\n1 OverlayWidget-\u0026gt;SetWidgetController(WidgetController); 只要调用对外公开的 InitOverlay() 函数，所有东西都能链接起来，那么 在哪里调用才合适？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;AbilityInfoSet(); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); if (AAuraPlayerController* AuraPlayerController = Cast\u0026lt;AAuraPlayerController\u0026gt;(GetController())) { if (AAuraHUD* AuraHud = Cast\u0026lt;AAuraHUD\u0026gt;(AuraPlayerController-\u0026gt;GetHUD())) { AuraHud-\u0026gt;InitOverlay(AuraPlayerController,AuraPlayerState,AbilitySystemComponent,AttributeSet); } } } 最终如图所示，完成整个流程。\nCharacter::PossessedBy是入口，在这里获得 玩家控制器、玩家状态、技能组件、属性Set.初始化角色自己的GAS组件 的同时 ，传给HUD 让HUD也用用，HUD在创建Controller时，把 玩家控制器、玩家状态、技能组件、属性集 传给Controller，HUD在创建UMG时，把Controller 传给UMG.\n消息广播 GAS对外公开有委托事件，当属性变化时 这个委托就会广播，Controller订阅GAS的广播 就可以在属性变化时 获得属性的最新值。\n当Controller被HUD初始化时，就要广播一次 用来初始化UMG里的内容，总不能开局血条是空的吧。\nUAuraWidgetController追加空函数，在OverlayWidgetController进行override.\n1 2 3 UFUNCTION(BlueprintCallable) virtual void BroadcastInitialValues(){}; virtual void BindCallbacksToDependencies(){}; 还要在OverlayWidgetController里面定义委托 和 委托变量\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewValue); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); —————————————————————————————————————————————————————————————————————————— UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnHealthChanged; UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnMaxHealthChanged; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void UOverlayWidgetController::BroadcastInitialValues() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); OnHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxHealth()); OnManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMana()); OnMaxManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxMana()); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); } MVVM GAS B系列使用MVVM框架更新UMG.\n(有一个漏掉的操作 → 没有手动调用一次广播，开局血条是空的，)\nELMVVMPlayer.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 UCLASS(BlueprintType) class ELEMENTAL_III_API UELMVVMPlayer : public UMVVMViewModelBase { GENERATED_BODY() public: UFUNCTION(BlueprintCallable) void SetMvvmParams(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); protected: UPROPERTY() TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Health; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxHealth; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Mana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxMana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter=GetIsBattleMode,Setter=SetIsBattleMode) bool bIsBattleMode = false; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) int32 KillNumber; void SetHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Health,Value);} float GetHealth() const {return Health;}; void SetMaxHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxHealth,Value);} float GetMaxHealth() const {return MaxHealth;}; void SetMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Mana,Value);} float GetMana() const {return Mana;}; void SetMaxMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxMana,Value);} float GetMaxMana() const {return MaxMana;}; void SetIsBattleMode(const bool Value) {UE_MVVM_SET_PROPERTY_VALUE(bIsBattleMode,Value);} bool GetIsBattleMode() const {return bIsBattleMode;}; void SetKillNumber(const int32 Value) {UE_MVVM_SET_PROPERTY_VALUE(KillNumber,Value);} int32 GetKillNumber() const {return KillNumber;}; }; ELMVVMPlayer.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // AELCharacterBase::InitAbilityInfo ---\u0026gt; AELHUD::InitMVVM ---\u0026gt; ThisClass::SetMvvmParams void UELMVVMPlayer::SetMvvmParams(APlayerController* PC, UAbilitySystemComponent* ASC, UAttributeSet* AS) { PlayerController = PC; AbilitySystemComponent = ASC; AttributeSet = AS; AELPlayerController* ELPlayerController = Cast\u0026lt;AELPlayerController\u0026gt;(PlayerController); ELPlayerController-\u0026gt;OnBattleModeChange.AddLambda( [this](bool InBattleMode) { SetIsBattleMode(InBattleMode); }); const UELAttributeSet* ELAttributeSet = Cast\u0026lt;UELAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetKillNumberAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetKillNumber(Data.NewValue); }); } ELHUD.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 UCLASS() class ELEMENTAL_III_API AELHUD : public AHUD { GENERATED_BODY() public: void InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;ACharacter\u0026gt; Character; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, EditDefaultsOnly) FMVVMViewModelContext MVVMContext; UPROPERTY(BlueprintReadOnly) class UELMVVMPlayer* MVVMPlayer; }; ELHUD.cpp\n在这里创建MvvmPlayer并且添加到Mvvm全局子系统里. UMG里根据Context从全局获取MvvmPlayer.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void AELHUD::InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS) { AbilitySystemComponent = ASC; PlayerController = PC; Character = Cast\u0026lt;ACharacter\u0026gt;(PlayerController-\u0026gt;GetPawn()); AttributeSet = AS; MVVMPlayer = NewObject\u0026lt;UELMVVMPlayer\u0026gt;(PC); UGameInstance* GameInstance = UGameplayStatics::GetGameInstance(this); UMVVMGameSubsystem* MvvmGameSubsystem = GameInstance-\u0026gt;GetSubsystem\u0026lt;UMVVMGameSubsystem\u0026gt;(); MvvmGameSubsystem-\u0026gt;GetViewModelCollection()-\u0026gt;AddViewModelInstance(MVVMContext,MVVMPlayer); MVVMPlayer-\u0026gt;SetMvvmParams(PC,ASC,AS); } CharacterBase\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AELCharacterBase::InitAbilityInfo() { AHUD* HUD = Cast\u0026lt;AELPlayerController\u0026gt;(GetController())-\u0026gt;GetHUD(); if (AELHUD* ELHud = Cast\u0026lt;AELHUD\u0026gt;(HUD)) { ELHud-\u0026gt;InitMvvm(Cast\u0026lt;AELPlayerController\u0026gt;(GetController()),AbilitySystemComponent,AttributeSet); } } void AELCharacterBase::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); InitAbilityInfo(); } 调用顺序: AELCharacterBase::PossessedBy\u0026mdash;\u0026gt;AELCharacterBase::InitAbilityInfo \u0026mdash;\u0026gt; AELHUD::InitMVVM \u0026mdash;\u0026gt; UELMVVMPlayer::SetMvvmParams\n","date":"2025-01-11T11:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-ui-mvc-or-mvvm/","title":"GAS A - UI - MVC or MVVM"},{"content":"起手式 网页图片模糊 点击图片预览高清大图\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/gameplay-ability-system-for-unreal-engine↑首先看一遍官方文档↑\nGAS学习资料:https://github.com/BillEliot/GASDocumentation_Chinese\n官方的ActionRPG项目，\nGAS A系列是由 \u0026lt; Gameplay Ability System - Top Down RPG\u0026gt; 这一套教程来的,简单的细枝末节不记录https://www.bilibili.com/video/BV1JD421E7yC\n与GameplayAbilitySystem交互的Actor须拥有 GameplayAbilitySystemComponent。此组件将激活技能、存储属性、更新效果，和处理Actor间的交互。\n角色类拥有UAbilitySystemComponent 和 UAttributeSet 两个组件，AttributeSet保存角色的属性值，例如:生命值、魔法值、生命回复、攻击力、法术强度，而这些属性由GameplayEffect来修改，不应手动修改.尽管AttributeSet提供了Setter方法，也不该手动调用它去做一些事情.\nGameplayAbility执行技能任务，被动、Q、W、E、R、D、F都可以是GameplayAbility.技能(GameplayAbility) 可以配置CD、Cost，也就是冷却时长，耗费多少蓝量. CD和Cost都由GamePlayEffect定义. CD、Cost的信息都可以在GA的蓝图面板中配置，选择对应的GE蓝图即可.\n技能执行流程 先描述最感兴趣的一集吧，开局就写难懂的东西 只会让脑子开局就过载，作文首先要引起读者的兴趣。 这把先开\u0026lt;泽拉斯\u0026gt;奥兄弟们，最会空技能的一个英雄。\n冷却时间 泽拉斯的Q技能一级有9秒CD，释放技能时 如果在冷却中 就不让释放，这个流程如何使用GAS来执行？GE可以选择 \u0026lt;立即生效 | 持续一段时间 | 无限时间\u0026gt; 三个策略。假设这个技能是GA_Q，它拥有标签TAG_Q，那么就让GE_Q_CD使用 \u0026lt;持续一段时间\u0026gt; 这个策略，并且让GE_Q_CD去阻挡TAG_Q，等到GE的持续时间结束才会取消阻挡。 这样就实现了技能的冷却。执行流程为:GA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;不在CD中\u0026mdash;\u0026gt;执行技能\u0026mdash;\u0026gt;技能结束，开始CDGA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;正在CD中\u0026mdash;\u0026gt;技能结束\n技能耗费 泽拉斯的Q技能需要耗费80蓝量，这就要求Attribute里面拥有\u0026lt;魔法值\u0026gt;这个属性，在GA_Q执行时扣除相应的魔法值，如果蓝量不够 就不能执行技能.GE_Q_Cost 使用 \u0026lt;立即生效\u0026gt; 策略，(瞪眼观察法可知 另外两个策略一看就不对)Q需要耗费80蓝量，GE_Q_Cost就得让 \u0026lt;魔法值\u0026gt; 减80，魔法值够减的话 那么就能执行技能. 不够减 就不执行.\n执行流程与 冷却时间 相似.\n技能伤害 有了上面使用GE去做CD 耗蓝，那么伤害如何去做？ 直接减掉目标的血量值？NO ，Attribute中定义 \u0026lt;即将到来的伤害\u0026gt;， 如果伤害值是50， 那么就使用GE 让敌人的 \u0026lt;即将到来的伤害\u0026gt; +50。 在Attribute中去执行减掉生命值的操作.\n这把开一局\u0026lt;爆破鬼才\u0026gt;，假如我发射一个火球，那么在火球滑行的途中，它撞到了地面 触发爆炸伤害. 这里就得范围检测Enemy，并且获得它们身上的 AbilitySystemComponent 并且对这个组件应用GE，造成伤害\n技能蓝图 被动技能 生命回复、法力回复 这些都是自动运行的， 每秒回复1点生命值 回复1点魔法值， 可以用GE做一个 无限时间 的效果，持续一段时间 | 无限时间 ， 这两个策略都可以设置触发周期，比如每1秒触发一次，每0.5秒触发一次 等等。\n自动回复就使用 无限时间 ，每秒触发一次，每次触发添加1点生命值，1点魔法值。就叫它 GE_Regeneration ，在BeginPlay时 对AbilitySystemComponent应用这个GE即可。那死亡时 不想要自动回复了怎么办？ GE可以被Apply，也可以被Remove，死亡时只要移除这个GE就行了,这是手动移除的案例.\nBuff也可以用一个GE完成，例如 增加50攻击力，并且持续90秒，那么就使用一个 持续一段时间的GE，让攻击力+50，时间结束后 GE自动取消. 这是自动移除的案例.手动移除方法：\nGameplayAbilitySystem 初始化技能组件 ASC附加的Actor被引用作为该ASC的OwnerActor, 该ASC的物理代表Actor被称为AvatarActor. OwnerActor和AvatarActor可以是同一个 Actor, 比如MOBA游戏中的一个简单AI小兵; 它们也可以是不同的Actor, 比如MOBA游戏中玩家控制的英雄, 其中OwnerActor是PlayerState, AvatarActor是英雄的Character类. 绝大多数Actor的ASC都附加在其自身, 如果你的Actor会重生并且重生时需要持久化Attribute或GameplayEffect(比如MOBA中的英雄), 那么ASC理想的位置就是PlayerState.\nGAS要求添加 AbilitySystemComponent (ASC) 和 AttributeSet (AS)，那么往角色身上添加 是否可行？\n如果角色可以被摧毁、可以死亡，当CharacterActor死亡时 在它身上挂载的 ASC、AS 全都没有了，一起跟着销毁再次复活时 技能信息会丢失。 这就要求把ASC、AS放到一个可靠的地方，在这个教程里 放到了PlayerState里面。\n问题:如何放？ 还要把玩家角色与PlayerState里的ASC、AS连接起来，这样在场景里才能通过玩家角色获得玩家的ASC、AS，如何连接？ ACharacter -\u0026gt; AuraCharacterBase -\u0026gt;Enemy / AuraCharacter , AuraCharacter 是玩家角色\n【Enemy 和 AuraCharacter 都继承自AuraCharacterBase 】\n在AuraCharacterBase 和 PlayerStae 中定义GAS的两个组件的指针，但是实体在Enemy 和 PlayerState 中创建.因为玩家角色的GAS组件要放在PlayerState里，而敌人AI就放在它自己的角色类里面.\n下面的内容就是解决上面的两个问题:如何放 如何连接。定义组件指针、初始化组件、连接 玩家角色 与 PlayerState 的组件.(玩家角色 被玩家控制器 控制后，就要获得PlayerState里面的ASC、AS组件)思路不清晰 可以看小节结尾的流程图.\n1 2 3 4 5 UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 AAuraEnemy::AAuraEnemy() { GetMesh()-\u0026gt;SetCollisionResponseToChannel(ECC_Visibility,ECR_Block); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); HealthBar = CreateDefaultSubobject\u0026lt;UWidgetComponent\u0026gt;(\u0026#34;HealthBar\u0026#34;); HealthBar-\u0026gt;SetupAttachment(GetRootComponent()); } AAuraPlayerState::AAuraPlayerState() { //NetUpdateFrequency = 100.f; SetNetUpdateFrequency(100.f); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); } 完了还要在AuraCharacterBase继承一个接口，用来获得ASC，因为要与ASC通信，不管是哪个类，只要调用这个接口就能得到它的ASC组件.\n1 2 3 4 5 6 7 8 9 10 class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraCharacterBase::GetAbilitySystemComponent() const { return AbilitySystemComponent; } 现在Enemy的组件注册完了，玩家角色的还没有结束，它的组件都在PlayerState里面，还要再手动从PS里获取组件.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AURA_API AAuraPlayerState : public APlayerState,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraPlayerState::GetAbilitySystemComponent() const { return AbilitySystemComponent; } —————————————————————————————————————————————————————————————————————————————————————— void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); } 这样就把玩家角色和AuraPlayerState链接起来了，AbilitySystemComponent 和 AttributeSet 都初始化了.\nAttribute https://github.com/BillEliot/GASDocumentation_Chinese?tab=readme-ov-file#43-attribute\nAttribute里定义生命值，FGameplayAttributeData Health; FGameplayAttributeData 是一个结构体，其数值是浮点型，结构体里面有一个BaseValue和一个CurrentValue，假如当前生命值是100，BaseValue = CurrentValue = 100 ， 有一个持续10秒的加50生命值的buff，一个NPC吃了一个buff 这是他生命值发生的变化， BaseValue = 100 ， CurrentValue = 100 + 50 = 150，10秒后 buff结束，CurrentValue就会变回BaseValue， 此时 BaseValue = CurrentValue = 100.\n即刻(Instant)GameplayEffect可以永久性的修改BaseValue, 而持续(Duration)和无限(Infinite)GameplayEffect可以修改CurrentValue. 周期性(Periodic)GameplayEffect被视为即刻(Instant)GameplayEffect并且可以修改BaseValue.\nAttributeSet.h里提供了一个Help宏，它被注释了，这个宏提供4个函数，Getter、Setter、Init以及一个静态的GetAttribute\n1 2 3 4 5 #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName) 将它复制到自己的类里面使用，定义一个Health属性，并且初始化为100.\n1 2 3 UPROPERTY(BlueprintReadOnly\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); 药瓶 Effect Actor 这个Actor这样修改属性只是为了简单测试，属性修改要使用GE. 当角色碰到这个Actor时 角色的Health会增加50.\n附 教程里因为版本不同 名称不同的对照，一些属性名称 , 还有打起来贼他妈麻烦的代码片段， 都可以到这复制\nGameplayEffectAssetTag 【=】 Tags This Effect Has GrantedTags 【=】 Grant Tags to Target Actor Ongoing Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Application Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Removal Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Remove Gameplay Effect With Tags 【=】 Remove Other Effects\nArmor,ArmorPenetration,BlockChance,\nCriticalHitChance,CriticalHitDamage,CriticalHitResistance,\nHealthRegeneration,ManaRegeneration\nAttribute.Primary.Intelligence Row_Strength Row_Intelligence Row_Resilience Row_Vigor\nRow_Armor Row_ArmorPenetration Row_BlockChance Row_CriticalHitChance Row_CriticalHitDamage Row_CriticalHitResistance Row_HealthRegeneration Row_ManaRegeneration Row_MaxHealth Row_MaxMana\nAuraGameplayTags.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;GameplayTagContainer.h\u0026#34; struct FAuraGameplayTags { public: static const FAuraGameplayTags\u0026amp; Get() {return GameplayTags;} static void InitializeNativeGameplayTags(); FGameplayTag Attribute_Primary_Strength; FGameplayTag Attribute_Primary_Intelligence; FGameplayTag Attribute_Primary_Resilience; FGameplayTag Attribute_Primary_Vigor; FGameplayTag Attribute_Secondary_Armor; FGameplayTag Attribute_Secondary_ArmorPenetration; FGameplayTag Attribute_Secondary_BlockChance; FGameplayTag Attribute_Secondary_CriticalHitChance; FGameplayTag Attribute_Secondary_CriticalHitDamage; FGameplayTag Attribute_Secondary_CriticalHitResistance; FGameplayTag Attribute_Secondary_HealthRegeneration; FGameplayTag Attribute_Secondary_ManaRegeneration; FGameplayTag Attribute_Secondary_MaxHealth; FGameplayTag Attribute_Secondary_MaxMana; FGameplayTag InputTag_LMB; FGameplayTag InputTag_RMB; FGameplayTag InputTag_1; FGameplayTag InputTag_2; FGameplayTag InputTag_3; FGameplayTag InputTag_4; FGameplayTag Damage; FGameplayTag Effect_HitReact; private: static FAuraGameplayTags GameplayTags; }; AuraGameplayTags.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026#34;AuraGameplayTags.h\u0026#34; #include \u0026#34;GameplayTagsManager.h\u0026#34; FAuraGameplayTags FAuraGameplayTags::GameplayTags; void FAuraGameplayTags::InitializeNativeGameplayTags() { GameplayTags.Attribute_Primary_Strength = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Strength\u0026#34;), FString(\u0026#34;Increases physical damage\u0026#34;)); GameplayTags.Attribute_Primary_Intelligence = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Intelligence\u0026#34;), FString(\u0026#34;Increases magical damage\u0026#34;)); GameplayTags.Attribute_Primary_Resilience = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Resilience\u0026#34;), FString(\u0026#34;Increases Armor and ArmorPenetration\u0026#34;)); GameplayTags.Attribute_Primary_Vigor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Vigor\u0026#34;), FString(\u0026#34;Increases Health\u0026#34;)); //////////////////// GameplayTags.Attribute_Secondary_Armor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.Armor\u0026#34;), FString(\u0026#34;Reduce damage taken\u0026#34;)); GameplayTags.Attribute_Secondary_ArmorPenetration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ArmorPenetration\u0026#34;), FString(\u0026#34;Ignore percentage of enemy\u0026#34;)); GameplayTags.Attribute_Secondary_BlockChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.BlockChance\u0026#34;), FString(\u0026#34;Chance to cut incoming damage in half\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitChance\u0026#34;), FString(\u0026#34;Chance to double damage plus critical hit bonus\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitDamage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitDamage\u0026#34;), FString(\u0026#34;Bonus damage added when a critical hit is scored\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitResistance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitResistance\u0026#34;), FString(\u0026#34;Reduces critical hit chance of attacking enemies\u0026#34;)); GameplayTags.Attribute_Secondary_HealthRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.HealthRegeneration\u0026#34;), FString(\u0026#34;Amount of Health regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_ManaRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ManaRegeneration\u0026#34;), FString(\u0026#34;Amount of Mana regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_MaxHealth = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxHealth\u0026#34;), FString(\u0026#34;Maximum amount of Health\u0026#34;)); GameplayTags.Attribute_Secondary_MaxMana = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxMana\u0026#34;), FString(\u0026#34;Maximum amount of Mana\u0026#34;)); ///////////// GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.LMB\u0026#34;), FString(\u0026#34;Input Tag for Left Mouse Button\u0026#34;)); GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.RMB\u0026#34;), FString(\u0026#34;Input Tag for Right Mouse Button\u0026#34;)); GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.1\u0026#34;), FString(\u0026#34;Input Tag for Key 1\u0026#34;)); GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.2\u0026#34;), FString(\u0026#34;Input Tag for Key 2\u0026#34;)); GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.3\u0026#34;), FString(\u0026#34;Input Tag for Key 3\u0026#34;)); GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.4\u0026#34;), FString(\u0026#34;Input Tag for Key 4\u0026#34;)); //////////////////// GameplayTags.Damage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Damage\u0026#34;), FString(\u0026#34;Damage\u0026#34;)); GameplayTags.Effect_HitReact = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Effect.HitReact\u0026#34;), FString(\u0026#34;Tag granted when Hit Reacting\u0026#34;)); } AuraAttributeSet.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Strength, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Strength; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Strength); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Intelligence, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Intelligence; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Intelligence); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Resilience, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Resilience; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Resilience); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Vigor, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Vigor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Vigor); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxHealth, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxHealth; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxHealth); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxMana, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxMana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxMana); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Armor, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData Armor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Armor); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ArmorPenetration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ArmorPenetration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ArmorPenetration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_BlockChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData BlockChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,BlockChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitDamage, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitDamage); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitResistance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitResistance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitResistance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_HealthRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData HealthRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,HealthRegeneration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ManaRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ManaRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ManaRegeneration); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Health, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Mana, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Mana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Mana); ///////////////// UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); //////////////////// UFUNCTION() void OnRep_Strength(const FGameplayAttributeData\u0026amp; OldStrength)const; UFUNCTION() void OnRep_Intelligence(const FGameplayAttributeData\u0026amp; OldIntelligence)const; UFUNCTION() void OnRep_Resilience(const FGameplayAttributeData\u0026amp; OldResilience)const; UFUNCTION()\tvoid OnRep_Vigor(const FGameplayAttributeData\u0026amp; OldVigor)const; UFUNCTION()\tvoid OnRep_MaxHealth(const FGameplayAttributeData\u0026amp; OldMaxHealth)const; UFUNCTION()\tvoid OnRep_MaxMana(const FGameplayAttributeData\u0026amp; OldMaxMana)const; UFUNCTION()\tvoid OnRep_Armor(const FGameplayAttributeData\u0026amp; OldArmor)const; UFUNCTION()\tvoid OnRep_ArmorPenetration(const FGameplayAttributeData\u0026amp; OldArmorPenetration)const; UFUNCTION()\tvoid OnRep_BlockChance(const FGameplayAttributeData\u0026amp; OldBlockChance)const; UFUNCTION()\tvoid OnRep_CriticalHitChance(const FGameplayAttributeData\u0026amp; OldCriticalHitChance)const; UFUNCTION()\tvoid OnRep_CriticalHitDamage(const FGameplayAttributeData\u0026amp; OldCriticalHitDamage)const; UFUNCTION()\tvoid OnRep_CriticalHitResistance(const FGameplayAttributeData\u0026amp; OldCriticalHitResistance)const; UFUNCTION()\tvoid OnRep_HealthRegeneration(const FGameplayAttributeData\u0026amp; OldHealthRegeneration)const; UFUNCTION()\tvoid OnRep_ManaRegeneration(const FGameplayAttributeData\u0026amp; OldManaRegeneration)const; UFUNCTION()\tvoid OnRep_Health(const FGameplayAttributeData\u0026amp; OldHealth)const; UFUNCTION()\tvoid OnRep_Mana(const FGameplayAttributeData\u0026amp; OldMana)const; AuraAttributeSet.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 UAuraAttributeSet::UAuraAttributeSet() { const FAuraGameplayTags\u0026amp; GameplayTags = FAuraGameplayTags::Get(); TagToAttribute.Add(GameplayTags.Attribute_Primary_Strength,\tGetStrengthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Intelligence,\tGetIntelligenceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Resilience,\tGetResilienceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Vigor,\tGetVigorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_Armor,\tGetArmorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ArmorPenetration,\tGetArmorPenetrationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_BlockChance,\tGetBlockChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitChance,\tGetCriticalHitChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitDamage,\tGetCriticalHitDamageAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitResistance,\tGetCriticalHitResistanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_HealthRegeneration,\tGetHealthRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ManaRegeneration,\tGetManaRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxHealth,\tGetMaxHealthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxMana,\tGetMaxManaAttribute); } AuraAttributeSet.cpp 这是一个宏，那些属性的网络同步函数写起来真逆天，用这个宏去写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define ATTRIBUTE_REP(Name)\\ void UAuraAttributeSet::OnRep_##Name(const FGameplayAttributeData\u0026amp; Old##Name)const\\ {\\ GAMEPLAYATTRIBUTE_REPNOTIFY(UAuraAttributeSet,Name,Old##Name);\\ }; #define ATTRIBUTE_NOTIFY(Name)\\ DOREPLIFETIME_CONDITION_NOTIFY(UAuraAttributeSet,Name,COND_None,REPNOTIFY_Always); #pragma region Net ATTRIBUTE_REP(Health)\tATTRIBUTE_REP(Mana) ATTRIBUTE_REP(Strength)\tATTRIBUTE_REP(Intelligence)\tATTRIBUTE_REP(Resilience)\tATTRIBUTE_REP(Vigor) ATTRIBUTE_REP(Armor)\tATTRIBUTE_REP(ArmorPenetration)\tATTRIBUTE_REP(BlockChance)\tATTRIBUTE_REP(CriticalHitChance) ATTRIBUTE_REP(MaxHealth)\tATTRIBUTE_REP(MaxMana)\tATTRIBUTE_REP(CriticalHitDamage)ATTRIBUTE_REP(CriticalHitResistance) ATTRIBUTE_REP(HealthRegeneration)\tATTRIBUTE_REP(ManaRegeneration) void UAuraAttributeSet::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); ATTRIBUTE_NOTIFY(Health)\tATTRIBUTE_NOTIFY(Mana) ATTRIBUTE_NOTIFY(Strength)\tATTRIBUTE_NOTIFY(Intelligence)\tATTRIBUTE_NOTIFY(Resilience)\tATTRIBUTE_NOTIFY(Vigor) ATTRIBUTE_NOTIFY(Armor)\tATTRIBUTE_NOTIFY(ArmorPenetration)\tATTRIBUTE_NOTIFY(BlockChance)\tATTRIBUTE_NOTIFY(CriticalHitChance) ATTRIBUTE_NOTIFY(MaxHealth)\tATTRIBUTE_NOTIFY(MaxMana)\tATTRIBUTE_NOTIFY(CriticalHitDamage)\tATTRIBUTE_NOTIFY(CriticalHitResistance) ATTRIBUTE_NOTIFY(HealthRegeneration)\tATTRIBUTE_NOTIFY(ManaRegeneration) } #pragma endregion ","date":"2025-01-10T11:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88/","title":"GAS A - 技能系统总览"},{"content":"示例 点击按钮自动创建GE，并且避免重名\n修改LOGO图标，要手动把svg文件放到Shader文件夹里(示例代码是这样写的)\n可以修改代码 放到别的位置去，\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #define RootToContentDir Style-\u0026gt;RootToContentDir void FElemental_EditorModule::StartupModule() { const FString ProjectShaderDir = FPaths::Combine(FPaths::ProjectDir(), TEXT(\u0026#34;Shaders\u0026#34;)); //[const ISlateStyle*] -\u0026gt; [ISlateStyle*] -\u0026gt; [FSlateStyleSet*] FSlateStyleSet* Style = static_cast\u0026lt;FSlateStyleSet*\u0026gt;(const_cast\u0026lt;ISlateStyle*\u0026gt;(\u0026amp;FAppStyle::Get())); Style-\u0026gt;SetContentRoot(ProjectShaderDir); Style-\u0026gt;Set(\u0026#34;AppIcon\u0026#34;, new IMAGE_BRUSH_SVG(\u0026#34;ELIcon\u0026#34;, FVector2f(50.f, 50.f), FStyleColors::White)); RegisterMenus(); } static void CreateBP() { UEditorAssetSubsystem* EditorAssetSubsystem = GEditor-\u0026gt;GetEditorSubsystem\u0026lt;UEditorAssetSubsystem\u0026gt;(); IContentBrowserSingleton\u0026amp; CB = IContentBrowserSingleton::Get(); const auto Path = CB.GetCurrentPath(); int32 RandName = 0; FString BaseName; FString PackageName; do { RandName++; BaseName = FString::Printf(TEXT(\u0026#34;MyGameplayEffect%d\u0026#34;), RandName); PackageName = FPaths::Combine(Path.GetInternalPathString(), BaseName); } while (EditorAssetSubsystem-\u0026gt;DoesAssetExist(PackageName)); UPackage * Package = CreatePackage(*PackageName); UBlueprint* Blueprint = FKismetEditorUtilities::CreateBlueprint(UGameplayEffect::StaticClass(), Package, *BaseName, BPTYPE_Normal, UBlueprint::StaticClass(), UBlueprintGeneratedClass::StaticClass()); if (Blueprint) { FAssetRegistryModule::AssetCreated(Blueprint); Package-\u0026gt;MarkPackageDirty(); } } void FElemental_EditorModule::RegisterMenus() { auto Visible = [](){return GEditor-\u0026gt;PlayWorld == nullptr;}; UToolMenu* Menu = UToolMenus::Get()-\u0026gt;ExtendMenu(\u0026#34;LevelEditor.LevelEditorToolBar.PlayToolBar\u0026#34;); FToolMenuSection\u0026amp; Section = Menu-\u0026gt;AddSection(\u0026#34;PlayGameExtensions\u0026#34;, TAttribute\u0026lt;FText\u0026gt;(), FToolMenuInsert(\u0026#34;Play\u0026#34;, EToolMenuInsertType::After)); const FUIAction UIAction = FUIAction(FExecuteAction::CreateStatic(CreateBP), FCanExecuteAction::CreateLambda(Visible),FIsActionChecked(),FIsActionButtonVisible::CreateLambda(Visible)); const FToolMenuEntry CommonMapEntry = FToolMenuEntry::InitToolBarButton( \u0026#34;CreateGE\u0026#34;,UIAction,FText::FromString(\u0026#34;GE\u0026#34;),FText::FromString(\u0026#34;Create GameplayEffect\u0026#34;), FSlateIcon(FAppStyle::GetAppStyleSetName(), \u0026#34;Icons.Blueprint\u0026#34;)); Section.AddEntry(CommonMapEntry); } Build.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PublicDependencyModuleNames.AddRange( new string[] { \u0026#34;Core\u0026#34;,\u0026#34;AssetDefinition\u0026#34;, \u0026#34;GameplayAbilities\u0026#34;, \u0026#34;EngineAssetDefinitions\u0026#34;,\u0026#34;ToolMenus\u0026#34;,\u0026#34;ContentBrowser\u0026#34;,\u0026#34;ContentBrowserData\u0026#34; } ); PrivateDependencyModuleNames.AddRange( new string[] { \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;Slate\u0026#34;, \u0026#34;SlateCore\u0026#34; } ","date":"2025-01-09T21:38:46+08:00","permalink":"http://localhost:1313/p/%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91-%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%93%9D%E5%9B%BE-%E4%BF%AE%E6%94%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%9B%BE%E6%A0%87/","title":"编辑器开发 - 创建指定类型蓝图 - 修改编辑器图标"},{"content":"https://ue5wiki.com/\nUObject 反射系统 反射文档 反射知识库\nC++ 编译为 CPU 机器码，而 CPU 并不了解类或变量的概念。类只是为编译器提供如何设置 CPU 代码的信息，变量最终只转化为内存地址，因此CPU并不知道类的存在，这些信息是由软件自身来跟踪的。在虚幻引擎4（UE4）中，这是通过反射系统实现的，所以你的代码可以“反映”其自身。\nUE4 拥有一个特别的工具叫做 UnrealHeaderTool，它收集你创建的那些宏，比如 UPROPERTY、UCLASS、USTRUCT，并生成额外的 C++ 代码，这些代码将类、函数和属性注册到反射系统中，这样引擎就能识别这些元素并跟踪它们。反射系统注册表中的每个元素都有一个对应的 UField 对象被创建，用来表示代码中的事物并存储有关它的信息。每个UObject类都有一个UClass对象，你可以通过调用GetClass()或StaticClass()来获取这个对象\nCDO 它的主要功能是存储类对象的默认状态并保存默认变量状态。在 C++ 中创建的每个标有 UCLASS() 的 UObject 类都会注册到反射系统。\n在C++创建一个Actor \u0026ndash;\u0026gt; AXActor，int32 K = 1 , 但是在构造函数里重新赋值 K=2，那么它的默认对象(CDO)的值就是2，\n1 2 3 4 UClass* XActor = AXActorStaticClass(); Uobject* XAObj = XActor-\u0026gt;GetDefaultObject(); AXACtor* CDO = Cast\u0026lt;AXActor\u0026gt;(XAObj); //CDO-\u0026gt;K 得到的值是2 1 StaticClass\u0026lt;UObject\u0026gt;` 或者 `UObject::StaticClass() 当UClass的 类默认对象（CDO）更改，引擎将尝试在加载类的所有实例时对这些实例应用这些更改。对于给定Object实例，如果更新的变量值与旧CDO中的值相匹配，则将更新为它在新CDO中保存的值。如果变量包含任何其他值，系统会假设这个值是故意设置的，这些更改将会被保留。\n例如，假设你在一个关卡中放置了多个 AEnemy Object并保存，然后将 AEnemy 构造函数中的默认Health值设置为100。再假设将Enemy_3的Health值设置为500，因为它们特别难对付。现在，假设你改变注意了，将Health的默认值增加到150。下次加载关卡时，虚幻意识到你更改了CDO，并将使用旧默认Health值（100）的所有AEnemy实例更新为使用Health值150。Enemy_3的Health将保持在500，因为它不使用旧的默认值。\n因为构造函数是在引擎和对象自身的初始化早期阶段调用的，你不应该在其中执行任何游戏逻辑代码，否则很可能会导致崩溃。你应该使用类中的其他事件，如PostInitProperties（在蓝图系统对对象所做的更改应用后调用）、PostInitComponents（在Actor中的组件被初始化后调用）或BeginPlay（当Actor被完全初始化时）。请注意，前两个事件也在你将Actor放置在关卡编辑器时被调用。\n总结来说，CDO的主要作用是在引擎中保持类的默认状态，使得即使是在C++中，也可以方便地获取到类的默认属性和行为。由于CDO是在引擎初始化期间创建的，因此在这个时候调用构造函数可能会导致不稳定的行为，所以开发者应该避免在构造函数中进行依赖于其他尚未初始化对象的操作。\n反射宏 其实 GENERATED_BODY 与GENERATED_UCLASS_BODY的区别在于：GENERATED_BODY声明并定义 了一个接收 const FObjectInitializer\u0026amp; 的构造函数，GENERATED_UCLASS_BODY只声明 了该构造函数，需要用户自己提供一个定义。\n乱七八糟 Log 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;, Package-\u0026gt;GetName(), ErrorCode); 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;,(\u0026#34;Name\u0026#34;, Package-\u0026gt;GetName()), (\u0026#34;Error\u0026#34;, ErrorCode),(\u0026#34;Flags\u0026#34;, LoadFlags)); 1 GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT(\u0026#34;This is an Example on-screen debug message.\u0026#34;)); 1 2 3 std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Hello, {}!\\n\u0026#34;, \u0026#34;World\u0026#34;); // std::format printf(\u0026#34;Hello, %s!\\n\u0026#34;, \u0026#34;World\u0026#34;); // printf std::cout \u0026lt;\u0026lt; \u0026#34;Hello, \u0026#34; \u0026lt;\u0026lt; \u0026#34;World\u0026#34; \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; // iostreams 私有变量访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; struct TAccessPrivate { static inline typename T::Type Value; }; template \u0026lt;class T,typename T::Type Value\u0026gt; struct TAccessPrivateStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivate\u0026lt;T\u0026gt;::Value = Value; } }; static inline FAccessPrivateStub AccessPrivateStub; }; //---------------------// struct AccessPalette { typedef TSharedPtr\u0026lt;class SMaterialPalette\u0026gt; (FMaterialEditor::*Type); }; template struct TAccessPrivateStub\u0026lt;AccessPalette,\u0026amp;FMaterialEditor::Palette\u0026gt;; //--------------------// TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 代码的目标\n这段代码的目标是访问一个类的私有成员变量（例如 FMaterialEditor::Palette），而不使用 friend 声明。它通过模板和静态初始化的技巧来实现这一点。\n代码结构\n代码分为以下几个部分：\nTAccessPrivate 模板：用于存储私有成员的指针。 TAccessPrivateStub 模板：用于在静态初始化时设置私有成员的指针。 AccessPalette 结构体：定义了一个类型别名，用于描述私有成员的类型。 模板特化：将 TAccessPrivateStub 特化为 AccessPalette 和 FMaterialEditor::Palette。 访问私有成员：通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 访问私有成员。 详细分析\n1. TAccessPrivate 模板\n1 2 3 4 5 template \u0026lt;class T\u0026gt; struct TAccessPrivate { static inline typename T::Type Value; }; 这是一个模板类，T 是一个类型参数。 T::Type 是一个嵌套类型别名，需要在特化时定义。 Value 是一个静态成员变量，类型是 T::Type，用于存储私有成员的指针。 作用：\nTAccessPrivate 的作用是提供一个全局的存储位置，用于保存私有成员的指针。 2. TAccessPrivateStub 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;class T, typename T::Type Value\u0026gt; struct TAccessPrivateStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivate\u0026lt;T\u0026gt;::Value = Value; } }; static inline FAccessPrivateStub AccessPrivateStub; }; 这是一个模板类，接受两个参数： T：一个类型，需要定义 T::Type。 Value：一个 T::Type 类型的值（通常是私有成员的指针）。 在 TAccessPrivateStub 内部，定义了一个嵌套类 FAccessPrivateStub，其构造函数将 Value 赋值给 TAccessPrivate\u0026lt;T\u0026gt;::Value。 AccessPrivateStub 是一个静态成员变量，类型是 FAccessPrivateStub。 作用：\nTAccessPrivateStub 的作用是在静态初始化时，通过 FAccessPrivateStub 的构造函数将私有成员的指针（Value）赋值给 TAccessPrivate\u0026lt;T\u0026gt;::Value。 由于 AccessPrivateStub 是静态的，它的构造函数会在程序启动时自动调用，从而完成赋值。 3. AccessPalette 结构体\n1 2 3 4 struct AccessPalette { typedef TSharedPtr\u0026lt;class SMaterialPalette\u0026gt; (FMaterialEditor::*Type); }; 这是一个结构体，定义了一个嵌套类型别名 Type。 Type 是一个指向 FMaterialEditor 成员函数的指针类型，返回值为 TSharedPtr\u0026lt;class SMaterialPalette\u0026gt;。 作用：\nAccessPalette 的作用是描述私有成员的类型。在这里，Type 表示 FMaterialEditor::Palette 的类型。 4. 模板特化\n1 template struct TAccessPrivateStub\u0026lt;AccessPalette, \u0026amp;FMaterialEditor::Palette\u0026gt;; 这里对 TAccessPrivateStub 进行了特化： T 被特化为 AccessPalette。 Value 被特化为 \u0026amp;FMaterialEditor::Palette（即私有成员的指针）。 由于 TAccessPrivateStub 的静态成员 AccessPrivateStub 会在程序启动时初始化，其构造函数会将 \u0026amp;FMaterialEditor::Palette 赋值给 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 作用：\n通过特化，TAccessPrivateStub 的静态初始化将私有成员的指针存储到 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 中。 5. 访问私有成员\n1 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value，可以访问到 FMaterialEditor::Palette，即使它是私有的。 这是因为 TAccessPrivateStub 的静态初始化已经将 \u0026amp;FMaterialEditor::Palette 赋值给了 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 为什么可以访问私有成员？\n关键点 1：静态初始化\nTAccessPrivateStub 的静态成员 AccessPrivateStub 会在程序启动时初始化。 在初始化时，FAccessPrivateStub 的构造函数会将 \u0026amp;FMaterialEditor::Palette 赋值给 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 静态初始化发生在 main 函数执行之前，此时编译器不会检查私有成员的访问权限。 关键点 2：绕过访问控制\n虽然 FMaterialEditor::Palette 是私有的，但 TAccessPrivateStub 的静态初始化在程序启动时完成了对私有成员指针的存储。 之后，通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 可以间接访问私有成员。 关键点 3：模板的特化\n模板特化允许在编译时为特定的类型和值生成代码。 在这里，特化将 AccessPalette 和 \u0026amp;FMaterialEditor::Palette 绑定在一起，使得 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 存储了私有成员的指针。 总结\n静态初始化：通过 TAccessPrivateStub 的静态成员，在程序启动时将私有成员的指针存储到 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 中。 模板特化：通过特化将 AccessPalette 和 \u0026amp;FMaterialEditor::Palette 绑定在一起。 间接访问：通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 访问私有成员。 这种方法虽然巧妙，但违背了 C++ 的封装原则，通常不建议在实际项目中使用。它依赖于静态初始化和模板特化的特性，绕过了访问控制机制。\n私有函数访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 目标类，包含私有成员函数 class MyClass { private: void VoidFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Private function called!\u0026#34; \u0026lt;\u0026lt; std::endl; } int IntVarFunc(int a) { cout \u0026lt;\u0026lt; \u0026#34;func: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 55; } }; // 模板类，用于存储私有成员函数的指针 template \u0026lt;typename T, typename FuncPtr\u0026gt; struct TAccessPrivateFunction { static inline FuncPtr Value; // 存储私有成员函数的指针 }; // 模板类，用于在静态初始化时设置私有成员函数的指针 template \u0026lt;typename T, typename FuncPtr, FuncPtr Value\u0026gt; struct TAccessPrivateFunctionStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivateFunction\u0026lt;T, FuncPtr\u0026gt;::Value = Value; // 在静态初始化时设置指针 } }; static inline FAccessPrivateStub AccessPrivateStub; // 静态成员，触发构造函数 }; // 定义私有成员函数的类型 using CallVoidFunc = void (MyClass::*)(); // 特化模板，将私有成员函数的指针存储到 TAccessPrivateFunction 中 template struct TAccessPrivateFunctionStub\u0026lt;MyClass, CallVoidFunc, \u0026amp;MyClass::VoidFunc\u0026gt;; void VoidFuncTemplate() { MyClass obj; // 获取私有成员函数的指针 auto pFunc = TAccessPrivateFunction\u0026lt;MyClass, CallVoidFunc\u0026gt;::Value; // 调用私有成员函数 (obj.*pFunc)(); } // 定义私有成员函数的类型 using CallIntVarFunc = int (MyClass::*)(int); // 特化模板，将私有成员函数的指针存储到 TAccessPrivateFunction 中 template struct TAccessPrivateFunctionStub\u0026lt;MyClass, CallIntVarFunc, \u0026amp;MyClass::IntVarFunc\u0026gt;; void IntVarFuncTemplate() { MyClass obj; // 获取私有成员函数的指针 auto pFunc = TAccessPrivateFunction\u0026lt;MyClass, CallIntVarFunc\u0026gt;::Value; // 调用私有成员函数，并传递参数 int result = (obj.*pFunc)(10); // 调用 PrivateFunction(10) std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } int main() { VoidFuncTemplate(); IntVarFuncTemplate(); return 0; } ","date":"2000-01-20T20:37:57+08:00","permalink":"http://localhost:1313/p/u-/","title":"U++"},{"content":"简介 设计模式是软件工程中一系列被广泛认可的解决特定问题的最佳实践。它们为常见问题提供了模板或指导方针，帮助开发者创建更加灵活、可维护和可复用的代码。C++作为一种多范式编程语言，支持面向对象和泛型编程等特性，因此非常适合实现各种设计模式。\n☆☆在C++中，绝大部分的模式 最终都是通过 指针指向一个多态对象 表达灵活性。☆☆对于C++特供版本来说，很多设计模式都是通过 继承抽象类 使用多态来实现，但是有些情况 使用函数指针会更好。例如观察者模式的最后一个例子 使用了函数指针，避免创建类。使用模板编程，将运行期的开销 提前到编译期，也是一种C++特供方法。\n文中的所有代码都不是伪代码，全都可以运行。有些设计模式并不常用 甚至是过时的。\n主要的设计模式分类\n创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性。\n工厂方法、抽象工厂、生成器、原型、单例\n结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n适配器、桥接、组合、装饰、外观、享元、代理\n行为模式负责对象间的高效沟通和职责委派。\n责任链、命令、迭代器、 中介者、备忘录、观察者、 状态、策略、模板方法、访问者\n设计模式中的抽象思维\n耦合：两个模块相互依赖，修改其中一个模块，那么另外一个也要修改。模块之间相互影响的关系叫做两个模块之间存在耦合关系。\n解耦合：通过修改程序代码，切换两个模块之间的依赖关系，对任意一个模块的修改，不会影响到另外一个模块，就叫做两个模块之间解耦合。\n抽象思维强调对象的本质属性，主要应用于一些软件设计中的解耦合过程。\n软件开发中需求变化频繁的，开发人员要尝试寻找变化点，把 变化部分 和 稳定部分 分离开来，在变化的地方应用设计模式。\n对于某一项任务，有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或由于固有原因无法和任务的整体结构同时实现，(出现 一个早一个晚 的关系)， 如何在确定稳定操作的前提下，灵活应对各个子步骤的变化或晚期实现需求？即 稳定中有变化\n面向对象设计原则 代码与技巧不重要，要在这个学习的过程中 建立抽象思维模型\n封装，隐藏内部实现\n继承，复用现有代码\n多态，改写对象行为\n解决复杂性：1.分解，大问题切分成小问题，复杂问题转为多个简单问题2.抽象，使用通用的技术，忽略事物非本质的细节，处理理想的对象模型.\n变化是复用的天敌，面向对象的优势在于抵御变化.\n依赖倒置原则 (DIP)\n高层模块(稳定) 不应该依赖于 低层模块(变化)，二者应该依赖于 抽象(稳定)抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape类有Draw函数 用来画东西，画家类可以使用Shape类画出各种形状，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Shape { public: virtual void Draw() = 0; } class Sphere : public Shape { public: virtual void Draw() override { //画一个圆形.... } } class Box : public Shape { .... } class Painter { public: TArray\u0026lt;Shape*\u0026gt; Shapes; void DrawSomething() { for(auto Shape : Shapes) { Shape-\u0026gt;Draw(); } } } int main() { Shape* SphereDrawer = new Sphere(); Shape* BoxDrawer = new Box(); Painter Painter; Painter.Shapes.add(SphereDrawer,BoxDrawer); // 开始画 Painter.DrawSomething(); //.... } TArray是一个数组，一行add可以添加多个元素。我不想用std::vector 不然要写两行push_back.\n当Sphere的Draw函数需要变化时，例如 添加或者删掉一点东西，或是因为其它原因，函数需要修改，此时Painter并没有被影响到，它的代码不会发生变动，只需要关注Sphere::Draw的修改即可.\n如果要新增一个三角形Triangle，只要继承自Shape类 重写Draw函数就好了，把Triangle传给Painter，就可以调用Draw来画一个三角形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Triangle : public Shape { public: virtual void Draw() override { //画一个三角形.... } } int main() { Shape* TriangleDrawer = new Triangle(); Painter Painter; Painter.Shapes.add(TriangleDrawer); Painter.DrawSomething(); } 新增了一个Triangle类，Painter类并不知道这些，也不需要知道，它只调用抽象类的虚函数就好了。\n高层模块(稳定) 不应该依赖于 底层模块(变化)\nPainter可看做是 高层模块，应该稳定，不依赖于 低层模块，Painter没有因为Sphere的变化而变化.\n抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape作为 抽象(稳定) 层，它的Draw没有依赖于具体的实现细节，使用子类来实现Draw.\n最终隔离变化，在Painter、Shape、Sphere中，变化的部分只有Sphere一个.\n通过这个画画的例子可以理解这句话了 \u0026mdash;\u0026gt; 现代软件设计的特征是“需求的频繁变化”，设计模式的要点是 “寻找变化点，在变化点处应用设计模式”，何时何地使用设计模式，比理解设计模式结构本身更重要.\n开放封闭原则 (OCP)\n对扩展开放，对更改封闭类模块应该是可扩展的，但是不可修改.\n单一职责原则(SRP)\n一个类应该仅有一个变化的原因.变化的方向隐含着类的责任.\nLiskov替换原则(LSP)\n子类必须能够替换它的基类（IS-A)\n继承表达类型抽象。\n接口隔离原则(ISP)\n不应该强迫客户程序依赖它们不用的方法\n接口应该小而完备\n优先使用对象组合，而不是类继承\n继承通常为“白箱复用”，对象组合通常为“黑箱复用”继承在某种程度上破坏了封装性，子类父类耦合度高对象组合则只要求被组合的对象具有良好定义的接口，耦合度低.\n封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响.\n针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某个接口\n客户程序无需知道对象的具体类型，只需要知道对象所具有的接口减少系统中各部分的依赖关系.\n产业强盛的标志 — 接口标准化\n雕版印刷：雕版印刷是在一定厚度的平滑的木板上，粘贴上抄写工整的书稿，薄而近乎透明的稿纸正面和木板相贴，字就成了反体，刻工人用刻刀把版面没有字迹的部分削去，印刷的时候，在凸起的字体上涂上墨汁，然后把纸覆在它的上面，轻轻拂拭纸背，字迹就留在纸上了。\n雕版印刷一版能印几百部甚至几千部书，但是制版很慢，而且有错字不容易更正。\n活字印刷：活字印刷术是一种印刷方法，使用可以移动的木刻字、金属或胶泥字块，用来取代传统的抄写，或是无法重复使用的雕版印刷。活字印刷的方法是先制成单字的阳文反文字模，然后按照稿件把单字挑选出来，排列在字盘内，涂墨印刷，印完后再将字模拆出，留待下次排印时再次使用。\n只印二三本，活字印刷并不比雕版印刷快。如果印成百上千份，工作效率就极其可观了，不仅能够节约大量的人力物力，而且可以大大提高印刷的速度和质量。\n模板方法模式 行为型模式\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n在固定步骤确定的情况下，通过多态机制在多个子类中对每个步骤的细节进行差异化实现。\n你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n下面的代码 基类里的JN_Burn函数是稳定的，执行了一套固定的流程，但是其中的某些步骤可以变化， 可以或必须被子类重写，才能完成整个流程. 总之就是 完形填空\n说白了就是重写虚函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 //父类 class Fighter { public: Fighter(int life, int magic, int attack) :m_life(life), m_magic(magic), m_attack(attack) {} virtual ~Fighter() {} //做父类时析构函数应该为虚函数 //对主角自身会产生影响，对敌人会产生影响。 //分析：对敌人产生影响，有函数effect_enemy。对主角自身产生影响，有函数effect_self。播放技能play_effect函数。 void JN_Burn() //技能“燃烧”,模板方法 { if (canUseJN() == false) //如果不能使用该技能，则直接返回 return; effect_enemy(); //对敌人产生的影响 effect_self(); //对主角自身产生的影响 play_effect(); //播放技能“燃烧”的技能特效 } private: virtual void effect_enemy() {} //函数体为空，表示啥也不做，如果要求必须在子类中重新实现该虚函数，则可以将该函数写成纯虚函数。 virtual void effect_self() {} void play_effect() { cout \u0026lt;\u0026lt; \u0026#34;播放 \\\u0026#34;燃烧\\\u0026#34; 特效\u0026#34; \u0026lt;\u0026lt; endl; //所有主角播放的技能特效都相同，因此不用写成一个虚函数并在子类中实现技能特效的播放。 } virtual bool canUseJN() = 0; //判断是否能使用技能“燃烧”，这是个纯虚函数声明，子类中必须重新实现canUseJN。 protected: //可能被子类访问，所以用protected修饰 //角色属性 int m_life; //生命值 int m_magic; //魔法 int m_attack; //攻击力 }; class F_Warrior :public Fighter { public: F_Warrior(int life, int magic, int attack) :Fighter(life, magic, attack) {} private: //对敌人产生的影响 virtual void effect_enemy() { cout \u0026lt;\u0026lt; \u0026#34;战士主角_让所有敌人每人失去500点生命，相关逻辑代码这里略......\u0026#34; \u0026lt;\u0026lt; endl; } //对主角自身产生的影响 virtual void effect_self() { cout \u0026lt;\u0026lt; \u0026#34;战士主角_自身失去300点生命值\u0026#34; \u0026lt;\u0026lt; endl; m_life -= 300; } virtual bool canUseJN() { if (m_life \u0026lt; 300) //生命值不够300点，不能使用技能“燃烧” return false; return true; } }; //------------------------- //“法师”类，父类为Fighter class F_Mage :public Fighter { public: F_Mage(int life, int magic, int attack) :Fighter(life, magic, attack) {} private: //对敌人产生的影响 virtual void effect_enemy() { cout \u0026lt;\u0026lt; \u0026#34;法师主角_让所有敌人每人失去650点生命，相关逻辑代码这里略......\u0026#34; \u0026lt;\u0026lt; endl; } //对主角自身产生的影响 virtual void effect_self() { cout \u0026lt;\u0026lt; \u0026#34;法师主角_自身失去100点魔法值\u0026#34; \u0026lt;\u0026lt; endl; m_magic -= 100; } virtual bool canUseJN() { if (m_magic \u0026lt; 100) //魔法值不够100点，不能使用技能“燃烧” return false; return true; } }; 输出：\n1 2 3 4 5 6 战士主角_让所有敌人每人失去500点生命，相关逻辑代码这里略...... 战士主角_自身失去300点生命值 播放 \u0026#34;燃烧\u0026#34; 特效 法师主角_让所有敌人每人失去650点生命，相关逻辑代码这里略...... 法师主角_自身失去100点魔法值 播放 \u0026#34;燃烧\u0026#34; 特效 工厂模式 简单工厂模式\nif-else 完了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 抽象产品角色 class Vehicle { public: virtual void drive() const = 0; }; // 具体产品角色 class Car : public Vehicle { public: Car() { std::cout \u0026lt;\u0026lt; \u0026#34;Creating a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Bus : public Vehicle { public: Bus() { std::cout \u0026lt;\u0026lt; \u0026#34;Creating a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 工厂角色 class VehicleFactory { public: static Vehicle* createVehicle(const std::string\u0026amp; type) { if (type == \u0026#34;car\u0026#34;) { return new Car(); } else if (type == \u0026#34;bus\u0026#34;) { return new Bus(); } else { throw std::invalid_argument(\u0026#34;Unknown vehicle type\u0026#34;); } } }; int main() { Vehicle* vehicle = VehicleFactory::createVehicle(\u0026#34;car\u0026#34;); vehicle-\u0026gt;drive(); delete vehicle; return 0; } 特点\n简单工厂模式将创建逻辑集中在一个工厂类中，适合产品类较少且创建逻辑简单的场景。 缺点是扩展性较差，新增产品类时需要修改工厂类的代码。 工厂方法模式 一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; // 抽象产品角色 - Vehicle class Vehicle { public: // 纯虚函数，定义了所有具体产品的接口 virtual void drive() const = 0; // 虚析构函数，确保派生类正确释放资源 virtual ~Vehicle() = default; }; // 具体产品角色 - Car class Car : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体产品角色 - Bus class Bus : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 抽象工厂角色 - VehicleFactory class VehicleFactory { public: // 工厂方法，返回一个抽象产品类型的指针 virtual Vehicle* createVehicle() const = 0; virtual ~VehicleFactory() = default; }; // 具体工厂角色 - CarFactory class CarFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Car; // 返回具体产品对象 } }; // 具体工厂角色 - BusFactory class BusFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Bus; // 返回具体产品对象 } }; int main() { // 创建CarFactory实例 VehicleFactory* carFactory = new CarFactory; Vehicle* car = carFactory-\u0026gt;createVehicle(); car-\u0026gt;drive(); // 输出: Driving a car. // 创建BusFactory实例 VehicleFactory* busFactory = new BusFactory; Vehicle* bus = busFactory-\u0026gt;createVehicle(); bus-\u0026gt;drive(); // 输出: Driving a bus. return 0; } 先搞结论，费这么大劲在干神魔？\nmain函数里面 虽然实际上创建了car和bus两个类，但是在整个main的代码里面，没有出现car和bus的具体类只有两个抽象的Vehicle类，没有依赖到具体类，\n扩展性:\n工厂方法模式使得系统更容易扩展新的产品类型和相应的工厂类,如果需要添加一种新的交通工具（例如自行车 Bike），只需创建一个新的具体产品类 Bike 和一个新的具体工厂类 BikeFactory,现有代码不需要做任何修改。符合开闭原则（OCP），即对扩展开放，对修改封闭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Bike : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Riding a bike.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class BikeFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Bike; } }; 封装性:\n工厂方法模式通过封装对象的创建过程，将创建逻辑与使用逻辑分离，隐藏了对象创建的具体细节。\nVehicleFactory 抽象类定义了一个接口 createVehicle()，而具体的工厂类（如 CarFactory 和 BusFactory）实现了这个接口。客户端只需要调用 createVehicle() 方法即可获得一个 Vehicle 对象，无需关心具体的创建逻辑。\n遵循设计原则\n开闭原则（OCP）: 如前所述，系统可以通过添加新的产品和工厂类来扩展功能，而无需修改现有代码。 依赖倒置原则（DIP）: 客户端依赖于抽象接口（如 VehicleFactory 和 Vehicle），而不是具体的实现类。这使得系统的层次结构更加清晰，减少了模块间的依赖关系。 里氏替换原则（LSP）: 子类可以替代父类出现的地方而不影响程序的正确性。在我们的例子中，Car 和 Bus 可以替代 Vehicle 出现在任何需要 Vehicle 的地方。 new 还是 factory ?\n工厂方法模式\n优点：\n解耦：将对象的创建与使用分离，降低代码耦合度。 扩展性：新增产品类时，只需扩展工厂类，无需修改现有代码，符合开闭原则。 多态性：通过工厂方法返回基类指针或引用，支持运行时多态。 缺点：\n复杂性：增加了类的数量，代码结构更复杂。 性能开销：间接创建对象可能带来轻微性能损失。 new\n优点：\n简单直接：代码直观，易于理解。 性能：直接创建对象，无额外开销。 缺点：\n耦合度高：对象的创建与使用紧密耦合，修改时可能影响其他代码。 扩展性差：新增类时需要修改多处代码，违反开闭原则。 灵活性低：难以在运行时动态切换对象类型。 使用new创建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Product { public: virtual void use() = 0; }; class ConcreteProduct : public Product { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Product* Pro = new ConcreteProduct; // 用抽象类指针接收具体类对象 Pro-\u0026gt;use(); delete Pro; return 0; } 多态性：通过抽象类指针调用具体类的实现，实现了运行时多态。 直接依赖：main函数直接依赖具体类ConcreteProduct，需要显式地写出new ConcreteProduct。 耦合性：main函数与ConcreteProduct类耦合，如果将来需要替换为其他具体类，需要修改main函数。 使用工厂模式创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Product { public: virtual void use() = 0; }; class ConcreteProduct : public Product { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; endl; } }; class Factory { public: virtual Product* createProduct() = 0; }; class ConcreteFactory : public Factory { public: Product* createProduct() override { return new ConcreteProduct(); } }; int main() { Factory* factory = new ConcreteFactory(); // 创建具体工厂 Product* Pro = factory-\u0026gt;createProduct(); // 通过工厂创建对象 Pro-\u0026gt;use(); delete Pro; // 释放对象 delete factory; // 释放工厂 return 0; } 特点\n解耦：main函数只依赖抽象工厂和抽象产品，不依赖具体类。 扩展性：如果需要创建新的具体类，只需新增一个具体工厂和具体产品类，无需修改main函数。 灵活性：可以通过切换工厂来动态创建不同的具体对象。 区别对比\n特性 直接使用new创建对象 工厂方法模式 耦合性 main函数直接依赖具体类（ConcreteProduct） main函数只依赖抽象工厂和抽象产品，不依赖具体类 扩展性 修改具体类时需要修改main函数 新增具体类时只需扩展工厂，无需修改main函数 灵活性 无法动态切换具体类 可以通过切换工厂动态创建不同对象 代码复杂度 简单直接，代码量少 增加了工厂类，代码结构更复杂 运行时多态 支持（通过抽象类指针调用具体类方法） 支持（通过抽象类指针调用具体类方法） 总结\n如果代码规模较小，且不需要频繁扩展或修改具体类，直接使用new创建对象是更简单直接的选择。 如果需要解耦、扩展性和灵活性，工厂方法模式是更好的选择，尽管它会增加一些代码复杂性。 在示例中，虽然通过抽象类指针实现了多态，但仍然存在耦合性问题。如果未来需要替换ConcreteProduct为其他类，仍需修改main函数。而工厂方法模式可以避免这个问题。\n抽象工厂模式 一种创建型设计模式，它提供了一个接口用于创建一系列相关或依赖的对象，而无需指定它们的具体类。与工厂方法模式不同，抽象工厂模式关注的是产品族（一组相关的产品），而不是单一产品。\n假设正在开发一个跨平台的 UI 库，需要支持两种操作系统：Windows 和 macOS。每个操作系统有不同的按钮（Button）和文本框（TextBox）。需要通过抽象工厂模式来创建这些 UI 组件，确保客户端代码与具体平台解耦。\n产品抽象类 Button 和 TextBox。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 抽象产品：按钮 class Button { public: virtual void render() = 0; virtual ~Button() = default; }; // 抽象产品：文本框 class TextBox { public: virtual void render() = 0; virtual ~TextBox() = default; }; 定义具体产品类\n为每个平台实现具体的产品类。\nWindows\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Windows 按钮 class WindowsButton : public Button { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a button in Windows style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Windows 文本框 class WindowsTextBox : public TextBox { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a text box in Windows style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; mac\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // macOS 按钮 class MacOSButton : public Button { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a button in macOS style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // macOS 文本框 class MacOSTextBox : public TextBox { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a text box in macOS style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 定义抽象工厂类\n抽象工厂类定义了创建一组相关产品的方法。\n1 2 3 4 5 6 class GUIFactory { public: virtual Button* createButton() = 0; virtual TextBox* createTextBox() = 0; virtual ~GUIFactory() = default; }; Windows\n1 2 3 4 5 6 7 8 9 10 class WindowsFactory : public GUIFactory { public: Button* createButton() override { return new WindowsButton(); } TextBox* createTextBox() override { return new WindowsTextBox(); } }; mac\n1 2 3 4 5 6 7 8 9 10 class MacOSFactory : public GUIFactory { public: Button* createButton() override { return new MacOSButton(); } TextBox* createTextBox() override { return new MacOSTextBox(); } }; 客户端代码\n客户端代码通过抽象工厂创建一组相关的产品，而无需关心具体平台。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Application { private: GUIFactory* factory; Button* button; TextBox* textBox; public: Application(GUIFactory* factory) : factory(factory), button(nullptr), textBox(nullptr) {} void createUI() { button = factory-\u0026gt;createButton(); textBox = factory-\u0026gt;createTextBox(); } void renderUI() { if (button) button-\u0026gt;render(); if (textBox) textBox-\u0026gt;render(); } ~Application() { delete button; delete textBox; delete factory; } }; int main() { // 创建 Windows 风格的 UI GUIFactory* windowsFactory = new WindowsFactory(); Application windowsApp(windowsFactory); windowsApp.createUI(); windowsApp.renderUI(); // 创建 macOS 风格的 UI GUIFactory* macFactory = new MacOSFactory(); Application macApp(macFactory); macApp.createUI(); macApp.renderUI(); return 0; } 输出：\n1 2 3 4 Rendering a button in Windows style. Rendering a text box in Windows style. Rendering a button in macOS style. Rendering a text box in macOS style. 只有一个Application类，但是通过不同的工厂方法，可以填充出不同风格的Application.\n抽象产品类：\nButton 和 TextBox 是抽象基类，定义了 UI 组件的通用接口。 具体产品类：\nWindowsButton 和 WindowsTextBox 是 Windows 平台的具体实现。 MacOSButton 和 MacOSTextBox 是 macOS 平台的具体实现。 抽象工厂类：\nGUIFactory 定义了创建一组相关产品（按钮和文本框）的接口。 具体工厂类：\nWindowsFactory 和 MacOSFactory 分别实现了 Windows 和 macOS 平台的具体工厂。 客户端代码：\nApplication 类通过抽象工厂创建一组相关的 UI 组件，并调用它们的 render 方法。 客户端代码与具体平台解耦，只需切换工厂即可创建不同平台的 UI 组件。 优点\n解耦： 客户端代码只依赖抽象工厂和抽象产品，不依赖具体平台。 一致性： 确保创建的一组产品属于同一平台（如 Windows 或 macOS）。 扩展性： 新增平台时，只需添加新的具体工厂和具体产品类，无需修改现有代码。 缺点\n复杂性： 增加了类的数量，代码结构更复杂。 不易扩展新产品： 如果需要在抽象工厂中新增一个产品（如 Checkbox），需要修改所有具体工厂类。 适用场景\n需要创建一组相关或依赖的对象。 系统需要支持多个产品族（如多个平台、多个主题）。 客户端代码需要与具体产品的创建过程解耦。 原型模式 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n它允许通过复制现有对象来创建新对象，而不是通过构造函数 实例化类来创建。这种模式特别适用于创建复杂对象或当创建过程非常耗时、资源密集时。通过克隆（Clone）来创建对象，避免了直接依赖具体类。\n原型模式适用于以下场景：\n当对象的创建成本较高（例如需要复杂的初始化过程），而复制现有对象更高效时。 当系统需要动态地创建对象，且对象的类型在运行时才能确定时。 当需要避免使用new关键字直接创建对象，以减少耦合性。 假设正在开发一个图形编辑器，支持绘制多种形状（如圆形、矩形）。每种形状都是一个对象，且对象的创建成本较高（例如需要加载资源或初始化复杂状态）。可以使用原型模式，通过克隆现有对象来创建新对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 抽象原型类 class Shape { public: virtual ~Shape() = default; virtual Shape* clone() const = 0; // 克隆方法 virtual void draw() const = 0; // 绘制方法 }; class Circle : public Shape { private: int radius; public: Circle(int radius) : radius(radius) { std::cout \u0026lt;\u0026lt; \u0026#34;Circle构造 Radius:\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } // 显式定义拷贝构造函数 Circle(const Circle\u0026amp; other) : radius(other.radius) { std::cout \u0026lt;\u0026lt; \u0026#34;Circle克隆 Radius:\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } // 实现克隆方法 Shape* clone() const override { return new Circle(*this); // 使用拷贝构造函数克隆对象 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; class Rectangle : public Shape { private: int width, height; public: Rectangle(int width, int height) : width(width), height(height) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle构造 Width:\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; Height:\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } Rectangle(const Rectangle\u0026amp; other) : width(other.width), height(other.height) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle克隆 Width:\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; Height:\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } // 实现克隆方法 Shape* clone() const override { return new Rectangle(*this); // 使用拷贝构造函数克隆对象 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a rectangle with width \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; and height \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建原型对象 Shape* circlePrototype = new Circle(10); Shape* rectanglePrototype = new Rectangle(20, 30); // 克隆原型对象 Shape* circleClone = circlePrototype-\u0026gt;clone(); Shape* rectangleClone = rectanglePrototype-\u0026gt;clone(); // 使用克隆对象 circleClone-\u0026gt;draw(); rectangleClone-\u0026gt;draw(); return 0; } 优点\n高效创建对象： 当对象的创建成本较高时，通过克隆现有对象可以避免重复初始化。 动态创建对象： 可以在运行时动态地创建对象，而无需依赖具体类。 减少耦合性： 客户端代码只依赖抽象原型类，不依赖具体类。 缺点\n深拷贝问题： 如果对象包含指针或动态分配的资源，需要实现深拷贝，否则克隆对象会共享资源。 复杂性增加： 需要为每个类实现clone方法，增加了代码的复杂性。 扩展：深拷贝\n浅拷贝是指创建一个新的对象，并将原始对象中的成员变量的值复制到新对象中。如果成员变量是基本数据类型（如int, float, char等），则直接复制其值；如果成员变量是指针或引用，则仅复制指针或引用的地址，而不是所指向的对象。\n浅拷贝只复制了指针的地址，因此新对象和原对象共享同一块内存区域。如果两个对象共享同一块内存区域，在一个对象中修改这块内存的内容会影响另一个对象。此外，当其中一个对象被销毁时，可能会导致悬挂指针（dangling pointer）问题，因为另一个对象仍然持有已释放内存的指针。\n深拷贝是指创建一个新的对象，并且递归地复制所有成员变量，包括指针指向的对象。这意味着每个对象都有自己的独立副本，不会共享任何资源。\n深拷贝为每个对象分配独立的内存区域，确保每个对象都有自己的数据副本。由于每个对象都有自己的独立副本，因此在一个对象中修改数据不会影响其他对象，也不会出现悬挂指针的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ComplexShape : public Shape { private: int* data; // 动态分配的资源 public: ComplexShape(int value) { data = new int(value); } // 深拷贝构造函数 ComplexShape(const ComplexShape\u0026amp; other) { data = new int(*other.data); // 深拷贝 } // 实现克隆方法 std::unique_ptr\u0026lt;Shape\u0026gt; clone() const override { return std::make_unique\u0026lt;ComplexShape\u0026gt;(*this); // 使用深拷贝构造函数 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a complex shape with data \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } ~ComplexShape() { delete data; // 释放资源 } }; 特性 浅拷贝 深拷贝 基本数据类型 直接复制值 直接复制值 指针/引用类型 复制指针地址，共享同一块内存区域 分配新的内存区域，并复制指针指向的数据 资源管理 共享资源，可能导致悬挂指针问题 独立资源，安全可靠 性能 性能较高，只需复制指针地址 性能较低，需要分配新内存并复制数据 适用场景 对象没有复杂嵌套结构或不需要独立副本的情况 对象包含复杂嵌套结构或需要完全独立副本的情况 建造者模式 建造者模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n建造者模式适用于以下场景：\n当对象的创建过程非常复杂，包含多个步骤时。 当需要创建的对象有不同的表示，但构建过程相似时。 当希望将对象的构建过程与表示解耦时。 示例场景\n假设正在开发一个游戏，需要创建不同类型的角色（如英雄、怪物）。每个角色有多个属性（如名字、职业、武器、盔甲等），且这些属性的设置过程可能非常复杂。可以使用建造者模式来分离角色的构建过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; // 角色类（产品） class Character { public: Character() { std::cout \u0026lt;\u0026lt; \u0026#34;Character created\u0026#34; \u0026lt;\u0026lt; std::endl; } void setName(const std::string\u0026amp; name) { this-\u0026gt;name = name; } void setClass(const std::string\u0026amp; className) { this-\u0026gt;className = className; } void setWeapon(const std::string\u0026amp; weapon) { this-\u0026gt;weapon = weapon; } void setArmor(const std::string\u0026amp; armor) { this-\u0026gt;armor = armor; } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;-------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Class: \u0026#34; \u0026lt;\u0026lt; className \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Weapon: \u0026#34; \u0026lt;\u0026lt; weapon \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Armor: \u0026#34; \u0026lt;\u0026lt; armor \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;-------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::string name; std::string className; std::string weapon; std::string armor; }; // 抽象建造者 class CharacterBuilder { public: virtual ~CharacterBuilder() = default; virtual void buildName() = 0; virtual void buildClass() = 0; virtual void buildWeapon() = 0; virtual void buildArmor() = 0; virtual std::unique_ptr\u0026lt;Character\u0026gt; getResult() = 0; }; // 英雄建造者 class HeroBuilder : public CharacterBuilder { public: HeroBuilder() { character = std::make_unique\u0026lt;Character\u0026gt;(); // 使用智能指针 } void buildName() override { character-\u0026gt;setName(\u0026#34;Arthur\u0026#34;); } void buildClass() override { character-\u0026gt;setClass(\u0026#34;Knight\u0026#34;); } void buildWeapon() override { character-\u0026gt;setWeapon(\u0026#34;Sword\u0026#34;); } void buildArmor() override { character-\u0026gt;setArmor(\u0026#34;Plate Armor\u0026#34;); } std::unique_ptr\u0026lt;Character\u0026gt; getResult() override { return std::move(character); // 转移所有权 } private: std::unique_ptr\u0026lt;Character\u0026gt; character; }; // 怪物建造者 class MonsterBuilder : public CharacterBuilder { public: MonsterBuilder() { character = std::make_unique\u0026lt;Character\u0026gt;(); // 使用智能指针 } void buildName() override { character-\u0026gt;setName(\u0026#34;Goblin\u0026#34;); } void buildClass() override { character-\u0026gt;setClass(\u0026#34;Enemy\u0026#34;); } void buildWeapon() override { character-\u0026gt;setWeapon(\u0026#34;Claws\u0026#34;); } void buildArmor() override { character-\u0026gt;setArmor(\u0026#34;Leather Armor\u0026#34;); } std::unique_ptr\u0026lt;Character\u0026gt; getResult() override { return std::move(character); // 转移所有权 } private: std::unique_ptr\u0026lt;Character\u0026gt; character; }; // 指挥者 class CharacterDirector { public: void setBuilder(CharacterBuilder* builder) { this-\u0026gt;builder = builder; } std::unique_ptr\u0026lt;Character\u0026gt; construct() { builder-\u0026gt;buildName(); builder-\u0026gt;buildClass(); builder-\u0026gt;buildWeapon(); builder-\u0026gt;buildArmor(); return builder-\u0026gt;getResult(); } private: CharacterBuilder* builder; }; int main() { // 创建建造者和指挥者 HeroBuilder heroBuilder; MonsterBuilder monsterBuilder; CharacterDirector director; // 构建英雄角色 director.setBuilder(\u0026amp;heroBuilder); auto hero = director.construct(); hero-\u0026gt;display(); // 构建怪物角色 director.setBuilder(\u0026amp;monsterBuilder); auto monster = director.construct(); monster-\u0026gt;display(); return 0; } 优点\n分离构建过程与表示： 将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。 更好的控制构建过程： 指挥者类可以精确控制构建过程。 代码复用： 可以复用相同的构建过程来创建不同的产品。 缺点\n增加代码复杂性： 需要定义多个类（建造者、指挥者等），增加了代码的复杂性。 适用于复杂对象： 如果对象非常简单，使用建造者模式可能会显得过度设计。 策略模式 策略是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。\n方便应对多重switch case 或 if else，随时间推移，switch 或 if中的代码需要扩展，写的越来越多，代码很长.\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n计算税，每个国家的税不同，计算方法不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 enum TaxBase { CN_Tax; US_Tax; DE_Tax }; class SalesOrder { TexBase Tax; public: double CalcTax() { if(Tex == CN_Tex) { } else if(Tex == US_Tax) { } else if(Tex == DE_Tax) { } //..... } } 每增加一个国家的计算方法，enum TexBase就要扩充一个枚举值，CalcTax要多一套if else.如果随着时间推移，后续增加的计算方法越多，代码越来越长，极端情况下 Cache甚至放不下代码，一部分代码需要放到内存 甚至是虚拟内存(硬盘)中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class TexStrategy { public: virtual double Calc(const Context\u0026amp; context) = 0; virtual ~TexStrategy(){} } class CNTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class USTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class DETax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class SalesOrder { private: TexStrategy* Strategy; public: SalesOrder(TexStrategy* InStrategy) : Strategy(InStrategy){} ~SalesOrder() { delete Strategy; } double CalcTex() { //.... Context context; double Tex = Strategy-\u0026gt;Calc(context); //..... return Tex; } } 需要扩充计算方法时，只要继承TexStrategy 写一个新的类即可，就能完成新的税种计算.SalesOrder是不需要修改的. 对于新增的类，甚至可以使用增量编译 单独编译一个dll.\n以上代码只是说明一个大概情况，下面的代码是可运行的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Strategy { public: virtual ~Strategy() = default; virtual std::string doAlgorithm(std::string_view data) const = 0; }; class Context { private: std::unique_ptr\u0026lt;Strategy\u0026gt; strategy_; public: explicit Context(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy = {}) : strategy_(std::move(strategy)) { } void set_strategy(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy) { strategy_ = std::move(strategy); } void doSomeBusinessLogic() const { if (strategy_) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = strategy_-\u0026gt;doAlgorithm(\u0026#34;aecbd\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Strategy isn\u0026#39;t set\\n\u0026#34;; } } }; class ConcreteStrategyA : public Strategy { public: std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result), std::greater\u0026lt;\u0026gt;()); return result; } }; void clientCode() { Context context(std::make_unique\u0026lt;ConcreteStrategyA\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context.doSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context.set_strategy(std::make_unique\u0026lt;ConcreteStrategyB\u0026gt;()); context.doSomeBusinessLogic(); } int main() { clientCode(); return 0; } 输出结果\n1 2 3 4 5 6 7 Client: Strategy is set to normal sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) abcde Client: Strategy is set to reverse sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) edcba 这种设计模式 可以在运行时更改对象的算法，将算法和对象本身解耦. 对于这个例子，分辨出哪里是稳定的，哪里是变化的，算法可以通过扩展子类的方式 独立出来进行变化.\n有时候支持不使用的算法也是负担，例如 在计算税的if else版本的代码里，程序安装在America 只需要使用America部分，其它的if都是不必要的，代码在运行时 要加载到Cache、内存， 但是要使用的代码只有其中一小部分，所以其余的代码都是多余加载的。 使用策略模式可以顺便缓解这个情况.\n观察者模式 一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并自动更新。\n观察者模式的核心思想\n主题（Subject）：被观察的对象，维护一个观察者列表，并提供添加、删除和通知观察者的方法。 观察者（Observer）：接收主题通知的接口，通常包含一个 update 方法，用于接收主题的状态变化。 具体主题（Concrete Subject）：实现主题接口的具体类，负责管理状态并在状态变化时通知所有观察者。 具体观察者（Concrete Observer）：实现观察者接口的具体类，接收来自主题的通知并进行相应的处理。 按钮响应事件 当用户点击该按钮时，需要通知所有注册的监听器执行相应的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 观察者接口 class ButtonListener { public: virtual void onClick() = 0; }; // 主题类 - 按钮 class Button { private: std::vector\u0026lt;ButtonListener*\u0026gt; listeners; public: void addListener(ButtonListener* listener) { listeners.push_back(listener); } void notifyListeners() { for (auto* listener : listeners) { listener-\u0026gt;onClick(); } } void click() { std::cout \u0026lt;\u0026lt; \u0026#34;Button clicked!\u0026#34; \u0026lt;\u0026lt; std::endl; notifyListeners(); } }; // 具体观察者类 - ListenerA 和 ListenerB class ListenerA : public ButtonListener { public: void onClick() override { std::cout \u0026lt;\u0026lt; \u0026#34;Listener A: Handling button click event.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class ListenerB : public ButtonListener { public: void onClick() override { std::cout \u0026lt;\u0026lt; \u0026#34;Listener B: Handling button click event.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Button button; ListenerA listenerA; ListenerB listenerB; button.addListener(\u0026amp;listenerA); button.addListener(\u0026amp;listenerB); // 模拟点击按钮 button.click(); return 0; } 这不就是在Button类里面放一个vector，vector里面又存放了ButtonListener的基类，按下按钮时，遍历vector，逐个通知ButtonListener的onClick.\n新闻订阅服务 模拟一个新闻订阅服务，用户可以订阅不同的新闻主题。当有新的新闻更新时，所有订阅了该主题的用户都会收到通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; // 观察者接口 class NewsSubscriber { public: virtual void update(const std::string\u0026amp; news) = 0; }; // 主题类 - 新闻发布者 class NewsPublisher { private: std::unordered_map\u0026lt;std::string, std::vector\u0026lt;NewsSubscriber*\u0026gt;\u0026gt; subscribers; public: void subscribe(const std::string\u0026amp; topic, NewsSubscriber* subscriber) { subscribers[topic].push_back(subscriber); } void unsubscribe(const std::string\u0026amp; topic, NewsSubscriber* subscriber) { auto it = subscribers.find(topic); if (it != subscribers.end()) { auto\u0026amp; list = it-\u0026gt;second; list.erase(std::remove(list.begin(), list.end(), subscriber), list.end()); } } void notifySubscribers(const std::string\u0026amp; topic, const std::string\u0026amp; news) { auto it = subscribers.find(topic); if (it != subscribers.end()) { for (auto* sub : it-\u0026gt;second) { sub-\u0026gt;update(news); } } } void publishNews(const std::string\u0026amp; topic, const std::string\u0026amp; news) { std::cout \u0026lt;\u0026lt; \u0026#34;Publishing news on \u0026#34; \u0026lt;\u0026lt; topic \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; notifySubscribers(topic, news); } }; // 具体观察者类 - SubscriberA 和 SubscriberB class SubscriberA : public NewsSubscriber { public: void update(const std::string\u0026amp; news) override { std::cout \u0026lt;\u0026lt; \u0026#34;Subscriber A received news: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; } }; class SubscriberB : public NewsSubscriber { public: void update(const std::string\u0026amp; news) override { std::cout \u0026lt;\u0026lt; \u0026#34;Subscriber B received news: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; } }; int main() { NewsPublisher publisher; SubscriberA subscriberA; SubscriberB subscriberB; publisher.subscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberA); publisher.subscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberB); publisher.publishNews(\u0026#34;Technology\u0026#34;, \u0026#34;New tech breakthrough!\u0026#34;); std::cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;\u0026lt;\u0026lt;std::endl; publisher.unsubscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberA); publisher.publishNews(\u0026#34;Technology\u0026#34;, \u0026#34;New tech AA!\u0026#34;); return 0; } 输出：\n1 2 3 4 5 6 Publishing news on Technology: New tech breakthrough! Subscriber A received news: New tech breakthrough! Subscriber B received news: New tech breakthrough! Publishing news on Technology: New tech AA! Subscriber B received news: New tech AA! 状态监控 模拟一个环境监测系统，它会根据传感器的数据变化来通知多个显示组件进行更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 观察者接口 class SensorObserver { public: virtual void onUpdate(float temperature, float humidity) = 0; }; // 主题类 - 传感器 class EnvironmentSensor { private: std::vector\u0026lt;SensorObserver*\u0026gt; observers; float temperature; float humidity; public: void addObserver(SensorObserver* observer) { observers.push_back(observer); } void removeObserver(SensorObserver* observer) { observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); } void notifyObservers() { for (auto* observer : observers) { observer-\u0026gt;onUpdate(temperature, humidity); } } void setMeasurements(float temperature, float humidity) { this-\u0026gt;temperature = temperature; this-\u0026gt;humidity = humidity; notifyObservers(); } }; // 具体观察者类 - DisplayA 和 DisplayB class DisplayA : public SensorObserver { public: void onUpdate(float temperature, float humidity) override { std::cout \u0026lt;\u0026lt; \u0026#34;Display A: Temperature is \u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;F and Humidity is \u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class DisplayB : public SensorObserver { public: void onUpdate(float temperature, float humidity) override { std::cout \u0026lt;\u0026lt; \u0026#34;Display B: Current readings are Temp=\u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;F, Humidity=\u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { EnvironmentSensor sensor; DisplayA displayA; DisplayB displayB; sensor.addObserver(\u0026amp;displayA); sensor.addObserver(\u0026amp;displayB); sensor.setMeasurements(75.0f, 60.0f); // 更新传感器数据 return 0; } 输出：\n1 2 Display A: Temperature is 75F and Humidity is 60% Display B: Current readings are Temp=75F, Humidity=60% 函数指针 使用C++函数指针实现观察者模式是一种相对直接的方法，它允许你定义一个或多个回调函数来响应特定事件。下面是一个简单的示例，演示了如何使用C++函数指针实现观察者模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 定义一个Subject类，用于管理观察者的注册和通知 class Subject { public: // 注册观察者（函数指针） void registerObserver(void (*observer)(std::string)) { observers.push_back(observer); } // 通知所有注册的观察者 void notifyObservers(std::string message) { for (auto observer : observers) { observer(message); } } private: std::vector\u0026lt;void(*)(std::string)\u0026gt; observers; // 存储所有观察者函数指针 }; // 定义两个观察者函数 void observer1(std::string message) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer 1 received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } void observer2(std::string message) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer 2 received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } int main() { Subject subject; // 注册观察者 subject.registerObserver(observer1); subject.registerObserver(observer2); // 发生某个事件，通知所有观察者 subject.notifyObservers(\u0026#34;Event occurred!\u0026#34;); return 0; } 装饰模式 一种结构型设计模式，它允许动态地给对象添加功能，而无需修改其原始类。通过这种方式，可以在运行时为对象增加新的行为，同时保持代码的简洁性和灵活性。\n装饰模式的核心思想\n组件接口：定义了可以被装饰的对象的基础接口。 具体组件：实现了组件接口的基本功能。 装饰器基类：持有一个对组件接口的引用，并实现相同的接口，以确保可以像处理原始组件一样处理装饰器。 具体装饰器：扩展或修改组件的行为，通常通过在其方法中调用被装饰对象的方法，然后添加额外的功能。 角色能力增强： 在游戏中，玩家可以通过拾取道具或完成任务来获得新的能力或增强现有能力。例如，角色可以拾取一个加速道具，或者穿上一件增加防御力的盔甲。 武器升级： 玩家可以在游戏中找到不同的配件来升级他们的武器，如安装瞄准镜、消音器等。这些升级可以动态地改变武器的属性。 状态效果（Buff/Debuff）： 游戏中的角色可能会受到各种状态效果的影响，如中毒、燃烧、隐身等。这些状态效果可以在运行时动态地附加到角色上，并根据需要移除。 图形特效： 为了增强游戏的视觉效果，某些物品或技能可以给角色添加特殊的图形特效，如光环、粒子效果等。 要设计一个咖啡店系统，其中不同种类的咖啡可以通过添加调料（如糖、牛奶等）来定制。可以使用装饰模式来动态地给咖啡添加调料，而不需要创建大量的子类。\n继承实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 组件接口 - Beverage class Beverage { public: virtual ~Beverage() = default; virtual std::string getDescription() const = 0; virtual double cost() const = 0; }; // 具体组件 - Espresso class Espresso : public Beverage { public: std::string getDescription() const override { return \u0026#34;Espresso\u0026#34;; } double cost() const override { return 1.99; } }; // 装饰器基类 - CondimentDecorator class CondimentDecorator : public Beverage { protected: Beverage* beverage; public: explicit CondimentDecorator(Beverage* beverage) : beverage(beverage) {} }; // 具体装饰器 - Milk class Milk : public CondimentDecorator { public: explicit Milk(Beverage* beverage) : CondimentDecorator(beverage) {} std::string getDescription() const override { return beverage-\u0026gt;getDescription() + \u0026#34;, Milk\u0026#34;; } double cost() const override { return beverage-\u0026gt;cost() + 0.25; } }; // 具体装饰器 - Sugar class Sugar : public CondimentDecorator { public: explicit Sugar(Beverage* beverage) : CondimentDecorator(beverage) {} std::string getDescription() const override { return beverage-\u0026gt;getDescription() + \u0026#34;, Sugar\u0026#34;; } double cost() const override { return beverage-\u0026gt;cost() + 0.15; } }; int main() { // 创建基础饮料 Beverage* beverage = new Espresso(); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; // 添加装饰器 beverage = new Milk(beverage); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; beverage = new Sugar(beverage); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; // 清理资源 delete beverage; return 0; } 套娃，一层套一层，调用getDescription() 或 cost() 都是逐层调用的，\n输出：\n1 2 3 4 5 6 7 8 Description: Espresso Cost: $1.99 Description: Espresso, Milk Cost: $2.24 Description: Espresso, Milk, Sugar Cost: $2.39 初始状态\nbeverage 指向 Espresso 对象。 调用 beverage-\u0026gt;getDescription() 返回 \u0026quot;Espresso\u0026quot;。 调用 beverage-\u0026gt;cost() 返回 1.99。 1 2 beverage-\u0026gt;getDescription() -\u0026gt; Espresso::getDescription() -\u0026gt; \u0026#34;Espresso\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Espresso::cost() -\u0026gt; 1.99 第一次装饰：添加 Milk\n创建一个新的 Milk 对象，并将 Espresso 对象传递给它的构造函数。 新的 Milk 对象内部持有一个指向 Espresso 对象的指针。 调用 beverage-\u0026gt;getDescription() 实际上调用了 Milk::getDescription()，该方法会调用 beverage-\u0026gt;getDescription()（即 Espresso::getDescription()），并附加 \u0026quot;Milk\u0026quot;。 调用 beverage-\u0026gt;cost() 实际上调用了 Milk::cost()，该方法会调用 beverage-\u0026gt;cost()（即 Espresso::cost()），并加上 0.25。 此时，beverage 指向的是 Milk 对象，而 Milk 对象内部持有对 Espresso 对象的引用。\n1 2 3 4 5 6 7 beverage-\u0026gt;getDescription() -\u0026gt; Milk::getDescription() -\u0026gt; Espresso::getDescription() + \u0026#34;, Milk\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Milk::cost() -\u0026gt; Espresso::cost() + 0.25 -\u0026gt; 1.99 + 0.25 = 2.24 第二次装饰：添加 Sugar\n创建一个新的 Sugar 对象，并将 Milk 对象传递给它的构造函数。\n新的 Sugar 对象内部持有一个指向 Milk 对象的指针。\n调用 beverage-\u0026gt;getDescription() 实际上调用了 Sugar::getDescription()，该方法会调用 beverage-\u0026gt;getDescription()（即 Milk::getDescription()），并附加 \u0026quot;Sugar\u0026quot;。\n调用 beverage-\u0026gt;cost() 实际上调用了 Sugar::cost()，该方法会调用 beverage-\u0026gt;cost()（即 Milk::cost()），并加上 0.15。\n此时，beverage 指向的是 Sugar 对象，而 Sugar 对象内部持有对 Milk 对象的引用，Milk 对象内部持有对 Espresso 对象的引用。\n1 2 3 4 5 6 7 8 9 10 beverage-\u0026gt;getDescription() -\u0026gt; Sugar::getDescription() -\u0026gt; Milk::getDescription() + \u0026#34;, Sugar\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk\u0026#34; + \u0026#34;, Sugar\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk, Sugar\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Sugar::cost() -\u0026gt; Milk::cost() + 0.15 -\u0026gt; (Espresso::cost() + 0.25) + 0.15 -\u0026gt; 1.99 + 0.25 + 0.15 = 2.39 单例模式 一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例。单例模式通常用于需要控制资源（如数据库连接、配置设置、日志记录器等）的场景，以避免重复创建多个实例带来的资源浪费或不一致状态。\n使用单例模式 首先要确保 真的需要这个模式吗？\n单例模式的核心要素\n私有构造函数：防止外部通过 new 操作符创建对象。 静态方法：提供一个全局访问点来获取唯一实例。 静态成员变量：保存该类的唯一实例。 线程安全：在多线程环境下，确保实例化过程是线程安全的。 方法 说明 饿汉式 简单直接，但可能造成资源浪费。 线程安全。 懒汉式 延迟初始化，节省资源。 需要额外处理线程安全问题。 双重检查锁定 解决了懒汉式在多线程环境下的线程安全问题。 代码较为复杂。在多线程下，受内存访问重新排序影响，可能会出现致命问题，需要额外处理 使用智能指针 自动管理内存，避免手动释放资源。 使用 std::call_once 确保线程安全。 静态局部变量 最简单且线程安全，推荐指数:☆☆☆☆☆☆☆☆☆☆☆ 表格列举的方法都图一乐，真正使用的话 推荐使用静态局部变量法，C++11特供优化。\n饿汉式 饿汉式是最简单的单例模式实现方式，它在类加载时就初始化实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class Logger { private: static Logger instance; // 静态成员变量，存储唯一实例 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { return instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; // 定义静态成员变量 Logger Logger::instance; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); return 0; } 优点：\n实现简单，线程安全（因为实例在类加载时就已经创建）。 缺点：\n如果实例从未被使用，仍然会占用资源。 懒汉式 懒汉式是在第一次调用 getInstance 方法时才创建实例，这样可以避免不必要的资源浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; class Logger { private: static Logger* instance; // 静态指针，指向唯一实例 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { if (instance == nullptr) { instance = new Logger(); } return *instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { delete instance; instance = nullptr; } }; // 定义静态成员变量 Logger* Logger::instance = nullptr; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); // 清理资源 Logger::destroyInstance(); return 0; } 优点：\n延迟实例化，节省资源。 缺点：\n不是线程安全的，如果在多线程环境中同时调用 getInstance，可能会创建多个实例。 双重检查锁定 为了解决懒汉式在多线程环境下的线程安全问题，可以使用双重检查锁定机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Logger { private: static Logger* instance; // 静态指针，指向唯一实例 static std::mutex mutex; // 互斥锁，保证线程安全 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { if (instance == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (instance == nullptr) { instance = new Logger(); } } return *instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); delete instance; instance = nullptr; } }; // 定义静态成员变量 Logger* Logger::instance = nullptr; std::mutex Logger::mutex; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); // 清理资源 Logger::destroyInstance(); return 0; } 优点：\n在多线程环境下保证了线程安全。 通过双重检查减少了加锁的开销。 缺点：\n代码相对复杂一些。 不安全，reorder内存访问重新排序导致双重锁定失效问题。 双重检查修复 使用atomic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Logger { private: static std::atomic\u0026lt;Logger*\u0026gt; instance; // 使用 atomic 指针管理实例 static std::mutex mutex; // 互斥锁，保证线程安全 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { Logger* tmp = instance.load(std::memory_order_relaxed); //获得原子的指针 std::atomic_thread_fence(std::memory_order_acquire); // 内存屏障，防止重排序 if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Logger(); std::atomic_thread_fence(std::memory_order_release); //释放内存屏障 instance.store(tmp, std::memory_order_relaxed); } } return *tmp; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); delete instance.load(); instance.store(nullptr, std::memory_order_relaxed); } }; // 定义静态成员变量 std::atomic\u0026lt;Logger*\u0026gt; Logger::instance(nullptr); std::mutex Logger::mutex; 进一步优化\nC++11 提供了 std::call_once 和 std::once_flag，可以确保某个函数只会被调用一次，非常适合用于实现线程安全的单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: // 获取单例实例 static Singleton* getInstance() { std::call_once(flag, []() { instance = new Singleton(); }); return instance; } // 删除拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态成员变量 static Singleton* instance; static std::once_flag flag; }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; std::once_flag Singleton::flag; int main() { // 多线程测试 auto func = []() { Singleton* instance = Singleton::getInstance(); instance-\u0026gt;doSomething(); }; std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); return 0; } 优点\n线程安全，代码简洁。 避免了双重检查锁定的复杂性。 缺点\n需要 C++11 及以上支持。 使用静态局部变量 主播主播🥰 你的单例确～实很强👍 但还是太吃操作了😇 有没有更加简单又强势的英雄推荐一下吗🧐 有的兄弟（战术停顿）有的😋 这么强势的英雄当～然是不止一个了🤓 一共有九位，都是当～前版本t～0.5的超～标英雄👉 告诉主播，你想学习哪个😤\nC++11 保证了静态局部变量的初始化是线程安全的，因此可以直接使用静态局部变量来实现单例模式。\n请务必禁用 copy 构造函数和赋值运算符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; class Singleton { public: // 获取单例实例 static Singleton\u0026amp; getInstance() { static Singleton instance; // 线程安全的静态局部变量 return instance; } // 删除拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 多线程测试 auto func = []() { Singleton\u0026amp; instance = Singleton::getInstance(); instance.doSomething(); }; std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); return 0; } 优点\n代码简洁，线程安全。 无需手动管理内存。 延迟加载，只在第一次使用时才构造。 避免静态对象在不同编译单元构造顺序的问题。 缺点\n需要 C++11 及以上支持。 静态类 在 C++ 中，单例模式 和 静态类 是两种常见的实现全局唯一实例或工具类的方式。它们各有优势和适用场景，以下是它们的详细对比：\n单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。静态类是指所有成员（包括方法和数据）都是静态的类。它通常用于工具类或全局函数集合。\n静态类示例：\n1 2 3 4 5 6 7 8 9 10 11 class StaticClass { public: // 删除构造函数和拷贝构造函数 StaticClass() = delete; StaticClass(const StaticClass\u0026amp;) = delete; // 静态方法 static void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something in StaticClass\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 特性 单例模式 静态类 实例化 延迟初始化，按需创建 无需实例化，直接调用静态方法 继承与多态 支持继承和多态 不支持继承和多态 线程安全 需要额外处理 通常是线程安全的 生命周期管理 需要手动管理 自动管理 适用场景 需要全局唯一实例的场景 工具类或全局函数集合 全局状态 引入全局状态 引入全局状态 扩展性 高（可继承、可扩展） 低（无法继承） 场景 单例模式 静态类 游戏管理器 ✔️ 适合管理全局状态 ❌ 不适合 资源管理器 ✔️ 适合按需加载资源 ❌ 不适合 音频管理器 ✔️ 适合管理全局音频 ❌ 不适合 数学工具类 ❌ 过度设计 ✔️ 适合工具函数 调试工具类 ❌ 过度设计 ✔️ 适合工具函数 输入工具类 ❌ 过度设计 ✔️ 适合工具函数 命令模式 命令模式是一种行为设计模式，它将请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。具体来说，命令模式允许你将请求发送者和请求接收者解耦，通过引入一个命令对象来封装请求调用的细节。\n发送者（调用者） 只需要知道如何调用命令对象的 execute() 方法，而不需要了解具体的实现细节。 接收者 只需要提供具体的操作方法，而不关心这些方法是如何被调用的。 命令对象 则充当了发送者和接收者之间的桥梁，封装了请求的具体执行逻辑。 说白了 就调用虚函数，完事了。假设有个Command命令基类，它有一个execute函数，只要是Command的子类 都可以接收过来，这些子类重写execute虚函数，就能做出不同的效果，调用者只要执行Command-\u0026gt;execute() 就行了。\n下面的例子创建了多个类来体现这个设计模式，但是在C++中 可以传递 Lambda函数、函数指针 什么的来调用函数。而不需要创建好几个类，就有点占地方了。\n正在开发一个遥控器应用，该应用可以控制多个家电设备（如灯、风扇等）。可以使用命令模式来实现遥控器的功能，使得遥控器与具体的设备操作解耦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // Command 接口 class Command { public: virtual ~Command() = default; virtual void execute() = 0; }; // Light 类（接收者） class Light { public: void on() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is ON\u0026#34; \u0026lt;\u0026lt; std::endl; } void off() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is OFF\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Fan 类（接收者） class Fan { public: void start() { std::cout \u0026lt;\u0026lt; \u0026#34;Fan is STARTED\u0026#34; \u0026lt;\u0026lt; std::endl; } void stop() { std::cout \u0026lt;\u0026lt; \u0026#34;Fan is STOPPED\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体命令类：打开灯 class LightOnCommand : public Command { private: Light\u0026amp; light; public: LightOnCommand(Light\u0026amp; light) : light(light) {} void execute() override { light.on(); } }; // 具体命令类：关闭灯 class LightOffCommand : public Command { private: Light\u0026amp; light; public: LightOffCommand(Light\u0026amp; light) : light(light) {} void execute() override { light.off(); } }; // 具体命令类：启动风扇 class FanStartCommand : public Command { private: Fan\u0026amp; fan; public: FanStartCommand(Fan\u0026amp; fan) : fan(fan) {} void execute() override { fan.start(); } }; // 具体命令类：停止风扇 class FanStopCommand : public Command { private: Fan\u0026amp; fan; public: FanStopCommand(Fan\u0026amp; fan) : fan(fan) {} void execute() override { fan.stop(); } }; // 调用者：遥控器 class RemoteControl { private: std::unique_ptr\u0026lt;Command\u0026gt; command; public: void setCommand(std::unique_ptr\u0026lt;Command\u0026gt; cmd) { command = std::move(cmd); } void pressButton() { if (command) { command-\u0026gt;execute(); } } }; int main() { // 创建接收者 Light light; Fan fan; // 创建命令对象 LightOnCommand lightOn(light); LightOffCommand lightOff(light); FanStartCommand fanStart(fan); FanStopCommand fanStop(fan); // 创建遥控器 RemoteControl remote; // 设置并按下按钮 remote.setCommand(std::make_unique\u0026lt;LightOnCommand\u0026gt;(lightOn)); remote.pressButton(); // 输出: Light is ON remote.setCommand(std::make_unique\u0026lt;LightOffCommand\u0026gt;(lightOff)); remote.pressButton(); // 输出: Light is OFF remote.setCommand(std::make_unique\u0026lt;FanStartCommand\u0026gt;(fanStart)); remote.pressButton(); // 输出: Fan is STARTED remote.setCommand(std::make_unique\u0026lt;FanStopCommand\u0026gt;(fanStop)); remote.pressButton(); // 输出: Fan is STOPPED return 0; } 这不就是 遥控器接收一个命令基类，调用命令基类里的execute函数，命令基类可以派生出子类，子类重写execute虚函数 执行出不同的效果，\n状态模式 一种行为设计模式，它允许对象在其内部状态改变时改变其行为。这种模式可以将状态的逻辑从对象中分离出来，使得状态转换更加清晰和易于管理。\n人的情绪可以是“开心”、“生气”或“平静”。根据他的情绪不同，他对同一件事情的反应也会不同。比如：\n当他开心时，有人跟他开玩笑他会笑得很开心。 当他生气时，同样的玩笑可能会让他愤怒地回应。 当他平静时，他可能只是微微一笑，或者完全不理会。 状态模式的核心元素\n上下文（Context）：这个人本身，他有不同的状态，并且根据当前的状态表现出不同的行为。 状态接口（State Interface）：定义了所有具体状态的公共接口，例如对玩笑的反应。 具体状态（Concrete States）：每种情绪的具体实现，如“开心”、“生气”和“平静”。 假设有一个简单的程序来模拟一个人的心情变化，并根据心情做出不同的反应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 定义状态接口 class Mood { public: virtual ~Mood() = default; virtual void reactToJoke() = 0; }; // 上下文类，持有当前状态 class Person { public: explicit Person(std::unique_ptr\u0026lt;Mood\u0026gt; mood) : currentMood_(std::move(mood)) {} void setMood(std::unique_ptr\u0026lt;Mood\u0026gt; mood) { currentMood_ = std::move(mood); } void hearJoke() { if (currentMood_) { currentMood_-\u0026gt;reactToJoke(); } } private: std::unique_ptr\u0026lt;Mood\u0026gt; currentMood_; }; // 具体状态类：开心 class HappyMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;哈哈，太好笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体状态类：生气 class AngryMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;你这是什么意思？别开玩笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体状态类：平静 class CalmMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;嗯...这有点意思。\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建一个初始状态为开心的人 auto person = std::make_unique\u0026lt;Person\u0026gt;(std::make_unique\u0026lt;HappyMood\u0026gt;()); // 听到一个笑话 person-\u0026gt;hearJoke(); // 输出: 哈哈，太好笑了！ // 切换到生气状态 person-\u0026gt;setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); person-\u0026gt;hearJoke(); // 输出: 你这是什么意思？别开玩笑了！ // 切换到平静状态 person-\u0026gt;setMood(std::make_unique\u0026lt;CalmMood\u0026gt;()); person-\u0026gt;hearJoke(); // 输出: 嗯...这有点意思。 return 0; } 清晰的行为转换：每个状态都有明确的行为，避免了大量的条件判断语句。 易于扩展：如果需要添加新的状态或修改现有状态的行为，只需添加或修改具体状态类，而不影响其他部分的代码。 更好的组织代码：将状态逻辑分离出来，使得代码更加模块化和易于维护。 状态机\n设计一个状态机来表现心情的变化，可以通过定义不同的状态和状态之间的转换规则来实现。状态机是一种模型，用于表示系统在不同状态下如何响应各种事件，并根据这些事件进行状态转换。\n设计步骤\n定义状态：首先确定有哪些可能的状态。 定义事件：确定哪些事件会触发状态的改变。 定义状态转换规则：明确每个状态下对每个事件的响应以及状态转换关系。 实现状态机：使用代码实现上述定义的状态、事件和转换规则。 状态转换规则\n开心(Happy) 听到笑话 (Joke)-\u0026gt; 更加开心（仍然保持开心状态） 受到表扬 (Praise) -\u0026gt; 更加开心（仍然保持开心状态） 受到批评 (Criticism)-\u0026gt; 生气 生气(Angry) 听到笑话 (Joke)-\u0026gt; 不理睬（仍然保持生气状态） 受到表扬 (Praise)-\u0026gt; 平静 受到批评 (Criticism)-\u0026gt; 更加生气（仍然保持生气状态） 平静(Calm) 听到笑话 (Joke)-\u0026gt; 轻微高兴（开心） 受到表扬 (Praise)-\u0026gt; 开心 受到批评 (Criticism)-\u0026gt; 生气 结合状态模式的思想，将每个状态作为一个类，并定义状态转换逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; // 定义状态接口 class Mood { public: virtual ~Mood() = default; virtual void handleEvent(const std::string\u0026amp; event) = 0; virtual std::string getStateName() const = 0; }; // 上下文类，持有当前状态 class Person { public: explicit Person(std::unique_ptr\u0026lt;Mood\u0026gt; mood) : currentMood_(std::move(mood)) {} void setMood(std::unique_ptr\u0026lt;Mood\u0026gt; mood) { currentMood_ = std::move(mood); } void handleEvent(const std::string\u0026amp; event) { if (currentMood_) { std::cout \u0026lt;\u0026lt; \u0026#34;Current mood: \u0026#34; \u0026lt;\u0026lt; currentMood_-\u0026gt;getStateName() \u0026lt;\u0026lt; std::endl; currentMood_-\u0026gt;handleEvent(event); } } private: std::unique_ptr\u0026lt;Mood\u0026gt; currentMood_; }; // 具体状态类：开心 class HappyMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;哈哈，太好笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;真不错，继续保持！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;哼，你说什么？\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); } } std::string getStateName() const override { return \u0026#34;Happy\u0026#34;; } }; // 具体状态类：生气 class AngryMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;你这是什么意思？别开玩笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;好吧，这还差不多。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;CalmMood\u0026gt;()); } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;你怎么能这么说！\u0026#34; \u0026lt;\u0026lt; std::endl; } } std::string getStateName() const override { return \u0026#34;Angry\u0026#34;; } }; // 具体状态类：平静 class CalmMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;嗯...这有点意思。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;HappyMood\u0026gt;()); } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;谢谢你的认可！\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;HappyMood\u0026gt;()); } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;我会注意的。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); } } std::string getStateName() const override { return \u0026#34;Calm\u0026#34;; } }; int main() { // 创建一个初始状态为开心的人 auto person = std::make_unique\u0026lt;Person\u0026gt;(std::make_unique\u0026lt;HappyMood\u0026gt;()); // 处理一系列事件 person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 哈哈，太好笑了！ person-\u0026gt;handleEvent(\u0026#34;ReceiveCriticism\u0026#34;); // 输出: 哼，你说什么？ Current mood: Angry person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 你这是什么意思？别开玩笑了！ person-\u0026gt;handleEvent(\u0026#34;ReceivePraise\u0026#34;); // 输出: 好吧，这还差不多。 Current mood: Calm person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 嗯...这有点意思。 Current mood: Happy person-\u0026gt;handleEvent(\u0026#34;ReceivePraise\u0026#34;); // 输出: 谢谢你的认可！ Current mood: Happy return 0; } 门面模式 一种结构型设计模式，它为复杂的子系统提供一个简化的接口。门面模式通过引入一个单一的接口类来隐藏系统的复杂性，使得外部与系统的交互更加简单和直观。\n门面模式的核心概念\n门面（Facade）：提供一个统一的接口，用于访问多个子系统的功能。客户端只需要与这个门面进行交互，而不需要直接调用各个子系统的具体实现。 子系统（Subsystem）：包含实际的功能模块或组件，通常由多个类组成，每个类负责特定的任务。 适用场景\n当需要简化一个复杂的子系统时。 当需要将子系统的实现细节与客户端代码解耦时。 当希望将一组复杂的类组织在一起，并对外提供一个简单的接口时。 当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。\n假设正在开发一个多媒体播放器，该播放器需要处理音频、视频和字幕等多个子系统。为了简化客户端代码的使用，可以使用门面模式来封装这些子系统的操作。\n子系统类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; // 音频子系统 class AudioPlayer { public: void loadAudio(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading audio: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void playAudio() { std::cout \u0026lt;\u0026lt; \u0026#34;Playing audio.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 视频子系统 class VideoPlayer { public: void loadVideo(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading video: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void playVideo() { std::cout \u0026lt;\u0026lt; \u0026#34;Playing video.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 字幕子系统 class SubtitleManager { public: void loadSubtitle(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading subtitle: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void displaySubtitle() { std::cout \u0026lt;\u0026lt; \u0026#34;Displaying subtitle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 门面类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 门面类，提供一个简化的接口来操作多媒体播放器 class MediaFacade { public: MediaFacade() : audioPlayer(new AudioPlayer()), videoPlayer(new VideoPlayer()), subtitleManager(new SubtitleManager()) {} ~MediaFacade() { delete audioPlayer; delete videoPlayer; delete subtitleManager; } void playMedia(const std::string\u0026amp; audioFile, const std::string\u0026amp; videoFile, const std::string\u0026amp; subtitleFile) { // 加载并播放音频 audioPlayer-\u0026gt;loadAudio(audioFile); audioPlayer-\u0026gt;playAudio(); // 加载并播放视频 videoPlayer-\u0026gt;loadVideo(videoFile); videoPlayer-\u0026gt;playVideo(); // 加载并显示字幕 subtitleManager-\u0026gt;loadSubtitle(subtitleFile); subtitleManager-\u0026gt;displaySubtitle(); } private: AudioPlayer* audioPlayer; VideoPlayer* videoPlayer; SubtitleManager* subtitleManager; }; 客户端代码\n1 2 3 4 5 6 7 8 9 int main() { // 创建门面对象 MediaFacade mediaFacade; // 使用门面对象来播放多媒体文件 mediaFacade.playMedia(\u0026#34;audio.mp3\u0026#34;, \u0026#34;video.mp4\u0026#34;, \u0026#34;subtitle.srt\u0026#34;); return 0; } 输出：\n1 2 3 4 5 6 Loading audio: audio.mp3 Playing audio. Loading video: video.mp4 Playing video. Loading subtitle: subtitle.srt Displaying subtitle. 门面类 MediaFacade： 提供了一个简化的接口 playMedia，该接口内部调用了各个子系统的相应方法来完成多媒体播放任务。 通过门面类，客户端代码不需要直接与各个子系统进行交互，只需要调用门面提供的接口即可。 优点\n简化客户端代码：客户端只需要与门面进行交互，无需了解子系统的内部细节。 提高灵活性：可以在不改变客户端代码的情况下修改子系统的实现。 促进松耦合：门面类与子系统之间是松耦合的，便于维护和扩展。 扩展示例\n假设需要在播放多媒体文件之前检查文件是否存在，可以在门面类中添加相应的逻辑，而无需修改子系统类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;fstream\u0026gt; class MediaFacade { public: MediaFacade() : audioPlayer(new AudioPlayer()), videoPlayer(new VideoPlayer()), subtitleManager(new SubtitleManager()) {} ~MediaFacade() { delete audioPlayer; delete videoPlayer; delete subtitleManager; } bool fileExists(const std::string\u0026amp; fileName) { std::ifstream file(fileName); return file.good(); } void playMedia(const std::string\u0026amp; audioFile, const std::string\u0026amp; videoFile, const std::string\u0026amp; subtitleFile) { if (!fileExists(audioFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Audio file not found: \u0026#34; \u0026lt;\u0026lt; audioFile \u0026lt;\u0026lt; std::endl; return; } if (!fileExists(videoFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Video file not found: \u0026#34; \u0026lt;\u0026lt; videoFile \u0026lt;\u0026lt; std::endl; return; } if (!fileExists(subtitleFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Subtitle file not found: \u0026#34; \u0026lt;\u0026lt; subtitleFile \u0026lt;\u0026lt; std::endl; return; } // 加载并播放音频 audioPlayer-\u0026gt;loadAudio(audioFile); audioPlayer-\u0026gt;playAudio(); // 加载并播放视频 videoPlayer-\u0026gt;loadVideo(videoFile); videoPlayer-\u0026gt;playVideo(); // 加载并显示字幕 subtitleManager-\u0026gt;loadSubtitle(subtitleFile); subtitleManager-\u0026gt;displaySubtitle(); } private: AudioPlayer* audioPlayer; VideoPlayer* videoPlayer; SubtitleManager* subtitleManager; }; 在这个扩展示例中，在门面类中添加了 fileExists 方法来检查文件是否存在，并在 playMedia 方法中进行了相应的检查。这样，即使子系统类没有文件检查的功能，也可以通过门面类来增强其功能，而不会影响到现有的子系统实现。\n通过这种方式，门面模式可以简化复杂的系统接口，使其更易于使用和维护。\n在扩展检查文件存在性的例子中，无论内部如何变，在外部看来是没有变化的，依然可以使用相同的方式使用\n1 2 3 4 5 6 7 8 9 int main() { // 创建门面对象 MediaFacade mediaFacade; // 使用门面对象来播放多媒体文件 mediaFacade.playMedia(\u0026#34;audio.mp3\u0026#34;, \u0026#34;video.mp4\u0026#34;, \u0026#34;subtitle.srt\u0026#34;); return 0; } 解耦—内部子系统的变化 不会影响到接口的变化.\n门面模式中组件的内部是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。\n迭代器模式 一种行为设计模式，它提供了一种方法来顺序访问一个聚合对象中的各个元素，而无需暴露其内部表示。迭代器模式将遍历集合的职责从集合本身分离出来，使得不同的遍历方式可以独立于集合实现。\n迭代器模式的核心概念\nAggregate（聚合类）：定义了创建迭代器对象的接口。 Iterator（迭代器接口）：声明了遍历集合所需的方法，如 hasNext() 和 next()。 ConcreteIterator（具体迭代器类）：实现了迭代器接口，并保持对遍历过程的跟踪。 传统迭代器模式是面向对象风格，在C++中需要使用虚函数实现，性能不好C++标准库的迭代器采用模板编程，在编译时确定\n面向对象风格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 迭代器接口 class Iterator { public: virtual ~Iterator() = default; virtual bool hasNext() const = 0; virtual std::string next() = 0; }; // 聚合类接口 class Aggregate { public: virtual ~Aggregate() = default; virtual std::unique_ptr\u0026lt;Iterator\u0026gt; createIterator() const = 0; }; // 图书类 class Book { public: explicit Book(const std::string\u0026amp; title) : title_(title) {} std::string getTitle() const { return title_; } private: std::string title_; }; // 具体聚合类：图书集合 class BookCollection : public Aggregate { public: void addBook(const std::string\u0026amp; title) { books_.emplace_back(title); } std::unique_ptr\u0026lt;Iterator\u0026gt; createIterator() const override { return std::make_unique\u0026lt;BookIterator\u0026gt;(books_); } private: std::vector\u0026lt;Book\u0026gt; books_; }; // 具体迭代器类：从前向后遍历 class BookIterator : public Iterator { public: explicit BookIterator(const std::vector\u0026lt;Book\u0026gt;\u0026amp; books) : books_(books), index_(0) {} bool hasNext() const override { return index_ \u0026lt; books_.size(); } std::string next() override { if (!hasNext()) { throw std::out_of_range(\u0026#34;No more books.\u0026#34;); } return books_[index_++].getTitle(); } private: const std::vector\u0026lt;Book\u0026gt;\u0026amp; books_; size_t index_; }; int main() { // 创建图书集合并添加一些图书 auto bookCollection = std::make_unique\u0026lt;BookCollection\u0026gt;(); bookCollection-\u0026gt;addBook(\u0026#34;C++ Primer\u0026#34;); bookCollection-\u0026gt;addBook(\u0026#34;Effective C++\u0026#34;); bookCollection-\u0026gt;addBook(\u0026#34;Design Patterns\u0026#34;); // 获取迭代器并遍历图书集合 auto iterator = bookCollection-\u0026gt;createIterator(); while (iterator-\u0026gt;hasNext()) { std::cout \u0026lt;\u0026lt; iterator-\u0026gt;next() \u0026lt;\u0026lt; std::endl; } return 0; } 组合模式 一种结构型设计模式， 可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n组合模式的核心思想是：\n定义一个统一的接口（抽象类或基类），用于表示单个对象和组合对象。 单个对象和组合对象都实现这个接口。 组合对象可以包含其他组合对象或单个对象，从而形成树形结构。 假设正在开发一个文件系统，文件系统中有两种类型的对象：\n文件（File）：单个对象，没有子对象。 文件夹（Folder）：组合对象，可以包含文件或其他文件夹。 可以使用组合模式来表示文件系统的层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 抽象组件类 class FileSystemComponent { public: virtual ~FileSystemComponent() = default; virtual void display(int depth = 0) const = 0; // 显示组件信息 }; // 叶子类：文件 class File : public FileSystemComponent { public: File(const std::string\u0026amp; name) : name(name) {} void display(int depth = 0) const override { std::cout \u0026lt;\u0026lt; std::string(depth, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; \u0026#34;File: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; } private: std::string name; }; // 组合类：文件夹 class Folder : public FileSystemComponent { public: Folder(const std::string\u0026amp; name) : name(name) {} void addComponent(FileSystemComponent* component) { components.push_back(component); } void display(int depth = 0) const override { std::cout \u0026lt;\u0026lt; std::string(depth, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Folder: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; for (const auto\u0026amp; component : components) { component-\u0026gt;display(depth + 2); // 递归显示子组件 } } private: std::string name; std::vector\u0026lt;FileSystemComponent*\u0026gt; components; }; int main() { // 创建文件 File* file1 = new File(\u0026#34;file1.txt\u0026#34;); File* file2 = new File(\u0026#34;file2.txt\u0026#34;); File* file3 = new File(\u0026#34;file3.txt\u0026#34;); // 创建文件夹 Folder* folder1 = new Folder(\u0026#34;Folder 1\u0026#34;); Folder* folder2 = new Folder(\u0026#34;Folder 2\u0026#34;); Folder* rootFolder = new Folder(\u0026#34;Root Folder\u0026#34;); // 构建树形结构 folder1-\u0026gt;addComponent(file1); folder1-\u0026gt;addComponent(file2); folder2-\u0026gt;addComponent(file3); rootFolder-\u0026gt;addComponent(folder1); rootFolder-\u0026gt;addComponent(folder2); // 显示文件系统结构 rootFolder-\u0026gt;display(); // 释放内存 delete file1; delete file2; delete file3; delete folder1; delete folder2; delete rootFolder; return 0; } 输出：\n1 2 3 4 5 6 Folder: Root Folder --Folder: Folder 1 ----File: file1.txt ----File: file2.txt --Folder: Folder 2 ----File: file3.txt 优点\n统一处理单个对象和组合对象： 客户端可以统一处理文件和文件夹，无需区分它们。 灵活性： 可以动态地添加或删除组件，构建复杂的树形结构。 可扩展性： 新增组件类型时，无需修改现有代码。 缺点\n设计复杂性： 需要定义抽象组件类、叶子类和组合类，增加了代码的复杂性。 类型检查： 在某些情况下，客户端可能需要检查组件的类型（如判断是否是文件夹），这可能会破坏组合模式的透明性。 适用场景\n表示部分-整体层次结构： 如文件系统、菜单系统、组织结构等。 统一处理单个对象和组合对象： 当客户端需要统一处理单个对象和组合对象时。 动态构建树形结构： 当需要动态地添加或删除组件时。 组合模式课后康复练习\n假设你有两个类的对象：产品和盒子。一个盒子可以包含多个产品或其他较小的盒子，这些小盒子也可以再包含产品或更小的盒子，以此类推。\n问题描述\n你需要开发一个订购系统，订单中可以包含：\n未包装的简单产品 装满产品的盒子 其他盒子（可能包含更多产品或盒子） 目标是计算每张订单的总价格。\n直接计算的问题\n直接计算所有项目的总价在现实中或许可行，但在程序中实现时会遇到以下困难：\n必须事先知道所有产品和盒子的类别。 需要了解所有盒子的嵌套层数和其他复杂细节。 这种方法非常繁琐且容易出错。 解决方案：组合模式\n组合模式通过使用通用接口来统一处理产品和盒子，并声明一个计算总价的方法。具体如下：\n定义通用接口： 声明一个计算总价的方法（例如 getPrice）。 实现叶子节点（产品）： 对于产品，该方法直接返回其价格。 实现组合节点（盒子）： 对于盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。 如果其中某个项目是另一个盒子，则当前盒子也会递归地遍历其中的所有项目，直到计算出所有内部组成部分的价格。 优点： 无需了解对象的具体类（无论是产品还是盒子）。 可以用相同的方式处理所有对象，无论它们是简单的还是复杂的结构。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 组件接口 class Component { public: virtual ~Component() = default; virtual double getPrice() const = 0; // 计算总价 }; // 产品类 class Product : public Component { public: Product(double price) : price_(price) {} double getPrice() const override { return price_; } private: double price_; }; // 盒子类 class Box : public Component { public: void add(std::unique_ptr\u0026lt;Component\u0026gt; component) { components_.push_back(std::move(component)); } double getPrice() const override { double total = 0.0; for (const auto\u0026amp; component : components_) { total += component-\u0026gt;getPrice(); } return total; } private: std::vector\u0026lt;std::unique_ptr\u0026lt;Component\u0026gt;\u0026gt; components_; }; int main() { // 创建一个盒子 auto box = std::make_unique\u0026lt;Box\u0026gt;(); // 向盒子中添加产品 box-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(10.0)); // 产品A box-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(20.0)); // 产品B // 创建另一个盒子并将其添加到第一个盒子中 auto nestedBox = std::make_unique\u0026lt;Box\u0026gt;(); nestedBox-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(5.0)); // 产品C nestedBox-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(15.0)); // 产品D box-\u0026gt;add(std::move(nestedBox)); // 计算并显示总价格 std::cout \u0026lt;\u0026lt; \u0026#34;Total Price: \u0026#34; \u0026lt;\u0026lt; box-\u0026gt;getPrice() \u0026lt;\u0026lt; std::endl; return 0; } Total Price: 50\n代理模式 一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n适用情况\n延迟初始化（Lazy Initialization）：在需要时才创建昂贵的对象。 访问控制：根据权限控制对对象的访问。 远程代理：代表远程对象进行操作，如网络请求。 虚拟代理：为复杂对象创建一个轻量级的占位符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;iostream\u0026gt; class Subject { public: virtual void Request() const = 0; }; class RealSubject : public Subject { public: void Request() const override { std::cout \u0026lt;\u0026lt; \u0026#34;RealSubject: Handling request.\\n\u0026#34;; } }; class Proxy : public Subject { private: RealSubject* real_subject_; bool CheckAccess() const { // Some real checks should go here. std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Checking access prior to firing a real request.\\n\u0026#34;; return true; } void LogAccess() const { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Logging the time of request.\\n\u0026#34;; } public: Proxy(RealSubject* real_subject) : real_subject_(new RealSubject(*real_subject)) {} ~Proxy() { delete real_subject_; } void Request() const override { if (this-\u0026gt;CheckAccess()) { this-\u0026gt;real_subject_-\u0026gt;Request(); this-\u0026gt;LogAccess(); } } }; void ClientCode(const Subject\u0026amp; subject) { // ... subject.Request(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the client code with a real subject:\\n\u0026#34;; RealSubject* real_subject = new RealSubject; ClientCode(*real_subject); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the same client code with a proxy:\\n\u0026#34;; Proxy* proxy = new Proxy(real_subject); ClientCode(*proxy); delete real_subject; delete proxy; return 0; } 间接访问：通过代理对象间接访问实际对象，可以在不修改实际对象的情况下添加额外的功能。 权限检查和日志记录：在调用实际对象的方法之前和之后，代理可以执行额外的操作，如权限检查和日志记录。 扩展性：可以在代理类中轻松添加新功能，而不需要修改实际对象的类，提高了代码的可维护性和扩展性。 适配器模式 一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n示例：手机充电适配器\n在这个示例中：\nPhone类代表的手机，它需要一个USB接口来充电。 OldCharger类代表一个旧式的充电器，它只有圆形插头输出。 UsbAdapter类是适配器，它接受圆形插头输入，并提供USB接口输出，使手机可以使用旧式充电器充电。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 目标接口：USB充电接口 class UsbCharger { public: virtual void charge() = 0; virtual ~UsbCharger() {} // 虚析构函数以确保正确释放派生类对象 }; // 具体实现：手机类，需要USB充电接口 class Phone { private: UsbCharger* charger; public: Phone(UsbCharger* c) : charger(c) {} void chargePhone() { std::cout \u0026lt;\u0026lt; \u0026#34;Connecting phone to charger...\u0026#34; \u0026lt;\u0026lt; std::endl; charger-\u0026gt;charge(); std::cout \u0026lt;\u0026lt; \u0026#34;Phone is charging.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 需要被适配的类：旧式充电器，只有圆形插头接口 class OldCharger { public: void oldCharge() { std::cout \u0026lt;\u0026lt; \u0026#34;Using old charger with round pin plug.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 适配器类：适配旧式充电器到USB充电接口 class UsbAdapter : public UsbCharger { private: OldCharger* oldCharger; public: UsbAdapter(OldCharger* oc) : oldCharger(oc) {} void charge() override { std::cout \u0026lt;\u0026lt; \u0026#34;Adapting old charger to USB...\u0026#34; \u0026lt;\u0026lt; std::endl; oldCharger-\u0026gt;oldCharge(); // 使用旧式充电器的方法 } }; // main函数演示如何使用这些类 int main() { OldCharger oldCharger; UsbAdapter usbAdapter(\u0026amp;oldCharger); Phone myPhone(\u0026amp;usbAdapter); myPhone.chargePhone(); return 0; } 输出：\n1 2 3 4 连接充电器... 适配旧式充电器为USB接口.... 使用旧式充电器（圆形插头）充电. 充电中. 即使 OldCharger 不直接兼容 Phone 所需的 USB 接口，通过 UsbAdapter，Phone 也能成功使用 OldCharger 来充电。这就是适配器模式的核心思想。\n享元模式 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n享元模式的核心思想\n内部状态：可以在多个对象之间共享的状态。 外部状态：不能在对象之间共享的状态，必须由客户端代码提供。 假设正在开发一个文本编辑器，其中每个字符都有其自己的格式（如颜色、字体大小等）。如果为每个字符都创建一个新的对象，这将消耗大量的内存。通过使用享元模式，可以共享那些具有相同格式设置的对象，从而减少内存使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; // 享元接口 class CharacterStyle { public: virtual void display(char ch) const = 0; }; // 具体享元类 class ConcreteCharacterStyle : public CharacterStyle { private: std::string color; int fontSize; public: ConcreteCharacterStyle(const std::string\u0026amp; color, int fontSize) : color(color), fontSize(fontSize) {} void display(char ch) const override { std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34;, Color: \u0026#34; \u0026lt;\u0026lt; color \u0026lt;\u0026lt; \u0026#34;, Font Size: \u0026#34; \u0026lt;\u0026lt; fontSize \u0026lt;\u0026lt; std::endl; } }; // 享元工厂 class CharacterStyleFactory { private: std::unordered_map\u0026lt;std::string, CharacterStyle*\u0026gt; styles; std::string getKey(const std::string\u0026amp; color, int fontSize) const { return color + \u0026#34;_\u0026#34; + std::to_string(fontSize); } public: CharacterStyle* getStyle(const std::string\u0026amp; color, int fontSize) { std::string key = getKey(color, fontSize); if (styles.find(key) == styles.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Creating new style for: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; styles[key] = new ConcreteCharacterStyle(color, fontSize); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Reusing existing style for: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; } return styles[key]; } ~CharacterStyleFactory() { for (auto\u0026amp; pair : styles) { delete pair.second; } } }; // 使用享元模式的客户端代码 void displayText(CharacterStyleFactory\u0026amp; factory, const std::string\u0026amp; text, const std::string\u0026amp; color, int fontSize) { for (char ch : text) { CharacterStyle* style = factory.getStyle(color, fontSize); style-\u0026gt;display(ch); } } int main() { CharacterStyleFactory factory; // 显示不同字符但相同格式的文本 displayText(factory, \u0026#34;Hello\u0026#34;, \u0026#34;Red\u0026#34;, 12); displayText(factory, \u0026#34;World\u0026#34;, \u0026#34;Red\u0026#34;, 12); // 显示不同格式的文本 displayText(factory, \u0026#34;Test\u0026#34;, \u0026#34;Blue\u0026#34;, 14); return 0; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Creating new style for: Red_12 Character: H, Color: Red, Font Size: 12 Character: e, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: o, Color: Red, Font Size: 12 Reusing existing style for: Red_12 Character: W, Color: Red, Font Size: 12 Character: o, Color: Red, Font Size: 12 Character: r, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: d, Color: Red, Font Size: 12 Creating new style for: Blue_14 Character: T, Color: Blue, Font Size: 14 Character: e, Color: Blue, Font Size: 14 Character: s, Color: Blue, Font Size: 14 Character: t, Color: Blue, Font Size: 14 CharacterStyle 类：这是享元接口，定义了所有具体享元类必须实现的方法 display()。 ConcreteCharacterStyle 类：实现了 CharacterStyle 接口的具体享元类。它包含了字符的格式信息（颜色和字体大小），并负责显示字符。 CharacterStyleFactory 类：这是一个享元工厂，用于管理和共享享元对象。它通过一个哈希表来存储已经创建的享元对象，并根据请求返回相应的享元对象。 displayText 函数：这是客户端代码，展示了如何使用享元工厂来获取和显示字符。 当第一次请求“Red_12”格式时，工厂会创建一个新的 ConcreteCharacterStyle 对象。 在后续请求相同格式（“Red_12”）时，工厂会重用之前创建的对象，而不是再次创建新的对象。 同样地，当请求不同的格式（如“Blue_14”）时，工厂会创建一个新的 ConcreteCharacterStyle 对象。 通过这种方式，享元模式有效地减少了内存使用，特别是在处理大量相似对象的情况下。\n桥接模式 一种结构型设计模式，它将抽象部分与其实现部分分离，使它们可以独立变化。这种模式通过提供一个桥梁接口来实现两个层次的抽象，使得系统更加灵活和可扩展。\n桥接模式的核心思想\n抽象部分：定义了高层控制逻辑，但不关心具体的实现细节。 实现部分：定义了底层的具体实现，但不关心如何被使用。 桥梁接口：将抽象部分与实现部分连接起来，使得两者可以独立变化。 假设要设计一个绘图应用，其中包含不同类型的形状（如圆形和矩形），并且这些形状可以在不同的渲染器上绘制（如矢量渲染器和光栅渲染器）。\n抽象部分：定义了形状的类型（如圆形、矩形）。 实现部分：定义了渲染器的具体实现（如矢量渲染器、光栅渲染器）。 桥梁接口：将形状与渲染器连接起来，使得两者可以独立变化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 实现部分：渲染器接口 class Renderer { public: virtual void renderCircle(float x, float y, float radius) const = 0; virtual ~Renderer() {} }; // 具体实现：矢量渲染器 class VectorRenderer : public Renderer { public: void renderCircle(float x, float y, float radius) const override { std::cout \u0026lt;\u0026lt; \u0026#34;VectorRenderer: Drawing Circle at (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;) with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; // 具体实现：光栅渲染器 class RasterRenderer : public Renderer { public: void renderCircle(float x, float y, float radius) const override { std::cout \u0026lt;\u0026lt; \u0026#34;RasterRenderer: Drawing Circle at (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;) with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; // 抽象部分：形状类 class Shape { protected: Renderer* renderer; public: Shape(Renderer* r) : renderer(r) {} virtual void draw() const = 0; virtual ~Shape() {} }; // 具体形状：圆形 class Circle : public Shape { private: float x, y, radius; public: Circle(float centerX, float centerY, float rad, Renderer* r) : Shape(r), x(centerX), y(centerY), radius(rad) { } void draw() const override { renderer-\u0026gt;renderCircle(x, y, radius); } }; // 客户端代码 void clientCode() { // 使用矢量渲染器绘制圆形 Renderer* vectorRenderer = new VectorRenderer(); Shape* circleWithVector = new Circle(1.0f, 2.0f, 3.0f, vectorRenderer); circleWithVector-\u0026gt;draw(); // 使用光栅渲染器绘制圆形 Renderer* rasterRenderer = new RasterRenderer(); Shape* circleWithRaster = new Circle(4.0f, 5.0f, 6.0f, rasterRenderer); circleWithRaster-\u0026gt;draw(); // 清理资源 delete circleWithVector; delete circleWithRaster; delete vectorRenderer; delete rasterRenderer; } int main() { clientCode(); return 0; } 这不就是把Renderer传给shape，让shape调用Renderer的renderCircle函数？而且Renderer类可以在运行时动态生成子类，可以把子类传给shape 从而实现shape能够调用任何Renderer子类的renderCircle函数.\n桥接模式的核心就是通过组合的方式，将抽象部分（如形状）与实现部分（如渲染器）解耦。具体来说，是通过将 Renderer 传给 Shape，使得 Shape 可以在运行时调用任何 Renderer 子类的 renderCircle 方法。这种方式不仅实现了分离关注点，还提供了极大的灵活性和可扩展性。\n桥接模式的关键点\n解耦抽象与实现：通过组合的方式，使得 Shape 和 Renderer 可以独立变化。 动态绑定：可以在运行时选择不同的 Renderer 实现，并将其传递给 Shape 对象。 灵活性：可以轻松添加新的 Shape 或 Renderer 类，而不需要修改现有代码。 备忘录模式 一种行为设计模式，它允许在不暴露对象实现细节的情况下保存和恢复对象的内部状态。这种模式通常用于需要回滚操作或撤销功能的场景中。\n备忘录模式的核心思想\n原发器（Originator）：负责创建和存储其内部状态的备忘录对象。 备忘录（Memento）：包含原发器对象的状态信息，但不允许其他对象访问这些信息，以保护封装性。 管理者（Caretaker）：负责保存备忘录对象，但不直接操作备忘录的内容。 假设正在开发一个简单的文本编辑器，用户可以输入文本并执行撤销操作。可以使用备忘录模式来保存和恢复文本编辑器的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 备忘录类 class Memento { public: std::string state; // 存储原发器的状态 // 只有原发器可以访问备忘录的私有成员 friend class TextEditor; Memento(){} Memento(const std::string\u0026amp; state) : state(state) {} std::string getState() const { return state; } }; // 原发器类 class TextEditor { private: std::string text; // 当前文本内容 public: void setText(const std::string\u0026amp; text) { this-\u0026gt;text = text; } std::string getText() const { return text; } // 创建备忘录 Memento createMemento() const { return Memento(text); } // 恢复状态 void restoreFromMemento(const Memento\u0026amp; memento) { text = memento.getState(); } }; // 管理者类 class History { public: void saveMemento(const Memento\u0026amp; memento) { this-\u0026gt;memento = memento; } Memento getMemento() const { return memento; } private: Memento memento; }; int main() { TextEditor editor; History history; // 编辑文本 editor.setText(\u0026#34;Version 1\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; // 保存状态 history.saveMemento(editor.createMemento()); // 继续编辑文本 editor.setText(\u0026#34;Version 2\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; // 恢复到之前的状态 editor.restoreFromMemento(history.getMemento()); std::cout \u0026lt;\u0026lt; \u0026#34;Restored Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 Current Text: Version 1 Current Text: Version 2 Restored Text: Version 1 代码说明\n备忘录类（Memento）： 存储原发器的内部状态（如文本内容）。 通过私有构造函数和友元类确保只有原发器可以创建和访问备忘录对象。 原发器类（TextEditor）： 负责创建备忘录对象（createMemento 方法）。 可以使用备忘录对象恢复自身状态（restoreFromMemento 方法）。 管理者类（History）： 负责保存备忘录对象（saveMemento 方法）。 不能修改备忘录对象的内容，只能获取备忘录对象（getMemento 方法）。 客户端代码： 使用原发器编辑文本并保存状态。 使用管理者保存备忘录对象。 使用备忘录对象恢复原发器的状态。 优点\n封装性： 备忘录模式在不破坏封装性的前提下保存和恢复对象的状态。 简化原发器： 将状态保存和恢复的逻辑分离到备忘录和管理者中，简化了原发器的代码。 可扩展性： 可以轻松地支持多次撤销操作（通过保存多个备忘录对象）。 缺点\n资源消耗： 如果对象的状态很大或需要保存多个状态，可能会消耗大量内存。 复杂性： 引入了备忘录和管理者类，增加了代码的复杂性。 中介模式 职责链模式 访问器模式 解析器模式 ","date":"1575-01-01T00:53:52+08:00","permalink":"http://localhost:1313/p/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"C++设计模式"},{"content":"简介 多线程 多线程是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。\n多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。\n关键概念\n线程：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。 并发：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。 并行：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。 并发，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。\n特性 并发（Concurrency） 并行（Parallelism） 定义 多个任务交替执行，看似同时运行。 多个任务真正同时执行。 硬件需求 单核 CPU 即可实现。 需要多核 CPU 或多个处理器。 目标 提高资源利用率，增强系统响应性。 提高计算性能，加快任务完成速度。 适用场景 I/O 密集型任务（如网络请求、文件读写）。 计算密集型任务（如科学计算、图像处理）。 实现方式 通过时间片轮转或事件循环实现。 通过多核 CPU 或分布式计算实现。 示例 单核 CPU 上运行多个线程。 多核 CPU 上同时运行多个线程。 并发示例：\n一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。 一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。 并行示例：\n使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。 使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。 多线程的作用\n提高性能：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。 提高响应性：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。 简化设计：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。 异步处理：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。 实际应用场景\nWeb 服务器： 场景：处理大量并发请求。 实现：每个请求由一个独立线程处理，主线程继续接收新请求。 优势：提高并发处理能力，减少响应时间。 图形用户界面（GUI）应用程序： 场景：执行耗时任务（如文件处理、网络请求）时保持界面响应。 实现：耗时任务在后台线程执行，主线程负责更新界面。 优势：避免界面卡顿，提升用户体验。 数据处理与计算： 场景：大数据处理或复杂计算（如图像处理、科学计算）。 实现：将数据分块，每个线程处理一块。 优势：充分利用多核 CPU，加快处理速度。 游戏开发： 场景：同时处理图形渲染、物理模拟、AI 计算等任务。 实现：不同任务由不同线程处理，通过同步机制协调。 优势：提高游戏性能和流畅度。 实时系统： 场景：需要快速响应的系统（如自动驾驶、工业控制）。 实现：关键任务由独立线程处理，确保实时性。 优势：提高系统响应速度和可靠性。 多线程与进程 在操作系统中，进程和线程是两个核心概念，而主线程是进程中的一个特殊线程。\n主线程是进程的一部分：进程是资源的容器，而主线程是进程内的执行单元。 主线程的生命周期与进程紧密相关： 当主线程开始执行时，进程开始运行。 当主线程执行完毕（main 函数返回）且没有其他非守护线程运行时，进程结束。 主线程与其他线程的关系： 主线程可以创建和管理其他线程。 主线程和其他线程共享进程的资源（如内存、文件句柄等）。 主线程的结束不会立即终止其他线程，但如果主线程结束且没有其他非守护线程，进程会终止。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void worker() { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread started.\u0026#34; \u0026lt;\u0026lt; std::endl; // 创建一个子线程 std::thread t(worker); // 主线程继续执行 std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; // 等待子线程结束 t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 输出\n1 2 3 4 5 Main thread started. Worker thread is running... Main thread is running... Worker thread finished. Main thread finished. 线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换要保存很多中间状态切换线程会耗费本该属于程序运行的时间.\n多线程-A 线程创建 线程的多种创建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;chrono\u0026gt; class Obj { public: Obj() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj is created\u0026#34; \u0026lt;\u0026lt; std::endl; } void operator()(int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Obj is called...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; } }; class Obj2 { public: Obj2() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj2 is created\u0026#34; \u0026lt;\u0026lt; std::endl; } void operator()() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj2 is called...\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Obj3 { public: void Func(int value) { std::cout\u0026lt;\u0026lt;\u0026#34;Obj3::Func() \u0026#34;\u0026lt;\u0026lt; value \u0026lt;\u0026lt;std::endl; } }; void worker(int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; } int main() { //------------------------// std::thread t(worker,1); t.join(); //------------------------// std::thread t2([](int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; }, 2); t2.join(); //------------------------// std::function\u0026lt;void(int)\u0026gt; Func = [](int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; }; std::thread t3(Func, 3); t3.join(); //------------------------// std::thread t4(Obj(), 4); t4.join(); //------------------------// Obj2 obj2; std::thread t5(obj2); t5.join(); //------------------------// Obj3 obj3; std::thread t6(\u0026amp;Obj3::Func,\u0026amp;obj3,233); //或 std::thread t6(\u0026amp;Obj3::Func,std::ref(obj3),233); t6.join(); return 0; } join 与 detach 行为 使用 join() 使用 detach() 主线程是否等待 是 否 子线程的生命周期 主线程等待子线程结束后才退出 子线程在后台运行，主线程不等待 资源管理 子线程资源在线程结束后自动释放 子线程资源在线程结束后自动释放 线程状态 主线程可以获取子线程的状态(如是否完成)。 主线程无法获取子线程的状态。 适用场景 需要确保子线程完成任务后再继续执行 子线程是独立任务，主线程无需等待 join() 的适用场景\n任务依赖： 主线程需要子线程的计算结果。 例如：并行计算中，主线程等待所有子线程完成并汇总结果。 资源清理： 主线程在退出前必须确保所有子线程已完成。 例如：多线程下载工具，主线程等待所有下载线程完成后再退出。 detach() 的适用场景\n后台任务： 子线程是独立任务，主线程无需关心其何时完成。 例如：日志记录线程、监控线程。 异步处理： 子线程执行耗时操作，主线程继续响应用户输入。 例如：GUI 应用程序中，后台线程处理文件读写，主线程保持界面响应。 如果需要确保子线程完成任务，使用 join()。 如果希望子线程在后台运行，使用 detach()。 不要既不调用 join() 也不调用 detach()，这会导致程序未定义行为。 被 detach() 的线程独立运行，主线程无法再控制或等待它。 子线程资源在线程结束后自动释放 当一个线程被 detach() 后，它变成了一个独立运行的线程，不再与创建它的线程（通常是主线程）关联。此时，线程的管理权交给了 C++ 运行时库 和 操作系统。\nC++ 运行时库：C++ 运行时库会负责管理线程的资源（如栈空间、线程 ID 等）。 操作系统：操作系统负责调度线程的执行，并在线程结束后回收其资源。 一旦线程被 detach()，就无法再通过 join() 等待其结束，也无法再获取其状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void task(int id) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时任务 std::cout \u0026lt;\u0026lt; \u0026#34;线程任务 \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; 完成.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { // 场景 1：使用 join() std::thread t1(task, 1); std::cout \u0026lt;\u0026lt; \u0026#34;主线程t1创建，调用join...\u0026#34; \u0026lt;\u0026lt; std::endl; t1.join(); // 主线程等待 t1 完成 std::cout \u0026lt;\u0026lt; \u0026#34;主线程在t1结束后继续.\u0026#34; \u0026lt;\u0026lt; std::endl; // 场景 2：使用 detach() std::thread t2(task, 2); std::cout \u0026lt;\u0026lt; \u0026#34;主线程t2创建，调用detach...\u0026#34; \u0026lt;\u0026lt; std::endl; t2.detach(); // 主线程不等待 t2，直接继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;t2已经分离，主线程继续运行...\u0026#34; \u0026lt;\u0026lt; std::endl; // 主线程等待一段时间，确保 t2 有机会运行 std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout \u0026lt;\u0026lt; \u0026#34;主线程完成.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 输出\n1 2 3 4 5 6 7 主线程t1创建，调用join... 线程任务 1 完成. 主线程在t1结束后继续. 主线程t2创建，调用detach... t2已经分离，主线程继续运行... 线程任务 2 完成. 主线程完成. 线程t1创建后 调用join()， t1在睡觉，主线程会卡住，2秒后 t1执行完毕 主线程才继续运行，线程t2创建后 调用detach()，此时 主线程不再等待t2，继续执行，与此同时t2在睡觉，2秒后睡醒 执行完毕.\njoinable() 用于检查一个线程对象是否可以被 join() 或 detach()。它的作用是判断线程对象是否关联了一个可执行的线程。管理线程生命周期的重要工具，尤其在多线程编程中需要确保资源正确释放时。\n检查线程状态： 如果线程对象关联了一个可执行的线程（即线程正在运行或尚未启动），则 joinable() 返回 true。 如果线程对象没有关联可执行的线程（即线程已经结束、被 join() 或 detach()），则 joinable() 返回 false。 在程序退出前，检查所有线程是否已完成，避免资源泄漏。 防止错误操作： 在调用 join() 或 detach() 之前，可以使用 joinable() 检查线程对象的状态，避免重复调用或无效调用。 如果线程已经被 join() 或 detach()，再次调用会导致程序崩溃。 线程状态 joinable() 返回值 线程已创建但未启动 true 线程正在运行 true 线程已结束但未调用 join() 或 detach() true 线程已被 join() false 线程已被 detach() false 默认构造的线程对象（未关联线程） false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void task() { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时任务 std::cout \u0026lt;\u0026lt; \u0026#34;Task finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(task); // 创建线程 // 检查线程是否可 join if (t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is joinable.\u0026#34; \u0026lt;\u0026lt; std::endl; t.join(); // 等待线程结束 } // 再次检查线程是否可 join if (!t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is no longer joinable.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 输出\n1 2 3 Thread is joinable. Task finished. Thread is no longer joinable. 线程传参 当一个线程被 detach() 后，它会独立运行，不再与创建它的线程（通常是主线程）关联。如果这个线程使用了 主线程或函数局部的资源（如局部变量、栈内存等），而主线程或函数结束后这些资源被销毁，会导致线程访问无效的内存，从而引发 未定义行为\n访问已释放的内存：\n如果线程访问了已经被销毁的局部变量或栈内存，可能会导致程序崩溃（如段错误）。 数据损坏：\n如果线程尝试修改已释放的内存，可能会导致数据损坏或其他不可预知的行为。 未定义行为：\n由于访问无效内存，程序的行为是不可预测的，可能表现为崩溃、输出错误结果，或者看似正常运行但隐藏严重问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; class MyString { public: MyString(const std::string\u0026amp; str) : str_(str) { std::cout \u0026lt;\u0026lt; \u0026#34;MyString 创建\u0026#34; \u0026lt;\u0026lt; std::endl; } // 显式定义拷贝构造函数 MyString(const MyString\u0026amp; other) : str_(other.str_) { std::cout \u0026lt;\u0026lt; \u0026#34;MyString 拷贝创建\u0026#34; \u0026lt;\u0026lt; std::endl; } std::string str_; }; // --------TaskA--------- // void TaskA(const MyString\u0026amp; message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskA: \u0026#34; \u0026lt;\u0026lt; message.str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskA() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskA, local_message); t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskA finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } // --------TaskA--------- // // --------TaskB--------- // void TaskB(MyString* message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskB: \u0026#34; \u0026lt;\u0026lt; message-\u0026gt;str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskB() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskB, \u0026amp;local_message); t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskB finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } // --------TaskB--------- // int main() { run_taskA(); run_taskB(); std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } TaskA成功运行，TaskB会发生错误.\n只调用TaskA的输出：发现有两个MyString创建了，\n1 2 3 4 5 MyString 创建 MyString 拷贝创建 run_taskA finished. TaskA: Hello, World! Main thread finished. 值传递：线程函数通过值传递的方式接收参数，线程内部会保存一份独立的拷贝，因此即使局部变量被销毁，线程仍然可以访问有效的数据。 拷贝构造函数：如果没有显式定义拷贝构造函数，编译器会生成默认的拷贝构造函数，执行浅拷贝，且不会输出日志。 生命周期：线程内部的拷贝对象的生命周期与线程绑定，在线程函数执行期间一直有效。 修复TaskB\n把detach改为join，run_taskB函数 会等待线程运行完成才结束.\n1 2 3 4 5 6 7 8 9 10 11 12 13 void TaskB(MyString* message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskB: \u0026#34; \u0026lt;\u0026lt; message-\u0026gt;str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskB() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskB, \u0026amp;local_message); t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskB finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 MyString 创建 TaskB: Hello, World! run_taskB finished. Main thread finished. 在这个例子中，TaskA创建了2个MyString，明明是常量引用，但实际上是值传递TaskB使用指针传递，两个MyString是同一个对象，那么在run_taskB结束后，这个MyString访问就错误了.detach子线程时 不能传递指针.\n在多线程编程中，正确传递函数参数非常重要，尤其是在涉及局部资源时。如果传递方式不当，可能会导致线程访问无效的内存，从而引发未定义行为。\n传递方式 适用场景 注意事项 值传递 大多数场景，确保线程安全 数据会被拷贝，可能有一定开销 引用传递 需要修改原始数据的场景 必须确保原始数据的生命周期长于线程 指针传递 需要共享数据的场景 使用智能指针（如 std::shared_ptr）管理资源，避免悬空指针 移动语义 大数据或不可拷贝的对象 转移所有权后，原始对象不再有效 Lambda 捕获 一次性使用的场景，简洁直观 通过值捕获或引用捕获传递参数 参数传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void func(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } int main() { char c[] = \u0026#34;world\u0026#34;; std::thread t(func, c); // 传递 C 风格字符串 t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } std::string 的创建时机：\n当线程函数 func 开始执行时，会尝试从 const char* 创建 std::string。 如果此时 c 已经被销毁，const char* 指向无效的内存，导致未定义行为。 情况 1：c 未被销毁\n如果线程在 c 被销毁之前完成了 std::string 的创建，程序会正常运行。 情况 2：c 被销毁\n如果线程在 c 被销毁之后才开始执行，尝试从已销毁的 c 创建 std::string，会导致未定义行为。 解决方法：\nstd::thread t(func, string(c))显式地将 char c[] 转换为 std::string. 1 2 char c[] = \u0026#34;world\u0026#34;; std::thread t(func, string(c)); string会在此时构造，在 c销毁之前 创建string。\nstd::thread t(func, string(c)) 构造了第一个string，传递给void func(const std::string\u0026amp; str)时，调用string的拷贝构造 又创建了第二个string.\n常量引用 在这个例子里，void func(const std::string\u0026amp; str)已经用常量引用了，还构造了2个string如果不使用常量引用，void func(std::string str) 不得构造3个string吗？\n不使用常量引用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; class A { public: int Value = -321; A() { cout \u0026lt;\u0026lt; \u0026#34;A 默认构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造 \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt;endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造 \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(A A) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; std::thread t(func, A(c)); t.detach(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 拷贝构造在 传入的a的基础上，将Value值加1，以此区分不同的拷贝构造.\n输出：\n1 2 3 4 5 6 7 A 初始化构造 1 A 拷贝构造 2 ~A 1 A 拷贝构造 3 Hello 3 ~A 3 ~A 2 拷贝构造了2个A， 一共有3个A被创造了，\n使用常量引用：\n把Func的参数改为常量引用\n1 2 3 4 void func(const A\u0026amp; A) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 A 初始化构造 1 A 拷贝构造 2 ~A 1 Hello 2 ~A 2 线程ID 线程 ID 是操作系统或运行时库为每个线程分配的唯一标识符,它用于区分和识别不同的线程。在多线程编程中，线程 ID 是一个重要的概念，可以帮助开发者调试、监控和管理线程。线程 ID 是唯一的、不可预测的，并且在线程销毁后失效。\n在 C++ 中，可以通过以下方式获取线程 ID：\n（1）当前线程的 ID\n使用 std::this_thread::get_id() 获取当前线程的 ID。 （2）线程对象的 ID\n使用 std::thread::get_id() 获取线程对象的 ID。如 t.get_id(); 使用线程ID 观察A类是在哪个线程里创建的，主线程还是子线程？\n常量引用版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } }; void func(const A\u0026amp; A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; int c = 1; std::thread t(func, A(c)); t.detach(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 输出：\n1 2 3 4 5 6 7 8 主线程ID: 2608 A 初始化构造1 线程ID: 2608 A 拷贝构造2 线程ID: 2608 A 析构1 线程ID: 2608 func子线程ID: 19240 Hello 2 A 析构2 线程ID: 19240 主线程ID:2608，子线程ID: 192402个A类的构造 都是在主线程完成的，但是第2个A类的析构却在子线程里.\n构造过程：\n在主线程中创建临时对象 A(c)。 由于函数参数是常量引用，编译器可能会进行一次拷贝构造以传递给子线程的函数。 因此，两个构造操作都在主线程中完成。 析构过程：\n第一个对象在主线程中被析构。 第二个对象在子线程中被析构。 值传递版本：\n1 2 3 4 5 void func(A A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 主线程ID: 12340 A 初始化构造1 线程ID: 12340 A 拷贝构造2 线程ID: 12340 A 析构1 线程ID: 12340 A 拷贝构造3 线程ID: 10368 func子线程ID: 10368 Hello 3 A 析构3 线程ID: 10368 A 析构2 线程ID: 10368 实际运行中，主线程ID:12340，子线程ID:10368，3个A类中， 前2个在主线程构造，第3个在子线程构造后2个都在子线程中析构.\n构造过程： 在主线程中创建临时对象 A(c)。 由于函数参数是按值传递，编译器会进行两次拷贝构造：一次是在主线程中创建临时对象，另一次是将该对象传递给子线程的函数。 因此，前两个构造操作在主线程中完成，第三个构造操作在子线程中完成。 析构过程： 第一个对象在主线程中被析构。 后两个对象在子线程中被析构。 上面测试的函数为 std::thread t(func, A(c));,如果是std::thread t(func, c); 会发生什么？\n常量引用版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void func(const A\u0026amp; A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; int c = 1; std::thread t(func, c); t.join(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 输出：\n1 2 3 4 5 6 主线程ID: 14908 A 初始化构造1 线程ID: 19900 func子线程ID: 19900 Hello 1 A 析构1 线程ID: 19900 构造过程： 由于直接传递整数 c，在子线程中通过构造函数 A(int V) 创建对象。 所有构造操作都在子线程中完成。 析构过程： 对象在子线程中被析构。 值传递版本：\n1 2 3 4 5 void func(A A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 6 主线程ID: 15064 A 初始化构造1 线程ID: 4928 func子线程ID: 4928 Hello 1 A 析构1 线程ID: 4928 构造过程： 类似于常量引用版本，所有构造操作都在子线程中完成。 析构过程： 对象在子线程中被析构。 可以看到，不管是 常量引用 还是 值传递，A类都在子线程中构造，并且只构造一次，虽然比std::thread t(func, A(c));构造次数的少，但是暗藏危机.\n总结\n常量引用版本 (std::thread t(func, A(c));): 构造操作主要在主线程中完成，但部分析构操作会在子线程中发生。 值传递版本 (std::thread t(func, A(c));): 构造操作分布在主线程和子线程中，析构操作主要在子线程中完成。 使用 std::thread t(func, c);: 不论是常量引用还是值传递，构造和析构操作都集中在子线程中完成。 在detach()情况下，使用常量引用版本的std::thread t(func, A(c)); 安全高效.\n线程传参-类对象 前面已经证实了，即便是常量引用，也会生成第二个类对象， 在常量引用的情况下，如果将类对象作为线程参数 在线程函数里面修改对象的数据，那么在主线程里面的那个 不会受到影响。\n主线程中有一个 A类型的 MyA 变量，在传给线程函数时，会调用拷贝构造 创建第二个A类，因此线程函数不会影响到MyA的数据。\n在线程中修改A对象 还有一个问题，因为是常量引用，所以无法修改，但是在变量前面添加mutable就能够修改.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: mutable int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(const A\u0026amp; A) { A.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; A MyA(5); std::thread t(func,MyA); t.join(); this_thread::sleep_for(chrono::seconds(1)); cout\u0026lt;\u0026lt;\u0026#34;主线程A的Value \u0026#34; \u0026lt;\u0026lt; MyA.Value \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 4 5 6 7 A 初始化构造5 A 拷贝构造6 子线程A的Value 123 A 析构123 主线程A的Value 5 A 析构5 虽然使用mutable让变量可修改，但是修改无效啊，并且如果要在线程中修改对象的内容，改的变量很多的话，那每个变量都要加mutable，这河里吗？\nstd::ref 在上面的例子中，要修改const的对象，并且修改了还无效， 双重错误，那有没有更好的办法呢？我们说 有的\nstd::ref 是 C++ 标准库中的一个工具，位于 \u0026lt;functional\u0026gt; 头文件中。它的主要作用是创建一个对象的引用包装器，使得函数参数可以按引用传递而不是按值传递。允许将引用传递给需要值传递的函数或对象这对于避免不必要的拷贝和确保对同一个对象进行操作非常有用，尤其是在使用标准库算法或线程时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(A\u0026amp; A) { A.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; A MyA(5); std::thread t(func,std::ref(MyA)); t.join(); this_thread::sleep_for(chrono::seconds(1)); cout\u0026lt;\u0026lt;\u0026#34;主线程A的Value \u0026#34; \u0026lt;\u0026lt; MyA.Value \u0026lt;\u0026lt; endl; return 0; } 输出:\n1 2 3 4 A 初始化构造5 子线程A的Value 123 主线程A的Value 123 A 析构123 std::ref为什么那么神奇？为什么会这样？\nstd::reference_wrapper 是一个模板类，其简化实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename T\u0026gt; class reference_wrapper { public: // 构造函数，接受一个引用并保存其地址 reference_wrapper(T\u0026amp; ref) : ptr(\u0026amp;ref) {} // 隐式类型转换运算符，将 reference_wrapper 转换为 T\u0026amp; operator T\u0026amp;() const { return *ptr; } private: T* ptr; // 保存引用的指针 }; 构造函数： reference_wrapper(T\u0026amp; ref) 接受一个引用，并将其地址保存到成员变量 ptr 中。 隐式类型转换运算符： operator T\u0026amp;() const 是一个类型转换运算符，它允许 reference_wrapper\u0026lt;T\u0026gt; 对象隐式转换为 T\u0026amp; 类型。 当需要 T\u0026amp; 类型时，编译器会自动调用这个运算符。 1 2 3 4 5 6 7 8 9 10 11 void func(A\u0026amp; a) { a.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; a.Value \u0026lt;\u0026lt; std::endl; } int main() { A MyA(5); std::thread t(func, std::ref(MyA)); // std::ref(MyA) 返回 reference_wrapper\u0026lt;A\u0026gt; t.join(); return 0; } 具体过程：\n传递参数： std::ref(MyA) 返回一个 std::reference_wrapper\u0026lt;A\u0026gt; 对象。 这个对象被传递给 std::thread 的构造函数。 线程内部存储： std::thread 将 std::reference_wrapper\u0026lt;A\u0026gt; 对象拷贝到线程的内部存储中。 调用线程函数： 当线程启动时，std::thread 会调用线程函数 func，并将存储的参数传递给它。 由于 func 的参数类型是 A\u0026amp;，而实际传递的是 std::reference_wrapper\u0026lt;A\u0026gt;，编译器会尝试将 std::reference_wrapper\u0026lt;A\u0026gt; 转换为 A\u0026amp;。 隐式转换： 编译器：编译器在调用线程函数时，发现参数类型不匹配（std::reference_wrapper\u0026lt;A\u0026gt; vs A\u0026amp;），于是尝试查找合适的转换方式。 隐式类型转换运算符：std::reference_wrapper\u0026lt;A\u0026gt; 中定义的 operator A\u0026amp;() 提供了从 std::reference_wrapper\u0026lt;A\u0026gt; 到 A\u0026amp; 的转换规则。 自动调用：编译器根据规则自动调用 operator A\u0026amp;()，完成类型转换。 总结\n隐式转换的触发：当 std::reference_wrapper\u0026lt;A\u0026gt; 需要转换为 A\u0026amp; 时，编译器会自动调用 operator A\u0026amp;()。 转换的实现：std::reference_wrapper 中定义的隐式类型转换运算符提供了转换规则。 应用场景：std::ref 通过 std::reference_wrapper 实现引用传递，适用于需要值传递但希望避免拷贝的场景。 智能指针 在多线程编程中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）可以有效地管理资源的生命周期，并避免内存泄漏和其他资源管理问题。\nshared_ptr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;memory\u0026gt; // 包含智能指针 class MyClass { public: MyClass(int value) : value_(value) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass 创建: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } ~MyClass() { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass 销毁: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } void print() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } int value_; }; void task(std::shared_ptr\u0026lt;MyClass\u0026gt; ptr) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 ptr-\u0026gt;print(); // 访问共享对象 ptr-\u0026gt;value_ = 100; } int main() { // 创建 shared_ptr auto ptr = std::make_shared\u0026lt;MyClass\u0026gt;(42); // 创建线程，传递 shared_ptr std::thread t(task, ptr); // 主线程继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;主线程继续执行...\u0026#34; \u0026lt;\u0026lt; std::endl; t.join(); // 等待线程结束 std::cout\u0026lt;\u0026lt;\u0026#34;主线程的Value:\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;value_\u0026lt;\u0026lt;std::endl; return 0; } 1 2 3 4 5 MyClass 创建: 42 主线程继续执行... Value: 42 主线程的Value:100 MyClass 销毁: 100 std::make_shared\u0026lt;MyClass\u0026gt;(42) 创建了一个 MyClass 对象，并由 std::shared_ptr 管理。 std::thread t(task, ptr) 将 ptr 传递给线程函数 task。 线程函数 task 通过 std::shared_ptr 访问 MyClass 对象。 当线程和主线程都结束时，std::shared_ptr 的引用计数变为 0，MyClass 对象被自动销毁。 std::unique_ptr\n1 2 3 4 5 // 创建 unique_ptr auto ptr = std::make_unique\u0026lt;MyClass\u0026gt;(42); // 创建线程，传递 unique_ptr（必须使用 std::move） std::thread t(task, std::move(ptr)); std::make_unique\u0026lt;MyClass\u0026gt;(42) 创建了一个 MyClass 对象，并由 std::unique_ptr 管理。 std::thread t(task, std::move(ptr)) 将 ptr 的所有权转移给线程函数 task。 线程函数 task 通过 std::unique_ptr 访问 MyClass 对象。 当线程结束时，std::unique_ptr 被销毁，MyClass 对象被自动销毁。 特性 std::shared_ptr std::unique_ptr 所有权 共享所有权，多个指针可以指向同一个对象 独占所有权，只能有一个指针指向对象 拷贝 可以拷贝 不能拷贝，只能移动 性能 有引用计数的开销 无额外开销 适用场景 需要共享所有权的场景 需要独占所有权的场景 线程安全：std::shared_ptr 的引用计数是线程安全的，但对象的访问需要额外的同步机制（如 std::mutex）。 多线程-B CPU 瞎jb转，线程跟了瞎jb干\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void MyPrint(int i) { cout \u0026lt;\u0026lt; \u0026#34;线程开始，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程结束，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;thread\u0026gt; threads; for (int i = 0; i \u0026lt; 10; i++) { threads.push_back(thread(MyPrint, i)); } for (auto\u0026amp; t : threads) { t.join(); } cout \u0026lt;\u0026lt; \u0026#34;main thread end\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 线程开始，编号：0线程开始，编号：线程开始，编号：线程开始，编号：线程开始，编号：6线程开始，编号：线程开始，编号：9 线程结束，编号：0 线程结束，编号：6 5 线程结束，编号：5 8 线程结束，编号：8 3线程开始，编号：1 线程结束，编号：1 线程开始，编号：2 线程结束，编号：2 线程结束，编号：9 4 线程结束，编号：4 线程开始，编号：7 线程结束，编号：7 线程结束，编号：3 main thread end 多个线程运行时确实会受到CPU时间片轮转（time-slicing）的影响。这是操作系统调度器用来管理多个线程或进程执行的一种机制。\n时间片轮转 是操作系统用于管理多线程环境下的CPU时间分配的一种机制。\n它会影响多线程程序的执行顺序和性能，尤其是上下文切换带来的开销。\n为了优化多线程程序，应该尽量减少不必要的上下文切换，合理分配任务，并使用合适的同步机制。\n数据共享 多个线程读取同一个数据\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; vec = { 1,2,3 }; void MyPrint(int i) { // cout \u0026lt;\u0026lt; \u0026#34;线程开始，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; \u0026#34;线程结束，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl cout\u0026lt;\u0026lt;\u0026#34;线程ID: \u0026#34;\u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; vec[0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; vec[1] \u0026lt;\u0026lt;\u0026#34; \u0026#34; \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; endl; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 线程ID: 线程ID: 线程ID: 21108线程ID: 线程ID: 线程ID: 21224线程ID: 线程ID: 183921 2 31 2 3 线程ID: 211761 2 3 线程ID: 222561 2 3 25601 2 3 1 2 3 220161 2 3 233601 2 3 229761 2 3 221361 2 3 main thread end 线程执行顺序不可控，如果一堆线程对同一个数据 有读有写，比如 多个线程读，同时有多个线程写，会造成错误。\n下面的代码会崩溃\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;format\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; class A { public: void InMsgQueue() { for (int i = 0;i \u0026lt; 100000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; MsgQueue.push_back(i); } } void OutMsgQueue() { for (int i = 0;i \u0026lt; 100000;i++) { if (!MsgQueue.empty()) { int Command = MsgQueue.front(); MsgQueue.pop_front(); } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } private: list\u0026lt;int\u0026gt; MsgQueue; }; int main() { A a; std::thread T_InMsg(\u0026amp;A::InMsgQueue, \u0026amp;a); std::thread T_OutMsg(\u0026amp;A::OutMsgQueue, \u0026amp;a); T_InMsg.join(); T_OutMsg.join(); return 0; } 互斥量 互斥量（Mutex）是一种同步机制，用于在并发编程中保护共享资源，确保在同一时间只有一个线程可以访问该资源。互斥量的主要目的是防止多个线程同时访问和修改共享数据，从而避免竞态条件（race condition）和其他并发问题。\n它的实现依赖于操作系统的底层同步机制，通常是对操作系统提供的原语（Windows 的 CRITICAL_SECTION）的封装。\n锁的状态通过原子操作或内存屏障来保证线程安全。\nstd::mutex 内部维护一个等待队列，用于存储被阻塞的线程。 当线程尝试获取锁时，如果锁已被其他线程持有，当前线程会被阻塞，并放入等待队列。 等待队列通常由另一个互斥锁（如 queue_mutex）保护，以确保线程安全。 当锁被释放时，操作系统会从等待队列中唤醒一个线程，使其继续执行。 当线程无法获取锁时，会调用操作系统的阻塞原语（如 futex 或 WaitForSingleObject）将线程挂起。 当锁被释放时，会调用操作系统的唤醒原语（如 futex_wake 或 WakeByAddressSingle）唤醒一个等待线程。 互斥量的工作原理\n锁定（Lock）：当一个线程想要访问共享资源时，它首先尝试获取互斥量的锁。如果互斥量当前没有被其他线程持有，则该线程成功获取锁，并开始访问共享资源。 解锁（Unlock）：当线程完成对共享资源的操作后，它会释放互斥量的锁，允许其他等待的线程获取锁并访问资源。 阻塞（Block）：如果一个线程尝试获取已经被其他线程持有的互斥量锁，该线程会被阻塞，直到持有锁的线程释放锁为止。 lock()：尝试获取互斥量的锁。如果锁已被其他线程持有，调用线程将被阻塞，直到锁可用。\ntry_lock()：尝试获取互斥量的锁，但不会阻塞。如果锁不可用，函数立即返回失败状态。\nunlock()：释放互斥量的锁，允许其他线程获取锁并访问共享资源。\nstd::mutex 是最基本的互斥量类型，适用于大多数场景。\nstd::recursive_mutex 支持递归锁定，适用于需要在一个线程中多次锁定同一个互斥量的情况。\nstd::timed_mutex 和 std::shared_timed_mutex 提供了带超时功能和共享锁的支持，适用于更复杂的同步需求。\n使用mutex，运行稳定，每次只有一个线程访问资源，但是线程运行顺序不稳定..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { private: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; mtx.lock(); MsgQueue.push_back(i); mtx.unlock(); } } bool OutMsg(int\u0026amp; InCommand) { mtx.lock(); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); mtx.unlock(); return true; } mtx.unlock(); return false; } void OutMsgQueue() { int command = 0; for (int i = 0;i \u0026lt; 2000;i++) { if (OutMsg(command)) { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } }; lock_guard 主播主播🥰你的牢锁确～实很强👍 但还是太吃操作了😇 有没有更加简单又强势的英雄推荐一下吗🧐 有的兄弟（战术停顿）有的😋 这么强势的英雄当～然是不止一个了🤓 一共有九位，都是当～前版本t～0.5的超～标英雄👉 告诉主播，你想学习哪个😤\nstd::lock_guard 通过 RAII 机制自动管理互斥量的锁定和解锁操作，从而避免手动管理锁可能导致的错误，如忘记释放锁或在异常情况下未能正确解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mtx); MsgQueue.push_back(i); } } bool OutMsg(int\u0026amp; InCommand) { std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mtx); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); return true; } return false; } lock_guard 构造时就上锁，析构时解锁.\n下面是lock_guard的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;class _Mutex\u0026gt; class _NODISCARD_LOCK lock_guard { // class with destructor that unlocks a mutex public: using mutex_type = _Mutex; explicit lock_guard(_Mutex\u0026amp; _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } lock_guard(_Mutex\u0026amp; _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don\u0026#39;t lock ~lock_guard() noexcept { _MyMutex.unlock(); } lock_guard(const lock_guard\u0026amp;) = delete; lock_guard\u0026amp; operator=(const lock_guard\u0026amp;) = delete; private: _Mutex\u0026amp; _MyMutex; }; 另一个构造函数是什么？ 两个构造函数的区别在于 第二个参数，\n1 2 lock_guard(_Mutex\u0026amp; _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don\u0026#39;t lock 当mutex已经上锁时，召唤lock_guard会再次对mutex上锁 就会错误， 因此有了这个版本的构造函数lock_guard构造时 不自动锁上mutex\n1 2 3 4 5 6 7 8 9 10 11 12 13 void thread_func() { // 手动锁定互斥量 mtx.lock(); // 使用 std::adopt_lock 告诉 lock_guard 互斥量已经被锁定 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 访问共享资源 std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock_guard 自动解锁互斥量 } 死锁 死锁（Deadlock）是并发编程中的一种常见问题，指的是两个或多个线程或进程在执行过程中，由于争夺资源而陷入无限等待的状态。每个线程都持有某些资源并等待获取其他线程持有的资源，导致所有这些线程都无法继续执行。\n有两个线程，都需要同时锁住两个互斥量，才可以进行某项操作，但它们分别都只锁住了一个互斥，都等着再给另一个互斥加锁。于是，双方毫无进展，因为它们同在苦苦等待对方解锁互斥，这种情形称为死锁。\n有两个线程A和B，两个锁L1和L2，两个线程都需要锁住L1、L2才能继续执行线程A执行时 先锁了L1，A正准备锁L2时 发生了上下文切换，此时，线程B开始执行，B锁住了L2，然后去锁L1， 此时 两个锁在两个不同的线程中锁住，发生死锁。\n这种情形下，没有任何一个线程能够同时拥有两个锁，没有任何一个线程能继续运行。\n因此，只要保证锁的顺序一致，就可避免死锁， 如:线程AB都先锁L1 再锁L2。\nstd::lock\nstd::lock 是 C++ 标准库提供的一个函数，用于原子化地锁定多个互斥量（mutex）。它的主要作用是避免在锁定多个互斥量时发生死锁。通过 std::lock，可以确保所有互斥量要么全部成功锁定，要么全部不锁定，从而避免了潜在的死锁问题。\n如果任何一个互斥量无法锁定，它会自动解锁之前已经锁定的所有互斥量，并重新尝试锁定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx1; std::mutex mtx2; void threadFuncA() { std::lock(mtx1, mtx2); // 原子化锁定两个互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); // 采用已锁定的互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 采用已锁定的互斥量 std::cout \u0026lt;\u0026lt; \u0026#34;Thread A acquired both mutexes.\u0026#34; \u0026lt;\u0026lt; std::endl; } void threadFuncB() { std::lock(mtx1, mtx2); // 原子化锁定两个互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); // 采用已锁定的互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 采用已锁定的互斥量 std::cout \u0026lt;\u0026lt; \u0026#34;Thread B acquired both mutexes.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(threadFuncA); std::thread t2(threadFuncB); t1.join(); t2.join(); return 0; } unique_lock std::unique_lock 是 C++ 标准库提供的一个通用的互斥量管理类，比 std::lock_guard 更加灵活。它提供了更丰富的功能来管理互斥量的锁定和解锁操作，适用于更复杂的并发场景。\n灵活性：与 std::lock_guard 不同，std::unique_lock 允许延迟锁定、尝试锁定和递归锁定等高级操作。 可移动但不可复制：std::unique_lock 可以通过移动语义进行转移，但不能被复制。 支持多种锁定策略：除了基本的锁定和解锁操作外，还支持尝试锁定（try_lock）、超时锁定（try_lock_for/try_lock_until）等功能。 手动管理锁状态：允许显式地锁定和解锁互斥量，这在某些需要更精细控制锁状态的场景中非常有用。 特性 std::unique_lock std::lock_guard 锁定时机 可以延迟锁定 总是在构造时锁定 解锁时机 可以手动解锁 总是在析构时解锁 锁定策略 支持多种锁定策略 仅支持锁定和解锁 可移动性 可移动 不可移动 适用场景 复杂的同步需求 简单的同步需求 使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 创建并锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } int main() { std::thread t1(threadFunc); std::thread t2(threadFunc); t1.join(); t2.join(); return 0; } unique_lock的构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 explicit unique_lock(_Mutex\u0026amp; _Mtx) // 构造并且锁住 unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) // 加强版 构造，假设已经锁定 unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) // 构造但不锁 unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) // 构造，尝试锁住 template \u0026lt;class _Rep, class _Period\u0026gt; unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) // 构造 超时锁 template \u0026lt;class _Clock, class _Duration\u0026gt; unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) // 构造 超时锁 ~unique_lock() noexcept { if (_Owns) { _Pmtx-\u0026gt;unlock(); }} 构造函数 功能 explicit unique_lock(_Mutex\u0026amp; _Mtx) 构造时立即锁定互斥锁。 unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) 接管已经锁定的互斥锁。 unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) 构造时不锁定互斥锁，后续手动锁定。 unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) 构造时尝试锁定互斥锁，失败不阻塞。 unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) 构造时尝试在指定相对时间内锁定互斥锁，超时失败。 unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) 构造时尝试在指定绝对时间点前锁定互斥锁，超时失败。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //unique_lock(_Mutex\u0026amp; _Mtx) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 创建并锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) void threadFunc() { mtx.lock(); // 手动锁定 mtx std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 假设 mtx 已经被锁定 std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 创建但不锁定 mtx std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟一些工作负载 lock.lock(); // 显式锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); // 尝试锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex.\u0026#34; \u0026lt;\u0026lt; std::endl; } } //unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::chrono::seconds(2)); // 尝试在2秒内锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex within 2 seconds.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex within 2 seconds.\u0026#34; \u0026lt;\u0026lt; std::endl; } } //unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) void threadFunc() { auto now = std::chrono::system_clock::now(); auto timeout = now + std::chrono::seconds(2); // 设置超时时间为当前时间加上2秒 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, timeout); // 尝试在指定时间点前锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex before the timeout.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex before the timeout.\u0026#34; \u0026lt;\u0026lt; std::endl; } } 其它函数\n名称 描述 lock 阻止调用线程，直到线程获取关联的 mutex 的所有权。 mutex 检索指向关联的 mutex 的存储指针。 owns_lock 指定调用线程是否拥有关联的 mutex。 release 解除 unique_lock 对象与关联的 mutex 对象的关联。 swap 将关联的 mutex 和所有权状态与指定对象的互换。 try_lock 在不阻止的情况下尝试获取关联 mutex 的所有权。 try_lock_for 在不阻止的情况下尝试获取关联 mutex 的所有权。 try_lock_until 在不阻止的情况下尝试获取关联 mutex 的所有权。 unlock 释放关联的 mutex 的所有权。 operator= 从指定对象复制存储的 mutex 指针和关联的所有权状态。 所有权转移：\nunique_lock重载运算符，接收一个右值unique_lock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 unique_lock\u0026amp; operator=(unique_lock\u0026amp;\u0026amp; _Other) noexcept /* strengthened */ { if (this != _STD addressof(_Other)) { if (_Owns) { _Pmtx-\u0026gt;unlock(); } _Pmtx = _Other._Pmtx; _Owns = _Other._Owns; _Other._Pmtx = nullptr; _Other._Owns = false; } return *this; } std::mutex mutexA; std::unique_lock\u0026lt;std::mutex\u0026gt; ulA(mutexA); std::unique_lock\u0026lt;std::mutex\u0026gt; ulB(std::move(mutexA)); 从函数返回局部unique_lock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::mutex mtx; std::unique_lock\u0026lt;std::mutex\u0026gt; get_unlocked_lock() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 创建但不锁定 mtx return lock; // 返回未锁定的 unique_lock } void threadFunc() { auto lock = get_unlocked_lock(); lock.lock(); // 显式锁定 mutex std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; lock.unlock(); // 显式解锁 mutex } 线程安全的cout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; // 定义一个全局互斥锁 std::mutex coutMutex; // 定义一个线程安全的输出类 class SafeCout { public: // 构造函数 SafeCout() = default; // 重载 \u0026lt;\u0026lt; 运算符，支持各种基本类型 template\u0026lt;typename T\u0026gt; SafeCout\u0026amp; operator\u0026lt;\u0026lt;(const T\u0026amp; value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(coutMutex); // 自动管理锁 std::cout \u0026lt;\u0026lt; value; return *this; // 返回当前对象，以便链式调用 } }; // 全局实例化 SafeCout 对象 SafeCout cout_f; condition_variable std::condition_variable 是 C++11 标准库中提供的一个同步原语，用于线程间的通信。它允许一个线程等待某个条件变为真，而另一个线程在条件满足时通知等待的线程继续执行。std::condition_variable 通常与 std::mutex 一起使用，以确保对共享资源的安全访问。\n基本概念\nstd::condition_variable：这是一个类模板，提供了等待和通知机制。它允许一个或多个线程等待某个条件变量被通知。 std::mutex：互斥锁，用于保护共享资源，防止多个线程同时访问导致数据竞争。 std::unique_lock\u0026lt;std::mutex\u0026gt;：与 std::mutex 配合使用，提供更灵活的锁定机制，并且可以与 std::condition_variable 结合使用。 主要方法\nstd::condition_variable 提供了以下主要方法：\nwait()：使当前线程阻塞，直到条件变量被通知。通常与 std::unique_lock 一起使用。 notify_one()：唤醒一个等待该条件变量的线程（如果有）。 notify_all()：唤醒所有等待该条件变量的线程。 wait函数： _Pred是谓词\n1 2 3 4 5 6 7 8 9 10 11 void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; _Lck) noexcept /* strengthened */ { // wait for signal // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow _Cnd_wait(_Mycnd(), _Lck.mutex()-\u0026gt;_Mymtx()); } template \u0026lt;class _Predicate\u0026gt; void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; _Lck, _Predicate _Pred) { while (!_Pred()) { wait(_Lck); } } 谓词返回 true： 初始检查时 _Pred() 返回 true，因此不会进入 while 循环，也不会调用 wait(_Lck)。 锁 _Lck 保持锁定状态，没有释放也没有重新获取。 谓词返回 false： 初始检查时 _Pred() 返回 false，进入 while 循环并调用 wait(_Lck)。 wait(_Lck) 会释放互斥锁 _Lck，使当前线程进入等待状态，直到被其他线程通过 notify_one() 或 notify_all() 唤醒。 被唤醒后，线程会重新获取互斥锁 _Lck 并再次检查谓词，直到谓词返回 true。 如果调用了没有谓词的wait版本，也就是第一个，那么相当于 谓词 返回了false. 解锁互斥量.\n使用场景\nstd::condition_variable 适用于以下几种常见场景：\n生产者-消费者问题：生产者生成数据并放入队列，消费者从队列中取出数据进行处理。当队列为空时，消费者等待；当队列中有数据时，生产者通知消费者。 任务调度：主线程等待子线程完成任务后继续执行。 事件驱动系统：一个线程等待某个事件发生，另一个线程在事件发生时通知等待的线程。 问题代码：不停的判断list是否为空，占用资源，有没有一种方法 当队列为空时，取队列的方法应该等待，有数据时 才进行读取，而不是不断的判空？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class A { private: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout \u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; unique_lock\u0026lt;mutex\u0026gt; lock(mtx); MsgQueue.push_back(i); } } bool OutMsg(int\u0026amp; InCommand) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); return true; } return false; } void OutMsgQueue() { int command = 0; for (int i = 0;i \u0026lt; 2000;i++) { if (OutMsg(command)) { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } }; 使用condition_variable\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class A { public: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; std::condition_variable cv; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); MsgQueue.push_back(i); cout \u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; list size:\u0026#34; \u0026lt;\u0026lt; MsgQueue.size() \u0026lt;\u0026lt; endl; cv.notify_all(); //把wait的线程唤醒,OutMsgQueue()里面的wait被唤醒 //...其它处理代码 } } void OutMsgQueue() { int command = 0; while (true) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); //返回false 解锁互斥量，堵塞在这里，直到其它线程调用notify_one()或notify_all()为止 //返回true 锁上，往下执行 cv.wait(lock, [this] {return !MsgQueue.empty();}); command = MsgQueue.front(); MsgQueue.pop_front(); cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt;\u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; list size:\u0026#34; \u0026lt;\u0026lt; MsgQueue.size() \u0026lt;\u0026lt; endl; lock.unlock(); } } }; 线程执行是反复横跳的，这一段运行起来的效果是，InMsgQueue已经给List插入了N个元素后，OutMsgQueue才执行，例如：InMsgQueue执行了2秒，然后才执行OutMsgQueue.notify_one也不会每次都生效，例如OutMsgQueue已经被唤醒了，正在执行wait之后的操作，没有卡在wait()，\n那么notify_one就不会唤醒OutMsgQueue，因为没有东西可以唤醒。\n有2个OutMsgQueue线程函数，线程A堵塞在wait，线程B已经被唤醒且正在执行一些被唤醒后的操作\nnotify_one() 的行为\n等待状态：\n只有当线程处于等待状态（即调用了 wait() 方法并且尚未返回）时，它才能被 notify_one() 唤醒。 如果一个线程已经从 wait() 返回并重新获得了互斥锁，则它不再是等待状态，不会被 notify_one() 唤醒 唤醒机制：\nnotify_one() 只会发出一次通知信号，尝试唤醒一个等待的线程。 操作系统会选择一个等待的线程来唤醒（如果有多个等待的线程，选择哪个线程是未定义的行为）。 如果没有等待的线程或被唤醒的线程没有实际开始运行（例如因为它已经被唤醒），则通知信号将被忽略。 谁决定了 notify_one() 唤醒哪一个线程？这是由操作系统级别的条件变量机制决定的：\n等待队列：所有等待在条件变量上的线程会被放入一个等待队列中。 选择机制：当 notify_one() 被调用时，操作系统会从等待队列中选择一个线程来唤醒。具体选择哪个线程是未定义的行为，通常取决于操作系统的调度策略。 notify_all() 的行为\n调用 notify_all()：所有等待的线程（如线程 A）会被唤醒，并尝试重新获取互斥锁。线程 B 不受影响，因为它不在等待状态。 竞争互斥锁：被唤醒的线程会竞争互斥锁，只有一个线程能够成功获取锁并继续执行，其他线程将继续等待。 可以确保所有等待的线程都有机会被唤醒并处理新的消息或任务。 单例模式 Magic Static\nC++11 引入了局部静态变量的线程安全初始化特性，即所谓的“Magic Static”。当一个函数内的局部静态变量被首次访问时，编译器会确保其初始化是线程安全的，并且只执行一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Singleton { public: // 获取单例对象的静态方法 static Singleton\u0026amp; getInstance() { static std::unique_ptr\u0026lt;Singleton\u0026gt; instance(new Singleton()); return *instance; } // 示例方法 void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton is doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数和析构函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton destroyed!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 禁用拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; }; 双重检查锁定（DCLP）\n双重检查锁定是一种优化的懒加载单例模式实现方式，通过减少锁的竞争来提高性能。它的核心思想是先检查指针是否为空，如果不是空则直接返回实例；如果是空，则进入临界区再次检查并创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: static Singleton* getInstance() { if (instance == nullptr) // 第一次检查 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); if (instance == nullptr) // 第二次检查 { instance = new Singleton(); } } return instance; } private: Singleton() {} // 私有构造函数防止外部实例化 static Singleton* instance; static std::mutex mutex_; }; Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex_; 在并发编程和计算机体系结构中，\u0026ldquo;reorder\u0026rdquo;（重排序）指的是编译器或处理器对指令执行顺序进行调整的过程。这种重排序旨在优化程序性能，但如果不加以适当控制，可能会导致多线程程序中的数据竞争和不一致问题。\n编译器重排序（Compiler Reordering）\n编译器为了优化代码的执行效率，可能会改变源代码中指令的实际执行顺序。这种优化通常基于静态分析，目的是减少指令依赖、提高流水线利用率等。例如：\n1 2 3 4 5 6 7 int a = 0; int b = 0; void foo() { a = 1; // 操作1 b = 2; // 操作2 } 编译器可能将 b = 2 放在 a = 1 之前执行，因为这两个操作是独立的，不会互相影响。然而，在多线程环境中，这样的重排序可能会导致不可预期的行为。\n处理器重排序（Processor Reordering）\n现代处理器为了提高指令吞吐量和执行效率，也会对指令执行顺序进行重排。处理器重排序通常发生在以下几种情况下：\n指令级并行：处理器可以同时执行多个独立的指令。 内存访问重排序：处理器可以重新安排读写内存的操作顺序，以减少缓存未命中和等待时间。 1 2 3 4 5 6 7 8 // 线程1 a = 1; flag = true; // 线程2 if (flag) { assert(a == 1); } 如果没有适当的同步机制，处理器可能会先执行 flag = true，然后再执行 a = 1，这会导致线程2在检查 flag 时看到 true，但在读取 a 时仍然看到旧值 0，从而导致断言失败。\n内存模型（Memory Model）\n为了处理这些重排序问题，C++ 标准引入了内存模型的概念。内存模型定义了多线程程序中可见性和顺序的规则。C++11 及之后的标准提供了多种内存顺序（memory order），用于显式地控制指令的执行顺序和可见性。\nstd::memory_order_relaxed：最宽松的内存顺序，仅保证原子操作本身的原子性，不提供任何同步或顺序保证。 std::memory_order_consume：消费操作，依赖于其他线程的写操作，并确保这些写操作在当前线程中可见。 **std::memory_order_acquire：获取操作，保证在此操作之后的所有读写操作都不会被重排到此操作之前。 std::memory_order_release：释放操作，保证在此操作之前的所有读写操作都不会被重排到此操作之后。 std::memory_order_acq_rel：结合获取和释放操作，适用于读-修改-写操作。 std::memory_order_seq_cst：最严格的内存顺序，提供全局顺序一致性，但可能会带来较大的性能开销。 volatile 关键字告诉编译器不要对该变量进行重排序和优化。然而，C++ 中的 volatile 并不能解决所有重排序问题，尤其是处理器级别的重排序问题。\n这种方法并不推荐，因为它无法解决所有重排序问题，特别是处理器级别的重排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton { public: static Singleton* getInstance() { if (instance == nullptr) { // 第一次检查 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); if (instance == nullptr) { // 第二次检查 instance = new Singleton(); } } return instance; } private: Singleton() {} static volatile Singleton* instance; // 使用 volatile static std::mutex mutex_; }; volatile Singleton* Singleton::instance = nullptr; 更推荐的方法是使用 std::atomic 和适当的内存顺序来显式地控制指令的执行顺序和可见性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; class Singleton { public: static Singleton* getInstance() { Singleton* tmp = instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire); if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Singleton(); std::atomic_thread_fence(std::memory_order_release); instance.store(tmp, std::memory_order_relaxed); } } return tmp; } private: Singleton() {} // 私有构造函数防止外部实例化 static std::atomic\u0026lt;Singleton*\u0026gt; instance; static std::mutex mutex_; }; std::atomic\u0026lt;Singleton*\u0026gt; Singleton::instance(nullptr); std::mutex Singleton::mutex_; std::memory_order_relaxed：用于初步检查 instance 是否为 nullptr，因为此时只需要保证原子性，不需要严格的同步保证。 std::atomic_thread_fence(std::memory_order_acquire)：在进入临界区之前使用获取内存屏障，确保读取到的 instance 值是最新的。 std::atomic_thread_fence(std::memory_order_release)：在存储 instance 之后使用释放内存屏障，确保所有写操作已经完成，其他线程可以看到最新的值。 特性 Magic Static 双重检查锁定 (DCLP) 实现复杂度 简单 复杂 线程安全性 内置线程安全 需要显式加锁 懒加载 支持，但不可控 完全可控 性能 高（无锁） 中等（较少锁竞争） 资源管理 自动管理生命周期 需要手动管理 依赖环境 需要 C++11 及以上标准 标准 C++，但需注意内存顺序问题 call_once std::call_once 是 C++11 标准库提供的一个工具，用于确保某个函数或可调用对象在多线程环境中仅被调用一次。它通常与 std::once_flag 一起使用，以实现线程安全的单次初始化。\nstd::call_once：这是一个函数模板，接受一个 std::once_flag 对象和一个可调用对象（如函数、lambda 表达式或函数对象）。它保证传入的可调用对象只会被执行一次，即使在多线程环境下多个线程同时尝试调用。 std::once_flag：这是一个特殊的标记对象，用来标识某个操作是否已经执行过。每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例。 std::once_flag 必须是全局或静态变量：每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例，并且该实例必须具有持久的生命周期（即不能是局部变量）。 std::call_once 和 std::once_flag 主要用于以下场景：\n单例模式：确保单例对象的初始化只发生一次。 全局变量初始化：确保某些全局资源或配置只初始化一次。 其他一次性操作：任何需要确保只执行一次的操作都可以使用 std::call_once。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; std::once_flag onceFlag; int initializedValue = 0; void initialize() { std::call_once(onceFlag, []() { initializedValue = 42; std::cout \u0026lt;\u0026lt; \u0026#34;Initialization complete.\u0026#34; \u0026lt;\u0026lt; std::endl; }); } void threadFunc(int threadId) { initialize(); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; threadId \u0026lt;\u0026lt; \u0026#34;: initializedValue = \u0026#34; \u0026lt;\u0026lt; initializedValue \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(threadFunc, 1); std::thread t2(threadFunc, 2); t1.join(); t2.join(); return 0; } 输出\n1 2 3 Initialization complete. Thread 1: initializedValue = 42 Thread 2: initializedValue = 42 单例使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { public: static Singleton\u0026amp; getInstance() { std::call_once(initFlag, []() { instance.reset(new Singleton()); std::cout \u0026lt;\u0026lt; \u0026#34;Singleton instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; }); return *instance; } void doSomething() const { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton instance doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } private: Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;) = delete; // 禁止拷贝构造 Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; // 禁止赋值操作 static std::unique_ptr\u0026lt;Singleton\u0026gt; instance; static std::once_flag initFlag; }; // 初始化静态成员变量 std::unique_ptr\u0026lt;Singleton\u0026gt; Singleton::instance = nullptr; std::once_flag Singleton::initFlag; int main() { std::thread t1([]() { Singleton\u0026amp; singleton = Singleton::getInstance(); singleton.doSomething(); }); std::thread t2([]() { Singleton\u0026amp; singleton = Singleton::getInstance(); singleton.doSomething(); }); t1.join(); t2.join(); return 0; } 异步 async \u0026amp; future std::async 是 C++11 标准引入的一个函数模板，用于启动异步任务。它允许你以一种简便的方式创建和管理异步任务，并且可以获取这些任务的返回值。std::async 返回一个 std::future 对象，该对象可以在稍后用来获取任务的结果。\nstd::future 是 C++11 标准库中的一部分，用于处理异步操作的结果。它提供了一种机制来获取异步任务的返回值或异常，并允许你等待任务完成。\n创建future\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //带有_Policy的构造 template \u0026lt;class Function, class... _ArgTypes\u0026gt; future\u0026lt;_Invoke_result_t\u0026lt;decay_t\u0026lt;Function\u0026gt;, decay_t\u0026lt;_ArgTypes\u0026gt;...\u0026gt;\u0026gt; async(launch _Policy, Function\u0026amp;\u0026amp; _Fnarg, _ArgTypes\u0026amp;\u0026amp;... _Args) //不指定_Policy 就会调用这个版本的构造，此版本将会调用带有_Policy的构造， //并且_Policy策略是launch::async+launch::deferred template \u0026lt;class Function, class... _ArgTypes\u0026gt; future\u0026lt;_Invoke_result_t\u0026lt;decay_t\u0026lt;Function\u0026gt;, decay_t\u0026lt;_ArgTypes\u0026gt;...\u0026gt;\u0026gt; async(Function\u0026amp;\u0026amp; _Fnarg, _ArgTypes\u0026amp;\u0026amp;... _Args) { return async(launch::async | launch::deferred, forward\u0026lt;Function\u0026gt;(_Fnarg), forward\u0026lt;_ArgTypes\u0026gt;(_Args)...); } _Policy：指定任务的执行策略，可以是 std::launch::async 或 std::launch::deferred，或者两者的组合（默认情况下是 std::launch::async | std::launch::deferred）。 _Fnarg：要异步执行的函数或可调用对象。 _Args：传递给函数 f 的参数。 1 2 3 4 STD enum class launch { // names for launch options passed to async async = 0x1, deferred = 0x2 }; 如果选择了 std::launch::async，则立即在一个新线程中启动任务。\n如果选择了 std::launch::deferred，则延迟执行任务，直到调用 get() 或 wait() 方法。\n调用 std::future::get() 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。\n如果任务已经完成，则直接返回结果。\nfuture的函数\n名称 描述 get 检索存储在关联异步状态中的结果。 share 将对象转换为 shared_future。 valid 指定对象是否不为空。 wait 阻止当前线程，直到关联异步状态为准备就绪。 wait_for 进行阻止，直到关联异步状态为准备就绪或已过指定时间。 wait_until 进行阻止，直到关联异步状态为准备就绪或直到指定时间点。 阻塞行为：当调用 get() 方法时，如果异步任务尚未完成，当前线程会被阻塞，直到任务完成并返回结果。 异常处理：如果异步任务抛出异常，get() 方法会重新抛出该异常，并且当前线程会被阻塞直到异常被抛出。 延迟执行：如果使用 std::launch::deferred 策略，get() 方法不仅会阻塞，还会触发任务的实际执行。 超时等待：可以使用 wait_for 或 wait_until 方法设置超时时间，避免无限期等待。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool loop = true; int add(int a, int b) { this_thread::sleep_for(std::chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;add\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; loop = false; return a + b; } int main() { // 启动异步任务 std::future\u0026lt;int\u0026gt; result = std::async(add, 5, 3); // 主线程继续做其他事情 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else.\\n\u0026#34;; while (loop) { std::cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; this_thread::sleep_for(std::chrono::milliseconds(1)); } // 获取异步任务的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread Get Result.\\n\u0026#34;; int sum = result.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 4 5 6 7 8 9 Main thread is doing something else. ..................................... .................................... ..................................... ......................................... .......................................... .....................................add .Main thread Get Result. Result: 8 异步不会卡主线程，主线程一直在打印\u0026hellip;. 直到子线程执行完毕，\n假如调用异步任务的结果时，异步线程还没有执行完成，主线程会堵塞 直到异步线程执行完毕。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int add(int a, int b) { this_thread::sleep_for(std::chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;add\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return a + b; } int main() { // 启动异步任务 std::future\u0026lt;int\u0026gt; result = std::async(add, 5, 3); // 主线程继续做其他事情 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else.\\n\u0026#34;; // 获取异步任务的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread Get Result.\\n\u0026#34;; int sum = result.get();//卡在这里 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 1 2 3 4 5 Main thread is doing something else. Main thread Get Result. //在这里卡住，等待异步结果出来 才继续执行。 add Result: 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyClass { public: // 成员函数，接受两个整数并返回它们的和 int computeSum(int a, int b) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 return a + b; } }; int main() { MyClass obj; // 创建类的对象 // 使用 std::async 启动异步任务，调用成员函数 computeSum auto future = std::async(\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); std::cout \u0026lt;\u0026lt; \u0026#34;Doing some work in the main thread.\u0026#34; \u0026lt;\u0026lt; std::endl; // 获取异步任务的结果 int result = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } std::launch\n1 2 3 4 STD enum class launch { // names for launch options passed to async async = 0x1, deferred = 0x2 }; 如果选择了 std::launch::async，则立即在一个新线程中启动任务。\n如果选择了 std::launch::deferred，则延迟执行任务，直到调用 get() 或 wait() 方法。\n调用 std::future::get() 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。\n如果任务已经完成，则直接返回结果。\n如果将上面创建future的函数改为\n1 auto future = std::async(std::launch::deferred,\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); 那么future的函数将会在主线程中执行，因为没有用launch::async.\n下面的两种方式都会在新线程中执行，\n1 2 3 4 //新线程延迟到get()时执行 auto future = std::async(\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); //新线程立即执行 auto future = std::async(std::launch::async,\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); async vs thread\n使用std::thread，如果系统资源紧张，线程创建会失败，执行std::thread可能导致程序崩溃.std::async是创建异步任务，使用launch::deferred时不创建新线程，\nasync构造函数 默认使用了 launch::async | launch::deferred，\n如果系统资源充足，可能会选择 std::launch::async 并创建一个新线程来立即执行任务。 如果系统资源紧张或任务数量较多，可能会选择 std::launch::deferred，延迟任务的执行，直到你请求其结果时才执行。 判断是否创建线程\n1 2 3 4 5 6 7 8 std::thread thread; std::future\u0026lt;int\u0026gt; future = std::async(func); std::future_status status = future.wait_for(std::chrono::seconds(0)); if (status == std::future_status::deferred) { //线程被延迟执行 std::cout\u0026lt;\u0026lt;future.get()\u0026lt;\u0026lt;std::endl; } wait_for\nwait_for 方法，允许你在指定的时间内等待异步任务完成。如果在指定时间内任务完成了，wait_for 会返回一个指示任务状态的枚举值；如果超时，则返回一个表示超时的状态。\n应用场景：当你希望避免无限期等待异步任务完成时，可以使用 wait_for 方法设置超时时间，并根据任务状态采取不同的操作。 1 2 template\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; 参数：timeout_duration 是一个时间间隔，指定了你愿意等待的最大时间。 返回值：返回枚举值，表示当前任务的状态： std::future_status::ready：任务已经完成。 std::future_status::timeout：任务未完成，并且达到了超时时间。 std::future_status::deferred：任务被延迟执行（仅适用于使用 std::launch::deferred 启动的任务）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; int longComputation(int x) { std::this_thread::sleep_for(std::chrono::seconds(3)); // 模拟长时间计算 return x * x; } int main() { // 使用 std::async 启动异步任务，并获取 std::future 对象 auto future = std::async(std::launch::async, longComputation, 5); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for the result with timeout...\u0026#34; \u0026lt;\u0026lt; std::endl; // 设置超时时间为1秒 auto status = future.wait_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;End Wait...\u0026#34; \u0026lt;\u0026lt; std::endl; switch (status) { case std::future_status::ready: std::cout \u0026lt;\u0026lt; \u0026#34;Result is ready: \u0026#34; \u0026lt;\u0026lt; future.get() \u0026lt;\u0026lt; std::endl; break; case std::future_status::timeout: std::cout \u0026lt;\u0026lt; \u0026#34;Timeout occurred before the result was ready.\u0026#34; \u0026lt;\u0026lt; std::endl; break; case std::future_status::deferred: std::cout \u0026lt;\u0026lt; \u0026#34;The task has been deferred and will be executed on call to get().\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return 0; } 输出： 函数执行需要3秒，但是只等待了1秒，超时。\n1 2 3 Waiting for the result with timeout... End Wait... Timeout occurred before the result was ready. std::packaged_task std::packaged_task 是 C++11 标准库中的一个类模板，用于封装可调用对象（如函数、lambda 表达式或函数对象），并允许你异步执行这些对象。它与 std::future 配合使用，可以获取任务的执行结果。\n主要用途\n封装可调用对象：将可调用对象（如函数、lambda 表达式或函数对象）封装到 std::packaged_task 中。 异步执行：可以在不同的线程中执行封装的任务，并通过 std::future 获取结果。 异常处理：如果任务抛出异常，可以通过 std::future::get() 捕获并重新抛出该异常。 名称 描述 get_future 返回具有相同关联异步状态的 future 对象。 make_ready_at_thread_exit 调用存储在关联异步状态中的可调用的对象，并以原子方式存储返回值。 reset 替换关联异步状态。 swap 将关联异步状态与指定对象交换。 valid 指定对象是否具有关联异步状态。 简单使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; int add(int a, int b) { return a + b; } int main() { // 创建一个 packaged_task，包装 add 函数 std::packaged_task\u0026lt;int(int, int)\u0026gt; task(add); // 获取与任务关联的 future std::future\u0026lt;int\u0026gt; result = task.get_future(); // 在另一个线程中执行任务 //move(task) 或 ref(task) std::thread t(std::move(task), 2, 3); t.join(); // 获取任务结果 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; std::endl; return 0; } promise std::promise 是 C++11 标准库中的一个类模板，用于在不同的线程之间设置异步结果或异常。它通常与 std::future 配合使用，以便在一个线程中设置值或异常，并在另一个线程中获取这些值或异常。\n主要用途\n设置异步结果：在一个线程中通过 std::promise 设置某个值。 获取异步结果：在另一个线程中通过关联的 std::future 获取该值。 异常处理：如果任务抛出异常，可以通过 std::promise 将异常传递给 std::future。 名称 描述 get_future 返回与此 promise 关联的 future。 set_exception 以原子方式设置此 promise 的结果以指示异常。 set_exception_at_thread_exit 以原子方式设置此 promise 的结果以指示异常，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。 set_value 以原子方式设置此 promise 的结果以指示值。 set_value_at_thread_exit 以原子方式设置此 promise 的结果以指示值，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。 swap 用指定的 promise 对象的关联的异步状态交换此 promise 的关联的异步状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void computeSum(std::promise\u0026lt;int\u0026gt;\u0026amp; prom, int a, int b) { int sum = a + b; prom.set_value(sum); // 设置结果 } int main() { std::promise\u0026lt;int\u0026gt; prom; std::thread t1(computeSum,std::ref(prom),2,3); t1.join(); std::future\u0026lt;int\u0026gt; fut = prom.get_future(); auto sum = fut.get(); std::cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 多个线程之间传值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void step1(std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = 10; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 1 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt;std::endl; } void step2(int input, std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = input * 2; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 2 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } void step3(int input, std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = input + 5; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 3 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } int main() { std::promise\u0026lt;int\u0026gt; p1, p2, p3; std::future\u0026lt;int\u0026gt; f1 = p1.get_future(); std::future\u0026lt;int\u0026gt; f2 = p2.get_future(); std::future\u0026lt;int\u0026gt; f3 = p3.get_future(); // 启动第一个步骤，并将结果存储在p1中 std::thread t1(step1, std::move(p1)); // 启动第二个步骤，并等待第一个步骤的结果，将结果存储在p2中 std::thread t2(step2, f1.get(),std::move(p2)); // 启动第三个步骤，并等待第二个步骤的结果，将结果存储在p3中 std::thread t3(step3, f2.get(), std::move(p3)); // 获取最终结果 int final_result = f3.get(); // 如果任务未完成，这里会阻塞 std::cout \u0026lt;\u0026lt; \u0026#34;Final result: \u0026#34; \u0026lt;\u0026lt; final_result \u0026lt;\u0026lt; std::endl; t1.join(); t2.join(); t3.join(); return 0; } 输出：\n1 2 3 4 Step 1 completed,Value:10 Step 2 completed,Value:20 Step 3 completed,Value:25 Final result: 25 shared_future std::shared_future 是 C++11 标准库中的一个类模板，它是 std::future 的扩展版本，允许多个线程共享同一个异步结果。与 std::future 不同的是，std::shared_future 可以被多次拷贝，并且每个拷贝都可以独立地获取异步任务的结果或异常。\nstd::shared_future 通常通过 std::future 的 share() 方法获得。一旦你有了 std::shared_future 对象，就可以在多个线程中使用它来获取异步结果。\n主要用途\n共享异步结果：允许多个线程共享同一个异步结果。 多次获取结果：可以在多个地方调用 get() 方法来获取同一个异步任务的结果，而不会导致阻塞或重复执行任务。 异常处理：如果任务抛出异常，可以通过 std::shared_future::get() 捕获并重新抛出该异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;Tool.h\u0026#34; int computeSum(int a, int b) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return a + b; } void printResult(const std::shared_future\u0026lt;int\u0026gt;\u0026amp; fut) { printf(\u0026#34;Result:%d \\n\u0026#34;, fut.get()); // 获取异步任务的结果 } int main() { // 使用 std::async 启动异步任务，并获取 std::future 对象 auto future = std::async(std::launch::async, computeSum, 5, 3); // 将 std::future 转换为 std::shared_future std::shared_future\u0026lt;int\u0026gt; sharedFut = future.share(); // 在多个线程中获取异步任务的结果 std::thread t1(printResult, sharedFut); std::thread t2(printResult, sharedFut); t1.join(); t2.join(); std::this_thread::sleep_for(std::chrono::seconds(3)); printf(\u0026#34;Main thread value:%d\u0026#34;, sharedFut.get()); return 0; } 输出：\n1 2 3 Result:8 Result:8 Main thread value:8 atomic std::atomic 是 C++11 标准库中的一个模板类，用于提供原子操作的支持。原子操作是指不可分割的操作，在多线程环境中可以保证对共享数据的访问是安全的，不会出现竞态条件（race condition）。\n原语：操作系统或编程语言提供的基本构建块或不可再分的操作单元。要么完全执行，要么完全不执行 原子：指那些不可分割的操作或数据结构，在并发环境中保持一致性。 原子化：将一系列操作视为一个不可分割的整体，确保这些操作要么全部成功，要么全部失败。 原子操作：在执行过程中不会被中断的操作，通常用于确保并发环境下的线程安全性。\n主要用途\n线程安全：确保对共享变量的操作在多线程环境中是线程安全的。 无锁编程：通过原子操作实现高效的无锁编程。 内存顺序控制：允许你控制内存顺序，以优化性能或确保特定的内存可见性。 基本概念\n原子类型：std::atomic\u0026lt;T\u0026gt; 是一个模板类，其中 T 是你要进行原子操作的数据类型。\n原子操作：包括读取、写入、交换、比较并交换等操作，这些操作都是原子性的，即它们不会被其他线程中断。\n函数：\nload()：获取当前值（原子读取）。\nstore(value)：设置新值（原子写入）。\nfetch_add(arg) 和 fetch_sub(arg)：增加或减少当前值，并返回旧值。\nfetch_and(arg), fetch_or(arg), fetch_xor(arg)：按位与、或、异或操作，并返回旧值。\ncompare_exchange_weak(expected, desired)\n如果 atomic 的当前值 (currentValue) 等于 expected： 将 atomicPoint 更新为 desired。 返回 true。更新成功。 如果 atomic 的当前值 (currentValue) 不等于 expected： 更新 expected 为 atomicPoint 的当前值 (currentValue)。 返回 false。更新失败。 compare_exchange_strong(expected, desired)\n与 compare_exchange_weak 类似，但没有伪失败的情况。\n基础操作\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::atomic\u0026lt;int\u0026gt; atomicInt(0); // 定义一个原子整型变量，并初始化为0 std::cout \u0026lt;\u0026lt; \u0026#34;Initial value: \u0026#34; \u0026lt;\u0026lt; atomicInt.load() \u0026lt;\u0026lt; std::endl; atomicInt.store(42); // 设置值为42 std::cout \u0026lt;\u0026lt; \u0026#34;Updated value: \u0026#34; \u0026lt;\u0026lt; atomicInt.load() \u0026lt;\u0026lt; std::endl; return 0; } 写数值\n每个线程让Value+10000, 5个线程的执行结果应该为：50000，但是每次运行的Value结果是随机的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; int Value = 0; void incrementCounter(int id) { for (int i = 0; i \u0026lt; 10000; ++i) { Value++; } } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都增加计数器 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(incrementCounter, i + 1); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } std::cout \u0026lt;\u0026lt; \u0026#34;Final counter value: \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; return 0; } 使用atomic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; std::atomic\u0026lt;int\u0026gt; atomicCounter(0); void incrementCounter(int id) { for (int i = 0; i \u0026lt; 10000; ++i) { atomicCounter.fetch_add(1); // 原子增加 } printf(\u0026#34;Thread %d done \\n\u0026#34;, id); } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都增加计数器 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(incrementCounter, i + 1); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } std::cout \u0026lt;\u0026lt; \u0026#34;Final counter value: \u0026#34; \u0026lt;\u0026lt; atomicCounter.load() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 4 5 6 Thread 2 done Thread 5 done Thread 4 done Thread 1 done Thread 3 done Final counter value: 50000 1 2 3 4 5 6 7 8 9 10 11 12 std::atomic\u0026lt;int\u0026gt; atm(0); atm += 1; //原子操作 atm = atm + 1;//不是原子操作 //读atm是原子操作，但这一行不是原子操作 cout\u0026lt;\u0026lt; atm \u0026lt;\u0026lt; endl; //使用load原子读值 atomic\u0026lt;int\u0026gt; atm2(atm.load()); auto atm3(atm.load()); //store原子写入 atm2.store(12); 自定义类型的原子操作\n虽然 std::atomic 支持大多数基本数据类型，但对于自定义类型，需要满足一些条件才能使用原子操作：\n类型必须是可平凡复制的（Trivially Copyable）。 类型必须有一个公共的默认构造函数。 如果你需要对自定义类型进行原子操作，可以通过封装和手动实现 CAS 操作来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; struct Point { int x, y; Point(int x_ = 0, int y_ = 0) : x(x_), y(y_) {} }; std::atomic\u0026lt;Point\u0026gt; atomicPoint(Point(0, 0)); void updatePoint(int dx, int dy) { Point oldVal, newVal; do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都更新点的位置 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(updatePoint, i, i); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } Point finalValue = atomicPoint.load(); std::cout \u0026lt;\u0026lt; \u0026#34;Final point position: (\u0026#34; \u0026lt;\u0026lt; finalValue.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; finalValue.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 有一个全局的原子变量 atomicPoint，它是一个 Point 结构体类型的对象。多个线程可能会同时尝试修改这个变量。为了确保这些修改是安全且没有冲突的，需要使用原子操作来实现这一点。\n1 2 3 4 5 6 7 8 9 std::atomic\u0026lt;Point\u0026gt; atomicPoint(Point(0, 0)); void updatePoint(int dx, int dy) { Point oldVal, newVal; do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); } 1 2 oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); load()：这是一个原子操作，用来读取 atomicPoint 当前的值，并将其存储在 oldVal 中，以便在此基础上计算新的值\nnewVal：基于 oldVal 和增量值 dx 和 dy 计算出的新 Point 对象。\n1 2 3 4 do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); compare_exchange_weak(oldVal, newVal)：这是一个关键的原子操作，用于比较并交换（CAS，Compare-And-Swap）。\n比较部分：首先检查 atomicPoint 当前的值是否与 oldVal 相等。 交换部分：如果相等，则将 atomicPoint 更新为 newVal，返回true；如果不相等，则不会更新 atomicPoint，而是更新 oldVal 为 atomicPoint 的当前值，返回false。 循环机制：\n如果 compare_exchange_weak 返回 false，说明在我们读取 oldVal 和尝试更新之间，有其他线程已经修改了 atomicPoint 的值。 此时，我们需要重新加载最新的 oldVal，重新计算 newVal，然后再次尝试更新。 如果在尝试更新时发现 atomicPoint 已经被其他线程修改，则重新加载最新值并重新计算新值，直到成功为止。 检查 atomicPoint 和 刚才读取的 atomicPoint (oldVal) 的值是否相同，如果值不一样，那就说明atomicPoint被其它线程篡改了。相等 ， 说明没有线程修改atomicPoint，可以把newVal给它，函数返回true不相等，说明有线程修改了atomicPoint ，此时就要把oldval给它，返回false，重新进入循环体计算newVal的值。\n多线程-C 线程池 服务器 \u0026mdash;\u0026gt; 客户端， 每来一个客户端 就创建一个新线程给客户服务.网络游戏 2万个玩家，不可能给每个玩家创建一个线程，创建线程可能会因为资源不够而失败，也有线程切换造成的消耗，\n线程池是一种设计模式，用于管理和复用一组工作线程，以提高应用程序的性能和资源利用率。它通过预先创建一组线程，并将这些线程放入一个“池”中，以便在需要执行任务时可以快速分配和重用这些线程，而不需要频繁地创建和销毁线程。\n通过复用一组工作线程来处理多个任务，减少了线程创建和销毁的开销，提高了系统的响应速度和资源利用率。\n线程数量过多，因为线程切换时 需要切换上下文，所以性能效率下降，\n线程池的主要优点\n减少线程创建和销毁的开销： 创建和销毁线程是一个相对昂贵的操作，涉及内存分配、上下文切换等。使用线程池可以避免频繁创建和销毁线程，从而提高性能。 提高响应速度： 当有新的任务到达时，线程池中的空闲线程可以立即开始处理任务，而不是等待新线程的创建。这使得应用程序能够更快地响应请求。 控制并发线程数量： 线程池允许你设定最大并发线程数，防止系统因为创建过多线程而导致资源耗尽或系统崩溃。 资源管理： 线程池可以更好地管理系统资源，确保不会因为过度创建线程而导致内存或其他资源的耗尽。 线程池的基本组成\n一个典型的线程池通常包含以下几个部分：\n任务队列（Task Queue）： 存储待执行的任务。当有新的任务提交到线程池时，任务会被加入到这个队列中。 工作线程（Worker Threads）： 预先创建的一组线程，负责从任务队列中取出任务并执行。 线程池管理器（Pool Manager）： 负责管理线程池的状态，包括创建和销毁线程、监控线程状态、处理任务队列等。 任务调度机制： 决定如何从任务队列中取出任务并分配给空闲的工作线程。 线程池的工作流程\n初始化线程池： 在程序启动时，线程池会根据配置预先创建一组工作线程，并将它们放入池中。 提交任务： 当有新的任务需要执行时，任务会被提交到线程池的任务队列中。 任务分配： 空闲的工作线程会从任务队列中取出任务并开始执行。 如果所有线程都在忙于执行任务，则新任务会被暂时存储在任务队列中，直到有线程空闲下来。 任务完成： 工作线程完成任务后，会返回线程池中继续等待下一个任务。 关闭线程池： 当不再需要线程池时，可以通过调用相应的 API 来关闭线程池，释放所有资源。 线程池的应用场景\nWeb服务器： 处理客户端请求时，每个请求都可以作为一个独立的任务交给线程池中的线程处理。 数据库查询： 数据库查询操作通常比较耗时，可以将查询请求提交到线程池中异步执行，避免阻塞主线程。 图像处理： 对大量图像进行处理时，可以将每张图像的处理任务提交到线程池中并发执行。 批量数据处理： 批量处理大量数据时，可以将每个数据块的处理任务提交到线程池中并行执行。 ","date":"1574-01-01T13:05:38+08:00","permalink":"http://localhost:1313/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"C++多线程"},{"content":"并发编程 A系列 使用的书 → C++并发编程实战（第2版）\n下载PDF\n启程上路 每个线程都需要一个起始函数(initial function), 新线程从这个函数开始执行。起始线程从main()开始执行，新线程则从hello()开始执行新线程启动后，起始线程继续执行。 如果起始线程不等待新线程结束， 就会一路执行， 直到main()结束，甚至很可能直接终止整个程序，新线程根本没有机会启动。 这正是要调用join()的原因,该调用会令主线程等待子线程.\n线程管控 确定采用多线程技术，从何入手？ 怎么启动线程？怎么查验它们是否已经结束？怎么监测其运行状态？如果给定一个线程, 只要令 std::thread 对象与之关联,就能管控该线程的几乎每个细节。 在本章中,从基础开始: 发起线程, 然后等待它结束, 或让它在后台运行。接着,将学习在启动时向线程函数传递参数,以及如何把线程的归属权从某个 std: :thread 对象转移给另一个.最后,会探讨怎样选择合适数量的线程,以及怎样识别特定的线程.\n线程调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void Hello() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;; } class task { public: void operator()() const { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Hello!\\n\u0026#34;; } }; int main() { task q; std::thread t1(q); t1.join(); std::thread t2((task())); t2.join(); std::thread t3([]() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Lambda!\\n\u0026#34;; }); t3.join(); } 输出: Hello Hello! Hello Hello! Hello Lambda! 主线程的局部变量被销毁后，分离的线程仍会访问局部变量，导致未定义行为.意图在函数中创建线程，并让线程访问函数的局部变量身。除非线程肯定会在该函数退出前结束，否则切勿这么做。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; class MyClass { public: int T_Time = 0; std::string Name = \u0026#34;Manba out\u0026#34;; }; void GetName(MyClass Class) { while (true) { Class.T_Time +=1 ; std::cout \u0026lt;\u0026lt; Class.T_Time \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; Class.Name \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; class Thread_guard { std::thread\u0026amp; t; public: Thread_guard(std::thread\u0026amp; t1) : t(t1){} ~Thread_guard() { if (t.joinable()) { t.join(); } } }; int main() { MyClass Manba; std::thread t1(GetName,Manba); Thread_guard tg(t1); std::this_thread::sleep_for(std::chrono::seconds(1)); } join? detach? join 使用 join 场景: 当你需要确保主线程等待子线程完成其任务后再继续执行时。 当子线程的结果或副作用对主线程很重要时。 优点: 确保线程资源被正确释放。 可以获取子线程的返回值（通过 std::future 和 std::promise）。 避免数据竞争和未定义行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void workerFunction(int id) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; finished\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(workerFunction, 1); std::thread t2(workerFunction, 2); t1.join(); // 主线程等待 t1 完成 t2.join(); // 主线程等待 t2 完成 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } detach 使用 detach 场景: 当你希望子线程独立运行，不需要主线程等待其完成时。 当子线程执行的任务是后台任务，且不需要与主线程交互时。 优点: 子线程可以独立运行，主线程可以继续执行其他任务。 适用于不需要等待结果的任务，如日志记录、监控等。 注意事项: 使用 detach 后，线程对象将不再与实际线程关联。 必须确保线程使用的资源（如动态分配的内存）在主线程结束前仍然有效，否则可能导致悬空指针或资源泄漏。 一旦线程被分离，无法再通过线程对象与其通信或等待其完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;memory\u0026gt; void backgroundTask(std::shared_ptr\u0026lt;int\u0026gt; data) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Background task finished with data: \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } int main() { auto data = std::make_shared\u0026lt;int\u0026gt;(42); std::thread t(backgroundTask, data); t.detach(); // 主线程不等待 t 完成 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 若要分离线程，则需在 std::thread对象上调用其成员函数 detach()。调用完成后， std::thread 对象不再关联实际的执行线程，故它变得从此不可汇合( 不可join)。如果要把std::thread 对象和线程分离，就必须存在与其关联的执行线程：若没有与 其关联的执行线程，便不能在std::thread对象上凭空调用 detach()。 这与调用join()的前 提条件毫无二致，检查方法完全相同，只有当t.joinable()返回true 时，我们才能调用 t.detach() .\n考虑一个应用程序，如文字处理软件。为了令它同时编辑多个文件，在用户界面层面和内部层面都有多种实现方式。一种常见的做法是,创建多个独立的顶层窗 口,分别与正在编辑的文件逐一对应。尽管这些窗口看起来完全独立， 各有自己的选项单,但它们其实都在同一应用程序的实例中运行。相应的内部处理是, 每个文件的编辑窗口都在各自线程内运行；每个线程运行的代码相同，而处理的数据有别， 因为这些数据与各文件和对应窗口的属性关联。按此，打开一个新文件就需启动一 个新线程。新线程只处理打开新文件的请求，并不牵涉等待其他线程的运行和结束。 对其他线程而言，该文件由新线程负责，与它们无关。综上，运行分离线程就成了首选方案。\n移交线程归属权 首先，我们启动新线程①,并使之关联t1。接着，构建t2.在其初始化过程中调用 std:;move()), 将新线程的归属权显式地转移给t2 ②。在②之前，t1关联着执行线程， some_function()函数在其上运行；及至②处，新线程关联的变换为t2。然后,启动另一新线程③，它与一个std::thread类型的临时对象关联。新线程的归属权随即转移给t1.这里无须显式调用std::move(), 因为新线程本来就由临时变量持有， 而源自临时变量的移动操作会自动地隐式进行。 t3按默认方式构造④，换言之，在创建时，它并未关联任何执行线程。在⑤处，t2 原本关联的线程的归属权会转移给t3，而t2是具名变量，故需再次显式调用 std::move(), 先将其转换为右值。经过这些转移，t1与运行 some_other_ function()的线程关联，t2没有关联线程，而t3与运行some_ function()的线程关联。在最后一次转移中⑥，运行some_function()的线程的归属权转移到t1. 该线程最初由t1启动。但在转移之时，t1已经关联运行 some_other_ function()的线程。因此 std: :terminate()会被调用，终止整个程序。\n从函数内部返回std::thread对象 std::thread 支持移动操作的意义是，函数可以便捷地向外部转移线程的归属权.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void Hello() { while (true) { std::cout\u0026lt;\u0026lt;\u0026#34;Hello \\n\u0026#34;; } } std::thread F() { std::thread t1(Hello); return t1; } int main() { std::thread MyThread = F(); MyThread.join(); std::this_thread::sleep_for(std::chrono::seconds(1)); } 输出: 很多Hello 类似地，若归属权可以转移到函数内部，函数就能够接收std::thread实例作为按右值传递的参数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Hello() { while (true) { std::cout\u0026lt;\u0026lt;\u0026#34;Hello \\n\u0026#34;; } } std::thread F() { std::thread t1(Hello); return t1; } void JoinThread(std::thread InThread) { InThread.join(); } int main() { std::thread MyThread = F(); JoinThread(std::move(MyThread)); std::this_thread::sleep_for(std::chrono::seconds(1)); } std::thead 支持移动语义给我们带来了不少好处。一个好处是，对 Thread_guard 类稍作修改，我们就能用其构建线程，并将线程交由该类掌管。另一个好处是，只要线程归属权转移给某个Thread_guard 对象，其他对象就无法执行汇合或分离操作。反之,假设std::thread 不支待移动语义，那么万一 Thread_guard 对象的生存期超出它管控的线程，将导致种种不良后果，事实上支持移动语义免除了这些麻烦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void do_work(unsigned id); void f() { std::vector\u0026lt;std::thread\u0026gt; threads; for(unsigned i = 0; i\u0026lt;20;++i) { threads.emplace_back(do_work,i); } for(auto\u0026amp; entry : threads) { entry.join(); } } 把std::thread对象存放到 std::vector容器内，向线程管控的自动化迈进了一步：若要为多个线程分别直接创建独立变量，还不如将它们集结成组，统一处理。\nstd::thread::hardware_concurrency() 函数，返回值表示程序在运行中可真正并发的线程数量。若信息无法获取，函数可能返回0.\n识别线程 线程ID 所属型别是 std::thread::id,\n1 2 3 void f(); std::thread t(f); std::thread::id ID = t.get_id(); 在与线程关联的 std: :thread 对象上调用成员函数get_idQ,即可得到该线程的 ID如果 std::thread 对象没有关联任何执行线程，调用get_id则会返回一个 std::thread::id 对象，它按默认构造方 式生成，表示“线程不存在＂。\n线程 ID, 可随意进行复制操作或比较运算。如果两个std::thread::id型别的对象相等，则它们表示相同的线程，或者它们的值都表示“线程不存在＂；如果不相等,它们就表示不同的线程，或者当中一个表示某个线程，而另一个表示\u0026quot;线程不存在“.\n主线程负责发起其他线程，它可能需要承担稍微不一样的工作。若需在该例中识别主线程，我们可以在发起其他线程之前， 在主线程中预先保存std::this_thread::get_id()的结果.只要对比各线程预存的值和自身的线程ID, 就能做出判断.\n1 2 3 4 5 6 7 8 9 std::thread::id master_thread; void some_core_part_of_algorithm() { if(std::this_thread::get_id() == master_thread) { do_master_thread_work(); } do_common_work(); } 线程间共享数据 运用多线程实现并发，其中一个好处是，它具备潜能，可以简单、直接地共享数据。\n设想你有一段时间和朋友合租公寓，公寓只有一个厨房和一个浴室。除非你们的感情格外深厚， 否则不可能同时使用浴室。另外,假若朋友占用浴室很久,而你恰好也需要,便会感到不方便。类似地,假设你们使用的是组合烤箱,尽管可以同时烹任,但若一人要烤香肠,同时另一人却要烘蛋糕, 结果应该不会太好。 并且,我们也清楚共用办公空间的烦恼:事情还没做完,有人却借走了工作所需之物,或者半成品被别人擅自更改。线程亦如此,若在线程之间共享数据，我们需要遵循规范:具体哪个线程按何种方式访问什么数据；还有，一旦改动了数据,如果牵涉到其他线程, 它们要在何时以什么通信方式获得通知。 同一进程内的多个线程之间，虽然可以简单易行地共享数据， 但这不是绝对的优势，有时甚至是很大的劣势。 不正确地使用共享数据，是产生与并发有关的错误的一个很大的诱因，其后果远比“香肠口味的蛋糕“严重。\n线程间共享数据的问题 如果多个线程共享数据,只要一个线程开始改动数据,就会带来很多隐患,产生麻烦。\n条件竞争 设想你去电影院购票看电影。大型影院有几位收银员同时收款,以便多人同时购票。 别人也在其他柜台购买电影票,倘若有人选择的场次与你相同, 那么,供选择的座位取决于你们谁先下单。如果只剩少量座位,事实上就形成了竞争,谁能买到最后几张票,下单的先后顺序至关重要。以上事例即为条件竞争:你得到什么座位 (甚至是否能买到票) 取决于购票的相对次序。\n诱发恶性条件竞争的典型场景是，要完成一项操作，却需改动两份或多份不同的数据.因为操作涉及两份独立的数据,而它们只能用单独的指令改动,当其中一份数据完成改动时,别的线程有可能不期而访。因为满足条件的时间窗口短小，所以条件竞争往往既难察觉又难复现。\n恶性条件竞争普遇“挑剔”出现的时机，当应用程序在调试环境下运行时,它们常常会完全消失,因为调试工具影响了程序的内部执行时序,哪怕只影响一点点。\n编写多线程程序，恶性条件竞争很可能成为致命伤；采用并发技术的软件会涉及许多复杂的逻辑，其目的正是避开恶性条件竞争。\n用互斥保护共享数据 访问一个数据结构前， 先锁住与数据相关的互斥；访问结束后， 再解锁互斥。 C++线程库保证了， 一旦有线程锁住了某个互斥，若其他线程试图再给它加锁, 则须等待,直至最初成功加锁的线程把该互斥解锁。互斥是C++最通用的共享数据保护措施之一，但非万能的灵丹妙药。互斥本身也有问题，表现形式是死锁、对数据的过保护或欠保护.\n在C＋＋中使用互斥 通过构造 std::mutex 的实例来创建互斥， 调用成员函数 lock()对其加锁，调用unlock()解锁。\n不推荐直接调用成员函数的做法。 原因是, 若按此处理, 那我们就必须记住,在函数以外的每条代码路径上都要调用 unlock(), 包括由于异常导致退出的路径。 取而代之， C++-标准库提供了类模板 std::lock_guard\u0026lt;\u0026gt;， 针对互斥类融合实现了 RAII 手法:在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int T_Value = 0; void func() { for (int i = 0;i\u0026lt;10000000 ; i++) { T_Value = T_Value + 1; T_Value = T_Value - 1; } } int main() { std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout\u0026lt;\u0026lt;T_Value\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } 输出：完全随机的数 T_Value总是 +1 再-1，最终结果应该为0才对，这就是线程不上锁的结果，导致乱序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int T_Value = 0; std::mutex T_Mutex; void func() { for (int i = 0;i\u0026lt;10000000 ; i++) { std::lock_guard guard(T_Mutex); T_Value = T_Value + 1; T_Value = T_Value - 1; } } 手动使用锁的方法 for (int i = 0;i\u0026lt;10000000 ; i++) { T_Mutex.lock(); T_Value = T_Value + 1; T_Value = T_Value - 1; T_Mutex.unlock(); } 利用互斥保护共享数据并不太简单，我们不能把std::lock_guard对象化作“铁拳”，对准每个成员函数施予“重击“。一旦出现游离的指针或引用，这种保护就全部形同虚设。不管成员函数通过什么”形式”——无论是返回值，还是输出参数(out parameter) ——向调用者返回指针或引用，指向受保护的共享数据，就会危及共享数据安全。\n死锁:问题和解决方法 假设一件玩具由两部分组成，需要同时配合才能玩，譬如玩具鼓和鼓槌； 又假设有两个小孩都喜欢这件玩具。倘若其中一个孩子拿到了玩具鼓和鼓槌，那他就能尽兴地一直敲鼓，敲烦了才停止。如果另一个孩子也想玩，便须等待，即使感到难受也没办法。 再想象一下，玩具鼓和鼓槌分散在玩具箱里，两个小孩同时都想玩。于是，他们翻遍玩具箱， 其中一人找到了玩具鼓，另一人找到了鼓槌， 除非当中一位割爱让对方先玩，否则，他们只会僵待不下，各自都紧抓手中的部件不放，还要求对方＂缴械＂，结果都玩不成。\n我们面对的并非小孩争抢玩具，而是线程在互斥上争抢锁：有两个线程，都需要同时锁住两个互斥，才可以进行某项操作，但它们分别都只锁住了一个互 斥，都等着再给另一个互斥加锁。于是，双方毫无进展，因为它们同在苦苦等待对方解 锁互斥。上述情形称为死锁（deadlock)。为了进行某项操作而对多个互斥加锁， 由此诱发的最大的问题之一正是死锁。\n防范死锁的建议通常是，始终按相同顺序对两个互斥加锁。若我们总是先锁互斥A 再锁互斥B，则永远不会发生死锁。有时候，这直观、易懂，因为诸多互斥的用途各异。 但也会出现棘手的状况，例如，运用多个互斥分别保护多个独立的实例， 这些实例属于同一个类。考虑一个函数，其操作同一个类的两个实例，互相交换它们的内部数据。为了保证互换正确完成，免受并发改动的不良影响，两个实例上的互斥都必须加锁。可是， 如果选用了固定的次序（两个对象通过参数传入，我们总是先给第一个实例的互斥加锁， 再轮到第二个实例的互斥），前面的建议就适得其反：针对两个相同的实例，若两个线程都通过该函数在它们之间互换数据，只是两次调用的参数顺序相反，会导致它们陷入死锁.\n所幸， C++标准库提供了 std::lock()函数，专门解决这一问题。它可以同时锁住多个互斥，而没有发生死锁的风险。\n下列代码中，传入构造函数的两个互斥都被加锁，机制与std::lock()函数相同， 因此，当构造函数完成时，它们就都被锁定，而后，在析构函数内一起被解锁。我们可以重写代码清单3.6 的swap()函数，其内部操作代码如下\n1 2 3 4 5 6 7 8 9 void swap(X\u0026amp; lhs,X\u0026amp; rhs) { if(\u0026amp;lhs==rhs) { return; } std::scoped_lock guard(lhs.m,rhs.m); swap(lhs.some_detail,rhs.some_detail); } 上例利用了C++17加入的另一个新特性：类模板参数推导.依据传入构造函数的参数对象自动匹配 选择正确的互斥型别。 等价于:\n1 std::scoped_lock\u0026lt;std::mutex,std::mutex\u0026gt; guard(lhs.m,rhs.m) 在C++17 之前，我们采用std::lock()编写代码。 现在有了 std::scoped_lock, 于是那些代码绝大多数可以改用这个编写，从而降低出错的概率。\n防范死锁的补充准则 虽然死锁的最常见诱因之一是锁操作,但即使没有牵涉锁,也会发生死锁现象。假定有两个线程， 各自关联了 std; :thread 实例，若它们同时在对方的 std::thread实例上 调用join(),就能制造出死锁现象却不涉及锁操作。 如果线程甲正等待线程乙完成某一动作， 同时线程乙却在等待线程甲完成某一动作， 便会构成简单的循环等待.引起死锁.防范死锁的准则最终可归纳成一个思想:只要另一线程有可能正在等待当前线程，那么当前线程千万不能反过来 等待它。\n避免嵌套锁 第一条准则最简单：假如已经持有锁，就不要试图获取第二个锁。若能恪守这点， 每个线程便最多只能持有唯一一个锁，仅锁的使用本身不可能导致死锁。但是还存在其他可能引起死锁的场景（譬如,多个线程彼此等待）,而操作多个互斥锁很可能就是最常见的死锁诱因。万一确有需要获取多个锁，我们应采用 std::lock()函数，借单独的调用动作一次获取全部锁来避免死锁。\n一旦持锁，就须避免调用由用户提供的程序接口 依从固定顺序获取锁 B: 原子性 原子性:一段代码独占整个计算机系统单处理器多线程: 线程在运行时可能被中断，切换到另一个线程运行.多处理器多线程: 线程根本就是并行执行的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void thread1() { while (1){printf(\u0026#34;a\u0026#34;);} } void thread2() { while (1) { printf(\u0026#34;b\u0026#34;);} } int main() { std::thread s1(thread1); std::thread s2(thread2); s1.join(); s2.join(); } printf没有打印出乱码，一直是a或b，因为它线程安全，保证多线程的原子性.\n","date":"1573-01-01T17:59:51+08:00","permalink":"http://localhost:1313/p/c-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-a-1/","title":"C++ 并发编程 A - 1"},{"content":"模板专题\n设计模式专题\n构造 赋值 析构 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { String s1(); String s2(\u0026#34;Hello\u0026#34;); // 拷贝构造 String s3(s1); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; // 拷贝赋值 s3 = s2; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; } 不写这些函数，编译器自动写.\n构造 析构 String类，手动定义 构造、赋值、析构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 String::String(const char* cstr = 0) { if(cstr) { // 字符长度+1 的+1 是结尾符号\u0026#39;\\0\u0026#39; m_data = new char[strlen(cstr)+1]; strcpy(m_data,cstr); } else { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } } String::~String() { //清理动态分配的数组内存[] delete[] m_data; } { String s1(); String s2(\u0026#34;hello\u0026#34;); String* p = new String(\u0026#34;hello\u0026#34;); delete p; } // 离开作用域，s1 s2自动释放 析构，p要delete. 拷贝构造 b=a 浅拷贝， b的data指向a的data的区域，导致b原本的\u0026quot;World\\0\u0026quot;内存泄露， 当a的data修改后，b跟着受影响.\n深拷贝，空间创建出以后 把内容拷贝过去.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 String::String(const String\u0026amp; str) { m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); } { String s1(\u0026#34;hello\u0026#34;); 下面两行意思相同 String s2(s1); //String s2 = s1; 忽略上面一行，s2是新创建出的对象，调用构造函数 } 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）.按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。\n深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）\n拷贝赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String\u0026amp; String::operator=(const String\u0026amp; str) { // 必写 检测自我赋值 if(this == \u0026amp;str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); return *this; } { String s1(\u0026#34;hello\u0026#34;); String s2(s1); s2 = s1; } 检测自我赋值，避免delete自杀\n流重载要写到类外\n1 2 3 4 5 6 7 8 9 10 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const string\u0026amp; str) { os \u0026lt;\u0026lt; str.get_c_str(); return os; } { String s1(\u0026#34;hello\u0026#34;); cout \u0026lt;\u0026lt; s1; } stack 栈 heap堆 stack是存在于某作用域的一块内存空间。调用函数时 函数本身会形成一个stack用来存放它接收的参数 和 返回地址在函数本体内声明的任何变量，其所使用的内存块都取自stack.heap 或 system heap ,是操作系统提供的一块 global内存空间，程序可动态分配从其中获得区块. new出来的东西必须手动delete\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Complex{...}; { Complex c1(1,2); Complex* p = new Complex(3); static Complex c3(1,2); //释放p，否则p离开作用域后就死亡了，会对内存失去控制，导致内存泄露，无法把内存还给系统 delete p; } //c1占用的空间来自stack. //Complex(3)是临时对象，占用的空间是以new自heap动态分配来的，并由p指向. //c1是stack object，生命在作用域结束的时候结束， //在作用域内的object 又称为 auto object，因为会被自动清理. //c3是static object,生命在作用域结束后仍然存在，直到整个程序结束. 1 2 3 4 5 6 7 8 9 10 class Complex{...}; Complex c4(1,2) int main() { } //C4是global object,生命在整个程序结束才结束。其作用域是 整个系统. new : 先分配内存，再调用构造 。 new内部调用malloc(n)\n1 2 3 4 5 6 Complex* pc = new Complex(1,2); //编译器转化为: void* mem = operator new( sizeof(Complex) ); pc = static_cast\u0026lt;Complex*\u0026gt;(mem); pc-\u0026gt;Complex::Complex(1,2); //实际是Complex::Complex(pc,1,2); delete:先调用析构， 再释放内存\n1 2 3 4 5 6 String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 1 2 3 4 5 6 7 8 9 10 class Complex { double A; double B; } class String { char* m_data; } VC内存 Complex、String被 new 出来之后的内存\n调试模式下的Complex的头尾都有 00000041 这一串数据，称为 cookie，这一个东西在delete时要用到. 末尾的1 表示内存以及分配出去，4表示其大小64，绿色块用来把内存大小从52填充为64Release模式下的Complex头尾有00000011,1表示大小为16. 当Complex被回收后，这一串数值会变成00000010，末尾的0表示已经被回收的内存.00000000 和 00000001 分别是0和16，只差一位，但十进制上差的是16，由于对象的内存大小必须是16的倍数，所以16以及16以下的数据 都是没有用到的，可以拿来做内存 分配出去 与 回收 的状态标记.\nnew Array的内存:\n8x3 ，一个Complex有2个double，2个double是8.32+4是debug的块, 4x2是头尾的51h， 4是用一个整数记录有3个Complex.String里面只有一个指针，所以图中有一个箭头去表示这个指针指向一个地方.\nArray 的new 与 delete delete要看内存头尾的cookie，cookie 记录了一整块的大小，如 图中的两个21h，delete根据它们可以把内存删掉. 此时 delete 和 delete[]不会造成内存泄露，使用delete[] 编译器才知道要删除的是数组，数组里有3个String，调用3次析构，再回收整块内存.不写delete[] 会造成内存泄露，但泄露的不是这一块内存，而是String里的指针，如图中右边的红色 ?! 块 是String里面指针指向的地方. 这里会发生内存泄露.\n1 2 3 4 5 6 7 8 9 10 11 class String { char* m_data; } String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 如果new的是Complex，里面只有double 没有指针， 即便是用 delete 也可以.\n用了array new 就必须搭配 delete[] 才可万无一失.\n阶段A 复习String.\nString使用char*指针，动态分配大小. 不使用数组 如果用数组，数组大小不确定 太大太小都不好.\nString里面有指针，要关注3个重要函数: 拷贝构造、拷贝赋值、析构.\n在这里不会修改来源端的数据，函数参数用const\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class String { public: // C - Style String(const char* cstr = 0); // 拷贝构造 String(const String\u0026amp; str); // 拷贝赋值 String\u0026amp; operator=(const String\u0026amp; str); //析构 ~String(); char* get_c_str() const {return m_data;} private: char* m_data; } static、cout 所有Account实例共用一份m_rate数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Account { public: static double m_rate; static void set_rate(const double\u0026amp; x){m_rate = x;} }; // 定义初始值 double Account::m_rate = 8.0; int main() { // 调用static函数的两个方式 Account::set_rate(5.0); Account a; a.set_rate(7.0); } Singleton ， 把构造函数放在private\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); static A a; } A::GetInstance.setup(); 有人调用GetInstance时，A才会出现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); } A\u0026amp; A::GetInstance() { static A a; return a; } Cout为了打印出一些不同类型的数据 ， 做了一堆重载\n复合、继承、委托 复合 Adapter适配器设计模式\ndeque的功能很强，拿过来改造一下，只开放部分函数 成为queue.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template\u0026lt;class T\u0026gt; class queue { ... protected: deque\u0026lt;T\u0026gt; c; public: // 使用c的操作函数完成. bool empty() const {return c.empty();} size_type size() const {return c.size();} reference front() {return c.front();} reference back() {return c.back();} // void push(const value_type\u0026amp; x) {c.push_back(x);} void pop() {c.pop_front();} }; 构造由内而外，析构由外而内.\n构造： queue的构造函数首先调用deque的默认构造函数，然后才执行自己析构： queue的析构函数首先执行自己，然后才次调用deque的析构函数.\n委托 用指针指向实现功能的那个类，指针可以指向不同的实现类，右边的变动不影响左边.编译防火墙：左边不用再编译，要编译的是右边.\n继承 1 2 3 4 5 6 7 8 9 10 11 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; } template\u0026lt;typename _Tp\u0026gt; struct _List_node : public _List_node_base { _Tp _M_Data } 构造由内而外，析构由外而内\n子类的构造函数首先调用父类的默认构造函数，然后才执行自己析构首先执行自己，然后才调用父类的析构函数.\n继承搭配虚函数才是更强的.\nnon-virtual：不希望子类重新定义(override)virtual:希望子类重新定义，并且它已有默认定义pure virtual:希望子类一定要重新定义，它没有默认定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Shape { public: // pure virtual virtual void draw() const = 0; // impure virtual virtual void error(const std::string\u0026amp; msg); // non - virtual int objectID()const; } class Rectangle : public Shape { ... } 转换函数 分母默认为1，Fraction(3) 就是3/1 = 3；只需要一个参数够了，one-argument\nnon-explicit-one-argument\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); // 调用operator double将f转换为0.6 double d=4+f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; Fraction重载了+号，但是f+4时 4是int，不是Fraction类型，调用non-explicit ctor将4转换为Fraction(4,1)，然后调用operator+\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; //[Error] operator double() 可以把Fraction转为double， Fraction(int num,int den=1) 可以把4转为Fraction\n此时有两条路线可以走，编译器报错.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: explicit Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; 构造加上explicit，防止隐式转换，不可以把3变成3/1了，不能把3变成Fraction类型，\nf+4 , 4不会变成Fraction，而operator+(const Fraction\u0026amp; f) 要的参数是Fraction类型，所以4转不到Fraction,会转换失败.\nC++11 变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\nrange-based for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for(int i : {2,3,5,7,9,13,17,19}) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } vector\u0026lt;double\u0026gt; vec; // pass by value for(auto elem: vec) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt;endl; } // pass by reference for(auto\u0026amp; elem:vec) { elem *=3 ; } auto lambda 1 2 3 4 5 6 7 8 9 10 11 12 auto i = 42; double f(); auto d = f(); vector\u0026lt;string\u0026gt; v; ... auto pos = v.begin(); auto I = [](int x) -\u0026gt; bool { ...; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; } //call: []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }(); // print \u0026#34;hello lambda\u0026#34; auto I = []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }; I(); // print \u0026#34;hello lambda\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 [...](...)-\u0026gt;returnType{...} ()参数 {}函数体 [=] 外部变量值传递 [\u0026amp;] 外部变量引用传递 int id = 0; //mutable []里的东西是可变的，不写 就不能++id auto f = [id]()mutable{ std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } { id = 42; f(); f(); f(); std::cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; } //输出 id:0; id:1; id:2; 42 //内部的id变了，外部的还是42. // class Functor { private: int id;//copy of outside id public: void operator() { std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } }; Functor f; Uniform Initialization 1 2 3 4 int values[] {1,2,3}; vector\u0026lt;int\u0026gt; v{2,3,5,7}; vector\u0026lt;string\u0026gt; cities{\u0026#34;New York\u0026#34;,\u0026#34;Berlin\u0026#34;}; complex\u0026lt;double\u0026gt; c{4.0,3.0}; 编译器在幕后做出一个 initializer_list 进行构造.\ninitializer_list 1 2 3 4 int i;\ti拥有未定义值 int j{}; j = 0 int* p; p未定义值 int* q{}; q = nullptr 1 2 3 4 5 6 7 8 void print(std::initializer_list\u0026lt;int\u0026gt; vals) { for(auto p=vals.bee();p!=vals.end;++p) { std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } print({12,3,5,7,11,13,17}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } P(initializer_list\u0026lt;int\u0026gt; initlist) { cout \u0026lt;\u0026lt; \u0026#34;P(initializer_list\u0026lt;int\u0026gt;) ,values =\u0026#34;; for(auto i : initlist) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\u0026#39;; } cout \u0026lt;\u0026lt; endl; } } P p(77,5); //P(int,int) a=77,b=5 P q{77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 P r{77,5,42}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 42 P s={77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 1 2 3 4 5 6 7 8 9 10 11 12 13 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } } P p(77,5); P q{77,5}; P r{77,5,42}; P s={77,5}; 没有initializer_list构造时，编译器会把{}里面的一包内容拆解出来，q{77,5} 和 s={77,5} 有两个数，符合P(int,int)r里面有3个数，不符合P(int,int)，失败.\ninitializer_list背后是个array，编译器能够调用initializer_list的私有构造函数.编译器看到 {} 时就制造一个initializer_list，\n=default , =delete 如果自行定义了一个构造函数，那么编译器就不会再给你一个默认构造函数。如果强制加上 = default，就可以重新获得并使用默认构造函数。 =delete告诉编译器不要定义它。必须出现在声明式。适用于任何成员函数。也适用于构造函数，但后果自负。\n1 2 3 4 5 6 7 8 9 10 11 12 class Zoo { public: Zoo(int i1,inti2) : d1(i1),d2(i2){} Zoo(const Zoo\u0026amp;) = delete; Zoo(Zoo\u0026amp;\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;\u0026amp;)=delete; virtual ~Zoo(){} private: int d1,d2; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A { public: // A user-defined // parameterized constructor A(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is a parameterized constructor\u0026#34;; } // Using the default specifier to instruct // the compiler to create the default // implementation of the constructor. A() = default; }; int main() { // executes using defaulted constructor A a; // uses parameterized constructor A x(1); return 0; } 在上述情况下，我们不必指定构造函数 A() 的主体，因为通过附加说明符 \u0026lsquo;=default\u0026rsquo;，编译器将创建此函数的默认实现。\n默认函数需要是特殊成员函数（默认构造函数、复制构造函数、析构函数等），或者没有默认参数。例如，以下代码说明非特殊成员函数不能为默认值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class B { public: // Error, func is not a special member function. int func() = default; // Error, constructor B(int, int) is not // a special member function. B(int, int) = default; // Error, constructor B(int=0) // has a default argument. B(int = 0) = default; }; // driver program int main() { return 0; } 禁用复制构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class A { public: A(int x): m(x) { } // Delete the copy constructor A(const A\u0026amp;) = delete; // Delete the copy assignment operator A\u0026amp; operator=(const A\u0026amp;) = delete; int m; }; int main() { A a1(1), a2(2), a3(3); // Error, the usage of the copy // assignment operator is disabled a1 = a2; // Error, the usage of the // copy constructor is disabled a3 = A(a2); return 0; } 禁用不需要的参数转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class A { public: A(int) {} // Declare the conversion constructor as a // deleted function. Without this step, // even though A(double) isn\u0026#39;t defined, // the A(int) would accept any double value // for it\u0026#39;s argumentand convert it to an int A(double) = delete; }; int main() { A A1(1); // Error, conversion from // double to class A is disabled. A A2(100.1); return 0; } 删除特殊成员函数提供了一种更清晰的方法来防止编译器生成我们不需要的特殊成员函数。\n删除普通成员函数或非成员函数可以防止有问题的类型提升导致意外调用函数(如“禁用不需要的参数转换”示例所示)。\nAlias Template 别名: 李白 字太白\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; using Vec = std::vector\u0026lt;T,MyAlloc\u0026lt;T\u0026gt;\u0026gt;; Vec\u0026lt;int\u0026gt; coll; std::vector\u0026lt;int,MyAlloc\u0026lt;int\u0026gt;\u0026gt; coll; //TODO::模板内容很多，不止这些\n右值与移动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //解决非必要的拷贝，右边是右值时，左边可以偷右边的资源 //而不需要执行allocation重新分配内存 //Lvalue:可以出现在operator=左侧者 //Rvalue:只能出现在operator=右侧者 //临时对象一定被当作右值 //————————————————————————————————————————————————————————————// int a = 9; int b = 4; a=b; //ok b=a;\t//ok a=a+b;\t//ok //a+b是右值 a+b=42 //Error , lvalue required as left operand of assignment //————————————————————————————————————————————————————————————// string s1(\u0026#34;hello\u0026#34;); string s2(\u0026#34;world\u0026#34;); s1 + s2 = s2; //通过编译 cout \u0026lt;\u0026lt; \u0026#34;s1:\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;s2:\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt;endl; string() = \u0026#34;world\u0026#34;; //对临时对象赋值？ //————————————————————————————————————————————————————————————// 1 2 3 4 5 int foo(){return 5;} int x = foo(); //ok int* p = \u0026amp;foo(); //Error，不能对右值取地址 foo() = 7\t//Error 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyString { private: char* _data; public: //copy ctor MyString(const MyString\u0026amp; str):initialization_list{...} //move ctor MyString(MyString\u0026amp;\u0026amp; str) noexcept : initialization_list{...} } //---------------- M c1(c); M c2(std::move(c1));//要确保后续不再使用c1. 完美转发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 template\u0026lt;typename T1,typename T2\u0026gt; void functionA(T1\u0026amp;\u0026amp;t1,T2\u0026amp;\u0026amp;t2) { functionB(std::forward\u0026lt;T1\u0026gt;(t1),std::forward\u0026lt;T2\u0026gt;(t2)); } //-------------------------------------// void _init_data(const char* s) { _data = new char[_len+1]; memcpy(_data,s,_len); _data[_len] = \u0026#39;\\0\u0026#39;; } // copy constructor MyString(const MyString\u0026amp; str) :_len(str.len) { _init_data(str._data); } // move constructor MyString(MyString\u0026amp;\u0026amp; str) noexcept :_data(str._data),_len(str._len) { str._len = 0; str._data=null; } //----------------------------------------------// //copy assignment MyString\u0026amp; operator=(const MyString\u0026amp; str) { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str.len; _init_data(str.data); // Copy } else { } return *this; } //move assignment MyString\u0026amp; operator=(MyString\u0026amp;\u0026amp; str) noexcept { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str._len; //Move _data = str.data; //Move str._len = 0; //重要 str._data = null; //重要 } } //----------------------------------------------// virtual ~MyString() { if(_data) { delete _data; } } 模板 函数模板 模板函数Max，不管是什么样的类型 都可以调用这个模板，模板函数在使用时实例化，只有使用 Max(float,float) 时 才会生成对于float的Max函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; template \u0026lt;typename T\u0026gt; T Max(const T\u0026amp; T1, const T\u0026amp; T2) { return T1 \u0026gt; T2 ? T1 : T2; } class VNumber { public: float A; float B; std::string Name; VNumber(float InA , float InB,std::string InName) : A(InA),B(InB),Name(InName) {} bool operator\u0026lt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026lt; (Ohter.A + Ohter.B); } bool operator\u0026gt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026gt; (Ohter.A + Ohter.B); } }; int main() { int A = Max(2,3); double B = Max(2.2,3.3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;float Max - A:{} B:{} \\n\u0026#34;,A,B); //float Max - A:3 B:3.3 VNumber V1(1,2,\u0026#34;V1\u0026#34;); VNumber V2(3,5,\u0026#34;V2\u0026#34;); auto MaxVNumber = Max(V1,V2); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber.Name,MaxVNumber.A,MaxVNumber.B); // MaxName:V2 A:3 B:5 VNumber V3(10,5,\u0026#34;V3\u0026#34;); auto MaxVNumber2 = Max(V2,V3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber2.Name,MaxVNumber2.A,MaxVNumber2.B); // MaxName:V3 A:10 B:5 } 自动推导返回值 C++14引入自动推导:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format; template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { return tv1 + tv2; } int main() { int a = 5; int b = 3; int c = Add(a, b); float d = 5.5f; float e = 3.3f; float f = Add(d, e); auto AplusD = Add(a, d); cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2}\u0026#34;, a, b, c) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2}\u0026#34;, d, e, f) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2} Type:{3}\u0026#34;, a, d, AplusD, typeid(AplusD).name()) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; 输出：\n1 2 3 5 + 3 = 8 5.5 + 3.3 = 8.8 5 + 5.5 = 10.5 Type:float 如果在C++11中使用自动推导，需要使用尾置返回类型（trailing return type）：\n1 2 3 4 5 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 函数重载 当调用 Add 函数时，编译器会优先选择最匹配的重载函数。\n如果没有匹配的重载函数，则调用模板函数。\n如果重载函数和模板函数同时存在，编译器会优先选择重载函数（如果匹配）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { return tv1 + tv2; } // 2. 重载函数：处理两个整数相加 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用整数相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } // 3. 重载函数：处理两个字符串相加 string Add(const string\u0026amp; str1, const string\u0026amp; str2) { cout \u0026lt;\u0026lt; \u0026#34;调用字符串相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return str1 + str2; } // 4. 重载函数：处理一个整数和一个字符串相加 string Add(int a, const string\u0026amp; str) { cout \u0026lt;\u0026lt; \u0026#34;调用整数和字符串相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return std::to_string(a) + str; } int main() { // 调用模板函数 cout \u0026lt;\u0026lt; Add(1.5, 2.3) \u0026lt;\u0026lt;endl; // 调用模板函数，返回 double 类型 // 调用整数相加的重载函数 cout \u0026lt;\u0026lt; Add(10, 20) \u0026lt;\u0026lt; endl; // 调用整数相加的重载函数 // 调用字符串相加的重载函数 cout \u0026lt;\u0026lt; Add(string(\u0026#34;Hello\u0026#34;), string(\u0026#34;World!\u0026#34;)) \u0026lt;\u0026lt; endl; // 调用字符串相加的重载函数 // 调用整数和字符串相加的重载函数 cout \u0026lt;\u0026lt; Add(42, string(\u0026#34; is the answer\u0026#34;)) \u0026lt;\u0026lt; endl; // 调用整数和字符串相加的重载函数 }; 1 2 3 4 5 6 7 8 调用模板函数 3.8 调用整数相加的重载函数 30 调用字符串相加的重载函数 HelloWorld! 调用整数和字符串相加的重载函数 42 is the answer 特化 Specialization 特化是指为模板的某些特定类型或条件提供特殊的实现\n针对Object类 ，调用Add时 只会把它们内部的Name变量加起来.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format,std::string; template\u0026lt;typename T\u0026gt; void Add(T\u0026amp; T1, T\u0026amp; T2) { T1 += T2; } struct Object { Object(string InName) : Name(InName){} string Name; }; template\u0026lt;\u0026gt; void Add\u0026lt;Object\u0026gt;(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } int main() { int A = 5; int B = 6; Add(A,B); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,A,B); //A:11 B:6 Object Obj1(\u0026#34;Manba\u0026#34;); Object Obj2(\u0026#34;Out\u0026#34;); Add(Obj1,Obj2); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,Obj1.Name,Obj2.Name); //A:ManbaOut B:Out } 这个例子里的第二个Add 手动指定了两个参数的类型，而且模板函数也只有这两个参数，也就是把所有参数类型全部手动指定了，这就是全特化.\n以下两种写法都可以，有时候还是写明模板实参比较好，即第一种写法，在尖括号里指明特化类型.\n1 2 3 4 5 6 template\u0026lt;\u0026gt; void Add\u0026lt;Object\u0026gt;(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } 1 2 3 4 5 6 template\u0026lt;\u0026gt; void Add(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } 全特化是指为模板的所有模板参数指定具体的类型或值，从而为这些特定类型提供一个完全独立的实现。\n偏特化是指为模板的部分模板参数指定具体的类型或条件，而不是全部参数。偏特化允许对模板参数进行部分约束，从而为某些特定情况提供特殊实现。\n实际上 函数模板只有全特化，没有偏特化，模板类有全特化和偏特化.\n模板类特化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename T\u0026gt; void VarType(T T1) {} template \u0026lt;\u0026gt; void VarType\u0026lt;int\u0026gt;(int) { cout \u0026lt;\u0026lt; \u0026#34;VarType is int\\n\u0026#34;; } template \u0026lt;\u0026gt; void VarType\u0026lt;float\u0026gt;(float) { cout \u0026lt;\u0026lt; \u0026#34;VarType is float\\n\u0026#34;; } 函数重载与特化 （1）普通函数重载优先 普通函数重载的优先级最高。如果调用时的实参与某个普通函数重载完全匹配，编译器会直接选择该函数，而不会考虑模板函数或模板特化版本。\n（2）模板全特化版本次之 如果没有匹配的普通函数重载，编译器会检查是否存在模板全特化版本。如果调用时的实参与某个模板全特化版本完全匹配，编译器会选择该特化版本。\n（3）模板函数最后 如果既没有匹配的普通函数重载，也没有匹配的模板全特化版本，编译器会选择最匹配的模板函数，并实例化该模板。\n函数模板重载 普通函数重载：这是指在同一作用域内定义多个具有相同名称但参数列表不同的函数。\n1 2 3 4 5 // 普通函数重载 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用整数相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } 函数模板重载：这是指在同一作用域内定义多个具有相同名称但模板参数或参数列表不同的函数模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 通用函数模板 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { cout \u0026lt;\u0026lt; \u0026#34;调用模板函数: T, U\u0026#34; \u0026lt;\u0026lt; endl; return tv1 + tv2; } // 特定参数类型的函数模板重载 template\u0026lt;typename T\u0026gt; auto Add(float T1, T\u0026amp; T2) { cout \u0026lt;\u0026lt; \u0026#34;调用第二个Add\u0026#34; \u0026lt;\u0026lt; endl; return T1 + T2; } 缺省参数 缺省值\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T\u0026gt; auto Sub(T tv1, T tv2 = 1) { cout \u0026lt;\u0026lt; \u0026#34;调用模板函数: T\u0026#34; \u0026lt;\u0026lt; endl; return tv1 - tv2; } int main() { int A = 10; auto c = Sub(A); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 调用模板函数: T 9 缺省类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T = int,typename T2\u0026gt; auto Add(T2 tv2) { T tv1 = 1; return tv1 + tv2; } int main() { int A = 10; auto c = Add(A); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 运行结果 C = 11\n非类型模板参数 非类型模板参数是具体的值或对象，它们可以在编译时确定，并且可以用于控制模板的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T,typename U,auto V = 100\u0026gt; auto Add(T a,T b) { return a + b + V; } int main() { int A = 10; int B = 20; auto c = Add\u0026lt;int,int\u0026gt;(A,B); //C = A + B + 100 //C = 130 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; auto d = Add\u0026lt;int,int,2.2\u0026gt;(A,B); // d = A + B + 2.2 // d = 32.2 cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 运行结果 c=130，d=32.2\n非类型模板参数要在编译期确定，不能使用变量，除非是const、constexpr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int V1 = 100; constexpr int V2 = 100; int V3 = 100; template\u0026lt;typename T,typename U,auto V = 100\u0026gt; auto Add(T a,T b) { return a + b + V; } int main() { int a = 10; int b = 20; auto c = Add\u0026lt;int,int,V1\u0026gt;(a,b); auto d = Add\u0026lt;int,int,V2\u0026gt;(a,b); auto e = Add\u0026lt;int,int,V3\u0026gt;(a,b); return 0; } 其中 e的V3是变量，编译时报错\n1 2 表达式的计算结果不是常数 非常量参数或对非常量符号的引用导致了故障 如果在代码中 没有使用到非类型模板参数，可以不写参数名，但在调用时 还是要用尖括号指明类型的，以下的写法是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T, int value\u0026gt; auto Add2() { return 100; } template \u0026lt;typename , int \u0026gt; auto Add2() { return 100; } //调用时指明尖括号 Add2\u0026lt;int,5\u0026gt;(); 可变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\n折叠表达式极大地简化了可变参数模板的操作，使得编写递归模板函数来处理参数包变得不再必要，从而让代码更加简洁和易读\n折叠表达式主要用于对可变数量的模板参数进行操作，常见的应用场景包括：\n对所有参数应用一个二元运算符：例如求和、求积等。 构建复杂的类型列表或值列表：例如生成类型列表或初始化列表。 简化递归模板函数：通过折叠表达式可以避免手动编写递归模板函数来处理参数包。 求和 求积：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 使用折叠表达式计算参数包中所有整数的和 template\u0026lt;typename... Args\u0026gt; auto sum(Args... args) { return (args + ...); // 左折叠 } template\u0026lt;typename... Args\u0026gt; auto product(Args... args) { return (args * ...); // 左折叠 } template\u0026lt;typename... Args\u0026gt; std::string concat(Args... args) { return (... + std::string(args)); // 右折叠 } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Sum: \u0026#34; \u0026lt;\u0026lt; sum(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出: 15 std::cout \u0026lt;\u0026lt; \u0026#34;Product: \u0026#34; \u0026lt;\u0026lt; product(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出: 120 // 输出: Hello World! cout \u0026lt;\u0026lt; \u0026#34;Concatenated:\u0026#34; \u0026lt;\u0026lt; concat(\u0026#34;Hello\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 左折叠 vs 右折叠\n左：参数从左侧开始计算 (((\u0026ldquo;Hello\u0026rdquo; + \u0026quot; \u0026ldquo;) + \u0026ldquo;World\u0026rdquo;) + \u0026ldquo;!\u0026rdquo;)右：参数从右侧开始计算 ((\u0026ldquo;Hello\u0026rdquo; + (\u0026rdquo; \u0026quot; + (\u0026ldquo;World\u0026rdquo; + \u0026ldquo;!\u0026rdquo;))))\n对于字符串连接操作 +，左折叠和右折叠的结果也是相同的，因为字符串连接也是结合律的。\n对于具有结合律的运算符（如 +, *），左折叠和右折叠的结果是相同的。但对于没有结合律的运算符（如 -, /），左折叠和右折叠的结果可能会不同。因此，在选择左折叠还是右折叠时，需要根据具体情况和运算符的特性进行选择。\n一元左折(unary left fold) 格式:(\u0026hellip; 运算符 一包参数) 计算方式:(((参数1 运算符 参数2) 运算符 参数3)\u0026hellip;.运算符 参数N)\n一元右折(unary right fold) 格式: (一包参数 运算符 \u0026hellip;) 计算方式:(参数1 运算符 ( \u0026hellip; (参数N-1 运算符 参数N)))\n二元左折(binary left fold) 格式:(init 运算符 \u0026hellip; 运算符 一包参数) 计算方式:(((init 运算符 参数1) 运算符 参数2) \u0026hellip; 运算符 参数N) init表示 一个初始的东西，它可能是一个值，也可能是个其他东西。\n二元右折(binary right fold) 格式:(一包参数 运算符 \u0026hellip; 运算符 init) 计算方式:(参数1 运算符 (\u0026hellip;（参数N 运算符 init )))\n多态 模板中的多态，并不需要用到父类以及继承的概念，子类也不需要虚函数(压根就不存在父类指针指向子类对象或者父类引用绑定子类对象这种概念)\n1 编译期间内，编译器会实例化出eatTmpl\u0026lt;A\u0026gt;和eatTmpl\u0026lt;B\u0026gt;这两个函数。 总结： 传统多态：也叫动态多态（运行时多态），因为要访问虚函数表指针，所以对执行期间的性能多少会有一些影响。 模板多态：也叫静态多态，编译期间就确定了具体调用谁，就不存在执行期间的性能问题 只要支持相同的语法，就允许不同类型的对象以同样的方式被操纵——都有eat成员函数，那么就允许调用该成员函数，因为这是在编译期间完成的多态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class A { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;A!\u0026#34; \u0026lt;\u0026lt; endl; } }; class B { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;B!\u0026#34; \u0026lt;\u0026lt; endl; } }; //函数模板 template\u0026lt;typename T\u0026gt; void eatTmpl(T\u0026amp; obj) { obj.eat(); } int main() { A ObjA; B ObjB; eatTmpl(ObjA); eatTmpl(ObjB); return 0; } 类模板 类模板可以做数据结构的容器什么的. 比如在一个模板类里面搞一个数组，在使用时 可以定义数组存放什么样的类型， 或者 搞个链表，放一串int / float / string 等等类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template\u0026lt;typename T\u0026gt; class SimpleContainer { public: SimpleContainer(T InContent) : Content(InContent){} T GetContent() { return Content; } void SetContent(T InContent) { Content = InContent; } private: T Content; }; int main() { SimpleContainer SC(5); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} ,type:{} \\n\u0026#34;,SC.GetContent(),typeid(SC.GetContent()).name()); //SC Content:5 ,type:int SC.SetContent(10); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} , Is String? : {}\\n\u0026#34;, SC.GetContent(), std::is_same\u0026lt;decltype(SC.GetContent()),string\u0026gt;::value); //SC Content:10 , Is String? : false SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); cout\u0026lt;\u0026lt;format(\u0026#34;SC1 Content:{}, Is String? : {} \\n\u0026#34;, SC1.GetContent(), std::is_same\u0026lt;decltype(SC1.GetContent()),string\u0026gt;::value); //SC1 Content:Manba out, Is String? : true } C++17 模板参数自动推导，下面两种写法是一样的\n1 2 SimpleContainer SC(string(\u0026#34;Fuck\u0026#34;)); SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); 推断指引 在 C++17 之前，如果你有一个模板类，比如 std::pair，你在实例化时必须显式指定模板参数：\n1 2 3 4 std::pair\u0026lt;int, double\u0026gt; p(42, 3.14); // 必须显式指定 \u0026lt;int, double\u0026gt; //C++17 引入了 类模板参数推导 std::pair p(42, 3.14); // 编译器自动推导为 std::pair\u0026lt;int, double\u0026gt; 但有些情况下，编译器无法根据构造函数参数正确推导模板参数，这时就需要 deduction guide 来明确推导规则。\nDeduction guide 的主要作用是在 不显式指定模板参数 的情况下，帮助编译器推导模板参数\n1 2 template \u0026lt;模板参数列表\u0026gt; 类名(构造函数参数列表) -\u0026gt; 推导出的模板参数; 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; class Box { public: T value; Box(T v) : value(v) { cout\u0026lt;\u0026lt;format(\u0026#34;Box created with value {}\\n\u0026#34;,value); } }; int main() { Box b(\u0026#34;hello\u0026#34;); return 0; } 当Box b构建完成，它的value是const char*类型，\n使用推断指引 指定value的类型，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename T\u0026gt; class Box { public: T value; Box(T v) : value(v) { cout\u0026lt;\u0026lt;format(\u0026#34;Box created with value {}\\n\u0026#34;,value); } }; // Deduction guide for const char* Box(const char*)-\u0026gt;Box\u0026lt;std::string\u0026gt;; int main() { Box b(\u0026#34;hello\u0026#34;); return 0; } 添加了推断指引后，value为string类型\n例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename T\u0026gt; class Wrapper { public: T value; Wrapper(int v) : value(v) { cout \u0026lt;\u0026lt; format(\u0026#34;Wrapper({}) created\\n\u0026#34;, value); } // 构造函数参数是 int，但 T 可能是其他类型 }; // Deduction guide for Wrapper Wrapper(int)-\u0026gt;Wrapper\u0026lt;int\u0026gt;; int main() { Wrapper w(42); return 0; } 如果不添加推导指引，编译器会报错，\n1 2 3 error C2641: 无法推导“Wrapper”的模板参数 error C2783: “Wrapper\u0026lt;T\u0026gt; Wrapper(int)”: 无法推导“T”的 模板 参数 error C2784: “Wrapper\u0026lt;T\u0026gt; Wrapper(Wrapper\u0026lt;T\u0026gt;)”: 无法从“int”推导出“Wrapper\u0026lt;T\u0026gt;”的 模板 参数 当不添加推导指引时，可以手动使用尖括号指定T的类型，不需要依赖 类模板参数推导（CTAD） 或 deduction guide。\n1 Wrapper\u0026lt;int\u0026gt; w(42); 例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename T\u0026gt; struct B { T m_b; T m_b2; }; template\u0026lt;typename T\u0026gt; B(T) -\u0026gt; B\u0026lt;T\u0026gt;; template\u0026lt;typename T\u0026gt; B(T, T) -\u0026gt; B\u0026lt;T\u0026gt;; int main() { B\u0026lt;int\u0026gt; bobj1; //需要明确指定模板参数类型 B\u0026lt;int\u0026gt; bobj2{ 15 }; //可以用初始化列表的方式来定义对象bobj2,成员变量m_b=15。 B bobj3{ 15 }; //无法推导B的模板参数 B bobj4{ 15,20 }; return 0; } 在C++17版本，不添加推断指引，编译错误.\nC++20版本，即使不写推断指引，也能自动推导，编译成功.\n模板类特化 全特化 说人话就是 模板里的参数被手动指定了，例如指定为 int和double\n偏特化 模板里的参数 只指定了一个为int，另一个还是T\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 主模板 template \u0026lt;typename T, typename U\u0026gt; class MyClass { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;主模板\u0026#34; \u0026lt;\u0026lt; endl; } }; // 全特化：T = int, U = double template \u0026lt;\u0026gt; class MyClass\u0026lt;int, double\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;全特化版本：T = int, U = double\u0026#34; \u0026lt;\u0026lt; endl; } }; // 偏特化：T = int, U 任意 template \u0026lt;typename U\u0026gt; class MyClass\u0026lt;int, U\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化版本：T = int, U 任意\u0026#34; \u0026lt;\u0026lt; endl; } }; // 偏特化：T 任意, U = double template \u0026lt;typename T\u0026gt; class MyClass\u0026lt;T, double\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化版本：U = double, T 任意\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void TemA() { MyClass\u0026lt;char, char\u0026gt; obj1; obj1.print(); // 调用主模板 MyClass\u0026lt;int, double\u0026gt; obj2; obj2.print(); // 调用全特化版本 return 0; } void TemB() { MyClass\u0026lt;char, char\u0026gt; obj1; obj1.print(); // 调用主模板 MyClass\u0026lt;int, char\u0026gt; obj2; obj2.print(); // 调用偏特化版本：T = int, U 任意 MyClass\u0026lt;char, double\u0026gt; obj3; obj3.print(); // 调用偏特化版本：U = double, T 任意 return 0; } 函数定义也可以写在类外\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 主模板 template \u0026lt;typename T, typename U\u0026gt; class MyClass { public: void print(); }; template \u0026lt;typename T, typename U\u0026gt; void MyClass\u0026lt;T,U\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;主模板\u0026#34; \u0026lt;\u0026lt; endl; } // 全特化：T = float, U = double template \u0026lt;\u0026gt; class MyClass\u0026lt;float, double\u0026gt; { public: void print(); }; void MyClass\u0026lt;float,double\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;全特化 float, double\u0026#34; \u0026lt;\u0026lt; endl; } // 偏特化：T = int, U 任意 template \u0026lt;typename U\u0026gt; class MyClass\u0026lt;int, U\u0026gt; { public: void print(); }; template \u0026lt;typename U\u0026gt; void MyClass\u0026lt;int, U\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化：T = int, U 任意\u0026#34; \u0026lt;\u0026lt; endl; } int main() { MyClass\u0026lt;float, float\u0026gt; Mclass; Mclass.print(); MyClass\u0026lt;float,double\u0026gt; Mclass2; Mclass2.print(); MyClass\u0026lt;int,int\u0026gt; Mclass1; Mclass1.print(); return 0; } 输出：\n1 2 3 主模板 全特化 float, double 偏特化：T = int, U 任意 成员函数模板 类模板中的成员函数，只有源程序代码中出现调用这些成员函数的代码时，这些成员函数才会出现在一个实例化了的类模板中。\n类模板中的成员函数模板，只有源程序代码中出现调用这些成员函数模板的代码时，这些成员函数模板的具体实例才会出现在一个实例化了的类模板中。\n目前编译器并不支持虚成员函数模板，因为虚函数表vtbl的大小是固定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u0026lt;typename T1\u0026gt; class A { public: template \u0026lt;typename T2\u0026gt; A(T2 v1, T2 v2); //构造函数模板，引入了自己的模板参数T2，与类A的模板参数T1没有关系 template \u0026lt;typename T3\u0026gt; void myft(T3 tmpt) //普通成员函数模板 { cout \u0026lt;\u0026lt; tmpt \u0026lt;\u0026lt; endl; } }; template \u0026lt;typename T1\u0026gt; template \u0026lt;typename T2\u0026gt; A\u0026lt;T1\u0026gt;::A(T2 v1, T2 v2) { cout \u0026lt;\u0026lt; \u0026#34;A::A(T2,T2)执行了!\u0026#34; \u0026lt;\u0026lt; endl; } int main() { A\u0026lt;int\u0026gt; A1(1,2); A1.myft(3); return 0; } 继承关系 CRTP\nCRTP（Curiously Recurring Template Pattern，奇特递归模板模式）是一种C++编程技术，通过使用模板和继承来实现静态多态性。与传统的运行时多态（通过虚函数实现）不同，CRTP可以在编译时进行优化，从而提高性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename Derived\u0026gt; class Base { public: void interface() { // 调用派生类的实现 static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); } }; class Derived : public Base\u0026lt;Derived\u0026gt; { public: void implementation() { // 实现细节 } }; CRTP实现策略模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 策略接口 template \u0026lt;typename Derived\u0026gt; class Strategy { public: void execute() { static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;doExecute(); } }; // 具体策略A class ConcreteStrategyA : public Strategy\u0026lt;ConcreteStrategyA\u0026gt; { public: void doExecute() { std::cout \u0026lt;\u0026lt; \u0026#34;Executing strategy A\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体策略B class ConcreteStrategyB : public Strategy\u0026lt;ConcreteStrategyB\u0026gt; { public: void doExecute() { std::cout \u0026lt;\u0026lt; \u0026#34;Executing strategy B\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { ConcreteStrategyA strategyA; ConcreteStrategyB strategyB; strategyA.execute(); // 输出: Executing strategy A strategyB.execute(); // 输出: Executing strategy B return 0; } 这里的关键点在于派生类Derived在定义时将自己作为模板参数传递给了基类Base。这样做的好处是可以让基类访问到派生类的成员，同时保持一定的抽象层次和代码复用。\n实现机制\n静态绑定：由于所有操作都在编译期确定，因此避免了虚函数调用带来的间接性和开销。CRTP允许基类调用派生类的方法或访问其数据成员，而不需要通过虚函数表（vtable）。 类型识别：在CRTP中，基类通过模板参数知道它是为哪个具体的派生类实例化的。这使得基类可以根据不同的派生类提供不同的行为，而这些行为在编译期就已经确定。 接口扩展与策略模式：除了实现静态多态外，CRTP还常用于接口扩展和策略模式的实现。例如，可以为一个类添加额外的功能而不修改其原始定义。 C++23\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Base { void name(this auto\u0026amp;\u0026amp; self) { self.impl(); } }; struct D1 : Base { void impl() { cout\u0026lt;\u0026lt;\u0026#34;D1::impl() \\n\u0026#34;; } }; struct D2 : Base { void impl() { cout\u0026lt;\u0026lt;\u0026#34;D2::impl() \\n\u0026#34;; } }; int main() { D1 d1; d1.name(); D2 d2; d2.name(); } 混入\n通过模板混入技巧，我们可以在不修改基类的情况下，动态地为类添加新的功能。这种方式比继承更加灵活，因为它允许我们在编译时选择性地组合功能，而不需要创建复杂的继承层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 基类 class Base { public: void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Base is doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 混入类：添加日志功能 template \u0026lt;typename T\u0026gt; class LoggingMixin : public T { public: void doSomethingWithLog() { std::cout \u0026lt;\u0026lt; \u0026#34;Logging: Before doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; T::doSomething(); // 调用基类的功能 std::cout \u0026lt;\u0026lt; \u0026#34;Logging: After doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 使用混入类扩展 Base 的功能 LoggingMixin\u0026lt;Base\u0026gt; obj; // 调用扩展后的功能 obj.doSomethingWithLog(); return 0; } 结果\n1 2 3 Logging: Before doing something. Base is doing something. Logging: After doing something. 基类 Base：这是一个普通的类，有一个 doSomething 方法。\n混入类 LoggingMixin：这是一个模板类，继承自模板参数 T。它添加了一个新的方法 doSomethingWithLog，在调用基类的 doSomething 方法前后添加了日志输出。\n使用混入类：在 main 函数中，我们通过 LoggingMixin\u0026lt;Base\u0026gt; 创建了一个对象 obj。这个对象既拥有 Base 的功能，又拥有 LoggingMixin 添加的日志功能。\nMixin 模式非常适合以下场景：\n功能扩展：当你需要为现有类添加新功能而不修改其源代码时。 模块化设计：通过将不同功能分离到不同的 Mixin 类中，使代码更加模块化和易于维护。 代码复用：Mixin 类可以被多个不同的类复用，减少了重复代码。 灵活性：通过多重继承或模板组合，可以在不修改原始类的情况下灵活地组合多种功能。 然而，需要注意的是，过多的多重继承可能会导致复杂的继承层次结构，增加代码理解和维护的难度。因此，在使用 Mixin 时应权衡其优点和潜在的复杂性。结合 CRTP（Curiously Recurring Template Pattern）等技术，可以进一步增强 Mixin 的功能和控制力。\n变量模板 C++14，允许定义模板化的常量或变量。通过变量模板，可以在编译时生成不同类型的常量或变量实例，并且可以简化代码，提高可读性和维护性。\n例1：使用变量模板表示某个类型的最小值\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; constexpr T min_value = std::numeric_limits\u0026lt;T\u0026gt;::min(); template\u0026lt;typename T\u0026gt; constexpr T max_value = std::numeric_limits\u0026lt;T\u0026gt;::max(); cout \u0026lt;\u0026lt; \u0026#34;Min value for unsigned short: \u0026#34; \u0026lt;\u0026lt; min_value\u0026lt;unsigned short\u0026gt; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Max value for unsigned short: \u0026#34; \u0026lt;\u0026lt; max_value\u0026lt;unsigned short\u0026gt; \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt;format(\u0026#34;Min value for unsigned short: {}\\nMax value for unsigned short: {}\\n\u0026#34;, min_value\u0026lt;unsigned short\u0026gt;, max_value\u0026lt;unsigned short\u0026gt;); 例2：数字常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;typename T\u0026gt; constexpr T pi = T(3.1415926535897932385L); // 定义一个函数模板，计算圆的面积 template\u0026lt;typename T\u0026gt; T circle_area(T radius) { return pi\u0026lt;T\u0026gt; * radius * radius; } cout \u0026lt;\u0026lt; \u0026#34;Pi (double): \u0026#34; \u0026lt;\u0026lt; pi\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Pi (float): \u0026#34; \u0026lt;\u0026lt; pi\u0026lt;float\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Area of a circle with radius 5 (double): \u0026#34; \u0026lt;\u0026lt; circle_area(5.0) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Area of a circle with radius 5 (float): \u0026#34; \u0026lt;\u0026lt; circle_area(5.0f) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 例3：类型特性\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; constexpr bool is_integer = std::is_integral_v\u0026lt;T\u0026gt;; cout \u0026lt;\u0026lt; \u0026#34;Is int an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;int\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Is double an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Is char an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;char\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;typename T\u0026gt; T Value{}; int main() { Value\u0026lt;int\u0026gt; = 10; cout \u0026lt;\u0026lt; format(\u0026#34;Value = {}\\n\u0026#34;, Value\u0026lt;int\u0026gt;); Value\u0026lt;string\u0026gt; = \u0026#34;Hello\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;Value = {}\\n\u0026#34;, Value\u0026lt;string\u0026gt;); cout \u0026lt;\u0026lt; format(\u0026#34;Value\u0026lt;int\u0026gt; = {} Value\u0026lt;string\u0026gt; = {}\\n\u0026#34;, Value\u0026lt;int\u0026gt;, Value\u0026lt;string\u0026gt;); return 0; } 进阶 模板模板参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 template\u0026lt;typename T,template\u0026lt;typename\u0026gt; typename Vec = std::vector\u0026gt; class Obj { public: Vec\u0026lt;T\u0026gt; vec; Obj() { cout \u0026lt;\u0026lt; format(\u0026#34;{}\u0026#34;,typeid(T).name()) \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; ++i) { vec.push_back(i); } } void print() { for (auto i : vec) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt; endl; } }; int main() { Obj\u0026lt;int\u0026gt; Ob; Ob.print(); return 0; } //输出： //int //0 1 2 3 4 5 6 7 8 9 使用模板模板参数 打印各种不同容器的元素\n1 2 3 4 5 6 7 8 9 template \u0026lt;template \u0026lt;typename, typename\u0026gt; class Container, typename T, typename Allocator\u0026gt; void printContainer(const Container\u0026lt;T, Allocator\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 打印vector 以及 模板实例化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::vector\u0026lt;int\u0026gt; vec = { 1, 2, 3, 4 }; printContainer(vec); // 模板实例化的代码 //template \u0026lt;typename, typename\u0026gt; class Container, typename T, typename Allocator // Container = std::vector // T = int // Allocator = Allocator\u0026lt;int\u0026gt; void printContainer(const std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt;\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 打印list 以及 模板实例化\n1 2 3 4 5 6 7 8 9 10 11 std::list\u0026lt;double\u0026gt; lst = { 1.1, 2.2, 3.3 }; printContainer(lst); //模板实例化 void printContainer(const std::list\u0026lt;double, std::allocator\u0026lt;double\u0026gt;\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 模板参数推导： 编译器根据传入的容器类型（如 std::vector\u0026lt;int\u0026gt; 或 std::list\u0026lt;double\u0026gt;）推导出模板参数 Container、T 和 Allocator。 默认模板参数： std::vector 和 std::list 的第二个模板参数（分配器）是默认的 std::allocator\u0026lt;T\u0026gt;，因此不需要显式指定。 万能引用 万能引用（Universal Reference） 是 C++11 引入的一个概念，通常与 \u0026amp;\u0026amp; 和模板结合使用。它允许函数模板接受任意类型的参数（左值或右值），并根据传入的参数类型自动推导出正确的引用类型。万能引用的典型应用是实现完美转发（Perfect Forwarding）。\n右值与移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 函数模板，使用万能引用 template \u0026lt;typename T\u0026gt; void print(T\u0026amp;\u0026amp; value) { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { int x = 10; const std::string str = \u0026#34;Hello\u0026#34;; // 传递左值 print(x); // T 推导为 int\u0026amp; print(str); // T 推导为 const std::string\u0026amp; // 传递右值 print(42); // T 推导为 int print(std::string(\u0026#34;World\u0026#34;)); // T 推导为 std::string return 0; } 万能引用的语法： T\u0026amp;\u0026amp; 是万能引用的语法形式。 当 T 是一个模板参数时，T\u0026amp;\u0026amp; 可以根据传入的参数类型推导出左值引用或右值引用。 类型推导： 如果传入的是一个左值（如 x 或 str），T 会被推导为左值引用类型（如 int\u0026amp; 或 const std::string\u0026amp;）。 如果传入的是一个右值（如 42 或 std::string(\u0026quot;World\u0026quot;)），T 会被推导为值类型（如 int 或 std::string）。 输出结果： 无论传入左值还是右值，print 函数都能正确处理并输出。 完美转发\n将参数以原始类型（左值或右值）传递给另一个函数。以下是一个完美转发的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void process(int\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing lvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } void process(int\u0026amp;\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing rvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } // 转发函数模板 template \u0026lt;typename T\u0026gt; void forwarder(T\u0026amp;\u0026amp; arg) { process(std::forward\u0026lt;T\u0026gt;(arg)); // 使用 std::forward 完美转发 } int main() { int x = 10; // 传递左值 forwarder(x); // 调用 process(int\u0026amp;) // 传递右值 forwarder(20); // 调用 process(int\u0026amp;\u0026amp;) return 0; } std::forward： std::forward\u0026lt;T\u0026gt;(arg) 用于保持参数的原始类型（左值或右值）。 如果 arg 是一个左值，std::forward 会将其转发为左值。 如果 arg 是一个右值，std::forward 会将其转发为右值。 完美转发的作用： 通过万能引用和 std::forward，forwarder 函数可以将参数以原始类型传递给 process 函数，确保调用正确的重载版本。 输出：\n1 2 Processing lvalue: 10 Processing rvalue: 20 总结\n万能引用（T\u0026amp;\u0026amp;）允许函数模板接受任意类型的参数（左值或右值）。 通过 std::forward，可以实现完美转发，保留参数的原始类型。 万能引用是 C++11 中实现通用代码和高效资源管理的重要工具。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Person 类 class Person { public: // 构造函数，接受 std::string 参数 explicit Person(const string\u0026amp; name) : name_(name) { cout \u0026lt;\u0026lt; \u0026#34;Person 左值创建：: \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } explicit Person(string\u0026amp;\u0026amp; name) : name_(std::move(name)) { cout \u0026lt;\u0026lt; \u0026#34;Person 右值创建：: \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } void greet() const { cout \u0026lt;\u0026lt; \u0026#34;Hello, my name is \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } private: string name_; }; using PersonPtr = std::unique_ptr\u0026lt;Person\u0026gt;; // 工厂函数模板，使用完美转发 template \u0026lt;typename T\u0026gt; PersonPtr createPerson(T\u0026amp;\u0026amp; name) { return std::make_unique\u0026lt;Person\u0026gt;(std::forward\u0026lt;T\u0026gt;(name)); } int main() { std::string lvalueName = \u0026#34;Alice\u0026#34;; // 使用左值创建 Person auto person1 = createPerson(lvalueName); // 调用 Person(const std::string\u0026amp;) // 使用右值创建 Person auto person2 = createPerson(\u0026#34;Bob\u0026#34;); // 调用 Person(std::string\u0026amp;\u0026amp;) // 使用右值（移动语义）创建 Person auto person3 = createPerson(std::move(lvalueName)); // 调用 Person(std::string\u0026amp;\u0026amp;) // 检查 lvalueName 是否被移动， 左值移动后 这个字符串应该为空 std::cout \u0026lt;\u0026lt; \u0026#34;lvalueName after move: \u0026#34; \u0026lt;\u0026lt; lvalueName \u0026lt;\u0026lt; endl; return 0; } 移动语义是一种优化技术，允许我们将资源（如动态内存、文件句柄等）从一个对象“转移”到另一个对象，而不是进行昂贵的拷贝操作。对于 std::string 来说，移动操作会将字符串的内部指针（指向字符数据的指针）从源对象转移到目标对象，同时将源对象置于有效但未定义的状态（通常是空字符串）。std::move 将 lvalueName 转换为右值，从而触发移动语义。移动后，lvalueName 的内容被转移到 Person 对象的构造函数中，而 lvalueName 本身会变为空字符串。如果输出是空值，说明 lvalueName 的内容已经被成功移动。\nSFINAE SFINAE C++模板编程中的一个重要概念，它的核心思想是：在模板推导过程中，如果某个替换失败了，编译器不会报错，而是简单地忽略这个候选，继续尝试其他可行的模板。SFINAE 通常用于在编译时根据类型特性选择不同的函数重载或模板特化。\nenable_if\nstd::enable_if 是C++模板编程中的一个工具，主要用于基于某些条件启用或禁用模板的实例化。它通常用来实现SFINAE原则，允许编译器根据表达式的有效性来选择不同的函数重载或类模板特化。\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; struct enable_if {}; // no member \u0026#34;type\u0026#34; when !_Test template \u0026lt;class _Ty\u0026gt; struct enable_if\u0026lt;true, _Ty\u0026gt; { // type is _Ty for _Test using type = _Ty; }; 当 _Test 为 true 时，std::enable_if\u0026lt;_Test,_Ty\u0026gt;::type 存在，并等于 T 类型。 当 _Test 为 false 时，std::enable_if\u0026lt;_Test,_Ty\u0026gt;::type 不存在，这会导致试图使用它的代码无法编译。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std::enable_if\u0026lt;true\u0026gt;::type; //可用作类型，其type是void类型. //等同于 using std::enable_if\u0026lt;true,void\u0026gt;::type = void std::enable_if\u0026lt;true\u0026gt;::type func() { cout \u0026lt;\u0026lt; \u0026#34;func\\n\u0026#34;; } //std::enable_if\u0026lt;true\u0026gt;::type func() // 二者相等 //void func() std::enable_if\u0026lt;false\u0026gt;::type; //类 \u0026#34;std::enable_if\u0026lt;false, void\u0026gt;\u0026#34; 没有成员 \u0026#34;type\u0026#34; 测试第一个模板参数bool _Test\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename T\u0026gt; enable_if\u0026lt;(sizeof(T)\u0026gt;2)\u0026gt;::type Func() { } int main() { Func\u0026lt;int\u0026gt;(); Func\u0026lt;char\u0026gt;(); return 0; } 第一个Func，int大于2，enable_if为true，true的特化版本有type成员，可以编译，函数匹配成功第二个Func，char小于2，enable_if为false，它没有type成员，忽略这个模板函数，寻找其它合适的函数，但没有合适的其它模板函数，函数匹配失败 所以报错\n1 2 error C2672: “Func”: 未找到匹配的重载函数 type Func(void)”的显式 模板 参数无效 enable_if_t简化版本，不用写::type\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; using enable_if_t = typename enable_if\u0026lt;_Test, _Ty\u0026gt;::type; template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;(sizeof(T)\u0026gt;2)\u0026gt; Func() { } 以上是第一个bool参数的实现，还有第二个参数_Ty\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; struct enable_if {}; // no member \u0026#34;type\u0026#34; when !_Test template \u0026lt;class _Ty\u0026gt; struct enable_if\u0026lt;true, _Ty\u0026gt; { // type is _Ty for _Test using type = _Ty; }; _Ty默认是void，也就是上面例子中void func 中的 void 的来历，\n1 2 3 4 5 6 7 8 9 10 11 12 enable_if_t\u0026lt;(sizeof(int) \u0026gt; 2),int\u0026gt; D = 3; //等同于using std::enable_if\u0026lt;true,int\u0026gt; = int int D = 3; template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;(sizeof(T)\u0026gt;2),T\u0026gt; Func() { } Func\u0026lt;int\u0026gt;(); //函数为: int Func\u0026lt;int\u0026gt;(); 例1:\n考虑需要根据类型的属性定义不同版本的函数。比如，你可能想要一个只适用于整数类型的加法函数和一个适用于浮点类型的加法函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 仅当 T 是整数类型时此函数才有效 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, T\u0026gt;::type add(T a, T b) { cout\u0026lt;\u0026lt; \u0026#34;Add integer \\n\u0026#34;; return a + b; } // 仅当 T 是浮点类型时此函数才有效 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_floating_point\u0026lt;T\u0026gt;::value, T\u0026gt;::type add(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;Add float \\n\u0026#34;; return a + b; } int main() { add(3,2); add(3.0,2.0); return 0; } 输出\n1 2 Add integer Add float 简化写法 使用enable_if_t\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 仅当 T 是整数类型时此函数才有效 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, T\u0026gt; add(T a, T b) { cout\u0026lt;\u0026lt; \u0026#34;Add integer \\n\u0026#34;; return a + b; } // 仅当 T 是浮点类型时此函数才有效 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_floating_point\u0026lt;T\u0026gt;::value, T\u0026gt; add(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;Add float \\n\u0026#34;; return a + b; } 标准库 std::declval std::declval 是 C++ 标准库中的一个工具，通常用于在编译时生成某个类型的假想值，以便在不实际创建对象的情况下进行类型推导或表达式求值。它主要用于模板元编程和 SFINAE场景中。主要作用是在编译时模拟一个类型的对象，从而可以在不实际构造对象的情况下推导表达式的类型或检查表达式的合法性。std::declval 通常与 decltype 一起使用，用于推导表达式的类型。\n1 2 template \u0026lt;class T\u0026gt; typename std::add_rvalue_reference\u0026lt;T\u0026gt;::type declval() noexcept; 它声明了一个返回类型为 T 的右值引用的函数，但这个函数不应该被调用。其目的仅在于帮助编译器推导类型。 从 C++14 开始，可以使用 std::declval\u0026lt;T\u0026gt;() 更简洁地表示相同的意思，其中 std::declval_t\u0026lt;T\u0026gt; 直接给出了 T 类型的右值引用。 add_rvalue_reference：是C++标准库中的类模板，他的能力是给进来一个类型，他能够返回该类型的右值引用类型。比如： a)给进来一个int类型,返回的就是int \u0026amp;\u0026amp; b)给进来一个int \u0026amp;类型，返回的还是int \u0026amp;类型。这里用到了引用折叠。 c)给进来一个int \u0026amp;\u0026amp;类型，返回的还是int \u0026amp;\u0026amp;类型。这里依旧用到了引用折叠知识。\n示例：基本用法\n假设我们有一个类 MyClass，它有一个成员函数 int foo()。我们想要在不实际创建 MyClass 对象的情况下，推导 foo() 函数的返回类型。\n1 2 int a = 10; decltype(a) b = a; // b 的类型是 int，因为 a 的类型是 int declval + decltype:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyClass { public: MyClass() {cout \u0026lt;\u0026lt; \u0026#34;MyClass constructor called\u0026#34; \u0026lt;\u0026lt; endl;} int foo() { return 42; } }; int main() { // 使用 std::declval 来模拟一个 MyClass 对象，并推导 foo() 的返回类型 using FooReturnType = decltype(std::declval\u0026lt;MyClass\u0026gt;().foo()); // 检查推导的类型是否是 int static_assert(std::is_same\u0026lt;FooReturnType, int\u0026gt;::value, \u0026#34;Foo return type should be int\u0026#34;); return 0; } 在这个过程中MyClass的构造函数不会被调用\nstd::true_type std::true_type 和 std::false_type 是 C++ 标准库中的类型，分别表示编译时的布尔值 true 和 false。它们是类型特征（type traits）的基础，通常用于模板元编程和编译时逻辑判断。\nstd::true_type 和 std::false_type 是类型别名，分别表示 true 和 false 的编译时常量。\n它们的主要作用是在编译时进行逻辑判断，例如通过模板特化或 SFINAE来实现条件编译或类型检查。\nstd::true_type 和 std::false_type 通常与 std::is_same、std::enable_if 等类型特征一起使用。\n它们可以通过 value 成员访问其布尔值（true 或 false）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 _EXPORT_STD using true_type = bool_constant\u0026lt;true\u0026gt;; _EXPORT_STD using false_type = bool_constant\u0026lt;false\u0026gt;; //true_type 拥有成员value //true_type 和 false_type 都继承自bool_constant template \u0026lt;bool _Val\u0026gt; using bool_constant = integral_constant\u0026lt;bool, _Val\u0026gt;; //bool_constant继承自integral_constant template \u0026lt;class _Ty, _Ty _Val\u0026gt; struct integral_constant { static constexpr _Ty value = _Val; using value_type = _Ty; using type = integral_constant; constexpr operator value_type() const noexcept { return value; } _NODISCARD constexpr value_type operator()() const noexcept { return value; } }; 示例1：模板特化\n假设我们有一个模板函数，它需要根据类型是否为指针来决定如何处理该类型的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 模板函数的基础版本，处理非指针类型 template\u0026lt;typename T\u0026gt; void processData(T data, std::false_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing non-pointer data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } // 模板函数的特化版本，处理指针类型 template\u0026lt;typename T\u0026gt; void processData(T* data, std::true_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing pointer data: \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } int main() { int a = 42; int* b = \u0026amp;a; // 对于非指针类型，使用 std::false_type processData(a, std::is_pointer\u0026lt;decltype(a)\u0026gt;{}); // 对于指针类型，使用 std::true_type processData(b, std::is_pointer\u0026lt;decltype(b)\u0026gt;{}); return 0; } processData 函数有两个重载版本：一个用于处理非指针类型，另一个用于处理指针类型。 std::is_pointer\u0026lt;T\u0026gt;::type 返回 std::true_type 或 std::false_type，取决于 T 是否是指针类型。 在 main 函数中，通过 std::is_pointer\u0026lt;decltype(a)\u0026gt; 和 std::is_pointer\u0026lt;decltype(b)\u0026gt; 来区分 a 和 b 的类型，并选择合适的 processData 版本。 1 2 3 //输出结果 Processing non-pointer data: 42 Processing pointer data: 42 示例 2：自定义类型特征\n以下示例展示了如何自定义一个类型特征，用于检查类型是否为指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 主模板：默认情况下，T 不是指针 template \u0026lt;typename T\u0026gt; struct IsPointer : std::false_type {}; // 特化模板：如果 T 是指针，继承 std::true_type template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; : std::true_type {}; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Is int* a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int*\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) std::cout \u0026lt;\u0026lt; \u0026#34;Is int a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) return 0; } 示例 3: SFINAE 中的应用\n假设我们需要一个函数模板，仅当类型 T 是整数类型时才有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 仅对整数类型有效的函数模板 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, void\u0026gt; printIfIntegral(T value, std::true_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Integer value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 如果类型不是整数，则不会实例化此函数 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;!std::is_integral\u0026lt;T\u0026gt;::value, void\u0026gt; printIfIntegral(T value, std::false_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Non-integer value\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { int a = 10; double b = 3.14; printIfIntegral(a, std::is_integral\u0026lt;decltype(a)\u0026gt;{}); printIfIntegral(b, std::is_integral\u0026lt;decltype(b)\u0026gt;{}); return 0; } printIfIntegral 函数有两个模板版本，分别针对整数类型和非整数类型。 std::enable_if 结合 std::is_integral 来控制哪个版本会被实例化。 通过传递 std::is_integral\u0026lt;decltype(a)\u0026gt;{} 或 std::is_integral\u0026lt;decltype(b)\u0026gt;{} 来选择合适的函数版本。 输出\n1 2 Integer value: 10 Non-integer value 总结\nstd::true_type 和 std::false_type 提供了一种简洁的方式来进行编译时的条件判断，特别适用于模板元编程中的类型选择和函数重载。通过结合其他类型特征工具（如 std::is_integral），可以在编译期实现复杂的行为控制和优化。\nstd::function C++11 引入的一个通用函数包装器，用于存储、复制和调用任何可调用对象（如函数、Lambda 表达式、函数对象等）。它提供了一种类型安全的方式来处理各种可调用对象，使得代码更加灵活和通用。\n统一接口：std::function 可以包装任何可调用对象，提供一个统一的接口来调用它们。 类型安全：通过模板参数指定函数签名，确保调用时参数和返回值的类型正确。 灵活性：可以在运行时动态地绑定不同的可调用对象。 1 std::function\u0026lt;返回类型(函数参数....)\u0026gt; 示例 1：包装普通函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int add(int a, int b) { return a + b; } int main() { // 包装一个普通函数 std::function\u0026lt;int(int, int)\u0026gt; func = add; // 调用包装的函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(2, 3) \u0026lt;\u0026lt; std::endl; // 输出 5 return 0; } std::function\u0026lt;int(int, int)\u0026gt; 定义了一个函数包装器，可以存储任何接受两个 int 参数并返回 int 的可调用对象。 func(2, 3) 调用包装的函数。 示例 2：包装 Lambda 表达式\nLambda 表达式也是可调用对象，可以直接存储在 std::function 中。\n1 2 3 4 5 6 7 8 9 // 包装一个 Lambda 表达式 std::function\u0026lt;int(int, int)\u0026gt; func = [](int a, int b) { return a * b; }; // 调用包装的 Lambda 表达式 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(2, 3) \u0026lt;\u0026lt; std::endl; // 输出 6 示例 3: 包装成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyClass { public: int add(int a, int b) { return a + b; } }; int main() { MyClass obj; // 包装一个成员函数 std::function\u0026lt;int(MyClass\u0026amp;, int, int)\u0026gt; func = \u0026amp;MyClass::add; // 调用包装的成员函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(obj, 2, 3) \u0026lt;\u0026lt; std::endl; // 输出 5 return 0; } \u0026amp;MyClass::add 是成员函数的指针。 std::function\u0026lt;int(MyClass\u0026amp;, int, int)\u0026gt; 的第一个参数是对象实例（MyClass\u0026amp;），后面是成员函数的参数。 示例4：作为回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 模拟一个异步任务，完成后调用回调函数 void asyncTask(std::function\u0026lt;void(int)\u0026gt; callback) { int result = 42; // 模拟任务结果 callback(result); // 调用回调函数 } int main() { // 定义一个回调函数 std::function\u0026lt;void(int)\u0026gt; callback = [](int result) { std::cout \u0026lt;\u0026lt; \u0026#34;Task completed with result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; }; // 执行异步任务 asyncTask(callback); // 输出 \u0026#34;Task completed with result: 42\u0026#34; return 0; } asyncTask 接受一个 std::function\u0026lt;void(int)\u0026gt; 类型的回调函数。 在任务完成后，调用回调函数并传递结果。 std::remove_all_extents 是C++ 标准库中的一个类型特征（type trait），用于移除数组类型的所有维度，最终得到数组元素的类型。它的主要作用是简化对多维数组类型的处理。\n移除数组类型的所有维度：如果传入的类型是多维数组（例如 int[3][4]），它会递归地移除所有维度，最终得到数组元素的类型（例如 int）。 简化类型处理：在处理数组类型时，可以直接获取其底层元素类型，而不需要手动解析数组的维度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;typename T\u0026gt; struct remove_all_extents { using type = T; }; template \u0026lt;typename T\u0026gt; struct remove_all_extents\u0026lt;T[]\u0026gt; { using type = typename remove_all_extents\u0026lt;T\u0026gt;::type; }; template \u0026lt;typename T, std::size_t N\u0026gt; struct remove_all_extents\u0026lt;T[N]\u0026gt; { using type = typename remove_all_extents\u0026lt;T\u0026gt;::type; }; 主模板：如果 T 不是数组类型，则直接返回 T。 特化模板：如果 T 是数组类型（如 T[] 或 T[N]），则递归地移除维度，直到得到非数组类型。 示例 1：移除一维数组的维度\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; // 包含 std::remove_all_extents int main() { using ArrayType = int[10]; using ElementType = std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;ArrayType: \u0026#34; \u0026lt;\u0026lt; typeid(ArrayType).name() \u0026lt;\u0026lt; std::endl; // 输出 int [10] std::cout \u0026lt;\u0026lt; \u0026#34;ElementType: \u0026#34; \u0026lt;\u0026lt; typeid(ElementType).name() \u0026lt;\u0026lt; std::endl; // 输出 int return 0; } ArrayType 是 int[10]，表示一个包含 10 个 int 元素的数组。 std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type 移除数组维度，得到 int。 如果传入的类型不是数组类型，std::remove_all_extents 会直接返回该类型。 示例2：结合 std::is_same 进行类型检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { using ArrayType = double[10][20]; using ElementType = std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type; // 检查 ElementType 是否是 double if (std::is_same\u0026lt;ElementType, double\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;ElementType is double!\u0026#34; \u0026lt;\u0026lt; std::endl; // 输出 \u0026#34;ElementType is double!\u0026#34; } else { std::cout \u0026lt;\u0026lt; \u0026#34;ElementType is not double!\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 萃取 类型萃取：从复杂类型（如指针、引用、数组等）中提取基础类型。 参数包萃取：从可变参数模板中提取特定参数。 主要用途\n类型萃取：用于获取类型的基本信息，例如去除引用、指针、cv限定符（const和volatile），或者从数组类型中提取元素类型。 参数包萃取：用于处理可变参数模板，从中提取特定参数进行操作。 类型别名 示例：为不同类型定义不同的求和结果类型\n假设我们需要实现一个通用的求和功能，但不同的类型在求和时可能需要不同的结果类型。例如：\n对于 char 类型，求和结果应该是 int，因为 char 的范围较小，直接相加可能导致溢出。 对于 int 类型，求和结果可以是 int 本身。 对于 double 类型，求和结果可以是 double 本身。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 主模板：默认情况下，求和类型为 T 本身 template \u0026lt;typename T\u0026gt; struct SumTraits { using sumT = T; // 默认求和类型为 T }; // 特化模板：针对 char 类型，求和类型为 int template \u0026lt;\u0026gt; struct SumTraits\u0026lt;char\u0026gt; { using sumT = int; // char 的求和类型为 int }; // 特化模板：针对 int 类型，求和类型为 int template \u0026lt;\u0026gt; struct SumTraits\u0026lt;int\u0026gt; { using sumT = int; // int 的求和类型为 int }; // 特化模板：针对 double 类型，求和类型为 double template \u0026lt;\u0026gt; struct SumTraits\u0026lt;double\u0026gt; { using sumT = double; // double 的求和类型为 double }; //--------------------------------// // 通用的求和函数 template \u0026lt;typename T\u0026gt; typename SumTraits\u0026lt;T\u0026gt;::sumT sum(T a, T b) { return a + b; } int main() { // 测试 char 类型 char c1 = 100, c2 = 100; auto resultChar = sum(c1, c2); cout \u0026lt;\u0026lt; \u0026#34;char sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultChar).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;char sum result: \u0026#34; \u0026lt;\u0026lt; resultChar \u0026lt;\u0026lt; endl; // 输出 200 // 测试 int 类型 int i1 = 100, i2 = 200; auto resultInt = sum(i1, i2); cout \u0026lt;\u0026lt; \u0026#34;int sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultInt).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;int sum result: \u0026#34; \u0026lt;\u0026lt; resultInt \u0026lt;\u0026lt; endl; // 输出 300 // 测试 double 类型 double d1 = 100.5, d2 = 200.5; auto resultDouble = sum(d1, d2); cout \u0026lt;\u0026lt; \u0026#34;double sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultDouble).name() \u0026lt;\u0026lt; endl; // 输出 double cout \u0026lt;\u0026lt; \u0026#34;double sum result: \u0026#34; \u0026lt;\u0026lt; resultDouble \u0026lt;\u0026lt; endl; // 输出 301.0 return 0; } 分析：\n1 2 3 4 5 // 测试 char 类型 char c1 = 100, c2 = 100; auto resultChar = sum(c1, c2); cout \u0026lt;\u0026lt; \u0026#34;char sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultChar).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;char sum result: \u0026#34; \u0026lt;\u0026lt; resultChar \u0026lt;\u0026lt; endl; // 输出 200 sum的返回类型是 SumTraits\u0026lt;T\u0026gt;::sumT, 根据特化模板，sum(char,char)的返回类型 即sumT ，将被推断为int，因此 针对char相加的情况， sum函数的返回类型是int, 所以变量resultChar的类型是int后面的两行cout，一个输出相加结果的类型名称，一个输出相加结果的值.\n总结\n类型别名（using）：通过 using 可以为类型定义别名，使代码更具可读性和灵活性。 模板特化：通过特化模板，可以为不同的类型定义不同的别名。 适用场景：当需要根据类型定制行为时（如返回值类型、参数类型等），可以使用 using 和模板特化。 优势：这种方式使代码更具通用性和可扩展性，能够轻松支持新的类型。 通过这个例子，我们可以看到 using 和模板特化的强大之处：它们能够根据类型的不同，自动选择合适的行为，从而实现高度灵活和可复用的代码。\n萃取元素类型-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 主模板：默认情况下，尝试通过 value_type 萃取元素类型 template \u0026lt;typename T\u0026gt; struct ElementType { using type = typename T::value_type; // 假设 T 有 value_type 成员 }; int main() { // 测试 std::vector using Vector = std::vector\u0026lt;int\u0026gt;; using VectorElement = ElementType\u0026lt;Vector\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;Element type of std::vector\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; typeid(VectorElement).name() \u0026lt;\u0026lt; std::endl; // 输出 int // 测试 std::list using List = std::list\u0026lt;double\u0026gt;; using ListElement = ElementType\u0026lt;List\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;Element type of std::list\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; typeid(ListElement).name() \u0026lt;\u0026lt; std::endl; // 输出 double return 0; } 萃取元素类型-2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template \u0026lt;typename T\u0026gt; struct GetEleType; //特化版本 template \u0026lt;typename T\u0026gt; struct GetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct GetEleType\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt; { using type = T; }; template \u0026lt;typename T, std::size_t Size\u0026gt; //这个特化版本增加了一个模板参数 struct GetEleType\u0026lt;T[Size]\u0026gt; //萃取出数组元素个数 { using type = T; static const std::size_t size = Size; }; int main() { using vectordouble = GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;vector\u0026lt;double\u0026gt;的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(vectordouble).name() \u0026lt;\u0026lt; endl; using listint = GetEleType\u0026lt;std::list\u0026lt;int\u0026gt; \u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;list\u0026lt;int\u0026gt;的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(listint).name() \u0026lt;\u0026lt; endl; using float45 = GetEleType\u0026lt; float[45] \u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;float[45]的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(float45).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float[45]的数组元素数量为：\u0026#34; \u0026lt;\u0026lt; GetEleType\u0026lt; float[45] \u0026gt;::size \u0026lt;\u0026lt; endl; return 0; } 模板参数匹配机制：第一个例子 using vectordouble = GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type;，看上去好像并没有把double传给GetEleType，double只是被传给了vector，但是它能够匹配到正确的GetEleType特化版本，\n实际上这是由 C++ 的 模板特化机制 和 模板参数推导规则 决定的，\nGetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; 的特化版本中有两个 T，分别是：\n模板参数 typename T：这是模板的通用参数，表示任意类型。 特化类型 std::vector\u0026lt;T\u0026gt;：这是特化版本的具体类型，表示 std::vector 的模板参数。 这两个 T 是同一个类型，因为它们是通过模板参数推导确定的。\n使用 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; 时，编译器会按照以下顺序确定 T 的具体类型：\n匹配特化版本： 编译器看到 std::vector\u0026lt;double\u0026gt;，发现它是一个 std::vector\u0026lt;T\u0026gt; 类型。 因此，编译器会尝试匹配特化版本 GetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;。 推导模板参数： 编译器将 std::vector\u0026lt;double\u0026gt; 与 std::vector\u0026lt;T\u0026gt; 进行比较。 由于 std::vector\u0026lt;double\u0026gt; 是 std::vector\u0026lt;T\u0026gt; 的一个实例化版本，编译器可以推导出 T = double。 实例化特化版本： 编译器将 T 替换为 double，实例化出 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;。 在特化版本中，using type = T; 被替换为 using type = double;。 提取类型： 通过 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type，你可以得到 double 类型。 类型萃取 简单的示例：实现一个类型萃取工具 IsPointer，用于判断一个类型是否为指针类型。\n定义主模板：默认情况下，类型不是指针类型，value 为 false。 特化模板：针对指针类型（T*），特化模板并将 value 设为 true。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; // 用于对比标准库的实现 // 主模板：默认情况下，类型不是指针 template \u0026lt;typename T\u0026gt; struct IsPointer { static constexpr bool value = false; }; // 特化模板：针对指针类型 T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; { static constexpr bool value = true; }; int main() { // 测试 int std::cout \u0026lt;\u0026lt; \u0026#34;Is int a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) // 测试 int* std::cout \u0026lt;\u0026lt; \u0026#34;Is int* a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int*\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) // 测试 int** std::cout \u0026lt;\u0026lt; \u0026#34;Is int** a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int**\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) // 测试 std::string std::cout \u0026lt;\u0026lt; \u0026#34;Is std::string a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) return 0; } 如果需要支持更多类型（如 const 指针、volatile 指针等），可以进一步扩展特化模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 特化模板：针对 const 指针类型 const T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;const T*\u0026gt; { static constexpr bool value = true; }; // 特化模板：针对 volatile 指针类型 volatile T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;volatile T*\u0026gt; { static constexpr bool value = true; }; // 特化模板：针对 const volatile 指针类型 const volatile T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;const volatile T*\u0026gt; { static constexpr bool value = true; }; C++ 标准库中已经提供了类似的类型萃取工具 std::is_pointer，其实现原理与上述代码类似。\n引用类型的移除和增加 引用类型的移除\n应用场景：\n在编写模板函数时，我们可能需要处理传入参数的原始类型，而不关心它是否是引用类型。 在完美转发中，我们需要移除参数的引用类型，以便正确地转发参数。 在实现自定义容器时，我们可能需要确保存储的元素类型是非引用类型。RemoveReference 可以帮助我们移除引用，确保类型安全。 有时需要将某个类型转换为它的非引用版本，例如在某些模板元编程场景中。 可能需要从复杂的类型推导出基础类型，去除所有修饰符（如引用、指针、cv限定符等）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u0026lt;class T1, class T2\u0026gt; void print_is_same() { cout \u0026lt;\u0026lt; \u0026#34;T1类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T1类型和T2类型是否相等：\u0026#34; \u0026lt;\u0026lt; std::is_same\u0026lt;T1, T2\u0026gt;::value \u0026lt;\u0026lt; endl; } int main() { std::remove_reference_t\u0026lt;int\u0026gt; a; std::remove_reference_t\u0026lt;int\u0026amp;\u0026gt; b; std::remove_reference_t\u0026lt;int\u0026amp;\u0026amp;\u0026gt; c; print_is_same\u0026lt;decltype(a), decltype(b)\u0026gt;(); print_is_same\u0026lt;decltype(a), decltype(c)\u0026gt;(); return 0; } 手动实现RemoveReferrce\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //泛化版本 template \u0026lt;typename T\u0026gt; struct RemoveReference { using type = T; }; //特化版本 template \u0026lt;typename T\u0026gt; struct RemoveReference\u0026lt;T\u0026amp;\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct RemoveReference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { using type = T; }; //别名模板 template \u0026lt;typename T\u0026gt; using RemoveReference_t = typename RemoveReference\u0026lt;T\u0026gt;::type; int main() { int\u0026amp;\u0026amp; A = 12; RemoveReference_t\u0026lt;decltype(A)\u0026gt; RemoveA = 125; int B = 64; int\u0026amp; RefB = B; RemoveReference_t\u0026lt;decltype(RefB)\u0026gt; RemoveRefB = 500; cout\u0026lt;\u0026lt;format(\u0026#34;{} {} {} {} {}\u0026#34;,A, RemoveA,B,RefB,RemoveRefB) \u0026lt;\u0026lt; endl; return 0; } 运行结果：\n变量 值 类型 A 12 int \u0026amp;\u0026amp; RemoveA 125 int B 64 int RefB 64 int \u0026amp; RemoveRefB 500 int 引用类型的增加：根据给定的类型来创建一个左值或者右值引用 std::add_lvalue_reference：给进来一个类型，返回该类型对应的左值引用类型 std::add_rvalue_reference：给进来一个类型，返回该类型对应的右值引用类型 std::is_lvalue_reference和std::is_rvalue_reference类模板：判断某个类型是否是左值引用类型或者右值引用类型。\n应用场景：\n确保函数参数是左值引用：使用 std::add_lvalue_reference 确保返回类型是左值引用。 实现移动语义：使用 std::add_rvalue_reference 实现移动构造函数或移动赋值操作符。 完美转发：在模板函数中使用完美转发时，可能需要将类型转换为右值引用以保留其值类别。 模板元编程中的类型转换：与其他类型特征结合使用，根据条件动态地添加或移除引用限定符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { int a = 15; //using std::add_lvalue_reference\u0026lt;int\u0026gt;::type = int\u0026amp; std::add_lvalue_reference\u0026lt;decltype(a)\u0026gt;::type b = a; //b的类型为int \u0026amp; //using std::add_rvalue_reference\u0026lt;int\u0026gt;::type = int\u0026amp;\u0026amp; std::add_rvalue_reference\u0026lt;decltype(a)\u0026gt;::type c = 16; //c的类型为int \u0026amp;\u0026amp; using btype = std::add_lvalue_reference_t\u0026lt;int\u0026gt;; //_t是个别名模板 cout \u0026lt;\u0026lt; std::is_same\u0026lt;int\u0026amp;, btype\u0026gt;() \u0026lt;\u0026lt; endl; //1 using ctype = std::add_rvalue_reference_t\u0026lt;int\u0026gt;; cout \u0026lt;\u0026lt; std::is_lvalue_reference\u0026lt;btype\u0026gt;::value \u0026lt;\u0026lt; endl; //1 cout \u0026lt;\u0026lt; std::is_rvalue_reference\u0026lt;ctype\u0026gt;::value \u0026lt;\u0026lt; endl; //1 //cc1类型为int\u0026amp;，这里涉及到引用折叠，\u0026amp;和\u0026amp;\u0026amp; 折叠后得到 \u0026amp;, 后面专门解释一下 std::add_rvalue_reference_t\u0026lt;int\u0026amp;\u0026gt; cc1 = a; //cc2的类型为int \u0026amp;\u0026amp;，这里涉及到引用折叠，\u0026amp;\u0026amp;和\u0026amp;\u0026amp;折叠得到\u0026amp;\u0026amp;。 std::add_rvalue_reference_t\u0026lt;int\u0026amp;\u0026amp;\u0026gt; cc2 = 16; return 0; } 手动实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T\u0026gt; struct AddLValueReference { using type = T\u0026amp;; //int \u0026amp;\u0026amp; \u0026amp; ，引用折叠：有左值 引用，结果必然为左值 引用，所以type = int \u0026amp; }; template\u0026lt;typename T\u0026gt; using AddLValueReference_t = typename AddLValueReference\u0026lt;T\u0026gt;::type; //实际上可以直接简化为using AddLValueReference_t = T\u0026amp;;，这样就不用定义AddLValueReference了。 template\u0026lt;typename T\u0026gt; struct AddRValueReference { using type = T\u0026amp;\u0026amp;; }; template\u0026lt;typename T\u0026gt; using AddRValueReference_t = typename AddRValueReference\u0026lt;T\u0026gt;::type; //实际上可以直接简化为using AddRValueReference_t = T\u0026amp;\u0026amp;;，这样就不用定义AddRValueReference了。 移除const 去除类型的 const 限定符，返回一个非 const 版本的类型。\n1 2 3 const int x = 10; //using std:remove_const\u0026lt;const int\u0026gt;::type = int std::remove_const\u0026lt;decltype(x)\u0026gt;::type D = 10; 手动实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //泛化版本 template \u0026lt;typename T\u0026gt; struct RemoveConst { using type = T; }; //特化版本 template \u0026lt;typename T\u0026gt; struct RemoveConst\u0026lt;const T\u0026gt; { using type = T; }; //根据需要增加其他特化版本.... template \u0026lt;typename T\u0026gt; using RemoveConst_t = typename RemoveConst\u0026lt;T\u0026gt;::type; std::decay 退化 std::decay 是 C++ 标准库中的一个类型特征（type trait），位于 \u0026lt;type_traits\u0026gt; 头文件中。\n用于将给定的类型转换为适合存储在数组或传递给函数的形式\n移除引用：将 T\u0026amp; 或 T\u0026amp;\u0026amp; 转换为 T。 移除 const 和 volatile 限定符：将 const T 或 volatile T 转换为 T。 数组到指针的转换：将数组类型（如 int[10]）转换为指针类型（如 int*）。 函数到指针的转换：将函数类型（如 int(int)）转换为函数指针类型（如 int(*)(int)）。 示例：打印参数类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template \u0026lt;typename T\u0026gt; void printType(T\u0026amp;\u0026amp; value) { using DecayedType = typename std::decay\u0026lt;T\u0026gt;::type; // 使用 std::decay 转换为值类型 std::cout \u0026lt;\u0026lt; \u0026#34;Decayed type of value: \u0026#34; \u0026lt;\u0026lt; typeid(DecayedType).name() \u0026lt;\u0026lt; std::endl; } int main() { int x = 42; const int\u0026amp; y = x; int\u0026amp;\u0026amp; z = 100; printType(x); // 输出 int printType(y); // 输出 int printType(z); // 输出 int printType(200); // 输出 int return 0; } 输出\n1 2 3 4 Decayed type of value: int Decayed type of value: int Decayed type of value: int Decayed type of value: int 示例：数组和函数的类型转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename T\u0026gt; void printDecayedType() { using DecayedType = typename std::decay\u0026lt;T\u0026gt;::type; // 使用 std::decay 转换为值类型 std::cout \u0026lt;\u0026lt; \u0026#34;Decayed type: \u0026#34; \u0026lt;\u0026lt; typeid(DecayedType).name() \u0026lt;\u0026lt; std::endl; } int main() { // 数组类型 printDecayedType\u0026lt;int[10]\u0026gt;(); // 输出 int* // 函数类型 printDecayedType\u0026lt;int(int)\u0026gt;(); // 输出 int (*)(int) return 0; } 输出 Decayed type: int* Decayed type: int (*)(int) 示例：实现通用的类型比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;typename T1, typename T2\u0026gt; void compareTypes() { using DecayedT1 = typename std::decay\u0026lt;T1\u0026gt;::type; // 使用 std::decay 转换为值类型 using DecayedT2 = typename std::decay\u0026lt;T2\u0026gt;::type; // 使用 std::decay 转换为值类型 if (std::is_same\u0026lt;DecayedT1, DecayedT2\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;Types are the same after decay.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Types are different after decay.\u0026#34; \u0026lt;\u0026lt; std::endl; } } int main() { compareTypes\u0026lt;int, const int\u0026amp;\u0026gt;(); // 输出 Types are the same after decay. compareTypes\u0026lt;int[10], int*\u0026gt;(); // 输出 Types are the same after decay. compareTypes\u0026lt;int(int), int(*)(int)\u0026gt;(); // 输出 Types are the same after decay. return 0; } 输出 Types are the same after decay. Types are the same after decay. Types are the same after decay. 值萃取 给进来一个类型，萃取出一个值.\nIsVoid\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; struct voidvaluetraits { static const bool value = false; }; template \u0026lt;\u0026gt; struct voidvaluetraits\u0026lt;void\u0026gt; { static const bool value = true; }; int main() { cout \u0026lt;\u0026lt; \u0026#34;int是void类型吗？\u0026#34; \u0026lt;\u0026lt; voidvaluetraits\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; \u0026#34;void是void类型吗？\u0026#34; \u0026lt;\u0026lt; voidvaluetraits\u0026lt;void\u0026gt;::value \u0026lt;\u0026lt; endl; //1 return 0; } IsSame\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //泛化版本 template\u0026lt;typename T1, typename T2\u0026gt; struct IsSameType { static const bool value = false; }; //特化版本 template\u0026lt;typename T1\u0026gt; struct IsSameType\u0026lt;T1, T1\u0026gt; { static const bool value = true; }; //变量模板 template\u0026lt;typename T1, typename T2\u0026gt; const bool IsSame_v = IsSameType\u0026lt;T1, T2\u0026gt;::value; int main() { cout \u0026lt;\u0026lt; IsSameType\u0026lt;int, const int\u0026gt;::value \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; IsSameType\u0026lt;int, int\u0026gt;::value \u0026lt;\u0026lt; endl; //1 cout \u0026lt;\u0026lt; IsSame_v\u0026lt;int, const int\u0026gt; \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; IsSame_v\u0026lt;int, int\u0026gt; \u0026lt;\u0026lt; endl; //1 return 0; } 因为std::true_type和std::false_type里面有value，所以也可以这样写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //泛化版本 template\u0026lt;typename T1, typename T2\u0026gt; struct IsSameType : std::false_type {\t}; //特化版本 template\u0026lt;typename T1\u0026gt; struct IsSameType\u0026lt;T1, T1\u0026gt;:std::true_type {\t}; //变量模板 template\u0026lt;typename T1, typename T2\u0026gt; const bool IsSame_v = IsSameType\u0026lt;T1, T2\u0026gt;::value; 元编程 将各种计算从运行期提前至编译期，往往会采用递归手段。\n泛型编程：“通用”，程序员不需要关心具体类型元编程：突出一种程序设计技巧达到常规编程难以达到的效果。前面章节：std::remove_all_extents类模板的实现。\n元函数 数值元函数\n1 2 3 4 5 6 7 8 9 10 11 constexpr int Add(int Value,int Value2) { return Value + Value2; } int main() { constexpr int V = Add(3,2); static_assert(V == 5, \u0026#34;std error\u0026#34;); //静态断言,编译期间断言 return 0; } V = 3+2，确实等于5， 如果把 V==5 改成其它值 断言就会失败.\n编译期计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //计算n的阶乘的泛化版本 template \u0026lt;int N\u0026gt; struct Factorial { static constexpr unsigned int value = N * Factorial\u0026lt;N - 1\u0026gt;::value; }; //计算n的阶乘的特化版本，用于做递归调用的出口 template \u0026lt;\u0026gt; struct Factorial\u0026lt;1\u0026gt; { static constexpr unsigned int value = 1; }; int main() { auto A = Factorial\u0026lt;5\u0026gt;::value; cout\u0026lt;\u0026lt;A\u0026lt;\u0026lt;endl; return 0; } 基本模板： template \u0026lt;unsigned int N\u0026gt; 这个模板类有一个静态成员变量 value，其值是 N * Factorial\u0026lt;N - 1\u0026gt;::value。这表示通过递归调用自身来计算阶乘。 特化模板： template \u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; 这是递归的终止条件。当 N 为0时，阶乘的值应该是1。因此，我们特化了这个模板，并将 value 设置为1。 主函数： 在 main 函数中，我们使用 Factorial\u0026lt;5\u0026gt;::value 来获取5的阶乘，并将其打印出来。 循环求值\n1 2 3 4 5 6 7 8 9 constexpr int Factorial(int n_v) { int result = 1; for (int i = 1; i \u0026lt;= n_v; ++i) { result *= i; } return result; } 类型元函数\nremove_all_extents类模板所实现的元编程就是靠递归模板实例化来驱动的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; struct AddPoint //类型元函数 { using type = T*; }; //using AddPoint\u0026lt;int\u0026gt;::type = int * //a是 int* 类型 AddPoint\u0026lt;int\u0026gt;::type a; 或写为 template \u0026lt;typename T\u0026gt; using AddPoint = T*; //using AddPoint\u0026lt;int\u0026gt; =int * AddPoint\u0026lt;int\u0026gt; a; 混合元编程 混合元编程指的是 结合 编译期元编程 和 运行期编程 的技术。通过这种方式，可以利用编译期计算的优势来优化程序性能，并且在运行时根据具体需求动态地执行某些操作。\n编译期元编程：使用模板、constexpr 等机制在编译期进行计算和类型推导，以生成高效的代码。 运行期编程：在程序运行期间进行的常规计算和逻辑处理。 应用场景：\n优化计算：将一些可以在编译期完成的计算提前完成，减少运行时的开销。 类型安全：利用编译期检查确保类型安全，同时在运行时进行灵活的操作。 生成代码：根据编译期信息生成特定的代码片段或数据结构，提高灵活性和效率。 点积计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //泛化版本 template \u0026lt;typename T, int U\u0026gt;//T：元素类型，U：数组大小 struct DotProduct { static T result(const T* a, const T* b) { return (*a) * (*b) + DotProduct\u0026lt;T, U - 1\u0026gt;::result(a + 1, b + 1); } }; //特化版本，用于做递归调用的出口 template \u0026lt;typename T\u0026gt; struct DotProduct\u0026lt;T, 0\u0026gt; { static T result(const T* a, const T* b) { return T{}; } }; int a[] = { 1,2,3 }; int b[] = { 4,5,6 }; int result = DotProduct\u0026lt;int, 3\u0026gt;::result(a, b); 设计模式 如果你只有一把铁锤， 那么任何东西看上去都像是钉子。这个问题常常会给初学模式的人们带来困扰： 在学习了某个模式后， 他们会在所有地方使用该模式， 即便是在较为简单的代码也能胜任的地方也是如此。\n创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性。 如:工厂方法、抽象工厂、生成器、原型、单例 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 如:适配器、桥接、组合、装饰、外观、享元、代理 行为模式负责对象间的高效沟通和职责委派。 如:职责链、命令、备忘录、观察者、模板方法、访问者、迭代器、中介者、状态、策略 面向对象设计原则 代码与技巧不重要，要在这个学习的过程中 建立抽象思维模型\n封装，隐藏内部实现\n继承，复用现有代码\n多态，改写对象行为\n解决复杂性：1.分解，大问题切分成小问题，复杂问题转为多个简单问题2.抽象，使用通用的技术，忽略事物非本质的细节，处理理想的对象模型.\n变化是复用的天敌，面向对象的优势在于抵御变化.\n依赖倒置原则 (DIP)\n高层模块(稳定) 不应该依赖于 低层模块(变化)，二者应该依赖于 抽象(稳定)抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape类有Draw函数 用来画东西，画家类可以使用Shape类画出各种形状，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Shape { public: virtual void Draw() = 0; } class Sphere : public Shape { public: virtual void Draw() override { //画一个圆形.... } } class Box : public Shape { .... } class Painter { public: TArray\u0026lt;Shape*\u0026gt; Shapes; void DrawSomething() { for(auto Shape : Shapes) { Shape-\u0026gt;Draw(); } } } int main() { Shape* SphereDrawer = new Sphere(); Shape* BoxDrawer = new Box(); Painter Painter; Painter.Shapes.add(SphereDrawer,BoxDrawer); // 开始画 Painter.DrawSomething(); //.... } 当Sphere的Draw函数需要变化时，例如 添加或者删掉一点东西，或是因为其它原因，函数需要修改，此时Painter并没有被影响到，它的代码不会发生变动，只需要关注Sphere::Draw的修改即可.\n高层模块(稳定) 不应该依赖于 底层模块(变化)\nPainter可看做是 高层模块，应该稳定，不依赖于 低层模块，Painter没有因为Sphere的变化而变化.\n抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape作为 抽象(稳定) 层，它的Draw没有依赖于具体的实现细节，使用子类来实现Draw.\n最终隔离变化，在Painter、Shape、Sphere中，变化的部分只有Sphere一个.\n通过这个画画的例子可以理解这句话了 \u0026mdash;\u0026gt; 现代软件设计的特征是“需求的频繁变化”，设计模式的要点是 “寻找变化点，在变化点处应用设计模式”，何时何地使用设计模式，比理解设计模式结构本身更重要.\n开放封闭原则 (OCP)\n对扩展开放，对更改封闭类模块应该是可扩展的，但是不可修改.\n单一职责原则(SRP)\n一个类应该仅有一个变化的原因.变化的方向隐含着类的责任.\nLiskov替换原则(LSP)\n子类必须能够替换它的基类（IS-A)\n继承表达类型抽象。\n接口隔离原则(ISP)\n不应该强迫客户程序依赖它们不用的方法\n接口应该小而完备\n优先使用对象组合，而不是类继承\n继承通常为“白箱复用”，对象组合通常为“黑箱复用”继承在某种程度上破坏了封装性，子类父类耦合度高对象组合则只要求被组合的对象具有良好定义的接口，耦合度低.\n封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响.\n针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某个接口\n客户程序无需知道对象的具体类型，只需要知道对象所具有的接口减少系统中各部分的依赖关系.\n产业强盛的标志 — 接口标准化\n秦始皇车同轨 书同文，统一度量衡\n雕版印刷：雕版印刷是在一定厚度的平滑的木板上，粘贴上抄写工整的书稿，薄而近乎透明的稿纸正面和木板相贴，字就成了反体，刻工人用刻刀把版面没有字迹的部分削去，印刷的时候，在凸起的字体上涂上墨汁，然后把纸覆在它的上面，轻轻拂拭纸背，字迹就留在纸上了。\n雕版印刷一版能印几百部甚至几千部书，但是制版很慢，而且有错字不容易更正。\n活字印刷：活字印刷术是一种印刷方法，使用可以移动的木刻字、金属或胶泥字块，用来取代传统的抄写，或是无法重复使用的雕版印刷。活字印刷的方法是先制成单字的阳文反文字模，然后按照稿件把单字挑选出来，排列在字盘内，涂墨印刷，印完后再将字模拆出，留待下次排印时再次使用。\n只印二三本，活字印刷并不比雕版印刷快。如果印成百上千份，工作效率就极其可观了，不仅能够节约大量的人力物力，而且可以大大提高印刷的速度和质量。\n模板方法 现代软件专业分工后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式.\n典型模式：Template Method 模板方法、Strategy 策略模式、Observer/Event 观察者模式\n对于某一项任务，有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或由于固有原因无法和任务的整体结构同时实现，(出现 一个早一个晚 的关系)，如何在确定稳定操作的前提下，灵活应对各个子步骤的变化或晚期实现需求？即 稳定中有变化\n在UE中，使用某些类时，往往需要玩家手动去重写某个函数. 其余的事情玩家不用管，交给引擎去管理流程.你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n下面的代码 基类里的Run函数是稳定的，执行了一套固定的流程，但是其中的某些步骤可以变化， 可以或必须被子类重写，才能完成整个流程. 总之就是 完形填空\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * 抽象类定义了一个模板方法，该方法包含了一些算法的框架， * 具体的子类应当实现这些操作，但应保持模板方法本身不变。 */ class AbstractClass { public: void Run() const { BaseOperation1(); RequiredOperations1();//必须重写 BaseOperation2(); Hook1();//可重写 RequiredOperation2();//必须重写 BaseOperation3(); Hook2();//可重写 } protected: void BaseOperation1() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: I am doing the bulk of the work\\n\u0026#34;; } void BaseOperation2() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I let subclasses override some operations\\n\u0026#34;; } void BaseOperation3() const { std::cout \u0026lt;\u0026lt; \u0026#34;AbstractClass says: But I am doing the bulk of the work anyway\\n\u0026#34;; } virtual void RequiredOperations1() const = 0; virtual void RequiredOperation2() const = 0; virtual void Hook1() const {} virtual void Hook2() const {} }; //////////////////////////////////// class ConcreteClass1 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass1 says: Implemented Operation2\\n\u0026#34;; } }; //////////////////////////////////////// class ConcreteClass2 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation1\\n\u0026#34;; } void RequiredOperation2() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Implemented Operation2\\n\u0026#34;; } void Hook1() const override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteClass2 says: Overridden Hook1\\n\u0026#34;; } }; /////////////////////////////// void ClientCode(AbstractClass *class_) { class_-\u0026gt;Run(); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass1 *concreteClass1 = new ConcreteClass1; ClientCode(concreteClass1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Same client code can work with different subclasses:\\n\u0026#34;; ConcreteClass2 *concreteClass2 = new ConcreteClass2; ClientCode(concreteClass2); delete concreteClass1; delete concreteClass2; return 0; } 输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Same client code can work with different subclasses: AbstractClass says: I am doing the bulk of the work ConcreteClass1 says: Implemented Operation1 AbstractClass says: But I let subclasses override some operations ConcreteClass1 says: Implemented Operation2 AbstractClass says: But I am doing the bulk of the work anyway Same client code can work with different subclasses: AbstractClass says: I am doing the bulk of the work ConcreteClass2 says: Implemented Operation1 AbstractClass says: But I let subclasses override some operations ConcreteClass2 says: Overridden Hook1 ConcreteClass2 says: Implemented Operation2 AbstractClass says: But I am doing the bulk of the work anyway 策略模式 策略是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。\n方便应对多重switch case 或 if else，随时间推移，switch 或 if中的代码需要扩展，写的越来越多，代码很长.\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n计算税，每个国家的税不同，计算方法不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 enum TaxBase { CN_Tax; US_Tax; DE_Tax }; class SalesOrder { TexBase Tax; public: double CalcTax() { if(Tex == CN_Tex) { } else if(Tex == US_Tax) { } else if(Tex == DE_Tax) { } //..... } } 每增加一个国家的计算方法，enum TexBase就要扩充一个枚举值，CalcTax要多一套if else.如果随着时间推移，后续增加的计算方法越多，代码越来越长，极端情况下 Cache甚至放不下代码，一部分代码需要放到内存 甚至是虚拟内存(硬盘)中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class TexStrategy { public: virtual double Calc(const Context\u0026amp; context) = 0; virtual ~TexStrategy(){} } class CNTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class USTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class DETax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class SalesOrder { private: TexStrategy* Strategy; public: SalesOrder(TexStrategy* InStrategy) : Strategy(InStrategy){} ~SalesOrder() { delete Strategy; } double CalcTex() { //.... Context context; double Tex = Strategy-\u0026gt;Calc(context); //..... return Tex; } } 需要扩充计算方法时，只要继承TexStrategy 写一个新的类即可，就能完成新的税种计算.SalesOrder是不需要修改的. 对于新增的类，甚至可以使用增量编译 单独编译一个dll.\n以上代码只是说明一个大概情况，下面的代码是可运行的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Strategy { public: virtual ~Strategy() = default; virtual std::string doAlgorithm(std::string_view data) const = 0; }; class Context { private: std::unique_ptr\u0026lt;Strategy\u0026gt; strategy_; public: explicit Context(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy = {}) : strategy_(std::move(strategy)) { } void set_strategy(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy) { strategy_ = std::move(strategy); } void doSomeBusinessLogic() const { if (strategy_) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = strategy_-\u0026gt;doAlgorithm(\u0026#34;aecbd\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Strategy isn\u0026#39;t set\\n\u0026#34;; } } }; class ConcreteStrategyA : public Strategy { public: std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result), std::greater\u0026lt;\u0026gt;()); return result; } }; void clientCode() { Context context(std::make_unique\u0026lt;ConcreteStrategyA\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context.doSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context.set_strategy(std::make_unique\u0026lt;ConcreteStrategyB\u0026gt;()); context.doSomeBusinessLogic(); } int main() { clientCode(); return 0; } 输出结果\n1 2 3 4 5 6 7 Client: Strategy is set to normal sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) abcde Client: Strategy is set to reverse sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) edcba 这种设计模式 可以在运行时更改对象的算法，将算法和对象本身解耦. 对于这个例子，分辨出哪里是稳定的，哪里是变化的，算法可以通过扩展子类的方式 独立出来进行变化.\n有时候支持不使用的算法也是负担，例如 在计算税的if else版本的代码里，程序安装在America 只需要使用America部分，其它的if都是不必要的，代码在运行时 要加载到Cache、内存， 但是要使用的代码只有其中一小部分，所以其余的代码都是多余加载的。 使用策略模式可以顺便缓解这个情况.\n观察者模式 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n定义对象间的一种一对多(变化)的依赖关系，以便当对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\n例如：UE中的委托、事件分发器、MVC模式\n上图中 中间站的那个小人Player，他拥有一个List容器，存放台下的观察者People，一场表演结束，中途休息， 观众都去外面转悠去了，他们告诉小人 表演的时候给他们发QQ当小人要表演时，遍历List容器 给每个观察者发送一个QQ消息，但是有些观众临时有事，就不再回来看表演了，\n假如A类观众 收到通知还要回来看表演，其中某些观众临时有事，不能回去看表演，所以反手告诉Player不用给他发消息了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; class IPeople { public: virtual void ReceiveNotify() = 0; }; class Player { std::list\u0026lt;IPeople*\u0026gt; Peoples; public: void AddNotify(IPeople* InPeople) { Peoples.push_back(InPeople); } void RemoveNotify(IPeople* InPeople) { Peoples.remove(InPeople); std::cout \u0026lt;\u0026lt; \u0026#34;Player 有一位观众取消接收表演通知 \\n\u0026#34;; } void Notify() { std::cout \u0026lt;\u0026lt; \u0026#34;Player 开播通知 \\n\u0026#34;; for (auto People : Peoples) { People-\u0026gt;ReceiveNotify(); } } }; class PeopleA : public IPeople { public: PeopleA(Player* InPlayer) :Player(InPlayer) { Player-\u0026gt;AddNotify(this); } void GoBack() { //回去看表演 std::cout \u0026lt;\u0026lt; \u0026#34;People 回去看表演 \\n\u0026#34;; } virtual void ReceiveNotify() override { GoBack(); } void RemoveMeFromTheList() { std::cout \u0026lt;\u0026lt; \u0026#34;People 临时有事 \\n\u0026#34;; Player-\u0026gt;RemoveNotify(this); } private: Player* Player; }; int main() { Player* PlayerA = new Player; PeopleA* PeopleA1 = new PeopleA(PlayerA); PeopleA* PeopleA2 = new PeopleA(PlayerA); PeopleA* PeopleA3 = new PeopleA(PlayerA); //中场休息 //临时有事，并告诉Player 表演时不用通知他 PeopleA3-\u0026gt;RemoveMeFromTheList(); //休息结束，要表演了，通知观众表演开始 PlayerA-\u0026gt;Notify(); } 1 2 3 4 5 People 临时有事 Player 有一位观众取消接收表演通知 Player 开播通知 People 回去看表演 People 回去看表演 装饰模式 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n穿衣服是使用装饰的一个例子.觉得冷时， 你可以穿一件毛衣, 如果穿毛衣还觉得冷， 你可以再套上一件夹克。 如果遇到下雨， 你还可以再穿一件雨衣。 所有这些衣物都 “扩展” 了你的基本行为,但它们并不是你的一部分,如果你不再需要某件衣物,可以方便地随时脱掉。\n","date":"1073-01-13T14:39:23+08:00","permalink":"http://localhost:1313/p/%E6%88%90%E4%B8%BA%E5%96%9C%E5%8A%A0%E5%8A%A0%E9%AB%98%E6%89%8B/","title":"成为喜加加高手"}]