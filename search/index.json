[{"content":"蘸豆 爽！ 生命值 = 当前生命值 - 即将到来的伤害.\nAttributeSet Class\n1 2 3 UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } } 受击反馈 1 2 3 4 5 6 7 8 9 10 11 12 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } 这是上文的伤害血量计算. 如果不是致命伤害，就播放 受击动画.\n被打也是一种技能. 受到伤害后 触发GA. 被打的GA要在角色生成时 就要GiveAbility. 作为天生技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } } } 受击 → 触发GA → 应用GE，添加Effect.HitReact标签 → 播放受击动画 → 动画结束 → 移除GE添加的标签 → 结束技能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void AAuraEnemy::BeginPlay() { Super::BeginPlay(); InitAbilityActorInfo(); GetCharacterMovement()-\u0026gt;MaxWalkSpeed = BaseWalkSpeed; UAuraAbilitySystemLibrary::GiveStartupAbilities(this,AbilitySystemComponent); if (UAuraUserWidget* AuraUserWidget = Cast\u0026lt;UAuraUserWidget\u0026gt;(HealthBar-\u0026gt;GetUserWidgetObject())) { AuraUserWidget-\u0026gt;SetWidgetController(this); } if (UAuraAttributeSet* AuraAS = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet)) { AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetMaxHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); OnHealthChanged.Broadcast(AuraAS-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAS-\u0026gt;GetMaxHealth()); } } void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 1 2 3 4 5 6 7 8 9 FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 如果Effect_HitReact标签数量大于0，移动速度设置为0，否则就是正常移动速度.\n1 2 3 4 5 6 7 8 9 10 11 12 13 UENUM(BlueprintType) namespace EGameplayTagEventType { /** Rather a tag was added or removed, used in callbacks */ enum Type : int { /** Event only happens when tag is new or completely removed */ NewOrRemoved, /** Event happens any time tag \u0026#34;count\u0026#34; changes */ AnyCountChange }; } 死亡？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(Props.TargetAvatarActor); if (CombatInterface) { CombatInterface-\u0026gt;Die(); } } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } // 显示伤害数字 ShowFloatingText(Props,LocalIncomingDamage); } } 血量小于0，就调用Die，怎么写？ 随便.\n加了一个 显示伤害数字 的功能， 调用到了 玩家控制器 的函数 ， 把 伤害值 和 受击Actor 的位置 传过去了\n1 2 3 4 5 6 7 8 9 10 11 void UAuraAttributeSet::ShowFloatingText(const FEffectProperites\u0026amp; Props, float Damage) { if (Props.SourceCharacter != Props.TargetCharacter) { AAuraPlayerController* PC = Cast\u0026lt;AAuraPlayerController\u0026gt;(UGameplayStatics::GetPlayerController(this, 0)); if (PC) { PC-\u0026gt;ShowDamageNumber(Damage,Props.TargetCharacter); } } } 玩家控制器 创建一个 DamageText 组件. 根据 传入的位置 设置组件的位置， 把伤害值 传给组件内部.\n1 2 3 4 5 6 7 8 9 10 11 void AAuraPlayerController::ShowDamageNumber_Implementation(float DamageAmount,ACharacter* TargetCharacter) { if (IsValid(TargetCharacter) \u0026amp;\u0026amp; DamageTextComponentClass) { UDamageTextComponent* DamageText = NewObject\u0026lt;UDamageTextComponent\u0026gt;(TargetCharacter,DamageTextComponentClass); DamageText-\u0026gt;RegisterComponent(); DamageText-\u0026gt;AttachToComponent(TargetCharacter-\u0026gt;GetRootComponent(),FAttachmentTransformRules::KeepRelativeTransform); DamageText-\u0026gt;DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform); DamageText-\u0026gt;SetDamageText(DamageAmount); } } SetDamageText是个蓝图实现的函数\n1 2 3 4 5 6 7 8 9 UCLASS() class AURA_API UDamageTextComponent : public UWidgetComponent { GENERATED_BODY() public: UFUNCTION(BlueprintImplementableEvent,BlueprintCallable) void SetDamageText(float Damage); }; UMG在构造函数里 播放这个K出来的数字动画，完事.\n计算伤害 头晕 不想写\nGameplayEffectContext 谁设置了这些Context？\n1 2 UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); ↓\n1 2 3 4 5 6 7 8 9 10 11 12 FGameplayEffectContextHandle UAbilitySystemComponent::MakeEffectContext() const { FGameplayEffectContextHandle Context = FGameplayEffectContextHandle(UAbilitySystemGlobals::Get().AllocGameplayEffectContext()); // By default use the owner and avatar as the instigator and causer if (ensureMsgf(AbilityActorInfo.IsValid(), TEXT(\u0026#34;Unable to make effect context because AbilityActorInfo is not valid.\u0026#34;))) { Context.AddInstigator(AbilityActorInfo-\u0026gt;OwnerActor.Get(), AbilityActorInfo-\u0026gt;AvatarActor.Get()); } return Context; } ↓\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { if (IsValid()) { Data-\u0026gt;AddInstigator(InInstigator, InEffectCauser); } } void FGameplayEffectContext::AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { Instigator = InInstigator; bReplicateInstigator = CanActorReferenceBeReplicated(InInstigator); SetEffectCauser(InEffectCauser); InstigatorAbilitySystemComponent = NULL; // Cache off the AbilitySystemComponent. InstigatorAbilitySystemComponent = UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(Instigator.Get()); } MakeEffectContext最终调用到了AddInstigator，设置Instigator、EffectCauser、InstigatorASC\n以及 MakeEffectContext 调用的构造函数，初始化了一些变量.\n1 2 3 4 5 6 7 8 9 FGameplayEffectContext() : AbilityLevel(1) , WorldOrigin(ForceInitToZero) , bHasWorldOrigin(false) , bReplicateSourceObject(false) , bReplicateInstigator(false) , bReplicateEffectCauser(false) { } 其它属性还没有设置，剩下的属性应该怎么用？\n以火球技能为例，void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); Context.SetAbility(this); Context.AddSourceObject(Projectile); FHitResult HitResult; HitResult.Location = TargetLocation; Context.AddHitResult(HitResult); TArray\u0026lt;TWeakObjectPtr\u0026lt;AActor\u0026gt;\u0026gt; Actors; Actors.Add(Projectile); Context.AddActors(Actors); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); Custom 扩展Context\n","date":"2025-01-16T17:07:49+08:00","permalink":"http://localhost:1313/p/gas-a-%E6%88%98%E6%96%97/","title":"GAS A - 战斗"},{"content":"TODO:属性菜单 没写，太他妈长了，以后再填.\nUI获取GE的GameplayTag消息 应用GE时，获得GE的AssetTag，并且根据这个Tag 做点事情，\n例如：捡到血瓶时，如果GE里面有 Message.xx.xx 的Tag，就通知UI显示“捡到一个血瓶” 之类的文字.\n整体框架:\nOverlayWidgetController.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void UAuraAbilitySystemComponent::AbilityInfoSet() { OnGameplayEffectAppliedDelegateToSelf.AddUObject(this,\u0026amp;UAuraAbilitySystemComponent::ClientEffectApplied); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;EffectAssetTags.AddLambda( [this](const FGameplayTagContainer\u0026amp; AssetTags) { for (const FGameplayTag\u0026amp; Tag : AssetTags) { auto MessageTag = FGameplayTag::RequestGameplayTag(FName(\u0026#34;Message\u0026#34;)); if (Tag.MatchesTag(MessageTag)) { FUIWidgetRow* Row = GetDataTableRowByTag\u0026lt;FUIWidgetRow\u0026gt;(MessageWidgetDataTable,Tag); MessageWidgetRowDelegate.Broadcast(*Row); } } } ); } WidgetController绑定ASC的生命值等属性变化后，再追加一个委托的订阅，ASC在GE应用时 能获得GE的AssetTag，这里只筛选Message的Tag，把它广播出来，WidgetController就能收到ASC应用的GE的标签.\n1 2 3 4 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Messages\u0026#34;) FMessageWidgetRowSignature MessageWidgetRowDelegate; WidgetController里面再来一个委托，让UMG在蓝图里面订阅，把接收到的GE标签广播出去，让UMG订阅接收.\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 USTRUCT() struct FUIWidgetRow : public FTableRowBase { GENERATED_BODY() UPROPERTY(EditAnywhere,BlueprintReadOnly) FGameplayTag AssetTag = FGameplayTag(); UPROPERTY(EditAnywhere,BlueprintReadOnly) FText Message = FText(); UPROPERTY(EditAnywhere,BlueprintReadOnly) TSubclassOf\u0026lt;class UAuraUserWidget\u0026gt; MessageWidget; UPROPERTY(EditAnywhere,BlueprintReadOnly) UTexture2D* Image = nullptr; }; //-------------------------------------// template\u0026lt;typename T\u0026gt; T* GetDataTableRowByTag(UDataTable* DataTable,const FGameplayTag\u0026amp; Tag); template \u0026lt;typename T\u0026gt; T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag\u0026amp; Tag) { return DataTable-\u0026gt;FindRow\u0026lt;T\u0026gt;(Tag.GetTagName(),TEXT(\u0026#34;\u0026#34;)); } //---------------------------------------// 查表，通过Tag获得Message，并广播给蓝图\nMMC 根据等级设置血量\n角色基类AAuraCharacterBase添加一个ICombatInterface接口，Enemy和AAuraCharacter都重写一下GetPlayerLeve函数.Enemy的Level就在Enemy类里面，玩家的Level在PlayerState里面，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 UINTERFACE(MinimalAPI,BlueprintType) class UCombatInterface : public UInterface { GENERATED_BODY() }; /** * */ class AURA_API ICombatInterface { GENERATED_BODY() // Add interface functions to this class. This is the class that will be inherited to implement this interface. public: virtual int32 GetPlayerLeve(); }; //---------------------------// class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface,public ICombatInterface //--------------------------// 1 2 3 4 5 6 7 8 9 10 11 12 int32 AAuraEnemy::GetPlayerLeve() { return Level; } int32 AAuraCharacter::GetPlayerLeve() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState) return AuraPlayerState-\u0026gt;GetPlayerLeve(); } MMC 自定义计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 UCLASS() class AURA_API UMMC_MaxHealth : public UGameplayModMagnitudeCalculation { GENERATED_BODY() public: UMMC_MaxHealth(); virtual float CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const override; private: FGameplayEffectAttributeCaptureDefinition VigorDef; }; UMMC_MaxHealth::UMMC_MaxHealth() { VigorDef.AttributeToCapture = UAuraAttributeSet::GetVigorAttribute(); VigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target; VigorDef.bSnapshot = false; RelevantAttributesToCapture.Add(VigorDef); } float UMMC_MaxHealth::CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const { const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags(); const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags(); FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = SourceTags; EvaluateParameters.TargetTags = TargetTags; float Vigor = 0 ; GetCapturedAttributeMagnitude(VigorDef,Spec,EvaluateParameters,Vigor); Vigor = FMath::Max\u0026lt;float\u0026gt;(Vigor,0.0f); ICombatInterface* Interface = Cast\u0026lt;ICombatInterface\u0026gt;(Spec.GetContext().GetSourceObject()); const int32 PlayerLevel = Interface-\u0026gt;GetPlayerLeve(); return 80 + 2.5 * Vigor + 10.0 * PlayerLevel; } GameplayAbility 1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA里的StartupInputTag是用来绑定输入的，参见后文的 “绑定EnhancedInput“\nASC类里的AddCharacterAbility函数，根据角色类传过来的技能Array赋予技能从StartupAbility里面创建FGameplayAbilitySpec，并且用StartupInputTag作为动态Tag，传入Spec.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 1 2 3 4 5 6 7 /*GameplayAbilitySpec* * An activatable ability spec, hosted on the ability system component. This defines both what the ability is (what class, what level, input binding etc) * and also holds runtime state that must be kept outside of the ability being instanced/activated. */ * 可激活的能力规范，托管在能力系统组件上。这既定义了能力是什么（什么类别、什么级别、输入绑定等） * 也保存了必须保留在实例化/激活的能力之外的运行时状态。 角色基类里用一个TArray保存初始技能，基类AddCharacterAbility函数赋予技能.在玩家类的PossessedBy函数里调用AddCharacterAbility.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 UPROPERTY(EditAnywhere,Category=\u0026#34;Ability\u0026#34;) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; StartupAbility; void AAuraCharacterBase::AddCharacterAbility() { UAuraAbilitySystemComponent* AuraASC = CastChecked\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent); if (!HasAuthority()) return; AuraASC-\u0026gt;AddCharacterAbility(StartupAbility); } void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); AddCharacterAbility(); } GATag Activation Owned Tags 当技能激活时，将设置的Tag应用给技能所有者，在结束时删除。如果将AbilitySystemGlobals里面的配置ReplicateActivationOwnedTags开启，Tag还将会被复制。 Activation Required Tags 当技能激活者拥有设置的所有的Tag时，此技能才能够被激活。 Activation Blocked Tags 当技能激活者有一项设置的Tag，技能就无法被激活 Source Required Tags 当技能所有者拥有设置的所有的Tag时，此技能才能够被激活 Source Blocked Tags 当技能所有者有一项设置的Tag，技能就无法被激活 Target Required Tags 当技能目标者拥有设置的所有的Tag时，此技能才能够被激活 Target Blocked Tags 当技能目标者有一项设置的Tag，技能就无法被激活 绑定EnhancedInput 增强输入\n绑定GameplayTag和InputAction 这是一个用来关联 GameplayTag 和 InputAction的资产 UAuraInputConfig\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 USTRUCT(BlueprintType) struct FAuraInputAction { GENERATED_BODY() UPROPERTY(EditDefaultsOnly) class UInputAction* InputAction = nullptr; UPROPERTY(EditDefaultsOnly) FGameplayTag InputTag = FGameplayTag(); }; UCLASS() class AURA_API UAuraInputConfig : public UDataAsset { GENERATED_BODY() public: const UInputAction* FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag,bool bLogNotFound = false); UPROPERTY(EditDefaultsOnly,BlueprintReadOnly) TArray\u0026lt;FAuraInputAction\u0026gt; AbilityInputActions; }; //------------------------------------// const UInputAction* UAuraInputConfig::FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag, bool bLogNotFound) { for (const auto\u0026amp; Action : AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag == InputTag) { return Action.InputAction; } } if (bLogNotFound) { UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Can Not Found AbilityInputAction for InputTag [%s] on InputConfig [%s]\u0026#34;), *InputTag.ToString(),*GetNameSafe(this)); } return nullptr; } 创建增强输入组件，继承自UEnhancedInputComponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 UCLASS() class AURA_API UAuraInputComponent : public UEnhancedInputComponent { GENERATED_BODY() public: template\u0026lt;class UserClass,typename PressedFuncType,typename ReleasedFuncType,typename HeldFuncType\u0026gt; void BindAbilityActions(const UAuraInputConfig* InputConfig,UserClass* Object, PressedFuncType PressedFunc,ReleasedFuncType ReleasedFunc,HeldFuncType HeldFunc); }; template \u0026lt;class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\u0026gt; void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) { check(InputConfig); for (const auto\u0026amp; Action : InputConfig-\u0026gt;AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag.IsValid()) { if (PressedFunc) { BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); } if (ReleasedFunc) { BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); } if (HeldFunc) { BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); } } } } typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\n这3个参数 传入函数时，编译器会自动推导其类型可以把 \u0026amp;AAuraPlayerController::AbilityInputTagPressed 这样的参数传入进去.\n在玩家控制器里调用这个BindAbilityActions函数， 来绑定GameplayTag和InputAction.\n准备3个输入函数，分别是 Pressed、Released、Held 状态下的输入， 按下、释放、按住.\n并且这3个函数可以接收传来的FGameplayTag InputTag，因为上面的增强输入在绑定时，就可以把参数传到函数里.\n1 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction的最后两个参数 - PressedFunc函数被调用时，会把Action.InputTag传给这个函数. 所以可以使用AbilityInputTagPressed(FGameplayTag InputTag) 这样的函数 去接收传来的InputTag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { } 使用准备好的UAuraInputConfig资产 绑定输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //AuraPlayerController.h\tUPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) TObjectPtr\u0026lt;UAuraInputConfig\u0026gt; InputConfig; void AAuraPlayerController::SetupInputComponent() { Super::SetupInputComponent(); UAuraInputComponent* AuraInputComponent = CastChecked\u0026lt;UAuraInputComponent\u0026gt;(InputComponent); AuraInputComponent-\u0026gt;BindAction(MoveAction,ETriggerEvent::Triggered,this,\u0026amp;AAuraPlayerController::Move); AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); } 注意执行输入的参数顺序Press,Released,Held\n1 2 3 4 5 void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); 现在就把 GameplayTag 和 玩家控制器 里面的函数绑定上了，\n总结 回顾整个流程，\n1.首先创建了一个资产UAuraInputConfig，这个资产定义了 GameplayTag 和 InputAction 绑定关系，2.在 玩家控制器 里面，指定了UAuraInputConfig，再调用 增强输入 的函数，使用这个资产进行 GameplayTag和InputAction的绑定.3.增强输入 利用InputAction绑定一个要执行的函数，按下按键时 执行哪一个函数.4.绑定完了函数 还不够， 按下按键时执行函数 并且函数还要接收到对应的那个 GameplayTag.\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); 第4个条件 就是用这个BindAction绑定起来的，当按下按键时、松开按键时、持续按住按键时、都会把 Action.InputTag 传给对应的 响应函数.\n这样就实现了 按下按键时，还能获得对应按键的GameplayTag.\n1 2 3 4 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } 这个函数就能接收到 GameplayTag 的值.\n1 2 3 4 5 6 7 8 template\u0026lt;class UserClass, typename... VarTypes\u0026gt;\t\\ FEnhancedInputActionEventBinding\u0026amp; BindAction(const UInputAction* Action, ETriggerEvent TriggerEvent, UserClass* Object, typename HANDLER_SIG::template TMethodPtr\u0026lt; UserClass, VarTypes... \u0026gt; Func, VarTypes... Vars) \\ {\t\\ TUniquePtr\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt; AB = MakeUnique\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt;(Action, TriggerEvent);\t\\ AB-\u0026gt;Delegate.BindDelegate\u0026lt;UserClass\u0026gt;(Object, Func, Vars...);\t\\ AB-\u0026gt;Delegate.SetShouldFireWithEditorScriptGuard(bShouldFireDelegatesInEditor);\t\\ return *EnhancedActionEventBindings.Add_GetRef(MoveTemp(AB));\t\\ } 这是增强输入里使用的变参模板，应该是可以让按下按键时 触发的那个响应函数 接收任意数量的参数. 随便接.例如:\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc, Action.InputTag,floatA,floatB,floatC,floatD); void Pressed(FGameplayTag InputTag,float a,float b,float c,float d); 激活技能 前面的 GameplayAbility 片段，在GA里面定义了一个变量StartupInputTag\n1 2 UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; 并且在ASC里面GiveAbility时，把这个StartupInputTag传给 GameplayAbilitySpec 作为动态Tag.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 现在 就使用这个Tag条件 作为 按键输入 和 激活技能 之间的桥梁.\n在ASC里创建下面两个函数，接收一个GameplayTag，按下按键时 就调用这两个函数，激活技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void UAuraAbilitySystemComponent::AbilityInputHeld(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputPressed(AbilitySpec); if (!AbilitySpec.IsActive()) { TryActivateAbility(AbilitySpec.Handle); } } } } void UAuraAbilitySystemComponent::AbilityInputReleased(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputReleased(AbilitySpec); } } } 玩家控制器 绑定了GameplayTag 和 按键响应的函数， 在按键响应的函数里能够接收到 那个按键对应的GameplayTag， 现在要做的是: 这个接收到的 GameplayTag 只要和某个 GA 的GameplayTag 匹配成功，就激活那个GA.\n按键响应的函数 在玩家控制器里，激活技能需要角色身上的ASC，AbilitySystemComponent玩家控制器 能够获得角色，从角色身上获得ASC， 好了 这就是思路.\n玩家控制器里面用一个指针存放 ASC，如果ASC有效 就使用存储的ASC，如果无效 则重新获得角色以及ASC.\n1 2 UPROPERTY() TObjectPtr\u0026lt;UAuraAbilitySystemComponent\u0026gt; AuraAbilitySystemComponent; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputReleased(InputTag); } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputHeld(InputTag); } UAuraAbilitySystemComponent* AAuraPlayerController::GetASC() { if (AuraAbilitySystemComponent == nullptr) { AuraAbilitySystemComponent =Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn\u0026lt;APawn\u0026gt;())); } return AuraAbilitySystemComponent; } 投射物 从人物手上发射一个火球，撞到敌人造成伤害\n前面在 GameplayAbility 这一片段创建了自定义的GA，\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; 一个GA，一个火球Actor.GA播放角色发射火球的动作蒙太奇，GA等待GameplayEvent， 当Event触发时 才发射火球，动画蒙太奇在执行到指定帧时，通过动画通知触发Event，让GA发射火球GA在生成火球Actor时，把GE传给Actor，Actor撞到敌人，对敌人应用GE 造成伤害，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void UAuraProjectileSpell::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); } void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) { AActor* AvartarActor = GetAvatarActorFromActorInfo(); bool bIsServer = AvartarActor-\u0026gt;HasAuthority(); if (!bIsServer) return; ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(AvartarActor); if (CombatInterface) { const FVector SockLocation = CombatInterface-\u0026gt;GetCombatSocketLocation(); FRotator Rotation = (TargetLocation - SockLocation).Rotation(); Rotation.Pitch = 0 ; AActor* OwningActor = GetOwningActorFromActorInfo(); FTransform SpawnTransform; SpawnTransform.SetLocation(SockLocation); SpawnTransform.SetRotation(Rotation.Quaternion()); AAuraProjectile* Projectile = GetWorld()-\u0026gt;SpawnActorDeferred\u0026lt;AAuraProjectile\u0026gt;( ProjectileClass, SpawnTransform, OwningActor, Cast\u0026lt;APawn\u0026gt;(OwningActor), ESpawnActorCollisionHandlingMethod::AlwaysSpawn); UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get(); const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel()); UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpeceHandle,GameplayTags.Damage,ScaledDamage); Projectile-\u0026gt;DamaeEffectSpecHandle = SpeceHandle; Projectile-\u0026gt;FinishSpawning(SpawnTransform); } } SetByCaller - AssignTagSetByCallerMagnitude\nSetByCaller，在GA里设置伤害，GE里配置Tag，GA通过Tag把数值传给GE.\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA能获得AvatarActor，这就是角色，但不直接Cast到玩家角色，而是使用一个接口去做，没有硬绑定为某个具体角色类.接口的GetCombatSocketLocation函数，只是一个获取骨骼插槽位置的，返回一个Vector. 有起始位置和目标位置 就能设置火球Actor的朝向，让火球对准过去.\n1 void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) TargetLocation是在蓝图里设置的\n1 2 3 4 5 FVector AAuraCharacterBase::GetCombatSocketLocation() { check(Weapon); return Weapon-\u0026gt;GetSocketLocation(WeaponTipSocketName); } AuraProjectile.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 UCLASS() class AURA_API AAuraProjectile : public AActor { GENERATED_BODY() public:\tAAuraProjectile(); UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;UProjectileMovementComponent\u0026gt; ProjectileMovement; UPROPERTY(BlueprintReadWrite,meta = (ExposeOnSpawn = true)) FGameplayEffectSpecHandle DamaeEffectSpecHandle; protected: virtual void BeginPlay() override; UFUNCTION() void OnSphereOverlap( UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult \u0026amp; SweepResult); private: UPROPERTY(EditAnywhere) float LifeSpan = 10; UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;USphereComponent\u0026gt; Sphere; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UNiagaraSystem\u0026gt; ImpactEffect; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; ImpactSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; LoopingSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UAudioComponent\u0026gt; LoopingSoundComponent; }; AuraProjectile.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 AAuraProjectile::AAuraProjectile() { PrimaryActorTick.bCanEverTick = false; bReplicates =true; Sphere = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(\u0026#34;Sphere\u0026#34;); SetRootComponent(Sphere); Sphere-\u0026gt;SetCollisionObjectType(ECC_Projectile); Sphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); Sphere-\u0026gt;SetCollisionResponseToAllChannels(ECR_Ignore); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldDynamic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldStatic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_Pawn,ECR_Overlap); ProjectileMovement = CreateDefaultSubobject\u0026lt;UProjectileMovementComponent\u0026gt;(\u0026#34;ProjectileMovement\u0026#34;); ProjectileMovement-\u0026gt;InitialSpeed = 550; ProjectileMovement-\u0026gt;MaxSpeed = 550; ProjectileMovement-\u0026gt;ProjectileGravityScale = 0; } void AAuraProjectile::BeginPlay() { Super::BeginPlay(); SetLifeSpan(LifeSpan); Sphere-\u0026gt;OnComponentBeginOverlap.AddDynamic(this,\u0026amp;ThisClass::OnSphereOverlap); LoopingSoundComponent = UGameplayStatics::SpawnSoundAttached(LoopingSound,GetRootComponent()); } void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult\u0026amp; SweepResult) { UGameplayStatics::PlaySoundAtLocation(this,ImpactSound,GetActorLocation()); UNiagaraFunctionLibrary::SpawnSystemAtLocation(this,ImpactEffect,GetActorLocation()); LoopingSoundComponent-\u0026gt;Stop(); if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor)) { TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*DamaeEffectSpecHandle.Data.Get()); } Destroy(); } AbilityTask 技能任务（C++类\u0026quot;UAbilityTask\u0026quot;）是更常规的技能任务类的特殊形式，旨在使用游戏性技能。使用游戏性技能系统的游戏通常包括各种自定义技能任务，这些任务实施其独特的游戏功能。它们在游戏性技能执行过程中执行异步工作，并且能够通过调用委托（Delegate） （在本地C++代码中）或移经一个或多个输出执行引脚（在蓝图中）来影响执行流。这使技能能够跨多个帧执行，并可在同一帧内执行多个不同的函数。大部分技能任务都有一个即时触发的执行引脚，使蓝图能够在任务开始后继续执行。此外，通常还有一些特定于任务的引脚，它们会在延迟后或在可能发生或不发生的某个事件之后触发。\n技能任务可以通过调用\u0026quot;EndTask\u0026quot;函数自行终止，或者等待运行它的游戏性技能结束，此时它会自动终止。这可以防止幻影技能任务运行，有效地泄漏CPU周期和内存。例如，某个技能任务可能播放一个施法动画，而另一个任务则在玩家的瞄准点处放置一个靶向标线。如果玩家点击确认输入来施放该法术，或者等待动画结束而未确认该法术，游戏性技能就会结束。虽然它们可以在任何时候自动终止，但是技能任务保证最晚在主要技能结束时终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMouseTargetDataSignature,const FVector\u0026amp;,Data); UCLASS() class AURA_API UTargetDataUnderMouse : public UAbilityTask { GENERATED_BODY() public: UFUNCTION(BlueprintCallable,Category=\u0026#34;Ability|Tasks\u0026#34;,meta = (DisplayName = \u0026#34;TargetDataUnderMouse\u0026#34;,HidePin=\u0026#34;OwningAbility\u0026#34;,DefaultToSelf = \u0026#34;OwningAbility\u0026#34;,BlueprintInternalUseOnly)) static UTargetDataUnderMouse* CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility); UPROPERTY(BlueprintAssignable) FMouseTargetDataSignature ValidData; private: virtual void Activate() override; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 UTargetDataUnderMouse* UTargetDataUnderMouse::CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility) { UTargetDataUnderMouse* Myobj = NewAbilityTask\u0026lt;UTargetDataUnderMouse\u0026gt;(OwningAbility); return Myobj; } void UTargetDataUnderMouse::Activate() { APlayerController* PC = Ability-\u0026gt;GetCurrentActorInfo()-\u0026gt;PlayerController.Get(); FHitResult HitResult; PC-\u0026gt;GetHitResultUnderCursor(ECC_Visibility,false,HitResult); ValidData.Broadcast(HitResult.Location); } 蓝图调用UTargetDataUnderMouse的static函数 创建UTargetDataUnderMouse，创建之后调用Activate函数.\nBlueprintAssignable\n写在AbilityTask.h里的说明: 点击查看大图UnrealEngine/Engine/Plugins/Runtime/GameplayAbilities/Source/GameplayAbilities/Public/Abilities/Tasks\nGithub上的AbilityTask.h\nGameplayEvent 等待指定的游戏标记事件触发。默认情况下，这将查看此功能的所有者。可以设置 OptionalExternalTarget 以使其查看另一个参与者的标记以进行更改 只要 OnlyTriggerOnce = false，它就会继续监听 如果 OnlyMatchExact = false，它将触发嵌套标记 WaitGameplayEvent与ASC有关. 或许 ASC就是连接Send和Wait之间的桥梁. 所以在动画通知里要GetOwnerActor 给Owner发Event.\nSendGameplayEventToActor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload) { if (::IsValid(Actor)) { UAbilitySystemComponent* AbilitySystemComponent = GetAbilitySystemComponent(Actor); if (AbilitySystemComponent != nullptr \u0026amp;\u0026amp; IsValidChecked(AbilitySystemComponent)) { using namespace UE::AbilitySystem::Private; if (EnumHasAnyFlags(static_cast\u0026lt;EAllowPredictiveGEFlags\u0026gt;(CVarAllowPredictiveGEFlagsValue), EAllowPredictiveGEFlags::AllowGameplayEventToApplyGE)) { FScopedPredictionWindow NewScopedWindow(AbilitySystemComponent, true); AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } else { AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } } else { ABILITY_LOG(Error, TEXT(\u0026#34;UAbilitySystemBlueprintLibrary::SendGameplayEventToActor: Invalid ability system component retrieved from Actor %s. EventTag was %s\u0026#34;), *Actor-\u0026gt;GetName(), *EventTag.ToString()); } } } 在HandleGameplayEvent里面 引用到一个AbilitySystemComponent里面的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int32 UAbilitySystemComponent::HandleGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload) { int32 TriggeredCount = 0; FGameplayTag CurrentTag = EventTag; ABILITYLIST_SCOPE_LOCK(); // 省略 if (FGameplayEventMulticastDelegate* Delegate = GenericGameplayEventCallbacks.Find(EventTag)) { // Make a copy before broadcasting to prevent memory stomping FGameplayEventMulticastDelegate DelegateCopy = *Delegate; DelegateCopy.Broadcast(Payload); } // 省略 return TriggeredCount; } AbilityTask_WaitGameplayEvent\n这里面就用到了上面提到的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void UAbilityTask_WaitGameplayEvent::Activate() { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC) { if (OnlyMatchExact) { MyHandle = ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).AddUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventCallback); } else { MyHandle = ASC-\u0026gt;AddGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), FGameplayEventTagMulticastDelegate::FDelegate::CreateUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventContainerCallback)); }\t} Super::Activate(); } void UAbilityTask_WaitGameplayEvent::OnDestroy(bool AbilityEnding) { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC \u0026amp;\u0026amp; MyHandle.IsValid()) { if (OnlyMatchExact) { ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).Remove(MyHandle); } else { ASC-\u0026gt;RemoveGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), MyHandle); } } Super::OnDestroy(AbilityEnding); } 大胆猜想，GamepalyEvent就是ASC运作的WaitGameplayEvent 把要监听的GameplayTag发给ASC，当SendGameplayEvent给ASC发送Tag时，如果监听的和接收到的Tag一样，ASC就会激活触发GameplayTagEvent，\n使用数据表初始化敌人属性 不想写了，看别人写的吧\n","date":"2025-01-11T12:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-gega%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/","title":"GAS A - GE、GA、输入绑定"},{"content":"官方文档\nGit文档\nGameplayEffect 函数名称 用途 PreAttributeChange / PreAttributeBaseChange 这些函数在即将修改属性之前调用。函数旨在实施关于属性值的规则，例如，\u0026ldquo;生命值必须介于0和最大生命值\u0026quot;之间，并且不得对属性更改触发游戏内响应。 PreGameplayEffectExecute 在即将修改属性值之前，此函数可以拒绝或更改拟定修改。 PostGameplayEffectExecute 在修改属性值后，此函数可立即对更改做出响应。这通常包括限制属性的最终值或触发对新值的游戏内响应，例如当\u0026quot;生命值\u0026quot;属性降至零时死亡。 Gameplay效果组件 说明 UChanceToApplyGameplayEffectComponent 应用Gameplay效果的概率。 UBlockAbilityTagsGameplayEffectComponent 根据所有者Gameplay效果目标Actor的Gameplay标签，进行Gameplay技能激活阻止处理。 UAssetTagsGameplayEffectComponent Gameplay效果资产拥有的标签。这些标签 不会 转移到Actor。 UAdditionalEffectsGameplayEffectComponent 添加尝试在特定条件下激活（或任何条件下都不激活）的其他Gameplay效果。 UTargetTagsGameplayEffectComponent 将标签授予Gameplay效果的目标（有时指所有者）。 UTargetTagRequirementsGameplayEffectComponent 指定如果此GE须应用或继续执行，目标（Gameplay效果的拥有者）必须具备的标签要求。 URemoveOtherGameplayEffectComponent 基于某些条件移除其他Gameplay效果。 UCustomCanApplyGameplayEffectComponent 处理CustomApplicationRequirement函数的配置，以查看是否应该应用此Gameplay效果。 UImmunityGameplayEffectComponent 免疫会阻止其他GameplayEffectSpecs的应用。 新版本的GE效果组件\nAbilities Gameplay Effect component 这个组件主要是在GameplayEffect激活时，可以向目标添加的GameplayAbility\nAddtional Effects Gameplay Effect Component 当此效果添加时或完成时，需要额外添加的效果。 On Appliaciton Gameplay Effects 在添加此效果时，额外添加的效果 On Complete Always 当此效果完成时，不管正常结束还是不正常结束时，添加的效果 On Complete Normal 当此效果正常结束时，添加的额外的效果 On Complete Prematurely 当此效果提前结束时，添加的额外的效果\nGameplay效果组件 说明 Asset Tags Gameplay Effect Component 在添加此GE时，需要额外处理的标签（添加 和 删除），这个标签将放置在GE上面，只是作为一个GE的标记 Block Ability Tags Gameplay Component 添加或删除能够阻挡技能的Tags的组件，这些Tags会在GE运行时添加到Actor身上，用于阻挡其它拥有此Tag的GE或者GA的激活。 Chance to Apply Gameplay Effect Component 当前GE应用到Actor身上的几率，0为百分之0几率，1为百分之百几率 Custom Can Apply Gameplay Effect Component 自定义能够应用GE的组件，可以自定义条件来设置应用是否成功。 Immunity Gameplay Effect Component 配置角色免疫其它GE的条件 Remove Other Gameplay Effect Component 配置移除其它的GE，满足设置的标签或者资源满足条件的GE都会被移除掉。 Target Tag Requirements Gameplay Effect Component 根据目标的Tag设置当前的GE的状态Appliaction 为GE添加到目标身上时Tag的状态Ongoing 为GE激活时Tag的状态Removal 为GE被删除时Tag的状态 Target Tags Gameplay Effect Component 添加此GE后，对Actor身上带有的Tag进行操作（添加或删除），这个会随着GE的添加修改，在GE失效时移除。非Instant使用。 GameplayEffectSpec GameplayEffectSpec(GESpec)可以看作是GameplayEffect的实例, 它保存了一个其所代表的GameplayEffect类引用, 创建时的等级和创建者, 它在应用之前可以在运行时(Runtime)自由的创建和修改, 不像GameplayEffect应该由设计师在运行前创建. 当应用GameplayEffect时, GameplayEffectSpec会自GameplayEffect创建并且会实际应用到目标(Target).\nGameplayEffectSpec是由UAbilitySystemComponent::MakeOutgoingSpec()(BlueprintCallable)自GameplayEffect创建的. GameplayEffectSpec不必立即应用. 通常是将GameplayEffectSpec传递给创建自Ability的投掷物, 该投掷物可以应用到它之后击中的目标. 当GameplayEffectSpec成功应用后, 就会返回一个名为FActiveGameplayEffect的新结构体.\nGameplayEffectSpec的重要内容:\n创建该GameplayEffectSpec的GameplayEffect类. 该GameplayEffectSpec的等级. 通常和创建GameplayEffectSpec的Ability的等级一样, 但是可以是不同的. GameplayEffectSpec的持续时间. 默认是GameplayEffect的持续时间, 但是可以是不同的. 对于周期性Effect中GameplayEffectSpec的周期, 默认是GameplayEffect的周期, 但是可以是不同的. 该GameplayEffectSpec的当前堆栈数. 堆栈限制取决于GameplayEffect. GameplayEffectContextHandle表明该GameplayEffectSpec由谁创建. Attribute在GameplayEffectSpec创建时由Snapshot捕获. 除了GameplayEffect授予的GameplayTags, GameplayEffectSpec还会授予目标(Target)DynamicGrantedTags. 除了GameplayEffect拥有的AssetTags, GameplayEffectSpec还会拥有DynamicAssetTags. SetByCaller TMaps. 1 2 3 4 5 6 7 8 9 10 11 12 void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); } Stack堆栈 GameplayEffect默认会应用新的GameplayEffectSpec实例, 而不明确或不关心之前已经应用过的尚且存在的GameplayEffectSpec实例. GameplayEffect可以设置到堆栈中, 新的GameplayEffectSpec实例不会添加到堆栈中, 而是修改当前已经存在的GameplayEffectSpec堆栈数. 堆栈只适用于持续(Duration)和无限(Infinite)GameplayEffect.\nSource就是AbilitySystemComponent\n堆栈类型 描述 Aggregate by Source 目标(Target)上的每个源(Source)ASC都有一个单独的堆栈实例, 每个源(Source)可以应用堆栈中的X个GameplayEffect. Aggregate by Target 目标(Target)上只有一个堆栈实例而不管源(Source)如何, 每个源(Source)都可以在共享堆栈限制(Shared Stack Limit)内应用堆栈. By Source ，每个Source对象拥有一个计数，计数达到限制时 不能再对Target应用GE.Source1的Stack达到2后，再次应用会失效. 这时再起一个Source2对象 就可以应用GE，因为它的Stack没有达到限制\nBy Target，只要Target的Stack达到限制，不管有多少个Source 都不能对Target应用GE.\n详细解释\n————————————————\nInfinite GE的添加、移除 当GameplayEffectSpec成功应用后, 就会返回一个FActiveGameplayEffectHandle.\n在应用GESpec后，把TargetASC和GEHandle加入到Map里这是针对区域效果的操作，如果有2个玩家进入伤害区域，在他们离开区域时 要通过 \u0026lt;离开的Acotr\u0026gt; 这个条件去Map寻找他对应的GEHandle，从而根据GEHandle移除他身上的GE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TMap\u0026lt;FActiveGameplayEffectHandle,UAbilitySystemComponent*\u0026gt; ActiveEffectHandls; void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); const bool bIsInfinite = EffectSpecHandle.Data.Get()-\u0026gt;Def.Get()-\u0026gt;DurationPolicy == EGameplayEffectDurationType::Infinite; if (bIsInfinite \u0026amp;\u0026amp; InfiniteEffectRemovePolicy == EEffectRemovePolicy::RemoveOnEndOverlap) { ActiveEffectHandls.Add(ActiveEffectHandle,TargetASC); } } 移除通过Actor的ASC查找Map里对应的GEHandle，使用Handle移除Actor的ASC上面的GE后，还要在Map里移除这一对元素.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void AAuraEffectActor::RemoveGE(AActor* TargetActor) { UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (!IsValid(ASC)) return; // TArray\u0026lt;FActiveGameplayEffectHandle\u0026gt; HandlesToRemove; for (TTuple\u0026lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*\u0026gt; HandlePair : ActiveEffectHandls) { if (HandlePair.Value == ASC) { ASC-\u0026gt;RemoveActiveGameplayEffect(HandlePair.Key,1); HandlesToRemove.Add(HandlePair.Key); } } for (FActiveGameplayEffectHandle\u0026amp; Handle : HandlesToRemove) { ActiveEffectHandls.FindAndRemoveChecked(Handle); } // /*使用迭代器遍历 TMap for (auto It = ActiveEffectHandls.CreateIterator(); It; ++It) { if (It-\u0026gt;Value == ASC) { // 删除 ActiveGameplayEffect ASC-\u0026gt;RemoveActiveGameplayEffect(It-\u0026gt;Key); // 删除 TMap 中的元素 It.RemoveCurrent(); } }*/ } 数值的限制 与 响应 生命值等属性在应用GE后 可能会变成负数，或者超出最大生命值，\nPreAttributeChange PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue)是AttributeSet中的主要函数之一, 其在修改发生前响应Attribute的CurrentValue变化, 其是通过引用参数NewValue限制(Clamp)CurrentValue即将进行的修改的理想位置.\n例如像样例项目那样限制移动速度Modifier:\n1 2 3 4 5 if (Attribute == GetMoveSpeedAttribute()) { // Cannot slow less than 150 units/s and cannot boost more than 1000 units/s NewValue = FMath::Clamp\u0026lt;float\u0026gt;(NewValue, 150, 1000); } GetMoveSpeedAttribute()函数是由我们在AttributeSet.h中添加的宏块创建的(定义Attribute).\nPreAttributeChange()可以被Attribute的任何修改触发, 无论是使用Attribute的setter(由AttributeSet.h中的宏块定义(定义Attribute))还是使用GameplayEffect.\nNote: 在这里做的任何限制都不会永久性地修改ASC中的Modifier, 只会修改查询Modifier的返回值, 这意味着像GameplayEffectExecutionCalculations和ModifierMagnitudeCalculations这种自所有Modifier重新计算CurrentValue的函数需要再次执行限制(Clamp)操作.\nNote: Epic对于PreAttributeChange()的注释说明不要将该函数用于游戏逻辑事件, 而主要在其中做限制操作. 对于修改Attribute的游戏逻辑事件的建议位置是UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)(响应Attribute变化).\n限制生命值示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue) { Super::PreAttributeChange(Attribute, NewValue); if (Attribute == GetHealthAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxHealth()); } if (Attribute == GetManaAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxMana()); } } ·当前值的变化 - 在变化发生之前 ·由属性的变化触发 - 属性访问器 - GameplayEffects ·不会永久更改修饰符，只会更改查询修饰符返回的值 ·后续操作会重新计算所有修饰符的当前值 - 我们需要再次限制\nPostGameplayEffectExecute PostGameplayEffectExecute(const FGameplayEffectModCallbackData \u0026amp; Data)仅在即刻(Instant)GameplayEffect对Attribute的BaseValue修改之后触发, 当GameplayEffect对其修改时, 这就是一个处理更多Attribute操作的有效位置.\n例如, 在样例项目中, 我们在这里从生命值Attribute中减去了最终的伤害值Meta Attribute, 如果有护盾值Attribute的话, 我们也会在减除生命值之前从护盾值中减除伤害值. 样例项目也在这里应用了被击打反应动画, 显示浮动的伤害数值和为击杀者分配经验值和赏金. 通过设计, 伤害值Meta Attribute总是会传递给即刻(Instant)GameplayEffect而不是Attribute Setter.\n其他只会由即刻(Instant)GameplayEffect修改BaseValue的Attribute, 像魔法值和耐力值, 也可以在这里被限制为其相应的最大值Attribute.\nNote: 当PostGameplayEffectExecute()被调用时, 对Attribute的修改已经发生, 但是还没有被同步回客户端, 因此在这里限制值不会造成对客户端的二次同步, 客户端只会接收到限制后的值.\n限制生命值:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } } PreAttributeChange 和 PostGameplayEffectExecute 一起使用，这样才是真正的限制住了\nFGameplayEffectModCallbackData PostGameplayEffectExecute的参数FGameplayEffectModCallbackData\u0026amp; Data，它包含了很多信息，\n下面这个 FEffectProperites 结构体里的信息 都能从Data里面获得.Source开头 指的是 “属性的改变是谁打过来的”，Target开头 指的是“受害者”例如: 泽拉斯Q了一下诺手， 这个Q的伤害是泽拉斯造成的，Source是泽拉斯.诺手接收到Q的伤害之后，要在PostGameplayEffectExecute里面一通计算 响应伤害，Target是诺手.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 USTRUCT() struct FEffectProperites { GENERATED_BODY() FEffectProperites(){}; FGameplayEffectContextHandle EffectContextHandle; UPROPERTY() UAbilitySystemComponent* SourceASC = nullptr; UPROPERTY() AActor* SourceAvatarActor = nullptr; UPROPERTY() AController* SourceController = nullptr; UPROPERTY() ACharacter* SourceCharacter = nullptr; //////////////////////////////////////////// UPROPERTY() UAbilitySystemComponent* TargetASC = nullptr; UPROPERTY() AActor* TargetAvatarActor = nullptr; UPROPERTY() AController* TargetController = nullptr; UPROPERTY() ACharacter* TargetCharacter = nullptr; }; FGameplayEffectModCallbackData\u0026amp; Data的使用方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); } void UAuraAttributeSet::SetEffectProperties(const struct FGameplayEffectModCallbackData\u0026amp; Data,FEffectProperites\u0026amp; Props) { Props.EffectContextHandle = Data.EffectSpec.GetContext(); Props.SourceASC = Props.EffectContextHandle.GetOriginalInstigatorAbilitySystemComponent(); if (IsValid(Props.SourceASC) \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.SourceAvatarActor = Props.SourceASC-\u0026gt;GetAvatarActor(); Props.SourceController = Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;PlayerController.Get(); if (Props.SourceController == nullptr \u0026amp;\u0026amp; Props.SourceAvatarActor!=nullptr) { if (APawn* Pawn = Cast\u0026lt;APawn\u0026gt;(Props.SourceAvatarActor)) { Props.SourceController = Pawn-\u0026gt;GetController(); } } if (Props.SourceController) { Props.SourceCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.SourceController-\u0026gt;GetPawn()); } } if (Data.Target.AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.TargetAvatarActor = Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.Get(); Props.TargetController = Data.Target.AbilityActorInfo-\u0026gt;PlayerController.Get(); Props.TargetCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.TargetAvatarActor); Props.TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Props.TargetAvatarActor); } } 使用Prop:\n1 2 3 4 5 6 if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } 诺手接收到伤害后，打印诺手的名字和血量，所以需要TargetAvatarActor来获得名字.\n","date":"2025-01-11T11:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-gameplayeffect/","title":"GAS A - GameplayEffect"},{"content":"MVC 插播一条：UE5中 有一套MVVM插件 可以与UMG联动。创建MVVM对象，在这个对象里面创建一些变量什么的，当变量改变时 它自己就会发出广播通知\nhttps://www.bilibili.com/video/BV1Dj411N735/\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/umg-viewmodel\n下面开始视频教程的内容：\n将应用程序分为三个核心组件：模型（Model）、视图（View）和控制器（Controller），以实现关注点分离。\n在这个系列课程中，使用这个架构来更新UMG， 玩家属性发生变化\u0026mdash;\u0026gt;通知Controller\u0026mdash;\u0026gt;Controller发出消息广播，UMG订阅Controller的消息广播，这样就把 玩家和UMG 联系起来了.\n直观上看的话，也就是 玩家大喊一声“该更新了”，具体去更新谁，玩家并不关心。\n在整个过程中，只关注一个中介者—Controller，需要更新自己数据的UMG界面 自己去订阅消息通知，变化事件发生时，Controller发出通知消息， UMG自己去查看是 生命值变化了，还是魔法值变化了，去做它自己该做的事情。\n套用MVC模式，View = UMG，Model = 玩家属性，Controller就是这两个之间的中间件. Controller可以是一个UObject. (这里的Controller不是引擎中的 AI控制器 / 玩家控制器，只是一个U类对象)\n这是最终要实现的结构，UMG内部需要Controller的指针，用来订阅Controller的消息，\nUMG和Controller都集中在HUD里面，HUD同时创建UMG、Controller，并且当场就把Controller与UMG 关联起来。 GameMode管理HUD，GameMode会自动创建HUD. 而HUD内部管理UMG、Controller，HUD对外公开一个函数，用来接收玩家相关的信息 以及 创建UMG、Controller\n1 InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) 这个函数接收4个参数 用来获得玩家信息，只需要一个合适的时机调用这个HUD的函数，一切就能关联起来。\n对于人类玩家角色来说，GAS相关组件都放在PlayerState里面，当角色死亡时 死的只是Actor 不是PlaeyrState，所以这些组件不会丢失角色的属性信息，角色复活时 就得重新获得PlayerState里面的GAS组件信息。复活 就可以视为是初始化了，游戏刚开始时，角色也算是“复活”，即调用 PossessedBy 函数，在PossessedBy 函数里面获得GAS信息的同时，就通知UI去更新信息。\n这就是InitOverlay调用的时机，即在 PossessedBy 里面调用. PossessedBy 拿到 PC、PS、ASC、AS 之后 传给HUD::InitOverlay，让HUD拿着这些信息去构造Controller\n有了这些指导思想，接下来的内容就容易看懂了.\n整这么一大堆，其实就是 本来UMG能直接GetPlayerCharacter，Cast到AuraCharacter，角色身上的所有东西都能获取，GetPlayerState ，Cast到AuraPlayerState也能获取GAS组件。这已经可以运行了，只是多了一个中间件，原本是 角色\u0026mdash;\u0026gt;UMG，一站直达的， 现在需要 角色\u0026ndash;\u0026gt;中间件\u0026mdash;\u0026gt;UMG于是乎，就要想办法把这一串逻辑 重新打通，就仅此而已.\nController \u0026amp; Widget 粗糙的结构图，WidgetController只是个继承自UObject的类，需要4个变量，PC、PS、ASC、AS，UserWidget 也就是UMG的父类， 有WidgetController的Getter、Setter，在代码里面调用SetWidgetController()，SetWidgetController内部又调用WidgetControllerSet()，这是用来调用蓝图事件的，绑定的事件在UMG的蓝图里做，这样就打通了C++和蓝图的通信.\n创建UMG 后面只是在蓝图里创建了几个UMG，这是结构图， WBP_Overlay是主界面，里面有小UI，WBP_HealthGlobe等等.\nHUD 在哪里创建主UI？Controller存放到哪里？又如何初始化？\nHUD的目的是 告知玩家当前游戏状态，即分数、生命值、游戏剩余时间等。\n这个课程把Controller放到了HUD里，UMG也由HUD来创建。\n1 2 3 4 5 6 7 AuraHUD UPROPERTY() TObjectPtr\u0026lt;UAuraUserWidget\u0026gt; OverlayWidget; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UAuraUserWidget\u0026gt; OverlayWidgetClass; 这是常用的操作，在蓝图里指定OverlayWidgetClass 选择使用哪一个蓝图，在C++中使用这个class创建对象.\n把BP_AuraHUD放到GameMode里面，用于创建BP_AuraHUD\nWidget Controller HUD能创建出UMG了，还剩下Controller没有初始化，AuraWidgetController里面还有4个变量需要初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState; TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; ———————————————————————————————————————————————————————————————————— USTRUCT(BlueprintType) struct FWidgetControllerParams { GENERATED_BODY() FWidgetControllerParams(){}; FWidgetControllerParams(APlayerController* PC,APlayerState* PS,UAbilitySystemComponent* ASC,UAttributeSet* AS) : PlayerController(PC),PlayerState(PS),AbilitySystemComponent(ASC),AttributeSet(AS) {}; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet = nullptr; }; void UAuraWidgetController::SetWidgetControllerParams(const FWidgetControllerParams\u0026amp; WCParams) { PlayerController = WCParams.PlayerController; PlayerState = WCParams.PlayerState; AbilitySystemComponent = WCParams.AbilitySystemComponent; AttributeSet = WCParams.AttributeSet; } 看着比较长，实际上只是定义一个结构体，函数接收这个结构体来初始化这些变量， 思考题：为什么要用结构体？ WidgetController里面的变量初始化完了，那么WidgetController本体在哪里初始化？\n创建OverlayWidgetController ，它继承自 UAuraWidgetController，用来更新主UI.\n在AuraHUD里添加两个变量，前面的UMG在HUD里初始化了，WidgetController也在HUD初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY() TObjectPtr\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetController; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetControllerClass; UOverlayWidgetController* AAuraHUD::GetOverlayWidgetController(const FWidgetControllerParams\u0026amp; WCParams) { if (OverlayWidgetController == nullptr) { OverlayWidgetController = NewObject\u0026lt;UOverlayWidgetController\u0026gt;(this,OverlayWidgetControllerClass); OverlayWidgetController-\u0026gt;SetWidgetControllerParams(WCParams); OverlayWidgetController-\u0026gt;BindCallbacksToDependencies(); return OverlayWidgetController; } return OverlayWidgetController; } GetOverlayWidgetController() 如果OverlayWidgetController没有值 则创建并返回，有值 直接返回。\n初始化函数有了，调用时机呢？\n1 2 3 4 5 这个函数是后文 消息广播 定义的函数，在Controller初始化时 广播一次属性值 总不能是空血条开局吧 WidgetController-\u0026gt;BroadcastInitialValues(); 这也是后文的函数，用来订阅 属性更改通知 的委托 BindCallbacksToDependencies() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) { checkf(OverlayWidgetClass,TEXT(\u0026#34;OverlayWidgetClass uninitialized,fill out BP_AurhHUD\u0026#34;)); checkf(OverlayWidgetControllerClass,TEXT(\u0026#34;OverlayWidgetControllerClass uninitialized,fill out BP_AurhHUD\u0026#34;)); OverlayWidget = CreateWidget\u0026lt;UAuraUserWidget\u0026gt;(GetWorld(), OverlayWidgetClass); const FWidgetControllerParams WidgetControllerParams(PC,PS,ASC,AS); UOverlayWidgetController* WidgetController = GetOverlayWidgetController(WidgetControllerParams); OverlayWidget-\u0026gt;SetWidgetController(WidgetController); WidgetController-\u0026gt;BroadcastInitialValues(); OverlayWidget-\u0026gt;AddToViewport(); } InitOverlay AAuraHUD::InitOverlay 是HUD公开出去的函数，是一切故事发生的入口.\n至此，HUD把UMG和WidgetController收集了起来. 在HUD中通过 InitOverlay() 创建UMG、WidgetController，并且在创建现场就把UMG和WidgetController关联起来.\n1 OverlayWidget-\u0026gt;SetWidgetController(WidgetController); 只要调用对外公开的 InitOverlay() 函数，所有东西都能链接起来，那么 在哪里调用才合适？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;AbilityInfoSet(); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); if (AAuraPlayerController* AuraPlayerController = Cast\u0026lt;AAuraPlayerController\u0026gt;(GetController())) { if (AAuraHUD* AuraHud = Cast\u0026lt;AAuraHUD\u0026gt;(AuraPlayerController-\u0026gt;GetHUD())) { AuraHud-\u0026gt;InitOverlay(AuraPlayerController,AuraPlayerState,AbilitySystemComponent,AttributeSet); } } } 最终如图所示，完成整个流程。\nCharacter::PossessedBy是入口，在这里获得 玩家控制器、玩家状态、技能组件、属性Set.初始化角色自己的GAS组件 的同时 ，传给HUD 让HUD也用用，HUD在创建Controller时，把 玩家控制器、玩家状态、技能组件、属性集 传给Controller，HUD在创建UMG时，把Controller 传给UMG.\n消息广播 GAS对外公开有委托事件，当属性变化时 这个委托就会广播，Controller订阅GAS的广播 就可以在属性变化时 获得属性的最新值。\n当Controller被HUD初始化时，就要广播一次 用来初始化UMG里的内容，总不能开局血条是空的吧。\nUAuraWidgetController追加空函数，在OverlayWidgetController进行override.\n1 2 3 UFUNCTION(BlueprintCallable) virtual void BroadcastInitialValues(){}; virtual void BindCallbacksToDependencies(){}; 还要在OverlayWidgetController里面定义委托 和 委托变量\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewValue); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); —————————————————————————————————————————————————————————————————————————— UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnHealthChanged; UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnMaxHealthChanged; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void UOverlayWidgetController::BroadcastInitialValues() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); OnHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxHealth()); OnManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMana()); OnMaxManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxMana()); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); } MVVM GAS B系列使用MVVM框架更新UMG.\n(有一个漏掉的操作 → 没有手动调用一次广播，开局血条是空的，)\nELMVVMPlayer.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 UCLASS(BlueprintType) class ELEMENTAL_III_API UELMVVMPlayer : public UMVVMViewModelBase { GENERATED_BODY() public: UFUNCTION(BlueprintCallable) void SetMvvmParams(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); protected: UPROPERTY() TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Health; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxHealth; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Mana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxMana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter=GetIsBattleMode,Setter=SetIsBattleMode) bool bIsBattleMode = false; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) int32 KillNumber; void SetHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Health,Value);} float GetHealth() const {return Health;}; void SetMaxHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxHealth,Value);} float GetMaxHealth() const {return MaxHealth;}; void SetMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Mana,Value);} float GetMana() const {return Mana;}; void SetMaxMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxMana,Value);} float GetMaxMana() const {return MaxMana;}; void SetIsBattleMode(const bool Value) {UE_MVVM_SET_PROPERTY_VALUE(bIsBattleMode,Value);} bool GetIsBattleMode() const {return bIsBattleMode;}; void SetKillNumber(const int32 Value) {UE_MVVM_SET_PROPERTY_VALUE(KillNumber,Value);} int32 GetKillNumber() const {return KillNumber;}; }; ELMVVMPlayer.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // AELCharacterBase::InitAbilityInfo ---\u0026gt; AELHUD::InitMVVM ---\u0026gt; ThisClass::SetMvvmParams void UELMVVMPlayer::SetMvvmParams(APlayerController* PC, UAbilitySystemComponent* ASC, UAttributeSet* AS) { PlayerController = PC; AbilitySystemComponent = ASC; AttributeSet = AS; AELPlayerController* ELPlayerController = Cast\u0026lt;AELPlayerController\u0026gt;(PlayerController); ELPlayerController-\u0026gt;OnBattleModeChange.AddLambda( [this](bool InBattleMode) { SetIsBattleMode(InBattleMode); }); const UELAttributeSet* ELAttributeSet = Cast\u0026lt;UELAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetKillNumberAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetKillNumber(Data.NewValue); }); } ELHUD.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 UCLASS() class ELEMENTAL_III_API AELHUD : public AHUD { GENERATED_BODY() public: void InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;ACharacter\u0026gt; Character; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, EditDefaultsOnly) FMVVMViewModelContext MVVMContext; UPROPERTY(BlueprintReadOnly) class UELMVVMPlayer* MVVMPlayer; }; ELHUD.cpp\n在这里创建MvvmPlayer并且添加到Mvvm全局子系统里. UMG里根据Context从全局获取MvvmPlayer.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void AELHUD::InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS) { AbilitySystemComponent = ASC; PlayerController = PC; Character = Cast\u0026lt;ACharacter\u0026gt;(PlayerController-\u0026gt;GetPawn()); AttributeSet = AS; MVVMPlayer = NewObject\u0026lt;UELMVVMPlayer\u0026gt;(PC); UGameInstance* GameInstance = UGameplayStatics::GetGameInstance(this); UMVVMGameSubsystem* MvvmGameSubsystem = GameInstance-\u0026gt;GetSubsystem\u0026lt;UMVVMGameSubsystem\u0026gt;(); MvvmGameSubsystem-\u0026gt;GetViewModelCollection()-\u0026gt;AddViewModelInstance(MVVMContext,MVVMPlayer); MVVMPlayer-\u0026gt;SetMvvmParams(PC,ASC,AS); } CharacterBase\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AELCharacterBase::InitAbilityInfo() { AHUD* HUD = Cast\u0026lt;AELPlayerController\u0026gt;(GetController())-\u0026gt;GetHUD(); if (AELHUD* ELHud = Cast\u0026lt;AELHUD\u0026gt;(HUD)) { ELHud-\u0026gt;InitMvvm(Cast\u0026lt;AELPlayerController\u0026gt;(GetController()),AbilitySystemComponent,AttributeSet); } } void AELCharacterBase::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); InitAbilityInfo(); } 调用顺序: AELCharacterBase::PossessedBy\u0026mdash;\u0026gt;AELCharacterBase::InitAbilityInfo \u0026mdash;\u0026gt; AELHUD::InitMVVM \u0026mdash;\u0026gt; UELMVVMPlayer::SetMvvmParams\n","date":"2025-01-11T11:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-ui-mvc-or-mvvm/","title":"GAS A - UI - MVC or MVVM"},{"content":"起手式 网页图片模糊 点击图片预览高清大图\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/gameplay-ability-system-for-unreal-engine↑首先看一遍官方文档↑\nGAS学习资料:https://github.com/BillEliot/GASDocumentation_Chinese\n官方的ActionRPG项目，\nGAS A系列是由 \u0026lt; Gameplay Ability System - Top Down RPG\u0026gt; 这一套教程来的,简单的细枝末节不记录https://www.bilibili.com/video/BV1JD421E7yC\n与GameplayAbilitySystem交互的Actor须拥有 GameplayAbilitySystemComponent。此组件将激活技能、存储属性、更新效果，和处理Actor间的交互。\n角色类拥有UAbilitySystemComponent 和 UAttributeSet 两个组件，AttributeSet保存角色的属性值，例如:生命值、魔法值、生命回复、攻击力、法术强度，而这些属性由GameplayEffect来修改，不应手动修改.尽管AttributeSet提供了Setter方法，也不该手动调用它去做一些事情.\nGameplayAbility执行技能任务，被动、Q、W、E、R、D、F都可以是GameplayAbility.技能(GameplayAbility) 可以配置CD、Cost，也就是冷却时长，耗费多少蓝量. CD和Cost都由GamePlayEffect定义. CD、Cost的信息都可以在GA的蓝图面板中配置，选择对应的GE蓝图即可.\n技能执行流程 先描述最感兴趣的一集吧，开局就写难懂的东西 只会让脑子开局就过载，作文首先要引起读者的兴趣。 这把先开\u0026lt;泽拉斯\u0026gt;奥兄弟们，最会空技能的一个英雄。\n冷却时间 泽拉斯的Q技能一级有9秒CD，释放技能时 如果在冷却中 就不让释放，这个流程如何使用GAS来执行？GE可以选择 \u0026lt;立即生效 | 持续一段时间 | 无限时间\u0026gt; 三个策略。假设这个技能是GA_Q，它拥有标签TAG_Q，那么就让GE_Q_CD使用 \u0026lt;持续一段时间\u0026gt; 这个策略，并且让GE_Q_CD去阻挡TAG_Q，等到GE的持续时间结束才会取消阻挡。 这样就实现了技能的冷却。执行流程为:GA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;不在CD中\u0026mdash;\u0026gt;执行技能\u0026mdash;\u0026gt;技能结束，开始CDGA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;正在CD中\u0026mdash;\u0026gt;技能结束\n技能耗费 泽拉斯的Q技能需要耗费80蓝量，这就要求Attribute里面拥有\u0026lt;魔法值\u0026gt;这个属性，在GA_Q执行时扣除相应的魔法值，如果蓝量不够 就不能执行技能.GE_Q_Cost 使用 \u0026lt;立即生效\u0026gt; 策略，(瞪眼观察法可知 另外两个策略一看就不对)Q需要耗费80蓝量，GE_Q_Cost就得让 \u0026lt;魔法值\u0026gt; 减80，魔法值够减的话 那么就能执行技能. 不够减 就不执行.\n执行流程与 冷却时间 相似.\n技能伤害 有了上面使用GE去做CD 耗蓝，那么伤害如何去做？ 直接减掉目标的血量值？NO ，Attribute中定义 \u0026lt;即将到来的伤害\u0026gt;， 如果伤害值是50， 那么就使用GE 让敌人的 \u0026lt;即将到来的伤害\u0026gt; +50。 在Attribute中去执行减掉生命值的操作.\n这把开一局\u0026lt;爆破鬼才\u0026gt;，假如我发射一个火球，那么在火球滑行的途中，它撞到了地面 触发爆炸伤害. 这里就得范围检测Enemy，并且获得它们身上的 AbilitySystemComponent 并且对这个组件应用GE，造成伤害\n技能蓝图 被动技能 生命回复、法力回复 这些都是自动运行的， 每秒回复1点生命值 回复1点魔法值， 可以用GE做一个 无限时间 的效果，持续一段时间 | 无限时间 ， 这两个策略都可以设置触发周期，比如每1秒触发一次，每0.5秒触发一次 等等。\n自动回复就使用 无限时间 ，每秒触发一次，每次触发添加1点生命值，1点魔法值。就叫它 GE_Regeneration ，在BeginPlay时 对AbilitySystemComponent应用这个GE即可。那死亡时 不想要自动回复了怎么办？ GE可以被Apply，也可以被Remove，死亡时只要移除这个GE就行了,这是手动移除的案例.\nBuff也可以用一个GE完成，例如 增加50攻击力，并且持续90秒，那么就使用一个 持续一段时间的GE，让攻击力+50，时间结束后 GE自动取消. 这是自动移除的案例.手动移除方法：\nGameplayAbilitySystem 初始化技能组件 ASC附加的Actor被引用作为该ASC的OwnerActor, 该ASC的物理代表Actor被称为AvatarActor. OwnerActor和AvatarActor可以是同一个 Actor, 比如MOBA游戏中的一个简单AI小兵; 它们也可以是不同的Actor, 比如MOBA游戏中玩家控制的英雄, 其中OwnerActor是PlayerState, AvatarActor是英雄的Character类. 绝大多数Actor的ASC都附加在其自身, 如果你的Actor会重生并且重生时需要持久化Attribute或GameplayEffect(比如MOBA中的英雄), 那么ASC理想的位置就是PlayerState.\nGAS要求添加 AbilitySystemComponent (ASC) 和 AttributeSet (AS)，那么往角色身上添加 是否可行？\n如果角色可以被摧毁、可以死亡，当CharacterActor死亡时 在它身上挂载的 ASC、AS 全都没有了，一起跟着销毁再次复活时 技能信息会丢失。 这就要求把ASC、AS放到一个可靠的地方，在这个教程里 放到了PlayerState里面。\n问题:如何放？ 还要把玩家角色与PlayerState里的ASC、AS连接起来，这样在场景里才能通过玩家角色获得玩家的ASC、AS，如何连接？ ACharacter -\u0026gt; AuraCharacterBase -\u0026gt;Enemy / AuraCharacter , AuraCharacter 是玩家角色\n【Enemy 和 AuraCharacter 都继承自AuraCharacterBase 】\n在AuraCharacterBase 和 PlayerStae 中定义GAS的两个组件的指针，但是实体在Enemy 和 PlayerState 中创建.因为玩家角色的GAS组件要放在PlayerState里，而敌人AI就放在它自己的角色类里面.\n下面的内容就是解决上面的两个问题:如何放 如何连接。定义组件指针、初始化组件、连接 玩家角色 与 PlayerState 的组件.(玩家角色 被玩家控制器 控制后，就要获得PlayerState里面的ASC、AS组件)思路不清晰 可以看小节结尾的流程图.\n1 2 3 4 5 UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 AAuraEnemy::AAuraEnemy() { GetMesh()-\u0026gt;SetCollisionResponseToChannel(ECC_Visibility,ECR_Block); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); HealthBar = CreateDefaultSubobject\u0026lt;UWidgetComponent\u0026gt;(\u0026#34;HealthBar\u0026#34;); HealthBar-\u0026gt;SetupAttachment(GetRootComponent()); } AAuraPlayerState::AAuraPlayerState() { //NetUpdateFrequency = 100.f; SetNetUpdateFrequency(100.f); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); } 完了还要在AuraCharacterBase继承一个接口，用来获得ASC，因为要与ASC通信，不管是哪个类，只要调用这个接口就能得到它的ASC组件.\n1 2 3 4 5 6 7 8 9 10 class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraCharacterBase::GetAbilitySystemComponent() const { return AbilitySystemComponent; } 现在Enemy的组件注册完了，玩家角色的还没有结束，它的组件都在PlayerState里面，还要再手动从PS里获取组件.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AURA_API AAuraPlayerState : public APlayerState,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraPlayerState::GetAbilitySystemComponent() const { return AbilitySystemComponent; } —————————————————————————————————————————————————————————————————————————————————————— void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); } 这样就把玩家角色和AuraPlayerState链接起来了，AbilitySystemComponent 和 AttributeSet 都初始化了.\nAttribute https://github.com/BillEliot/GASDocumentation_Chinese?tab=readme-ov-file#43-attribute\nAttribute里定义生命值，FGameplayAttributeData Health; FGameplayAttributeData 是一个结构体，其数值是浮点型，结构体里面有一个BaseValue和一个CurrentValue，假如当前生命值是100，BaseValue = CurrentValue = 100 ， 有一个持续10秒的加50生命值的buff，一个NPC吃了一个buff 这是他生命值发生的变化， BaseValue = 100 ， CurrentValue = 100 + 50 = 150，10秒后 buff结束，CurrentValue就会变回BaseValue， 此时 BaseValue = CurrentValue = 100.\n即刻(Instant)GameplayEffect可以永久性的修改BaseValue, 而持续(Duration)和无限(Infinite)GameplayEffect可以修改CurrentValue. 周期性(Periodic)GameplayEffect被视为即刻(Instant)GameplayEffect并且可以修改BaseValue.\nAttributeSet.h里提供了一个Help宏，它被注释了，这个宏提供4个函数，Getter、Setter、Init以及一个静态的GetAttribute\n1 2 3 4 5 #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName) 将它复制到自己的类里面使用，定义一个Health属性，并且初始化为100.\n1 2 3 UPROPERTY(BlueprintReadOnly\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); 药瓶 Effect Actor 这个Actor这样修改属性只是为了简单测试，属性修改要使用GE. 当角色碰到这个Actor时 角色的Health会增加50.\n附 教程里因为版本不同 名称不同的对照，一些属性名称 , 还有打起来贼他妈麻烦的代码片段， 都可以到这复制\nGameplayEffectAssetTag 【=】 Tags This Effect Has GrantedTags 【=】 Grant Tags to Target Actor Ongoing Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Application Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Removal Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Remove Gameplay Effect With Tags 【=】 Remove Other Effects\nArmor,ArmorPenetration,BlockChance,\nCriticalHitChance,CriticalHitDamage,CriticalHitResistance,\nHealthRegeneration,ManaRegeneration\nAttribute.Primary.Intelligence Row_Strength Row_Intelligence Row_Resilience Row_Vigor\nRow_Armor Row_ArmorPenetration Row_BlockChance Row_CriticalHitChance Row_CriticalHitDamage Row_CriticalHitResistance Row_HealthRegeneration Row_ManaRegeneration Row_MaxHealth Row_MaxMana\nAuraGameplayTags.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;GameplayTagContainer.h\u0026#34; struct FAuraGameplayTags { public: static const FAuraGameplayTags\u0026amp; Get() {return GameplayTags;} static void InitializeNativeGameplayTags(); FGameplayTag Attribute_Primary_Strength; FGameplayTag Attribute_Primary_Intelligence; FGameplayTag Attribute_Primary_Resilience; FGameplayTag Attribute_Primary_Vigor; FGameplayTag Attribute_Secondary_Armor; FGameplayTag Attribute_Secondary_ArmorPenetration; FGameplayTag Attribute_Secondary_BlockChance; FGameplayTag Attribute_Secondary_CriticalHitChance; FGameplayTag Attribute_Secondary_CriticalHitDamage; FGameplayTag Attribute_Secondary_CriticalHitResistance; FGameplayTag Attribute_Secondary_HealthRegeneration; FGameplayTag Attribute_Secondary_ManaRegeneration; FGameplayTag Attribute_Secondary_MaxHealth; FGameplayTag Attribute_Secondary_MaxMana; FGameplayTag InputTag_LMB; FGameplayTag InputTag_RMB; FGameplayTag InputTag_1; FGameplayTag InputTag_2; FGameplayTag InputTag_3; FGameplayTag InputTag_4; FGameplayTag Damage; FGameplayTag Effect_HitReact; private: static FAuraGameplayTags GameplayTags; }; AuraGameplayTags.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026#34;AuraGameplayTags.h\u0026#34; #include \u0026#34;GameplayTagsManager.h\u0026#34; FAuraGameplayTags FAuraGameplayTags::GameplayTags; void FAuraGameplayTags::InitializeNativeGameplayTags() { GameplayTags.Attribute_Primary_Strength = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Strength\u0026#34;), FString(\u0026#34;Increases physical damage\u0026#34;)); GameplayTags.Attribute_Primary_Intelligence = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Intelligence\u0026#34;), FString(\u0026#34;Increases magical damage\u0026#34;)); GameplayTags.Attribute_Primary_Resilience = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Resilience\u0026#34;), FString(\u0026#34;Increases Armor and ArmorPenetration\u0026#34;)); GameplayTags.Attribute_Primary_Vigor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Vigor\u0026#34;), FString(\u0026#34;Increases Health\u0026#34;)); //////////////////// GameplayTags.Attribute_Secondary_Armor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.Armor\u0026#34;), FString(\u0026#34;Reduce damage taken\u0026#34;)); GameplayTags.Attribute_Secondary_ArmorPenetration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ArmorPenetration\u0026#34;), FString(\u0026#34;Ignore percentage of enemy\u0026#34;)); GameplayTags.Attribute_Secondary_BlockChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.BlockChance\u0026#34;), FString(\u0026#34;Chance to cut incoming damage in half\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitChance\u0026#34;), FString(\u0026#34;Chance to double damage plus critical hit bonus\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitDamage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitDamage\u0026#34;), FString(\u0026#34;Bonus damage added when a critical hit is scored\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitResistance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitResistance\u0026#34;), FString(\u0026#34;Reduces critical hit chance of attacking enemies\u0026#34;)); GameplayTags.Attribute_Secondary_HealthRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.HealthRegeneration\u0026#34;), FString(\u0026#34;Amount of Health regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_ManaRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ManaRegeneration\u0026#34;), FString(\u0026#34;Amount of Mana regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_MaxHealth = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxHealth\u0026#34;), FString(\u0026#34;Maximum amount of Health\u0026#34;)); GameplayTags.Attribute_Secondary_MaxMana = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxMana\u0026#34;), FString(\u0026#34;Maximum amount of Mana\u0026#34;)); ///////////// GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.LMB\u0026#34;), FString(\u0026#34;Input Tag for Left Mouse Button\u0026#34;)); GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.RMB\u0026#34;), FString(\u0026#34;Input Tag for Right Mouse Button\u0026#34;)); GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.1\u0026#34;), FString(\u0026#34;Input Tag for Key 1\u0026#34;)); GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.2\u0026#34;), FString(\u0026#34;Input Tag for Key 2\u0026#34;)); GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.3\u0026#34;), FString(\u0026#34;Input Tag for Key 3\u0026#34;)); GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.4\u0026#34;), FString(\u0026#34;Input Tag for Key 4\u0026#34;)); //////////////////// GameplayTags.Damage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Damage\u0026#34;), FString(\u0026#34;Damage\u0026#34;)); GameplayTags.Effect_HitReact = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Effect.HitReact\u0026#34;), FString(\u0026#34;Tag granted when Hit Reacting\u0026#34;)); } AuraAttributeSet.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Strength, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Strength; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Strength); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Intelligence, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Intelligence; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Intelligence); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Resilience, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Resilience; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Resilience); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Vigor, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Vigor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Vigor); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxHealth, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxHealth; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxHealth); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxMana, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxMana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxMana); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Armor, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData Armor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Armor); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ArmorPenetration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ArmorPenetration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ArmorPenetration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_BlockChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData BlockChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,BlockChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitDamage, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitDamage); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitResistance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitResistance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitResistance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_HealthRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData HealthRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,HealthRegeneration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ManaRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ManaRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ManaRegeneration); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Health, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Mana, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Mana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Mana); ///////////////// UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); //////////////////// UFUNCTION() void OnRep_Strength(const FGameplayAttributeData\u0026amp; OldStrength)const; UFUNCTION() void OnRep_Intelligence(const FGameplayAttributeData\u0026amp; OldIntelligence)const; UFUNCTION() void OnRep_Resilience(const FGameplayAttributeData\u0026amp; OldResilience)const; UFUNCTION()\tvoid OnRep_Vigor(const FGameplayAttributeData\u0026amp; OldVigor)const; UFUNCTION()\tvoid OnRep_MaxHealth(const FGameplayAttributeData\u0026amp; OldMaxHealth)const; UFUNCTION()\tvoid OnRep_MaxMana(const FGameplayAttributeData\u0026amp; OldMaxMana)const; UFUNCTION()\tvoid OnRep_Armor(const FGameplayAttributeData\u0026amp; OldArmor)const; UFUNCTION()\tvoid OnRep_ArmorPenetration(const FGameplayAttributeData\u0026amp; OldArmorPenetration)const; UFUNCTION()\tvoid OnRep_BlockChance(const FGameplayAttributeData\u0026amp; OldBlockChance)const; UFUNCTION()\tvoid OnRep_CriticalHitChance(const FGameplayAttributeData\u0026amp; OldCriticalHitChance)const; UFUNCTION()\tvoid OnRep_CriticalHitDamage(const FGameplayAttributeData\u0026amp; OldCriticalHitDamage)const; UFUNCTION()\tvoid OnRep_CriticalHitResistance(const FGameplayAttributeData\u0026amp; OldCriticalHitResistance)const; UFUNCTION()\tvoid OnRep_HealthRegeneration(const FGameplayAttributeData\u0026amp; OldHealthRegeneration)const; UFUNCTION()\tvoid OnRep_ManaRegeneration(const FGameplayAttributeData\u0026amp; OldManaRegeneration)const; UFUNCTION()\tvoid OnRep_Health(const FGameplayAttributeData\u0026amp; OldHealth)const; UFUNCTION()\tvoid OnRep_Mana(const FGameplayAttributeData\u0026amp; OldMana)const; AuraAttributeSet.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 UAuraAttributeSet::UAuraAttributeSet() { const FAuraGameplayTags\u0026amp; GameplayTags = FAuraGameplayTags::Get(); TagToAttribute.Add(GameplayTags.Attribute_Primary_Strength,\tGetStrengthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Intelligence,\tGetIntelligenceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Resilience,\tGetResilienceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Vigor,\tGetVigorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_Armor,\tGetArmorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ArmorPenetration,\tGetArmorPenetrationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_BlockChance,\tGetBlockChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitChance,\tGetCriticalHitChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitDamage,\tGetCriticalHitDamageAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitResistance,\tGetCriticalHitResistanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_HealthRegeneration,\tGetHealthRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ManaRegeneration,\tGetManaRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxHealth,\tGetMaxHealthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxMana,\tGetMaxManaAttribute); } AuraAttributeSet.cpp 这是一个宏，那些属性的网络同步函数写起来真逆天，用这个宏去写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define ATTRIBUTE_REP(Name)\\ void UAuraAttributeSet::OnRep_##Name(const FGameplayAttributeData\u0026amp; Old##Name)const\\ {\\ GAMEPLAYATTRIBUTE_REPNOTIFY(UAuraAttributeSet,Name,Old##Name);\\ }; #define ATTRIBUTE_NOTIFY(Name)\\ DOREPLIFETIME_CONDITION_NOTIFY(UAuraAttributeSet,Name,COND_None,REPNOTIFY_Always); #pragma region Net ATTRIBUTE_REP(Health)\tATTRIBUTE_REP(Mana) ATTRIBUTE_REP(Strength)\tATTRIBUTE_REP(Intelligence)\tATTRIBUTE_REP(Resilience)\tATTRIBUTE_REP(Vigor) ATTRIBUTE_REP(Armor)\tATTRIBUTE_REP(ArmorPenetration)\tATTRIBUTE_REP(BlockChance)\tATTRIBUTE_REP(CriticalHitChance) ATTRIBUTE_REP(MaxHealth)\tATTRIBUTE_REP(MaxMana)\tATTRIBUTE_REP(CriticalHitDamage)ATTRIBUTE_REP(CriticalHitResistance) ATTRIBUTE_REP(HealthRegeneration)\tATTRIBUTE_REP(ManaRegeneration) void UAuraAttributeSet::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); ATTRIBUTE_NOTIFY(Health)\tATTRIBUTE_NOTIFY(Mana) ATTRIBUTE_NOTIFY(Strength)\tATTRIBUTE_NOTIFY(Intelligence)\tATTRIBUTE_NOTIFY(Resilience)\tATTRIBUTE_NOTIFY(Vigor) ATTRIBUTE_NOTIFY(Armor)\tATTRIBUTE_NOTIFY(ArmorPenetration)\tATTRIBUTE_NOTIFY(BlockChance)\tATTRIBUTE_NOTIFY(CriticalHitChance) ATTRIBUTE_NOTIFY(MaxHealth)\tATTRIBUTE_NOTIFY(MaxMana)\tATTRIBUTE_NOTIFY(CriticalHitDamage)\tATTRIBUTE_NOTIFY(CriticalHitResistance) ATTRIBUTE_NOTIFY(HealthRegeneration)\tATTRIBUTE_NOTIFY(ManaRegeneration) } #pragma endregion ","date":"2025-01-10T11:59:56+08:00","permalink":"http://localhost:1313/p/gas-a-%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88/","title":"GAS A - 技能系统总览"},{"content":"示例 点击按钮自动创建GE，并且避免重名\n修改LOGO图标，要手动把svg文件放到Shader文件夹里(示例代码是这样写的)\n可以修改代码 放到别的位置去，\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #define RootToContentDir Style-\u0026gt;RootToContentDir void FElemental_EditorModule::StartupModule() { const FString ProjectShaderDir = FPaths::Combine(FPaths::ProjectDir(), TEXT(\u0026#34;Shaders\u0026#34;)); //[const ISlateStyle*] -\u0026gt; [ISlateStyle*] -\u0026gt; [FSlateStyleSet*] FSlateStyleSet* Style = static_cast\u0026lt;FSlateStyleSet*\u0026gt;(const_cast\u0026lt;ISlateStyle*\u0026gt;(\u0026amp;FAppStyle::Get())); Style-\u0026gt;SetContentRoot(ProjectShaderDir); Style-\u0026gt;Set(\u0026#34;AppIcon\u0026#34;, new IMAGE_BRUSH_SVG(\u0026#34;ELIcon\u0026#34;, FVector2f(50.f, 50.f), FStyleColors::White)); RegisterMenus(); } static void CreateBP() { UEditorAssetSubsystem* EditorAssetSubsystem = GEditor-\u0026gt;GetEditorSubsystem\u0026lt;UEditorAssetSubsystem\u0026gt;(); IContentBrowserSingleton\u0026amp; CB = IContentBrowserSingleton::Get(); const auto Path = CB.GetCurrentPath(); int32 RandName = 0; FString BaseName; FString PackageName; do { RandName++; BaseName = FString::Printf(TEXT(\u0026#34;MyGameplayEffect%d\u0026#34;), RandName); PackageName = FPaths::Combine(Path.GetInternalPathString(), BaseName); } while (EditorAssetSubsystem-\u0026gt;DoesAssetExist(PackageName)); UPackage * Package = CreatePackage(*PackageName); UBlueprint* Blueprint = FKismetEditorUtilities::CreateBlueprint(UGameplayEffect::StaticClass(), Package, *BaseName, BPTYPE_Normal, UBlueprint::StaticClass(), UBlueprintGeneratedClass::StaticClass()); if (Blueprint) { FAssetRegistryModule::AssetCreated(Blueprint); Package-\u0026gt;MarkPackageDirty(); } } void FElemental_EditorModule::RegisterMenus() { auto Visible = [](){return GEditor-\u0026gt;PlayWorld == nullptr;}; UToolMenu* Menu = UToolMenus::Get()-\u0026gt;ExtendMenu(\u0026#34;LevelEditor.LevelEditorToolBar.PlayToolBar\u0026#34;); FToolMenuSection\u0026amp; Section = Menu-\u0026gt;AddSection(\u0026#34;PlayGameExtensions\u0026#34;, TAttribute\u0026lt;FText\u0026gt;(), FToolMenuInsert(\u0026#34;Play\u0026#34;, EToolMenuInsertType::After)); const FUIAction UIAction = FUIAction(FExecuteAction::CreateStatic(CreateBP), FCanExecuteAction::CreateLambda(Visible),FIsActionChecked(),FIsActionButtonVisible::CreateLambda(Visible)); const FToolMenuEntry CommonMapEntry = FToolMenuEntry::InitToolBarButton( \u0026#34;CreateGE\u0026#34;,UIAction,FText::FromString(\u0026#34;GE\u0026#34;),FText::FromString(\u0026#34;Create GameplayEffect\u0026#34;), FSlateIcon(FAppStyle::GetAppStyleSetName(), \u0026#34;Icons.Blueprint\u0026#34;)); Section.AddEntry(CommonMapEntry); } Build.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PublicDependencyModuleNames.AddRange( new string[] { \u0026#34;Core\u0026#34;,\u0026#34;AssetDefinition\u0026#34;, \u0026#34;GameplayAbilities\u0026#34;, \u0026#34;EngineAssetDefinitions\u0026#34;,\u0026#34;ToolMenus\u0026#34;,\u0026#34;ContentBrowser\u0026#34;,\u0026#34;ContentBrowserData\u0026#34; } ); PrivateDependencyModuleNames.AddRange( new string[] { \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;Slate\u0026#34;, \u0026#34;SlateCore\u0026#34; } ","date":"2025-01-09T21:38:46+08:00","permalink":"http://localhost:1313/p/%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91-%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%93%9D%E5%9B%BE-%E4%BF%AE%E6%94%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%9B%BE%E6%A0%87/","title":"编辑器开发 - 创建指定类型蓝图 - 修改编辑器图标"},{"content":"简介 FRunnable \u0026ldquo;可运行对象\u0026quot;的接口类定义:\n可运行对象指可在任意线程上被\u0026quot;运行\u0026quot;的对象。其调用模式遵循三步：Init() -\u0026gt; Run() -\u0026gt; Exit()。 执行该对象的线程严格按此顺序调用，确保线程相关资源（如TLS）在对应阶段可用。 对象的所有初始化操作应在Init()中完成。 若初始化失败，线程将中止执行并返回错误码。成功则进入Run()执行核心任务， 最后通过Exit()进行资源清理。 成员函数:\nInit(): 初始化“可运行”对象。 【注意】此方法在聚合此对象的线程（即创建线程）上下文中调用，而非新创建的工作线程中执行 返回值表示初始化是否成功。 Run(): 执行“可运行”对象的实际线程工作。 仅在Init()成功后调用，在此完成线程具体工作。 返回值是“可运行”对象的退出代码。返回运行结束状态码。 Stop(): 当请求线程提前终止时调用此方法。 默认为空实现，可以根据需要重写。 Exit(): 在聚合线程的上下文中调用此方法以执行任何清理操作。 在聚合线程（非工作线程）上下文中执行资源释放。 默认为空实现，可以根据需要重写。 GetSingleThreadInterface(): 获取用于在禁用多线程时对“可运行”对象进行滴答处理的单线程接口指针。 当平台不支持多线程时，通过此接口实现单线程模式下的逻辑驱动。 如果未实现该接口，则当平台不支持多线程时，此“可运行”不会被滴答处理。 默认返回 nullptr，可以根据需要重写。 与标准库对比\n功能 UE (FRunnable) 标准库 (std::thread) 线程创建 由 FRunnableThread::Create() 管理 直接构造 std::thread 错误处理 返回 uint32 错误码，引擎记录日志 抛出 std::system_error 异常 线程优先级 通过 EThreadPriority 设置 依赖平台 API（如 pthread_setschedparam） 跨线程通信 使用 FEvent、TQueue、FGraphEvent 需手动实现条件变量或管道 资源绑定 与 FGameThreadTask 深度集成 无内置机制 生命周期方法与线程绑定\n方法 调用线程 UE 内部行为 Init() 创建该任务的线程 通常为主线程或线程池管理者，用于分配线程安全资源（如绑定到 GameThread 的委托）。 Run() 新创建的独立线程 线程在此执行耗时操作（如资源加载、物理计算），通过 FPlatformProcess::Sleep 控制频率。 Exit() 原始创建线程 主线程负责清理资源，避免跨线程删除导致的崩溃。 Init() 和 Exit() 在 同一线程（通常为 GameThread）中调用，确保 UE 的线程安全规则（如 Slate UI 操作必须在 GameThread）。 Run() 在 工作线程 中执行，禁止直接调用引擎的非线程安全 API（如修改 UObject 属性）。 停止机制与 UE 的信号系统\nUE 的 FRunnable::Stop() 通常结合事件（FEvent）实现安全终止：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 示例：UE 风格的线程停止实现 class FMyTask : public FRunnable { FEventRef StopEvent; // 使用 UE 的 FEvent 而非 std::atomic virtual uint32 Run() override { while (StopEvent-\u0026gt;Wait(0)) // 非阻塞检查 { // 执行任务... } return 0; } virtual void Stop() override { StopEvent-\u0026gt;Trigger(); // 触发事件通知线程退出 } }; UE 特有机制：\n使用 FEvent（如 FPlatformProcess::GetSynchEventFromPool()）而非简单的原子变量，以支持跨平台等待/唤醒。 Stop() 可能由引擎的线程管理器自动调用（如任务超时或线程池关闭）。 UE 多线程编程的黄金法则\n资源归属规则 ✅ 在 Init() 中创建 该线程独享 的资源（如 FEvent）。 ❌ 禁止在 Run() 中直接操作 UObject 或 Slate 控件。 内存管理 使用 TUniquePtr 或引擎的智能指针（如 TSharedPtr）管理资源。 若需跨线程传递数据，使用 TQueue 或 TArray + 互斥锁（FCriticalSection）。 调试与统计 使用 UE_CLOG 输出线程日志. 通过 FThreadManager::Get().GetThreads() 查看引擎线程状态。 ","date":"2000-01-22T21:02:55+08:00","permalink":"http://localhost:1313/p/ue%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"UE多线程"},{"content":"需要会一些模板.\n类型别名 模板类片段:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename InElementType, typename InAllocatorType\u0026gt; class TArray { template \u0026lt;typename OtherInElementType, typename OtherAllocator\u0026gt; friend class TArray; public: using SizeType = typename InAllocatorType::SizeType ; using ElementType = InElementType; using AllocatorType = InAllocatorType; private: using USizeType = typename std::make_unsigned_t\u0026lt;SizeType\u0026gt;; public: using ElementAllocatorType = std::conditional_t\u0026lt; AllocatorType::NeedsElementType, typename AllocatorType::template ForElementType\u0026lt;ElementType\u0026gt;, typename AllocatorType::ForAnyElementType \u0026gt;; static_assert(std::is_signed_v\u0026lt;SizeType\u0026gt;, \u0026#34;TArray only supports signed index types\u0026#34;); } 使用TArray存放Actor时，默认的别名类型:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using Array = TArray\u0026lt;AActor*\u0026gt;; //signed int using ArraySizeType = Array::SizeType; //AActor* using ArrayElementType = Array::ElementType; // TSizedDefaultAllocator\u0026lt;32\u0026gt; using ArrayAllocatorType = Array::AllocatorType; // TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor*\u0026gt; using ArrayElementAllocatorType = Array::ElementAllocatorType; // TSizedHeapAllocator\u0026lt;32\u0026gt; using ArrayAllocatorTypeTypedef = ArrayAllocatorType::Typedef; //signed int using ArrayAllocatorSizeType = ArrayAllocatorType::SizeType; AllocatorType TArray::AllocatorType 默认分配器是 TSizedDefaultAllocator\u0026lt;32\u0026gt;\n作用：定义容器使用的 内存分配器类型（如 FDefaultAllocator、TInlineAllocator）。 设计原因： 允许用户自定义内存管理策略（堆分配、栈分配、内存池等）。 SizeType 作用：定义容器中 索引和大小 的类型（如 int32、int64）。 设计原因： 由分配器 InAllocatorType 决定，允许不同分配器根据需求选择不同大小的整数类型（例如，小内存容器用 int32，大内存用 int64）。 示例： 若分配器定义为 TSizedHeapAllocator\u0026lt;32\u0026gt;，则 SizeType 可能是 int32。 SizeType来自于分配器的SizeType，因为默认分配器使用 TSizedDefaultAllocator\u0026lt;32\u0026gt;，所以要去找TSizedDefaultAllocator里面的SizeType是什么.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 using SizeType = typename InAllocatorType::SizeType ; //----------分配器类-------// template \u0026lt;int IndexSize\u0026gt; class TSizedDefaultAllocator : public TSizedHeapAllocator\u0026lt;IndexSize\u0026gt; { public: typedef TSizedHeapAllocator\u0026lt;IndexSize\u0026gt; Typedef; }; template \u0026lt;int IndexSize, typename BaseMallocType = FMemory\u0026gt; class TSizedHeapAllocator { public: using SizeType = typename TBitsToSizeType\u0026lt;IndexSize\u0026gt;::Type; } //---------------------// template \u0026lt;int IndexSize\u0026gt; struct TBitsToSizeType { // Fabricate a compile-time false result that\u0026#39;s still dependent on the template parameter static_assert(IndexSize == IndexSize+1, \u0026#34;Unsupported allocator index size.\u0026#34;); }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;8\u0026gt; { using Type = int8; }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;16\u0026gt; { using Type = int16; }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;32\u0026gt; { using Type = int32; }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;64\u0026gt; { using Type = int64; }; //----------UE在Windows环境下的int类型--------------// // 8-bit signed integer typedef\tsigned char\tint8; // 16-bit signed integer typedef signed short int\tint16; // 32-bit signed integer typedef signed int\tint32; // 64-bit signed integer typedef signed long long\tint64; TSizedDefaultAllocator 继承自 TSizedHeapAllocator， TSizedHeapAllocator中定义了SizeType，\n通过偏特化，当IndexSize是32时 ，SizeType = int32.\nElementType 作用：表示容器存储的 元素类型（如 int、FString）。 设计原因： 直接透传模板参数 InElementType，简化代码中对元素类型的引用。 1 2 3 using Array = TArray\u0026lt;AActor*\u0026gt;; //AActor* using ArrayElementType = Array::ElementType; TArray存放Actor*，那么ElementType就是AActor*类型.\nUSizeType 作用：将 SizeType 转换为 无符号整数类型（如 uint32、uint64）。 设计原因： 在需要无符号运算的场景（如内存块大小计算）避免负数溢出问题。 ElementAllocatorType 1 2 3 4 5 using ElementAllocatorType = std::conditional_t\u0026lt; AllocatorType::NeedsElementType, typename AllocatorType::template ForElementType\u0026lt;ElementType\u0026gt;, typename AllocatorType::ForAnyElementType \u0026gt;; 作用：根据分配器是否需要元素类型，选择具体的 内存分配器实现。\n设计原因：\n**NeedsElementType = true**：分配器需要知道元素类型（例如，为元素构造/析构或对齐优化）。此时使用 ForElementType\u0026lt;ElementType\u0026gt;，即与元素类型绑定的分配器。\n**NeedsElementType = false**：分配器不依赖元素类型（例如，原始内存块管理）。此时使用 ForAnyElementType，即通用分配器。\n默认的分配器定义了这个NeedsElementType类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;int IndexSize, typename BaseMallocType = FMemory\u0026gt; class TSizedHeapAllocator { public: using SizeType = typename TBitsToSizeType\u0026lt;IndexSize\u0026gt;::Type; private: using USizeType = std::make_unsigned_t\u0026lt;SizeType\u0026gt;; public: enum { NeedsElementType = true }; enum { RequireRangeCheck = true }; } 因此通过std::conditional_t的匹配，选择ForElementType\nTArray存放AActor时，类型为:TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor\u0026gt;\n1 2 // TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor*\u0026gt; using ArrayElementAllocatorType = Array::ElementAllocatorType; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using ElementAllocatorType = std::conditional_t\u0026lt; AllocatorType::NeedsElementType, typename AllocatorType::template ForElementType\u0026lt;ElementType\u0026gt;, typename AllocatorType::ForAnyElementType \u0026gt;; //---------conditional的源码---------// template \u0026lt;bool _Test, class _Ty1, class _Ty2\u0026gt; struct conditional { // Choose _Ty1 if _Test is true, and _Ty2 otherwise using type = _Ty1; }; template \u0026lt;class _Ty1, class _Ty2\u0026gt; struct conditional\u0026lt;false, _Ty1, _Ty2\u0026gt; { using type = _Ty2; }; template \u0026lt;bool _Test, class _Ty1, class _Ty2\u0026gt; using conditional_t = typename conditional\u0026lt;_Test, _Ty1, _Ty2\u0026gt;::type; 当第一个bool值为true时，即 AllocatorType::NeedsElementType 为true，\n那么conditional的type选择 AllocatorType::template ForElementType\n如果是false，conditional的type将会选择 AllocatorType::ForAnyElementType\nstatic_assert 1 static_assert(std::is_signed_v\u0026lt;SizeType\u0026gt;, \u0026#34;TArray only supports signed index types\u0026#34;); 作用：编译时检查 SizeType 是否为 有符号整数类型。\n设计原因：\n安全性：有符号整数可以表示负数，便于处理 InvalidIndex（如 INDEX_NONE = -1）。\n兼容性：UE 代码中许多接口依赖有符号索引（如 TArray::Find 返回 int32）。\n错误预防：避免用户误用无符号类型导致索引计算错误（如 0u - 1 溢出为最大值）。\n总结 组件 功能 设计目标 **SizeType** 定义索引和容量类型，由分配器决定 支持不同内存规模的容器 **ElementType** 容器存储的元素类型 泛型编程的核心 **AllocatorType** 内存分配策略（堆、栈、池等） 灵活的内存管理 **USizeType** 无符号类型，用于内存大小计算 避免无符号运算的溢出问题 **ElementAllocatorType** 根据分配器需求选择类型相关或无关的实现 优化内存操作（构造/析构、对齐） **static_assert** 强制 SizeType 为有符号类型 确保索引逻辑安全 构造函数 TArray的成员变量\n1 2 3 ElementAllocatorType AllocatorInstance; SizeType ArrayNum; SizeType ArrayMax; SizeType = int32 = signed int\nElementAllocatorType = TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor*\u0026gt;\n默认构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Constructor, initializes element number counters. */ FORCEINLINE TArray() : ArrayNum(0) , ArrayMax(AllocatorInstance.GetInitialCapacity()) {} SizeType GetInitialCapacity() const { return 0; } // 创建一个空的 TArray（元素类型为 int32） TArray\u0026lt;int32\u0026gt; MyArray; // MyArray 初始状态：Num() = 0, Max() = Allocator 的初始容量（例如 4） 只定义一个TArray Array，不传入任何参数时，Num和Max都设为0.\n从原始数组构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Constructor from a raw array of elements. * * @param Ptr A pointer to an array of elements to copy. * @param Count The number of elements to copy from Ptr. * @see Append */ FORCEINLINE TArray(const ElementType* Ptr, SizeType Count) { if (Count \u0026lt; 0) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. // 首先转换为 USizeType 以防止负数大小在符号扩展时产生异常大的值。 UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)Count); } check(Ptr != nullptr || Count == 0); CopyToEmpty(Ptr, Count, 0); } // 原始 C 风格数组 int32 RawArray[] = {10, 20, 30}; // 从 RawArray 构造 TArray（复制前3个元素） TArray\u0026lt;int32\u0026gt; MyArray(RawArray, 3); // MyArray 内容：{10, 20, 30} CopyToEmpty 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template \u0026lt;typename OtherElementType, typename OtherSizeType\u0026gt; void CopyToEmpty(const OtherElementType* OtherData, OtherSizeType OtherNum, SizeType PrevMax) { //类型转换 SizeType NewNum = (SizeType)OtherNum; //检测 溢出/丢失精度 checkf((OtherSizeType)NewNum == OtherNum, TEXT(\u0026#34;Invalid number of elements to add to this array type: %lld\u0026#34;), (long long)NewNum); //更新元素数量 ArrayNum = NewNum; //如果 OtherNum 或 PrevMax 不为零，则需要调整当前数组的大小以适应新数据 if (OtherNum || PrevMax) { //调整数组的容量以适应新的元素数量。 ResizeForCopy(NewNum, PrevMax); //构造元素 ConstructItems\u0026lt;ElementType\u0026gt;((void*)GetData(), OtherData, OtherNum); } else { // 设为0 ArrayMax = AllocatorInstance.GetInitialCapacity(); } SlackTrackerNumChanged(); } ConstructItems 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Constructs a range of items into memory from a set of arguments. The arguments come from an another array. * * @param\tDest\tThe memory location to start copying into. * @param\tSource\tA pointer to the first argument to pass to the constructor. * @param\tCount\tThe number of elements to copy. */ template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; TIsBitwiseConstructible\u0026lt;DestinationElementType, SourceElementType\u0026gt;::Value) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCEINLINE void ConstructItems(void* Dest, const SourceElementType* Source, SizeType Count) { if (Count) { FMemory::Memcpy(Dest, Source, sizeof(SourceElementType) * Count); } } // template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; !TIsBitwiseConstructible\u0026lt;DestinationElementType, SourceElementType\u0026gt;::Value) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCENOINLINE void ConstructItems(void* Dest, const SourceElementType* Source, SizeType Count) { while (Count) { ::new ((void*)Dest) DestinationElementType(*Source); // Placement new 构造 ++(DestinationElementType*\u0026amp;)Dest; // 指针步进 ++Source; --Count; } } 这两个模板函数用于将源数组元素构造到目标内存中，根据类型是否支持位拷贝（bitwise copy）选择不同的构造策略。\n通过模板特化和类型特性检查，在保证类型安全的前提下，为简单类型提供高效内存拷贝，为复杂类型提供安全的逐个构造逻辑，是 UE 容器高性能设计的核心机制之一。\n第一个版本 即使用Memcpy， 是 位拷贝优化版本（快速路径）\nTIsBitwiseConstructible 类型特性检查，判断 SourceElementType 是否可以直接按位复制到 DestinationElementType 的内存中（如基本类型、POD 类型）\nFMemory::Memcpy 直接内存拷贝，效率高（O(n) 时间，无额外构造/析构调用）\n使用场景:\n基础类型：int32, float, FVector 等。 POD 类型：无自定义构造函数/析构函数的结构体。 内存布局兼容的类型：保证 Source 和 Dest 的二进制兼容性。 第二个版本 即使用while循环，是逐个构造版本（安全路径）\n!TIsBitwiseConstructible 类型不兼容位拷贝时启用此版本\nPlacement new 在目标内存地址调用构造函数（支持非 POD 类型）\n指针步进 手动移动目标指针到下一个元素位置\n使用场景:\n非 POD 类型：如包含 FString、TSharedPtr 等需要构造/析构的类型。 有自定义构造逻辑：需要调用拷贝构造函数或转换构造函数。 操作 位拷贝版本 逐个构造版本 时间复杂度 O(n)（内存连续拷贝） O(n)（循环调用构造函数） 适用类型 简单类型 复杂类型 内存安全性 依赖类型兼容性 安全 应用场景:\n容器扩容：TArray::Add 或 TArray::Append 时选择最优构造方式。 序列化：反序列化二进制数据到对象。 内存复用：重用已分配内存避免重复构造。 从TArrayView构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename OtherElementType, typename OtherSizeType\u0026gt; explicit TArray(const TArrayView\u0026lt;OtherElementType, OtherSizeType\u0026gt;\u0026amp; Other); //--------------// template\u0026lt;typename InElementType, typename InAllocatorType\u0026gt; template\u0026lt;typename OtherElementType, typename OtherSizeType\u0026gt; FORCEINLINE TArray\u0026lt;InElementType, InAllocatorType\u0026gt;::TArray(const TArrayView\u0026lt;OtherElementType, OtherSizeType\u0026gt;\u0026amp; Other) { CopyToEmpty(Other.GetData(), Other.Num(), 0); } // 原始 C 风格数组 int32 RawArray[] = {10, 20, 30}; // 创建一个 TArrayView（视图） TArrayView\u0026lt;int32\u0026gt; View = MakeArrayView(RawArray, 3); // 从 View 构造 TArray（复制数据） TArray\u0026lt;int32\u0026gt; MyArray(View); // MyArray 内容：{10, 20, 30} 初始化列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Initializer list constructor */ TArray(std::initializer_list\u0026lt;InElementType\u0026gt; InitList) { // This is not strictly legal, as std::initializer_list\u0026#39;s iterators are not guaranteed to be pointers, but // this appears to be the case on all of our implementations. Also, if it\u0026#39;s not true on a new implementation, // it will fail to compile rather than behave badly. CopyToEmpty(InitList.begin(), (SizeType)InitList.size(), 0); } // 直接通过初始化列表构造 TArray\u0026lt;FString\u0026gt; MyArray = {\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;}; // MyArray 内容：{\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;} 注释里面叽里呱啦说啥呢？\n// 严格来说，这是不合法的，因为 std::initializer_list 的迭代器并不保证是指针，\n// 但是在我们所有的实现中似乎都是这样的情况。此外，如果在新的实现中它不是指针，\n// 那么它将会编译失败，而不是表现糟糕。\n合法性问题：从技术上讲，假设 std::initializer_list 的迭代器是指针是不符合标准的，因为标准并没有保证这一点。\n实际实现情况：尽管标准没有保证，但在当前的所有实现中，这些迭代器实际上确实是指针。\n安全性：如果在未来某个新的实现中，这种假设不再成立（即迭代器不是指针），那么代码会在编译时就报错，而不是在运行时产生难以调试的行为问题。这提供了一种早期检测错误的方式，避免了潜在的运行时错误。\n跨分配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Copy constructor with changed allocator. Use the common routine to perform the copy. * * @param Other The source array to copy. */ template \u0026lt; typename OtherElementType, typename OtherAllocator UE_REQUIRES(UE::Core::Private::TArrayElementsAreCompatible_V\u0026lt;ElementType, const OtherElementType\u0026amp;\u0026gt;) \u0026gt; FORCEINLINE explicit TArray(const TArray\u0026lt;OtherElementType, OtherAllocator\u0026gt;\u0026amp; Other) { CopyToEmpty(Other.GetData(), Other.Num(), 0); } // 源数组（使用默认分配器） TArray\u0026lt;int32, FDefaultAllocator\u0026gt; SourceArray = {1, 2, 3}; // 目标数组（使用其他分配器，如栈分配器） TArray\u0026lt;int32, TInlineAllocator\u0026lt;16\u0026gt;\u0026gt; MyArray(SourceArray); // MyArray 内容：{1, 2, 3}（元素类型兼容即可拷贝） 拷贝构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Copy constructor. Use the common routine to perform the copy. * * @param Other The source array to copy. */ FORCEINLINE TArray(const TArray\u0026amp; Other) { CopyToEmpty(Other.GetData(), Other.Num(), 0); } TArray\u0026lt;FVector\u0026gt; SourceArray; SourceArray.Add(FVector(1.0f, 2.0f, 3.0f)); // 拷贝构造 TArray\u0026lt;FVector\u0026gt; MyArray(SourceArray); // MyArray 内容：{FVector(1,2,3)} 带预分配内存的拷贝构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Copy constructor. Use the common routine to perform the copy. * * @param Other The source array to copy. * @param ExtraSlack Tells how much extra memory should be preallocated * at the end of the array in the number of elements. */ FORCEINLINE TArray(const TArray\u0026amp; Other, SizeType ExtraSlack) { CopyToEmptyWithSlack(Other.GetData(), Other.Num(), 0, ExtraSlack); } TArray\u0026lt;int32\u0026gt; SourceArray = {100, 200}; // 拷贝构造并预留 5 个额外空间 TArray\u0026lt;int32\u0026gt; MyArray(SourceArray, 5); // MyArray 内容：{100, 200} // MyArray 容量：2（元素数） + 5（额外空间） = 7 ExtraSlack 数组末尾按元素的数量预先分配多少额外内存。\n移动构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 FORCEINLINE TArray(TArray\u0026amp;\u0026amp; Other) { MoveOrCopy(*this, Other, 0); } //-------------------------// template \u0026lt; typename OtherElementType, typename OtherAllocator UE_REQUIRES(UE::Core::Private::TArrayElementsAreCompatible_V\u0026lt;ElementType, OtherElementType\u0026amp;\u0026amp;\u0026gt;) \u0026gt; FORCEINLINE explicit TArray(TArray\u0026lt;OtherElementType, OtherAllocator\u0026gt;\u0026amp;\u0026amp; Other) { MoveOrCopy(*this, Other, 0); } //---------------------------// template \u0026lt; typename OtherElementType UE_REQUIRES(UE::Core::Private::TArrayElementsAreCompatible_V\u0026lt;ElementType, OtherElementType\u0026amp;\u0026amp;\u0026gt;) \u0026gt; TArray(TArray\u0026lt;OtherElementType, AllocatorType\u0026gt;\u0026amp;\u0026amp; Other, SizeType ExtraSlack) { MoveOrCopyWithSlack(*this, Other, 0, ExtraSlack); } MoveOrCpoy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 template \u0026lt;typename FromArrayType, typename ToArrayType\u0026gt; static FORCEINLINE void MoveOrCopy(ToArrayType\u0026amp; ToArray, FromArrayType\u0026amp; FromArray, SizeType PrevMax) { if constexpr (UE::Core::Private::CanMoveTArrayPointersBetweenArrayTypes\u0026lt;FromArrayType, ToArrayType\u0026gt;()) { // Move static_assert(std::is_same_v\u0026lt;TArray, ToArrayType\u0026gt;, \u0026#34;MoveOrCopy is expected to be called with the current array type as the destination\u0026#34;); using FromAllocatorType = typename FromArrayType::AllocatorType; using ToAllocatorType = typename ToArrayType::AllocatorType; if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } ToArray .ArrayNum = (SizeType)FromArray.ArrayNum; ToArray .ArrayMax = (SizeType)FromArray.ArrayMax; // Ensure the destination container could hold the source range (when the allocator size types shrink) if constexpr (sizeof(USizeType) \u0026lt; sizeof(typename FromArrayType::USizeType)) { if (ToArray.ArrayNum != FromArray.ArrayNum || ToArray.ArrayMax != FromArray.ArrayMax) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)ToArray.ArrayNum); } } FromArray.ArrayNum = 0; FromArray.ArrayMax = FromArray.AllocatorInstance.GetInitialCapacity(); FromArray.SlackTrackerNumChanged(); ToArray.SlackTrackerNumChanged(); } else { // Copy ToArray.CopyToEmpty(FromArray.GetData(), FromArray.Num(), PrevMax); } } MoveOrCopy 是用于在两个 TArray（或类似容器）之间高效地 移动或拷贝数据 的模板函数。\n其核心逻辑是：\n移动（Move）：若源数组（FromArray）和目标数组（ToArray）的 内存分配器（Allocator）和元素类型兼容，直接转移内存所有权（零拷贝）。 拷贝（Copy）：若条件不满足，则执行深拷贝。 片段1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } //------------------------------------------------// template \u0026lt;typename FromAllocatorType, typename ToAllocatorType\u0026gt; struct TCanMoveBetweenAllocators { enum { Value = false }; }; template \u0026lt;uint8 FromIndexSize, uint8 ToIndexSize\u0026gt; struct TCanMoveBetweenAllocators\u0026lt;TSizedHeapAllocator\u0026lt;FromIndexSize\u0026gt;, TSizedHeapAllocator\u0026lt;ToIndexSize\u0026gt;\u0026gt; { // Allow conversions between different int width versions of the allocator enum { Value = true }; }; template \u0026lt;uint8 FromIndexSize, uint8 ToIndexSize\u0026gt; struct TCanMoveBetweenAllocators\u0026lt;TSizedDefaultAllocator\u0026lt;FromIndexSize\u0026gt;, TSizedDefaultAllocator\u0026lt;ToIndexSize\u0026gt;\u0026gt; : TCanMoveBetweenAllocators\u0026lt;typename TSizedDefaultAllocator\u0026lt;FromIndexSize\u0026gt;::Typedef, typename TSizedDefaultAllocator\u0026lt;ToIndexSize\u0026gt;::Typedef\u0026gt; {}; TCanMoveBetweenAllocators 接受两个模板参数\n传入的两个都不是TSizedHeapAllocator或TSizedDefaultAllocator，Value为false，\n传入的都是TSizedHeapAllocator，Value为true\n传入的都是TSizedDefaultAllocator，则根据TSizedDefaultAllocator内部的兼容性判断true和false.\nValue=true 调用MoveToEmptyFromOtherAllocator\nValue=false 调用MoveToEmpty\n高僧解释:\nTCanMoveBetweenAllocators :你给我传的是什么东西我请问了，\n传俩TSizedHeapAllocator给我，OK 我回答你true.\n传俩TSizedDefaultAllocator，我只能说 具体问题具体分析.\n传来两个既不是TSizedHeapAllocator 也不是 TSizedDefaultAllocator，那我只能告诉你 false.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } //-----------------------------------// template \u0026lt;typename OtherAllocator\u0026gt; FORCEINLINE void MoveToEmptyFromOtherAllocator(typename OtherAllocator::ForAnyElementType\u0026amp; Other) { // 检查当前分配器实例和传入的分配器实例不是同一个对象 checkSlow((void*)this != (void*)\u0026amp;Other); // 如果当前分配器已经有分配的数据，则释放这些数据 if (Data) { BaseMallocType::Free(Data); } // 将源分配器的数据指针赋值给当前分配器 Data = Other.Data; // 将源分配器的数据指针设置为 nullptr，表示它现在为空 Other.Data = nullptr; } FORCEINLINE void MoveToEmpty(ForAnyElementType\u0026amp; Other) { // 调用模板函数，指定 TSizedHeapAllocator 作为模板参数 this-\u0026gt;MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026gt;(Other); } 这两段代码的核心区别在于 分配器类型兼容性处理，具体分为两种情况：\n1. 当分配器类型兼容时 (TCanMoveBetweenAllocators = true)\n模板参数：显式指定源分配器类型 FromAllocatorType。 目的： 当源分配器和目标分配器 类型不同但兼容（如 TSizedHeapAllocator\u0026lt;32\u0026gt; 和 TSizedHeapAllocator\u0026lt;64\u0026gt;），通过模板参数传递源分配器的类型，确保正确调用其内存管理逻辑（如释放旧内存、接管新内存）。 示例场景： 源数组使用 TSizedHeapAllocator\u0026lt;32\u0026gt;，目标数组使用 TSizedHeapAllocator\u0026lt;64\u0026gt;，但两者支持跨分配器移动。 2. 当分配器类型不兼容时 (TCanMoveBetweenAllocators = false)\n实际调用： MoveToEmpty 内部调用 MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026gt;，即强制将源分配器视为默认的 TSizedHeapAllocator。 目的： 当分配器类型 不兼容 时，假设源分配器与目标分配器共享相同的默认内存管理策略（如堆分配），直接通过默认逻辑转移内存。 风险： 若源分配器实际类型非 TSizedHeapAllocator，可能导致未定义行为（如内存泄漏或崩溃）。因此此路径仅在类型严格兼容时安全。 场景 1：同类型分配器移动\n1 2 TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt; Source, Dest; MoveOrCopy(Dest, Source, 0); 调用路径： MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt;。 行为： 安全转移内存，无额外开销。 场景 2：不同类型分配器移动（但兼容）\n1 2 3 TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt; Source; TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;64\u0026gt;\u0026gt; Dest; MoveOrCopy(Dest, Source, 0); 调用路径： MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt;。 行为： 根据源分配器类型释放旧内存，正确接管新内存。 场景 3：不兼容分配器移动\n1 2 3 TArray\u0026lt;int32, TInlineAllocator\u0026lt;16\u0026gt;\u0026gt; Source; TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt; Dest; MoveOrCopy(Dest, Source, 0); 调用路径： MoveToEmpty → MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026gt;。 行为： 错误！TInlineAllocator（栈分配）与 TSizedHeapAllocator（堆分配）策略不同，强制转换导致未定义行为。 条件 调用方式 安全性 适用场景 分配器兼容 (TCanMove=true) 显式模板参数传递 (FromAllocatorType) 高 不同类型但内存策略兼容的分配器 分配器不兼容 (TCanMove=false) 强制默认分配器类型 (TSizedHeapAllocator) 低 仅限同类型或设计确保安全的分配器 设计原则：\n零开销抽象：通过编译时分支选择最优路径。 类型安全：利用模板特性确保内存操作正确性。 扩展性：允许自定义分配器通过特化声明兼容性。 最佳实践：\n自定义分配器：若需支持跨类型移动，需特化 TCanMoveBetweenAllocators。 谨慎使用默认路径：确保不兼容分配器的移动操作在设计中无害。 片段2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ToArray.ArrayNum = (SizeType)FromArray.ArrayNum; ToArray.ArrayMax = (SizeType)FromArray.ArrayMax; // 确保目标容器能够容纳源容器中的数据范围，特别是在分配器大小类型缩小的情况下。 // 检查目标容器的大小类型 USizeType 是否比源容器的大小类型小。 if constexpr (sizeof(USizeType) \u0026lt; sizeof(typename FromArrayType::USizeType)) { //检查目标容器的当前元素数量 (ArrayNum) 和最大容量 (ArrayMax) 是否与源容器相匹配。 if (ToArray.ArrayNum != FromArray.ArrayNum || ToArray.ArrayMax != FromArray.ArrayMax) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)ToArray.ArrayNum); } } //----------------------------------------------------------------// void UE::Core::Private::OnInvalidArrayNum(unsigned long long NewNum) { UE_LOG(LogCore, Fatal, TEXT(\u0026#34;Trying to resize TArray to an invalid size of %llu\u0026#34;), NewNum); for (;;); } UE::Core::Private::OnInvalidArrayNum Log使用了Fatal，引擎崩溃报错.\n1 2 3 4 FromArray.ArrayNum = 0; FromArray.ArrayMax = FromArray.AllocatorInstance.GetInitialCapacity(); FromArray.SlackTrackerNumChanged(); ToArray.SlackTrackerNumChanged(); FromArray的ArrayNum、ArrayMax设置为0，\n总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 if constexpr (UE::Core::Private::CanMoveTArrayPointersBetweenArrayTypes\u0026lt;FromArrayType, ToArrayType\u0026gt;()) { // Move static_assert(std::is_same_v\u0026lt;TArray, ToArrayType\u0026gt;, \u0026#34;MoveOrCopy is expected to be called with the current array type as the destination\u0026#34;); using FromAllocatorType = typename FromArrayType::AllocatorType; using ToAllocatorType = typename ToArrayType::AllocatorType; //判断传入的两个分配器能否移动 if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { //移动分配器 ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } //拿来吧你 ToArray .ArrayNum = (SizeType)FromArray.ArrayNum; ToArray .ArrayMax = (SizeType)FromArray.ArrayMax; // 确保目标容器能够容纳源容器中的数据范围，特别是在分配器大小类型缩小的情况下。 // 检查目标容器的大小类型 USizeType 是否比源容器的大小类型小。 if constexpr (sizeof(USizeType) \u0026lt; sizeof(typename FromArrayType::USizeType)) { //检查目标容器的当前元素数量 (ArrayNum) 和最大容量 (ArrayMax) 是否与源容器相匹配。 if (ToArray.ArrayNum != FromArray.ArrayNum || ToArray.ArrayMax != FromArray.ArrayMax) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. // 触发崩溃 UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)ToArray.ArrayNum); } } //FromArray的ArrayNum、ArrayMax设为0 FromArray.ArrayNum = 0; FromArray.ArrayMax = FromArray.AllocatorInstance.GetInitialCapacity(); FromArray.SlackTrackerNumChanged(); ToArray.SlackTrackerNumChanged(); } 析构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** Destructor. */ ~TArray() { DestructItems(GetData(), ArrayNum); // note ArrayNum, ArrayMax and data pointer are not invalidated // they are left unchanged and use-after-destruct will see them the same as before destruct } //--------------------------------// template \u0026lt; typename ElementType, typename SizeType UE_REQUIRES(sizeof(ElementType) \u0026gt; 0 \u0026amp;\u0026amp; std::is_trivially_destructible_v\u0026lt;ElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCEINLINE void DestructItems(ElementType* Element, SizeType Count) { } template \u0026lt; typename ElementType, typename SizeType UE_REQUIRES(sizeof(ElementType) \u0026gt; 0 \u0026amp;\u0026amp; !std::is_trivially_destructible_v\u0026lt;ElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCENOINLINE void DestructItems(ElementType* Element, SizeType Count) { while (Count) { // We need a typedef here because VC won\u0026#39;t compile the destructor call below if ElementType itself has a member called ElementType typedef ElementType DestructItemsElementTypeTypedef; Element-\u0026gt;DestructItemsElementTypeTypedef::~DestructItemsElementTypeTypedef(); ++Element; --Count; } } is_trivially_destructible_v 检查给定类型的析构函数是否是平凡的（trivial）。\n平凡析构函数：类型没有用户定义的析构函数，所有非静态成员和基类都有平凡析构函数。\n示例：基本数据类型、简单的POD（Plain Old Data）结构体、某些标准库类型（如 std::array 当元素类型为平凡类型时）。\n非平凡析构函数：类型有用户定义的析构函数，或者其成员或基类有非平凡析构函数。\n示例：用户定义析构函数的类、包含标准库容器（如 std::vector）的类、从具有非平凡析构函数的基类派生的类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;array\u0026gt; // 基本数据类型 std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;int\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true // 简单结构体 struct Trivial { int x; double y; }; std::cout \u0026lt;\u0026lt; \u0026#34;Trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;Trivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true // 用户定义析构函数 struct NonTrivial { ~NonTrivial() noexcept {} int x; double y; }; std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;NonTrivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 成员类型有非平凡析构函数 struct NonTrivialMember { std::string str; }; std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivialMember: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;NonTrivialMember\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 基类有非平凡析构函数 struct Base { ~Base() noexcept {} }; struct Derived : public Base { int x; }; std::cout \u0026lt;\u0026lt; \u0026#34;Derived: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;Derived\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 标准库容器 std::vector\u0026lt;int\u0026gt; vec; std::cout \u0026lt;\u0026lt; \u0026#34;std::vector\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;decltype(vec)\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 标准库类型（当元素类型为平凡类型时） std::array\u0026lt;int, 5\u0026gt; arr; std::cout \u0026lt;\u0026lt; \u0026#34;std::array\u0026lt;int, 5\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;decltype(arr)\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true POD\n根据C++标准，POD类型必须满足以下条件：\n平凡的默认构造函数（Trivial Default Constructor）：\n类型没有用户定义的默认构造函数，或者它的默认构造函数是平凡的（即编译器生成的默认构造函数）。 平凡的析构函数（Trivial Destructor）：\n类型没有用户定义的析构函数，或者它的析构函数是平凡的（即编译器生成的析构函数）。 平凡的拷贝/移动操作（Trivial Copy/Move Operations）：\n类型没有用户定义的拷贝构造函数、拷贝赋值运算符、移动构造函数或移动赋值运算符，或者这些操作是平凡的（即编译器生成的操作）。 标准布局（Standard Layout）：\n类型的所有非静态数据成员都具有相同的访问控制（public, protected, private），并且基类和非静态数据成员不能有虚函数或虚基类。\n所有非静态数据成员都必须具有标准布局类型（standard-layout type）。\n类型没有虚函数或虚基类。\n**std::is_trivial**：检查类型是否有平凡的构造函数、析构函数和拷贝/移动操作。\n**std::is_standard_layout**：检查类型是否具有标准布局。\n平凡类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct Trivial { int x; double y; }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; // 检查是否为平凡类型 std::cout \u0026lt;\u0026lt; \u0026#34;Trivial is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;Trivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true // 检查是否为标准布局类型 std::cout \u0026lt;\u0026lt; \u0026#34;Trivial is standard layout: \u0026#34; \u0026lt;\u0026lt; std::is_standard_layout_v\u0026lt;Trivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true return 0; } 非平凡类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;string\u0026gt; struct NonTrivial { ~NonTrivial() noexcept {} int x; double y; }; struct NonStandardLayout { virtual void foo() {} int x; double y; }; struct NonTrivialMember { std::string str; int x; double y; }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; // 检查是否为平凡类型 std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivial is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;NonTrivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false std::cout \u0026lt;\u0026lt; \u0026#34;NonStandardLayout is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;NonStandardLayout\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivialMember is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;NonTrivialMember\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 检查是否为标准布局类型 std::cout \u0026lt;\u0026lt; \u0026#34;NonStandardLayout is standard layout: \u0026#34; \u0026lt;\u0026lt; std::is_standard_layout_v\u0026lt;NonStandardLayout\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false return 0; } TArray存放的 对象类型 与 析构时DestructItems:\n**平凡类型（int、float、原始指针等）**触发空实现，无额外操作。 **非平凡类型（如含资源的类）**触发显式析构，确保资源释放。 指针类型始终触发空实现，需手动管理指向的内存。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 当 TArray 存放需要显式析构的类型时（即非平凡可析构类型，如拥有自定义析构函数的类）， 会调用第二个版本的DestructItems，从而逐个调用元素的析构函数。 调用第一个空实现的DestructItems的影响： 对于平凡可析构类型（如int、float、指针等），这是安全的，因为它们无需显式析构。 但如果错误地应用于非平凡类型（如资源持有类），会导致资源泄漏，因为析构函数未被调用。 存放 int、float等基础类型 时： 调用第一个版本的DestructItems，因为它们属于平凡可析构类型。 存放 int*、float*指针 时： 同样调用第一个版本，指针类型自身是平凡可析构的。注意指针指向的内存不会被自动释放。 存放 有析构函数的类Obj 时： 存放Obj对象（TArray\u0026lt;Obj\u0026gt;）：Obj非平凡可析构，调用第二个版本，显式析构每个元素。 存放Obj*指针（TArray\u0026lt;Obj*\u0026gt;）：指针类型平凡可析构，调用第一个版本，不析构指针指向的对象。 存放 无析构函数的类Obj2 时： 存放Obj2对象（TArray\u0026lt;Obj2\u0026gt;）：若Obj2及其成员均为平凡类型，调用第一个版本； 则（如含非平凡成员），调用第二个版本。 存放Obj2*指针（TArray\u0026lt;Obj2*\u0026gt;）：调用第一个版本，指针自身无需析构。 详情举例\n有自定义析构函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Obj { public: int a = 3; ~Obj() {} // 自定义析构函数 }; void func() { Obj o1; { TArray\u0026lt;Obj\u0026gt; Array; Array.Add(o1); // 存储的是o1的副本 } // Array析构时调用副本的析构函数 cout \u0026lt;\u0026lt; o1.a; // 输出3（原对象未被析构） } 无自定义析构函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Obj {// 平凡类型 public: int a = 3; }; void func() { Obj o1; { TArray\u0026lt;Obj\u0026gt; Array; Array.Add(o1); } // 不调用任何析构 cout \u0026lt;\u0026lt; o1.a; // 输出3 } 常见误解澄清:\n副本原则：Array.Add(o1) 永远存储的是原对象的独立副本 生命周期分离： 原对象：由声明作用域决定 容器内对象：由容器生命周期决定 指针类型的特殊性： 1 2 TArray\u0026lt;Obj*\u0026gt; PtrArray; // 存储的是指针值 ~TArray() //仅释放指针占用的内存，不会delete指向的对象 1 2 3 4 5 6 7 8 9 10 11 TArray\u0026lt;Obj*\u0026gt; PtrArray; PtrArray.Add(new Obj()); PtrArray.Add(new Obj()); +-------------------+ +---------\u0026gt; [Obj instance 1] | PtrArray 内存块 | | | 0x1234: Obj* ptr1 |-----+ | 0x1238: Obj* ptr2 |----------+ +-------------------+ | v [Obj instance 2] 释放的是指针存储空间：即0x1234-0x1238的内存区域 不触及指向对象：0x1234和0x1238存储的地址值被丢弃，但对应Obj实例仍在堆中 析构总结:\n条件析构优化：通过 std::is_trivially_destructible 特征判断 性能考量：避免对简单类型执行不必要的析构操作 类型安全：强制要求资源管理类必须正确实现析构 总结 构造函数 示例场景 默认构造 创建空数组 原始数组构造 从 C 数组或内存块初始化 TArrayView 构造 从数据视图（无所有权）初始化 初始化列表构造 快速初始化小型数组 跨分配器拷贝 不同内存策略的数组间复制数据 普通拷贝构造 同类型数组的深拷贝 带额外容量的拷贝构造 预分配空间以减少后续扩容开销 移动构造 减少临时对象的开销 增删改查 方法 功能 时间复杂度 示例 Push / Add 在数组末尾添加元素 均摊 O(1) TArray\u0026lt;int\u0026gt; arr; ``arr.Add(1); Pop 移除并返回数组末尾元素 O(1) int val = arr.Pop(); Top / Last 获取数组末尾元素（不移除） O(1) int val = arr.Last(); Emplace 在末尾直接构造元素（避免拷贝） 均摊 O(1) arr.Emplace(42); Pop Pop 函数是 TArray 类中的一个成员函数，用于从数组中移除并返回最后一个元素。\n这个函数还提供了可选的收缩（shrink）功能，允许在移除元素后调整数组的容量以节省内存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // * * // *从数组中弹出元素。 // * // * @param allowshrink是否允许在删除元素期间收缩数组。 // * @返回弹出的元素。 // * ElementType Pop(EAllowShrinking AllowShrinking = EAllowShrinking::Yes) { //确保数组至少有一个元素 RangeCheck(0); //获取数组中最后一个元素（索引为 ArrayNum - 1）。 //使用 MoveTempIfPossible 将其转换为右值引用，从而启用移动语义。 //这可以避免不必要的拷贝操作，提高性能。 ElementType Result = MoveTempIfPossible(GetData()[ArrayNum - 1]); //从数组中移除最后一个元素。 RemoveAtImpl(ArrayNum - 1); if (AllowShrinking == EAllowShrinking::Yes) { //释放未使用的内存。 ResizeShrink(); } return Result; } template \u0026lt;typename T\u0026gt; UE_INTRINSIC_CAST FORCEINLINE constexpr std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp; MoveTempIfPossible(T\u0026amp;\u0026amp; Obj) noexcept { //定义一个类型别名 CastType，它是移除了引用属性后的 T 类型。 using CastType = std::remove_reference_t\u0026lt;T\u0026gt;; //将传入的对象 Obj 转换为右值引用，并返回。 //这样做的目的是启用移动语义。 return (CastType\u0026amp;\u0026amp;)Obj; } MoveTempIfPossible 右值引用 参数 T\u0026amp;\u0026amp; Obj ：使用了通用引用（universal reference），可以接受左值引用或右值引用。 返回类型 std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp;：移除 T 的引用属性后将其转换为右值引用。 将一个引用转换为右值引用（rvalue reference）， 这是 UE 中 std::move 的等价实现。\n与 MoveTemp 不同，它不会进行静态断言，因此在模板或宏中使用时更加灵活，不会中断编译。\n因为在模板或宏中使用时，参数的具体类型可能不明确，但你仍然希望在可以的情况下利用移动语义，而不中断编译。\n左值右值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyClass { public: MyClass() = default; MyClass(MyClass\u0026amp;\u0026amp; other) noexcept { // 移动构造函数的实现 } }; // 使用 MoveTempIfPossible template \u0026lt;typename T\u0026gt; void ProcessObject(T\u0026amp;\u0026amp; Obj) { MyClass MovedObj = MoveTempIfPossible(Obj); } int main() { MyClass Obj; ProcessObject(Obj); // 左值引用 ProcessObject(MyClass()); // 右值引用 return 0; } Obj 是一个左值引用。MoveTempIfPossible 会将其转换为右值引用，从而触发移动构造函数。 MyClass() 是一个临时对象（右值）。MoveTempIfPossible 也会将其转换为右值引用，从而触发移动构造函数。 Add 在数组末尾添加一个新项，可能会重新分配整个数组以容纳它。\n返回一个索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 FORCEINLINE SizeType Add(const ElementType\u0026amp; Item) { CheckAddress(\u0026amp;Item); return Emplace(Item); } FORCEINLINE SizeType Add(ElementType\u0026amp;\u0026amp; Item) { CheckAddress(\u0026amp;Item); return Emplace(MoveTempIfPossible(Item)); } // 检查指定的地址是否不是容器内元素的一部分。 // 用于在实现中检查引用参数是否会因为可能的重新分配而失效。 FORCEINLINE void CheckAddress(const ElementType* Addr) const { checkf(Addr \u0026lt; GetData() || Addr \u0026gt;= (GetData() + ArrayMax), TEXT(\u0026#34;Attempting to use a container element (%p) which already comes from the container being modified (%p, ArrayMax: %lld, ArrayNum: %lld, SizeofElement: %d)!\u0026#34;), Addr, GetData(), (long long)ArrayMax, (long long)ArrayNum, sizeof(ElementType)); } Emplace 在数组的末尾构造一个新元素，可能会重新分配整个数组来容纳它。\n返回一个索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Constructs a new item at the end of the array, possibly reallocating the whole array to fit. * * @param Args The arguments to forward to the constructor of the new item. * @return Index to the new item */ template \u0026lt;typename... ArgsType\u0026gt; FORCEINLINE SizeType Emplace(ArgsType\u0026amp;\u0026amp;... Args) { //增加数组的大小，并返回新元素将要插入的位置索引。 const SizeType Index = AddUninitialized(); //GetData() 返回指向数组数据的指针，GetData() + Index 计算出新元素应放置的位置。 //使用 ::new 进行原位构造（placement new）， //直接在指定内存位置构造新对象，避免额外的拷贝或移动操作。 //Forward\u0026lt;ArgsType\u0026gt;(Args)... 将参数完美转发给构造函数。 ::new((void*)(GetData() + Index)) ElementType(Forward\u0026lt;ArgsType\u0026gt;(Args)...); return Index; } FORCEINLINE SizeType AddUninitialized() { //确保数组内部状态的一致性，防止非法状态。 //checkSlow((ArrayNum \u0026gt;= 0) \u0026amp; (ArrayMax \u0026gt;= ArrayNum)); CheckInvariants(); // ArrayNum = ArrayNum + 1 const USizeType OldNum = (USizeType)ArrayNum; const USizeType NewNum = OldNum + (USizeType)1; ArrayNum = (SizeType)NewNum; if (NewNum \u0026gt; (USizeType)ArrayMax) { //如果 NewNum 超过了 ArrayMax，则调用 ResizeGrow 增加数组的容量。 ResizeGrow((SizeType)OldNum); } else { //调用 SlackTrackerNumChanged 更新松弛（slack）信息。 SlackTrackerNumChanged(); } //返回 OldNum，即新元素将要插入的位置索引。 return OldNum; } FPrivateToken 让TArray可以调用私有构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 class FMyType { private: struct FPrivateToken { explicit FPrivateToken() = default; }; public: // This has an equivalent access level to a private constructor, // as only friends of FMyType will have access to FPrivateToken, // but Emplace can legally call it since it\u0026#39;s public. explicit FMyType(FPrivateToken, int32 Int, float Real, const TCHAR* String); }; TArray\u0026lt;FMyType\u0026gt; Arr; Arr.Emplace(FMyType::FPrivateToken{}, 5, 3.14f, TEXT(\u0026#34;Banana\u0026#34;)); Remove 1 2 3 4 5 6 7 8 9 SizeType Remove(const ElementType\u0026amp; Item) { // 检查指定的地址是否不是容器内元素的一部分。 CheckAddress(\u0026amp;Item); // Element is non-const to preserve compatibility with existing code with a non-const operator==() member function // 元素是非 const 的，以保持与现有代码中具有非 const operator==() 成员函数的兼容性 return RemoveAll([\u0026amp;Item](ElementType\u0026amp; Element) { return Element == Item; }); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 template \u0026lt;class PREDICATE_CLASS\u0026gt; SizeType RemoveAll(const PREDICATE_CLASS\u0026amp; Predicate) { //如果为空，则直接返回 0，因为没有元素可以移除。 //OriginalNum 记录数组的原始大小 const SizeType OriginalNum = ArrayNum; if (!OriginalNum) { return 0; // nothing to do, loop assumes one item so need to deal with this edge case here } //指向数组数据的指针。 ElementType* Data = GetData(); //WriteIndex ReadIndex分别用于写入和读取操作的索引。 SizeType WriteIndex = 0; //不断增加，直到遇到与当前运行类型不同的元素。 SizeType ReadIndex = 0; //根据第一个元素是否满足谓词，初始化 bNotMatch 变量。 //如果bNotMatch = false，则说明匹配成功，在do-while中的if-else会执行false分支 //else分支调用DestructItems，销毁元素 //如果bNotMatch = true，匹配失败，if-else执行true分支，移动元素重新排序 bool bNotMatch = !::Invoke(Predicate, Data[ReadIndex]); // use a ! to guarantee it can\u0026#39;t be anything other than zero or one do { //记录当前运行的起始位置。 SizeType RunStartIndex = ReadIndex++; while (ReadIndex \u0026lt; OriginalNum \u0026amp;\u0026amp; bNotMatch == !::Invoke(Predicate, Data[ReadIndex])) { ReadIndex++; } //计算当前运行的长度。 SizeType RunLength = ReadIndex - RunStartIndex; checkSlow(RunLength \u0026gt; 0); if (bNotMatch) { // this was a non-matching run, we need to move it if (WriteIndex != RunStartIndex) { //将这些元素移动到 WriteIndex 指向的位置 RelocateConstructItems\u0026lt;ElementType\u0026gt;((void*)(Data + WriteIndex), Data + RunStartIndex, RunLength); } //更新 WriteIndex，使其指向下一个需要写入数据的位置。 WriteIndex += RunLength; } else { // this was a matching run, delete it //销毁这些元素。 DestructItems(Data + RunStartIndex, RunLength); } bNotMatch = !bNotMatch; } while (ReadIndex \u0026lt; OriginalNum); ArrayNum = WriteIndex; SlackTrackerNumChanged(); //返回被移除的元素数量，即原始数组大小减去当前数组大小。 return OriginalNum - ArrayNum; } 模板参数 **PREDICATE_CLASS**：谓词类实例的类型。 参数 **Predicate**：一个谓词对象，用于判断某个元素是否需要被移除。 返回值 **SizeType**：返回被移除的元素数量。 获取原始数组大小：\n如果数组为空，直接返回 0。 初始化变量：\n获取数组数据指针 Data。 初始化读取索引 ReadIndex 和写入索引 WriteIndex。 根据第一个元素的状态初始化 bNotMatch 变量。 遍历数组：\n使用 do...while 循环遍历数组，每次处理一段连续的匹配或非匹配元素段（运行）。 内层循环：找到一段连续的匹配或非匹配元素。 处理非匹配运行：将这些元素移动到 WriteIndex 指向的位置，并更新 WriteIndex。 处理匹配运行：销毁这些元素。 切换 bNotMatch 的值，准备处理下一个运行。 更新数组大小：\n更新数组的有效元素数量 ArrayNum 为 WriteIndex。 返回结果：\n返回被移除的元素数量。 RemoveAt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void RemoveAt(SizeType Index, EAllowShrinking AllowShrinking = EAllowShrinking::Yes) { RangeCheck(Index); RemoveAtImpl(Index); if (AllowShrinking == EAllowShrinking::Yes) { // 根据需要 缩小数组大小 ResizeShrink(); } } void RemoveAtImpl(SizeType Index) { // 获取要移除元素的位置 ElementType* Dest = GetData() + Index; // 销毁该位置的元素 DestructItem(Dest); // Skip relocation in the common case that there is nothing to move. // 在没有东西可移动的情况下，跳过重定位。 SizeType NumToMove = (ArrayNum - Index) - 1; if (NumToMove) { RelocateConstructItems\u0026lt;ElementType\u0026gt;((void*)Dest, Dest + 1, NumToMove); //将一组元素从一个位置移动到另一个位置 //传入参数是两个指针，所以TCanBitwiseRelocate_V通过，则调用的函数是: //FMemory::Memmove(Dest, Source, sizeof(SourceElementType) * Count); } // 减少数组的有效元素数量 --ArrayNum; // 更新松弛信息（如果有的话） SlackTrackerNumChanged(); } 1 2 3 4 5 6 7 8 9 namespace UE::Core::Private::MemoryOps { template \u0026lt;typename DestinationElementType, typename SourceElementType\u0026gt; constexpr inline bool TCanBitwiseRelocate_V = std::is_same_v\u0026lt;DestinationElementType, SourceElementType\u0026gt; || ( TIsBitwiseConstructible\u0026lt;DestinationElementType, SourceElementType\u0026gt;::Value \u0026amp;\u0026amp; std::is_trivially_destructible_v\u0026lt;SourceElementType\u0026gt; ); } 条件:\n如果 DestinationElementType 和 SourceElementType 是相同的类型。 DestinationElementType 可以从 SourceElementType 逐位构造，并且 SourceElementType 是平凡可析构的（trivially destructible）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; UE::Core::Private::MemoryOps::TCanBitwiseRelocate_V\u0026lt;DestinationElementType, SourceElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCEINLINE void RelocateConstructItems(void* Dest, SourceElementType* Source, SizeType Count) { static_assert(!std::is_const_v\u0026lt;SourceElementType\u0026gt;, \u0026#34;RelocateConstructItems: Source cannot be const\u0026#34;); /* All existing UE containers seem to assume trivial relocatability (i.e. memcpy\u0026#39;able) of their members, * so we\u0026#39;re going to assume that this is safe here. However, it\u0026#39;s not generally possible to assume this * in general as objects which contain pointers/references to themselves are not safe to be trivially * relocated. * * However, it is not yet possible to automatically infer this at compile time, so we can\u0026#39;t enable * different (i.e. safer) implementations anyway. */ FMemory::Memmove(Dest, Source, sizeof(SourceElementType) * Count); } template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; !UE::Core::Private::MemoryOps::TCanBitwiseRelocate_V\u0026lt;DestinationElementType, SourceElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCENOINLINE void RelocateConstructItems(void* Dest, SourceElementType* Source, SizeType Count) { static_assert(!std::is_const_v\u0026lt;SourceElementType\u0026gt;, \u0026#34;RelocateConstructItems: Source cannot be const\u0026#34;); //逐个元素地调用构造函数和析构函数进行移动。 while (Count) { // We need a typedef here because VC won\u0026#39;t compile the destructor call below if SourceElementType itself has a member called SourceElementType typedef SourceElementType RelocateConstructItemsElementTypeTypedef; ::new ((void*)Dest) DestinationElementType((SourceElementType\u0026amp;\u0026amp;)*Source); ++(DestinationElementType*\u0026amp;)Dest; (Source++)-\u0026gt;RelocateConstructItemsElementTypeTypedef::~RelocateConstructItemsElementTypeTypedef(); --Count; } } DestructItem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;typename ElementType\u0026gt; FORCEINLINE void DestructItem(ElementType* Element) { //如果 ElementType 的大小为 0，说明这是一个不完整的类型。 //虽然这种情况不应该发生，但这段代码可以帮助生成更有意义的编译错误信息。 if constexpr (sizeof(ElementType) == 0) { // Should never get here, but this construct should improve the error messages we get when we try to call this function with incomplete types } //检测不是平凡可析构的 else if constexpr (!std::is_trivially_destructible_v\u0026lt;ElementType\u0026gt;) { // We need a typedef here because VC won\u0026#39;t compile the destructor call below if ElementType itself has a member called ElementType //避免编译器在某些情况下（如 ElementType 自身有一个成员也叫 ElementType） //无法正确解析析构函数调用的问题。 typedef ElementType DestructItemsElementTypeTypedef; //显式调用对象的析构函数，通过 typedef 确保析构函数调用的语法正确。 Element-\u0026gt;DestructItemsElementTypeTypedef::~DestructItemsElementTypeTypedef(); } } 该函数针对类型 T 进行了优化，不会动态分派析构函数调用（如果 T 的析构函数是虚函数）。\nTop 返回顶部元素，即最后一个。\n1 2 3 4 5 6 7 8 9 FORCEINLINE ElementType\u0026amp; Top() UE_LIFETIMEBOUND { return Last(); } FORCEINLINE const ElementType\u0026amp; Top() const UE_LIFETIMEBOUND { return Last(); } Last 返回数组中从末尾开始计数的第 n 个元素.\nIndexFromTheEnd（可选）索引从数组的末尾（默认= 0）\n1 2 3 4 5 6 7 8 FORCEINLINE ElementType\u0026amp; Last(SizeType IndexFromTheEnd = 0) UE_LIFETIMEBOUND { RangeCheck(ArrayNum - IndexFromTheEnd - 1); return GetData()[ArrayNum - IndexFromTheEnd - 1]; } //获取倒数第二个元素 int\u0026amp; secondLastElement = MyArray.Last(1); Sort 假设项类型定义了 \u0026lt; 运算符，对数组进行排序。\n注意：\n如果你的数组包含原始指针，它们将在排序过程中自动解引用。 因此，你的数组将根据被指向的值进行排序，而不是指针本身的值。 如果这不是你想要的行为，请直接使用 Algo::Sort(MyArray)。 自动解引用行为不会发生在智能指针上。 1 2 3 4 void Sort() { Algo::Sort(*this, TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;(TLess\u0026lt;\u0026gt;())); } Algo::Sort传入了*this 和 一个谓词TDereferenceWrapper\nTDereferenceWrapper又传入了 ElementType 和 TLess\u0026lt;\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Pass through for non-pointer types */ FORCEINLINE bool operator()(T\u0026amp; A, T\u0026amp; B) { return Predicate(A, B); } FORCEINLINE bool operator()(const T\u0026amp; A, const T\u0026amp; B) const { return Predicate(A, B); } }; template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper\u0026lt;T*, PREDICATE_CLASS\u0026gt; { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Dereference pointers */ FORCEINLINE bool operator()(T* A, T* B) const { return Predicate(*A, *B); } }; TLess\u0026lt;\u0026gt;只是个比大小的仿函数，重载了()运算符 进行比大小\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;\u0026gt; struct TLess\u0026lt;void\u0026gt; { template \u0026lt;typename T, typename U\u0026gt; FORCEINLINE bool operator()(T\u0026amp;\u0026amp; A, U\u0026amp;\u0026amp; B) const { return Forward\u0026lt;T\u0026gt;(A) \u0026lt; Forward\u0026lt;U\u0026gt;(B); } }; TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;` 下面简称为`TD 在TD里面，此时 T = ElementType，PREDICATE_CLASS = TLess\u0026lt;\u0026gt;\n并且把TLess\u0026lt;\u0026gt;存到一个Predicate变量里面。\nTD 也重载了()运算符，在里面执行Predicate的()运算符，\n此时Predicate是TLess\u0026lt;\u0026gt;类型，所以\nTD(A,B)-\u0026gt;TLess(A,B)-\u0026gt;比大小\n那么A和B是从哪来的？再深入分析下去就看不懂了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Sort() { Algo::Sort(*this, TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;(TLess\u0026lt;\u0026gt;())); } //Algo::Sort template \u0026lt;typename RangeType, typename PredicateType\u0026gt; FORCEINLINE void Sort(RangeType\u0026amp;\u0026amp; Range, PredicateType Pred) { IntroSort(Forward\u0026lt;RangeType\u0026gt;(Range), MoveTemp(Pred)); } template \u0026lt;typename RangeType, typename PredicateType\u0026gt; FORCEINLINE void IntroSort(RangeType\u0026amp;\u0026amp; Range, PredicateType Predicate) { AlgoImpl::IntroSortInternal(GetData(Range), GetNum(Range), FIdentityFunctor(), MoveTemp(Predicate)); } TDereferenceWrapper的特化 抛开A、B不谈，这个Sort是怎么回事，为什么要如此复杂的层层包装，\n一个括号运算符重载 套了 另一个括号运算符的重载，怎么会这样？\nTDereferenceWrapper 的注释是:在排序函数中解引用指针类型的帮助类\n1 Algo::Sort(ArrayInt, TLess\u0026lt;\u0026gt;()); 这里直接使用了默认的 TLess\u0026lt;\u0026gt; 比较器。 TLess\u0026lt;\u0026gt; 使用标准的 \u0026lt; 运算符进行比较。 适用于非指针类型（如 int, float, 自定义类等） 或智能指针（如 std::shared_ptr, std::unique_ptr），这些类型的比较不需要额外的解引用操作。 如果对 TArray\u0026lt;int*\u0026gt; 进行TLess排序，排序将基于指针本身的内存地址，而不是指针所指向的整数值。\n这就和期望不符合，要的是对int排序，实际上却对int*排序了，排序对象不是值 而是指针。\n1 Algo::Sort(ArrayInt, TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;(TLess\u0026lt;\u0026gt;())); 这里使用了 TDereferenceWrapper 来包裹 TLess\u0026lt;\u0026gt;。\nTDereferenceWrapper 会根据元素类型的不同行为有所不同：\n如果元素是指针类型（如 int*），则会自动解引用指针，使得排序基于指针所指向的实际值。\n如果元素是非指针类型，则直接使用 \u0026lt; 运算符进行比较。\n既然它能够根据 指针类型 或 非指针类型 随机应变，那么它是如何实现的？\n它会根据TArray存放的元素类型ElementType 进行偏特化，\n如果ElementType是int，那么就选取下方代码中的 第一个模板类.\n如果ElementType是int*，那么就选取下方代码中的 第二个模板类.\n第二个模板类是一个偏特化，当传入的T是一个T*样式的指针时，第二个模板类就会被选择.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Pass through for non-pointer types */ FORCEINLINE bool operator()(T\u0026amp; A, T\u0026amp; B) { return Predicate(A, B); } FORCEINLINE bool operator()(const T\u0026amp; A, const T\u0026amp; B) const { return Predicate(A, B); } }; template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper\u0026lt;T*, PREDICATE_CLASS\u0026gt; { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Dereference pointers */ FORCEINLINE bool operator()(T* A, T* B) const { return Predicate(*A, *B); } }; 第二个模板类的括号运算符重载，对A、B进行了解引用。\n到此就真相大白了，原来是这么设计的，\n在编译时就根据TArray存放的数据类型 选择合适的模板类进行排序。\n根据 指针类型/非指针类型，TDereferenceWrapper从下面的两条路径里选择:\nTD(A,B) \u0026mdash;\u0026gt;TLess(A,B)\u0026mdash;\u0026gt; 比大小 TD(*A,*B) \u0026mdash;\u0026gt; TLess(A,B)\u0026mdash;\u0026gt;比大小\nFind 两个版本，\n1.传入元素和索引，判断 索引处的元素 = 传入的元素\n2.传入元素，遍历查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 FORCEINLINE bool Find(const ElementType\u0026amp; Item, SizeType\u0026amp; Index) const { Index = this-\u0026gt;Find(Item); return Index != INDEX_NONE; } SizeType Find(const ElementType\u0026amp; Item) const { // 返回指向第一个数组条目的指针 const ElementType* RESTRICT Start = GetData(); // 遍历数组，查找指定元素 for (const ElementType* RESTRICT Data = Start, *RESTRICT DataEnd = Data + ArrayNum; Data != DataEnd; ++Data) { if (*Data == Item) { return static_cast\u0026lt;SizeType\u0026gt;(Data - Start); } } return INDEX_NONE; } 在Engine\\Source\\Runtime\\Core\\Public\\Misc\\CoreMiscDefines.h中 有定义\n1 enum {INDEX_NONE= -1}; 所以查找失败时 返回-1.\nRESTRICT Engine\\Source\\Runtime\\Core\\Public\\HAL\\Platform.h\n1 #define RESTRICT __restrict 类型限定符，用于指针声明，表示该指针是唯一指向其目标对象的指针。\n当能确保某个指针不会与其他指针指向同一块内存时，\n可以使用 __restrict 来帮助编译器生成更高效的代码。这在循环和函数参数传递中特别有用，\n因为这些地方通常涉及大量的内存访问操作。\n1 2 3 4 5 void foo(int *__restrict p, int *__restrict q) { *p = 5; // 编译器知道 p 和 q 指向不同的对象 *q = 10; } __restrict 告诉编译器指针 p 和 q 不会指向同一块内存区域。\n因此，编译器可以假设对 *p 和 *q 的修改不会相互影响，从而进行更多的优化，例如重排序指令或减少不必要的内存屏障。\n1 2 3 4 5 6 7 void processArrays(int *__restrict a, int *__restrict b, int *__restrict c, size_t n) { for (size_t i = 0; i \u0026lt; n; ++i) { a[i] = b[i] + c[i]; } } __restrict 关键字告诉编译器：\na、b 和 c 指向的内存区域互不重叠。 因此，编译器可以假设对 a[i]、b[i] 和 c[i] 的访问不会互相干扰。 总结:\n**__restrict** 关键字：用于指示编译器优化内存访问，告诉编译器指针不会指向相同的内存区域。 作用：允许编译器进行更多的优化，如指令重排和向量化，从而提高代码性能。 注意事项：确保指针确实不会指向相同的内存区域，否则可能导致未定义行为。 FindByPredicate 1 2 3 4 5 6 7 8 9 10 11 12 13 class TGetValue { public: bool operator()(int x) { return x%2 ==0; } }; TArray\u0026lt;int\u0026gt; ArrayInt; ArrayInt = {2,3,5,7,50}; auto FindValue = *ArrayInt.FindByPredicate([](int x){return x==2;}); auto FindValue2 = *ArrayInt.FindByPredicate(TGetValue()); 自定义匹配方法，可以传入仿函数、lambda函数 等等..\n总之就是遍历TArray中的元素，执行传入的谓词，如果谓词的结果为true 则if(true) 返回Data.\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename Predicate\u0026gt; ElementType* FindByPredicate(Predicate Pred) { for (ElementType* RESTRICT Data = GetData(), *RESTRICT DataEnd = Data + ArrayNum; Data != DataEnd; ++Data) { if (::Invoke(Pred, *Data)) { return Data; } } return nullptr; } Invoke 用于统一调用不同类型的可调用对象（如普通函数指针、lambda 表达式、成员函数指针等）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //通用可调用对象 template \u0026lt;typename FuncType, typename... ArgTypes\u0026gt; FORCEINLINE auto Invoke(FuncType\u0026amp;\u0026amp; Func, ArgTypes\u0026amp;\u0026amp;... Args) -\u0026gt; decltype(Forward\u0026lt;FuncType\u0026gt;(Func)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...)) { return Forward\u0026lt;FuncType\u0026gt;(Func)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...); } //成员变量访问 template \u0026lt;typename ReturnType, typename ObjType, typename TargetType\u0026gt; FORCEINLINE auto Invoke(ReturnType ObjType::*pdm, TargetType\u0026amp;\u0026amp; Target) -\u0026gt; decltype(UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*pdm) { return UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*pdm; } //成员函数调用 template \u0026lt; typename PtrMemFunType, typename TargetType, typename... ArgTypes, typename ObjType = TMemberFunctionPtrOuter_T\u0026lt;PtrMemFunType\u0026gt; \u0026gt; FORCEINLINE auto Invoke(PtrMemFunType PtrMemFun, TargetType\u0026amp;\u0026amp; Target, ArgTypes\u0026amp;\u0026amp;... Args) -\u0026gt; decltype((UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*PtrMemFun)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...)) { return (UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*PtrMemFun)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...); } 三种形态，分别是 通用可调用对象、成员变量访问、成员函数调用\n在前面的例子中，FindByPredicate传入了一个lambda表达式 ，又测试了重载了括号运算符的仿函数类.\n这些情况都是通过第一个版本 通用可调用对象 进行调用的.\nForward 1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;typename T\u0026gt; UE_INTRINSIC_CAST FORCEINLINE constexpr T\u0026amp;\u0026amp; Forward(std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp; Obj) noexcept { return (T\u0026amp;\u0026amp;)Obj; } template \u0026lt;typename T\u0026gt; UE_INTRINSIC_CAST FORCEINLINE constexpr T\u0026amp;\u0026amp; Forward(std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp; Obj) noexcept { return (T\u0026amp;\u0026amp;)Obj; } 完美转发\n用于在函数调用过程中保留参数的值类别（value category），即保持参数是左值还是右值的特性。\n这使得函数可以将参数“完美”地转发给其他函数，而不会引入不必要的拷贝或转换。\n左值引用：当传入左值时，Forward 返回左值引用。 右值引用：当传入右值时，Forward 返回右值引用。 万能引用 T\u0026amp;\u0026amp;\n根据传入的参数类型推导为左值引用或右值引用。\n1 2 3 4 template \u0026lt;typename T\u0026gt; void foo(T\u0026amp;\u0026amp; param) { // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; void process(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename Func, typename... Args\u0026gt; void wrapper(Func\u0026amp;\u0026amp; func, Args\u0026amp;\u0026amp;... args) { // 使用 std::forward 进行完美转发 std::forward\u0026lt;Func\u0026gt;(func)(std::forward\u0026lt;Args\u0026gt;(args)...); } int main() { int value = 42; // 左值 //std::forward\u0026lt;int\u0026amp;\u0026gt;(value) 将 value 作为左值引用转发给 process。 wrapper(process, value); // 右值 //std::forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(100) 将 100 作为右值引用转发给 process。 wrapper(process, 100); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;memory\u0026gt; class MyClass { public: template \u0026lt;typename... Args\u0026gt; static std::unique_ptr\u0026lt;MyClass\u0026gt; create(Args\u0026amp;\u0026amp;... args) { return std::make_unique\u0026lt;MyClass\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } private: MyClass(int x, double y) : x_(x), y_(y) {} int x_; double y_; }; int main() { auto obj1 = MyClass::create(10, 3.14); // 右值 int a = 20; auto obj2 = MyClass::create(a, 2.71); // 左值 return 0; } create 函数是一个工厂函数，接受任意数量的参数并使用 std::make_unique 创建 MyClass 对象。 使用 std::forward\u0026lt;Args\u0026gt;(args)... 来完美转发构造参数，确保它们的值类别得以保留。 Reserve 保留内存，使数组至少可以包含Number元素。\nNumber-分配后数组应该能够包含的元素数量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 FORCEINLINE void Reserve(SizeType Number) { checkSlow(Number \u0026gt;= 0); if (Number \u0026lt; 0) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)Number); } else if (Number \u0026gt; ArrayMax) { ResizeTo(Number); } } Init 设置数组的大小，用给定的元素填充它。\nElement-用来填充数组的元素。\nNumber-分配后数组应该能够包含的元素数量。\n1 2 3 4 5 6 7 8 void Init(const ElementType\u0026amp; Element, SizeType Number) { Empty(Number); for (SizeType Index = 0; Index \u0026lt; Number; ++Index) { Add(Element); } } 其它函数 TOptional Why TOptional is my new favourite tool\nTOptional主要功能:\n表示存在或不存在的值。\n提供类型安全的方式来处理可能缺失的值。\n提供丰富的操作接口来检查是否有值、获取值以及处理没有值的情况。\n类似于C++标准库中的 std::optional。它用于表示一个值可能存在或不存在的状态。TOptional 提供了一种安全且类型安全的方式来处理可选值，避免了使用原始指针或特殊标记值（如 -1 或 nullptr）来表示缺失值的常见问题。\n零额外内存开销: TOptional 的大小与 TArray 相同，无需存储额外状态标志。\n侵入式操作高效性:\t直接通过 TArray 内部字段标记状态，无运行时性能损失。\n类型安全:\t仅允许 TOptional 通过友元访问 FIntrusiveUnsetOptionalState 构造函数。\nTArray 中的侵入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 FIntrusiveUnsetOptionalState是一个用于侵入式数据结构的辅助工具类，主要目的是管理数据结构中元素的可选状态标记。 // 静态标记，告知 TOptional 此类型（TArray）支持侵入式未设置状态。 constexpr static bool bHasIntrusiveUnsetOptionalState = true; //指定用于标记的类型（此处为 TArray 自身）。 using IntrusiveUnsetOptionalStateType = TArray; //创建一个特殊状态的 TArray，通过 ArrayMax = -1 表示未初始化。 explicit TArray(FIntrusiveUnsetOptionalState Tag) : ArrayNum(0) , ArrayMax(-1) { // 使用 ArrayMax = -1 标记未设置状态 // Use ArrayMax == -1 as our intrusive state so that the destructor still works without change, as it doesn\u0026#39;t use ArrayMax. } // 允许 TOptional 检查 TArray 是否处于未设置状态。 bool operator==(FIntrusiveUnsetOptionalState Tag) const { return ArrayMax == -1; } 使用举例1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //声明一个未设置的 TOptional\u0026lt;TArray\u0026gt; TOptional\u0026lt;TArray\u0026lt;int32\u0026gt;\u0026gt; OptionalArray; // 检查是否未设置 if (!OptionalArray.IsSet()) { // 输出：未初始化 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;OptionalArray is unset.\u0026#34;)); } // 赋值一个有效的 TArray OptionalArray = TArray\u0026lt;int32\u0026gt;{1, 2, 3}; // 检查状态 if (OptionalArray.IsSet()) { // 输出：元素数量为3 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Element count: %d\u0026#34;), OptionalArray-\u0026gt;Num()); } 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026#34;Misc/Optional.h\u0026#34; #include \u0026#34;UObject/ObjectMacros.h\u0026#34; void ExampleUsageOfTOptional() { // 定义一个 TOptional\u0026lt;int\u0026gt; TOptional\u0026lt;int\u0026gt; optionalInt; // 初始化为有值 TOptional\u0026lt;int\u0026gt; optionalIntWithValue = 42; if (optionalIntWithValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithValue has a value: %d\u0026#34;), optionalIntWithValue.GetValue()); } // 初始化为无值 TOptional\u0026lt;int\u0026gt; optionalIntWithoutValue = TOptional\u0026lt;int\u0026gt;(); if (!optionalIntWithoutValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithoutValue does not have a value\u0026#34;)); } // 使用 GetValueOr 提供默认值 int defaultValue = optionalIntWithoutValue.GetValueOr(0); UE_LOG(LogTemp, Log, TEXT(\u0026#34;DefaultValue is: %d\u0026#34;), defaultValue); // 重置为无值状态 optionalIntWithValue.Reset(); if (!optionalIntWithValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithValue has been reset and does not have a value\u0026#34;)); } // 设置新值 optionalIntWithValue = 10; if (optionalIntWithValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithValue now has a new value: %d\u0026#34;), optionalIntWithValue.GetValue()); } } GetData GetData 返回指向第一个数组条目的指针，如果ArrayMax == 0，则返回指向nullptr的指针。\n以下文本中 函数的解释顺序 就是 函数的调用顺序.\nGetData()-\u0026gt;GetAllocation()-\u0026gt;GetAllocation()\n1 2 3 4 FORCEINLINE ElementType* GetData() UE_LIFETIMEBOUND { return (ElementType*)AllocatorInstance.GetAllocation(); } 这个函数通过调用 AllocatorInstance.GetAllocation() 获取分配的内存块，\n并将其转换为 ElementType* 类型，从而返回指向数组数据的指针。\n1 2 3 4 FORCEINLINE ElementType* GetAllocation() const { return (ElementType*)ForAnyElementType::GetAllocation(); } GetAllocation 函数是 AllocatorInstance 的成员函数，负责返回实际分配的内存块。\n在这个函数中，ForAnyElementType::GetAllocation() 被调用来获取实际的内存块，\n并将其转换为 ElementType* 类型。\n最终，ForAnyElementType::GetAllocation() 调用了另一个 GetAllocation 函数：\n1 2 3 4 5 6 7 8 9 FORCEINLINE FScriptContainerElement* GetAllocation() const { return Data; } //----------------------// /** A type which is used to represent a script type that is unknown at compile time. */ struct FScriptContainerElement {}; FScriptContainerElement* Data; 这里的 Data 是一个指向 FScriptContainerElement 类型的指针.\nFScriptContainerElement 是一个空结构体，主要用于表示一种在编译时未知的具体类型。\n总结: GetData()最终返回的是一个Data\n1 2 3 4 5 6 7 8 9 10 +-------------------+ | MyArray | +-------------------+ | AllocatorInstance| | +---------------+| | | Data |---\u0026gt; [10, 20, 30] (指向实际存储元素的内存块) | +---------------+| | ArrayNum: 3 | | ArrayMax: 4 | +-------------------+ Data 是 AllocatorInstance 中的一个成员变量，指向实际存储数组元素的内存块。\n这个内存块通常是在堆上分配的，并且由 AllocatorInstance 进行管理。\nGetData() 函数会通过 AllocatorInstance.GetAllocation() 返回 Data 指针，\n即指向 [10, 20, 30] 这个内存块的首地址。\nGetTypeSize 1 2 3 4 FORCEINLINE static constexpr uint32 GetTypeSize() { return sizeof(ElementType); } ElementType就是TArray中的int32，相当于sizeof(int32)\nGetSlack 返回此数组中的闲置数量。\n1 2 3 4 FORCEINLINE SizeType GetSlack() const { return ArrayMax - ArrayNum; } CheckInvariants 1 2 3 4 FORCEINLINE void CheckInvariants() const { checkSlow((ArrayNum \u0026gt;= 0) \u0026amp; (ArrayMax \u0026gt;= ArrayNum)); // \u0026amp; for one branch } 使用了按位与操作符 \u0026amp; 而不是逻辑与操作符 \u0026amp;\u0026amp;，目的是为了确保两个条件都在同一分支中被评估，\n即使第一个条件为假也不会短路跳过第二个条件。\n虽然在这个上下文中两者的效果是相同的，但按位与可以确保所有条件都被检查到。\n**CheckInvariants 函数：**用于验证 TArray 的内部状态是否合法，确保 ArrayNum 和 ArrayMax 满足基本的约束条件。\n**目的：**通过这些检查，可以在开发过程中捕获潜在的错误，如非法的状态设置或数组管理不当，从而提高代码的健壮性和可靠性。\n**性能考虑：**使用 checkSlow 宏确保这些检查只在调试版本中生效，在发布版本中被优化掉，以避免不必要的性能开销。\nRangeCheck 检查index是否在数组范围内。\n1 2 3 4 5 6 7 8 9 10 FORCEINLINE void RangeCheck(SizeType Index) const { CheckInvariants(); // Template property, branch will be optimized out if constexpr (AllocatorType::RequireRangeCheck) { checkf((Index \u0026gt;= 0) \u0026amp; (Index \u0026lt; ArrayNum),TEXT(\u0026#34;Array index out of bounds: %lld into an array of size %lld\u0026#34;),(long long)Index, (long long)ArrayNum); // \u0026amp; for one branch } } AllocatorType::RequireRangeCheck\n在默认的情况下，AllocatorType是TSizedHeapAllocator\nTSizedHeapAllocator::RequireRangeCheck = true.\n1 2 3 4 5 6 7 8 9 template \u0026lt;int IndexSize, typename BaseMallocType = FMemory\u0026gt; class TSizedHeapAllocator { //.............. public: enum { NeedsElementType = true }; enum { RequireRangeCheck = true }; //.............. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //*检查指定下标范围是否在数组范围内。 //* //* @param Index要检查的范围起始位置的索引。 //* @param Count范围中元素的数量。 FORCEINLINE void RangeCheck(SizeType Index, SizeType Count) const { CheckInvariants(); // Template property, branch will be optimized out if constexpr (AllocatorType::RequireRangeCheck) { checkf((Count \u0026gt;= 0) \u0026amp; (Index \u0026gt;= 0) \u0026amp; (Index + Count \u0026lt;= ArrayNum), TEXT(\u0026#34;Array range out of bounds: index %lld and length %lld into an array of size %lld\u0026#34;), (long long)Index, (long long)Count, (long long)ArrayNum); // \u0026amp; for one branch } } IsValidIndex 测试index是否有效，即大于或等于0，小于数组中的元素数量。\n1 2 3 4 FORCEINLINE bool IsValidIndex(SizeType Index) const { return Index \u0026gt;= 0 \u0026amp;\u0026amp; Index \u0026lt; ArrayNum; } NumBytes SIZE_T，这是一个无符号整数类型，通常用于表示内存大小。\n1 2 3 4 5 6 7 /** @returns Number of bytes used, excluding slack */ FORCEINLINE SIZE_T NumBytes() const { return static_cast\u0026lt;SIZE_T\u0026gt;(ArrayNum) * sizeof(ElementType); //将 ArrayNum 转换为 SIZE_T 类型， //以确保与 sizeof(ElementType) 的乘积结果是 SIZE_T 类型，避免潜在的溢出问题。 } 计算数组当前使用的字节数，不包括未使用的额外空间（即所谓的“松弛”或“slack”）。\n这个函数对于了解数组的实际内存占用非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 TArray\u0026lt;int\u0026gt; MyArray; MyArray.Add(10); MyArray.Add(20); MyArray.Add(30); // 计算当前使用的字节数 SIZE_T bytesUsed = MyArray.NumBytes(); //NumBytes的计算过程 bytesUsed = static_cast\u0026lt;SIZE_T\u0026gt;(3) * sizeof(int); // 假设 sizeof(int) == 4 bytesUsed = 3 * 4; bytesUsed = 12; // 当前使用的字节数是 12 字节 GetAllocatedSize 返回容器分配的大小.\n1 2 3 4 5 6 7 8 9 FORCEINLINE SIZE_T GetAllocatedSize(void) const { return AllocatorInstance.GetAllocatedSize(ArrayMax, sizeof(ElementType)); } SIZE_T GetAllocatedSize(SizeType CurrentMax, SIZE_T NumBytesPerElement) const { return CurrentMax * NumBytesPerElement; } SIZE_T，这是一个无符号整数类型，通常用于表示内存大小。\n重载[] 访问数组中指定索引处的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Array bracket operator. Returns reference to element at given index. * * @returns Reference to indexed element. */ FORCEINLINE ElementType\u0026amp; operator[](SizeType Index) UE_LIFETIMEBOUND { RangeCheck(Index); return GetData()[Index]; } FORCEINLINE void RangeCheck(SizeType Index) const { CheckInvariants(); // Template property, branch will be optimized out if constexpr (AllocatorType::RequireRangeCheck) { checkf((Index \u0026gt;= 0) \u0026amp; (Index \u0026lt; ArrayNum),TEXT(\u0026#34;Array index out of bounds: %lld into an array of size %lld\u0026#34;),(long long)Index, (long long)ArrayNum); // \u0026amp; for one branch } } GetData 返回指向数组数据的指针，即实际存储数组元素的内存块的首地址。\n通过 GetData()[Index] 访问指定索引处的元素。\nUE_LIFETIMEBOUND 宏 用于 静态代码分析 的注解宏，其核心作用是标记函数返回的指针或引用 依赖于某个对象的生命周期，帮助开发者避免悬垂指针（Dangling Pointer）错误。\n编译警告/错误： 若返回的指针/引用的生命周期超出其依赖对象，静态分析工具（如 UE 的静态分析器或 Clang/GCC 的警告）会发出警告。 文档提示： 代码阅读者可以直观看出返回值需要谨慎处理生命周期。 该属性主要用于帮助静态分析工具检测潜在的生命周期问题。虽然它不会直接影响编译行为，但可以帮助开发者发现潜在的错误。 然而，过度使用可能会使代码变得冗长，因此需要合理使用。 宏定义在:\nEngine/Source/Runtime/Core/Public/MSVC/MSVCPlatform.h\nEngine/Source/Runtime/Core/Public/Clang/ClangPlatform.h\n1 2 3 4 5 6 7 8 #ifdef __has_cpp_attribute #if __has_cpp_attribute(msvc::lifetimebound) #define UE_LIFETIMEBOUND [[msvc::lifetimebound]] #endif #endif //---------------// #define UE_LIFETIMEBOUND [[clang::lifetimebound]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FContainer { public: int32* GetData() UE_LIFETIMEBOUND { return Data; // 返回指针，生命周期依赖 FContainer 实例 } private: int32* Data; }; void Test() { int32* Ptr; { FContainer Container; Ptr = Container.GetData(); // 警告：Ptr 的生命周期超出 Container } *Ptr = 42; // 危险！悬垂指针 } 函数接受一个引用类型的参数，并希望确保该引用在其整个生命周期内都是有效的\n1 2 3 4 void ProcessObject([[msvc::lifetimebound]] const MyClass\u0026amp; obj) { // 处理对象 } [[msvc::lifetimebound]] 标记了 obj 参数，表示该引用在其生命周期内应保持有效。\n如果编译器或静态分析工具检测到 obj 的生命周期可能超出其有效范围，会发出相应的警告或错误。\n对于返回值也可以使用 [[msvc::lifetimebound]] 来标记生命周期边界\n1 2 3 4 5 [[msvc::lifetimebound]] MyClass\u0026amp; GetObject() { static MyClass instance; return instance; } GetObject 返回一个静态对象的引用，并且使用 [[msvc::lifetimebound]] 标记返回值，确保返回的引用在其整个生命周期内都是有效的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; class MyClass { public: MyClass(int v) : value(v) {} void PrintValue() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } private: int value; }; // 使用 [[msvc::lifetimebound]] 标记函数参数 void ProcessObject([[msvc::lifetimebound]] const MyClass\u0026amp; obj) { obj.PrintValue(); } int main() { MyClass obj(42); ProcessObject(obj); // 正确使用，obj 在 ProcessObject 调用期间有效 // 下面的代码会导致悬空引用，静态分析工具可能会发出警告 // MyClass* ptr = new MyClass(100); // ProcessObject(*ptr); // delete ptr; // obj 已经被删除，ProcessObject 中的引用无效 return 0; } ","date":"2000-01-21T23:31:36+08:00","permalink":"http://localhost:1313/p/tarray/","title":"TArray"},{"content":"https://ue5wiki.com/\nUObject 反射系统 反射文档 反射知识库\nC++ 编译为 CPU 机器码，而 CPU 并不了解类或变量的概念。类只是为编译器提供如何设置 CPU 代码的信息，变量最终只转化为内存地址，因此CPU并不知道类的存在，这些信息是由软件自身来跟踪的。在 UE 中，这是通过反射系统实现的，所以你的代码可以“反映”其自身。\nUE4 拥有一个特别的工具叫做 UnrealHeaderTool，它收集你创建的那些宏，比如 UPROPERTY、UCLASS、USTRUCT，并生成额外的 C++ 代码，这些代码将类、函数和属性注册到反射系统中，这样引擎就能识别这些元素并跟踪它们。反射系统注册表中的每个元素都有一个对应的 UField 对象被创建，用来表示代码中的事物并存储有关它的信息。每个UObject类都有一个UClass对象，你可以通过调用GetClass()或StaticClass()来获取这个对象\nCDO 它的主要功能是存储类对象的默认状态并保存默认变量状态。在 C++ 中创建的每个标有 UCLASS() 的 UObject 类都会注册到反射系统。\n在C++创建一个Actor \u0026ndash;\u0026gt; AXActor，int32 K = 1 , 但是在构造函数里重新赋值 K=2，那么它的默认对象(CDO)的值就是2，\n1 2 3 4 UClass* XActor = AXActorStaticClass(); Uobject* XAObj = XActor-\u0026gt;GetDefaultObject(); AXACtor* CDO = Cast\u0026lt;AXActor\u0026gt;(XAObj); //CDO-\u0026gt;K 得到的值是2 1 StaticClass\u0026lt;UObject\u0026gt;` 或者 `UObject::StaticClass() 当UClass的 类默认对象（CDO）更改，引擎将尝试在加载类的所有实例时对这些实例应用这些更改。对于给定Object实例，如果 更新的变量值 与 旧CDO中的值 相匹配，则将更新为它在新CDO中保存的值。如果变量包含任何其他值，系统会假设这个值是故意设置的，这些更改将会被保留。\n例如，假设你在一个关卡中放置了多个 AEnemy Object并保存，然后将 AEnemy 构造函数中的默认Health值设置为100。再假设将Enemy_3的Health值设置为500，因为它们特别难对付。现在，假设你改变注意了，将Health的默认值增加到150。下次加载关卡时，虚幻意识到你更改了CDO，并将使用旧默认Health值（100）的所有AEnemy实例更新为使用Health值150。Enemy_3的Health将保持在500，因为它不使用旧的默认值。\n因为构造函数是在引擎和对象自身的初始化早期阶段调用的，你不应该在其中执行任何游戏逻辑代码，否则很可能会导致崩溃。你应该使用类中的其他事件，如PostInitProperties（在蓝图系统对对象所做的更改应用后调用）、PostInitComponents（在Actor中的组件被初始化后调用）或BeginPlay（当Actor被完全初始化时）。请注意，前两个事件也在你将Actor放置在关卡编辑器时被调用。\n总结来说，CDO的主要作用是在引擎中保持类的默认状态，使得即使是在C++中，也可以方便地获取到类的默认属性和行为。由于CDO是在引擎初始化期间创建的，因此在这个时候调用构造函数可能会导致不稳定的行为，所以开发者应该避免在构造函数中进行依赖于其他尚未初始化对象的操作。\n反射宏 其实 GENERATED_BODY 与GENERATED_UCLASS_BODY的区别在于：GENERATED_BODY声明并定义 了一个接收 const FObjectInitializer\u0026amp; 的构造函数，GENERATED_UCLASS_BODY只声明 了该构造函数，需要用户自己提供一个定义。\n核心 容器 特性 TArray TMap TSet 存储方式 连续内存 哈希表（键值对） 哈希表（唯一元素） 重复元素 允许 键唯一，值可重复 元素唯一 查找效率 O(n)（线性搜索） O(1)（平均） O(1)（平均） 插入/删除效率 末尾高效，中间低效 O(1)（平均） O(1)（平均） 内存占用 紧凑 较高（哈希表开销） 较高（哈希表开销） 典型场景 顺序访问、排序、随机访问 键值映射、快速键查找 唯一元素集合、存在性检查 实现:\n容器类型 UE 实现 STL 实现 特点 TArray 动态数组（类似 std::vector） std::vector 连续内存，支持快速随机访问，预分配内存优化。 TSet 哈希表（开放寻址法） std::unordered_set 使用线性探测解决冲突，内存紧凑，缓存友好。 TMap 哈希表（开放寻址法） std::unordered_map 类似 TSet，存储键值对，支持快速查找。 TMultiMap 哈希表（链地址法） std::unordered_multimap 支持重复键，链地址法解决冲突。 UE 不使用红黑树的原因\n性能考量： 哈希表的平均时间复杂度为 O(1)，而红黑树为 O(log N)。在游戏开发中，高频查找场景更倾向于哈希表。 内存布局： 开放寻址哈希表的内存连续，利于缓存命中，适合数据密集型操作。 用途:\n容器 适用场景 示例 TArray 需要快速随机访问、顺序遍历或堆栈式操作的数据集合 玩家背包物品列表、技能释放队列 TSet 需要快速查找唯一元素、不关心顺序的集合 玩家已解锁的成就集合、场景中激活的触发器列表 TMap 需要键值对映射、通过键快速查找值的场景 玩家属性表（键：属性名，值：数值）、NPC对话选项映射 TArray:\n1 2 3 4 5 6 7 8 9 10 11 // 存储需要频繁遍历的粒子系统实例 TArray\u0026lt;UParticleSystemComponent*\u0026gt; ActiveParticles; // 每帧遍历更新 for (auto\u0026amp; Particle : ActiveParticles) { Particle-\u0026gt;Tick(deltaTime); } // 实现优先级队列（见后文与二叉堆关系） TArray\u0026lt;int32\u0026gt; PriorityQueue; PriorityQueue.HeapPush(5, FGreater\u0026lt;int32\u0026gt;()); TSet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 存储玩家已收集的唯一道具ID TSet\u0026lt;FName\u0026gt; CollectedItemIDs; if (!CollectedItemIDs.Contains(NewItemID)) { CollectedItemIDs.Add(NewItemID); } // 快速判断敌人是否在警戒列表 TSet\u0026lt;AEnemy*\u0026gt; AlertedEnemies; if (AlertedEnemies.Contains(TargetEnemy)) { TriggerAlarm(); } TMap:\n1 2 3 4 5 6 7 8 // 存储玩家技能冷却时间 TMap\u0026lt;FName, float\u0026gt; SkillCooldowns; SkillCooldowns.Add(\u0026#34;Fireball\u0026#34;, 5.0f); float* Cooldown = SkillCooldowns.Find(\u0026#34;Fireball\u0026#34;); // 本地化文本映射 TMap\u0026lt;FString, FText\u0026gt; LocalizedTexts; FText WelcomeText = LocalizedTexts[\u0026#34;Welcome\u0026#34;]; 举例来说，如果需要保持一列特有元素并需要经常添加、移除或搜索它们，那么可以使用TArray这个容器，但实际上TSet是一个更好的选择。\nTArray TArray优化\nTArray 的堆操作不是线程安全的，多线程环境下需手动加锁。\nUObject管理\nUObject 是 UE 中所有游戏对象的基类（如 AActor、UActorComponent），其生命周期由 垃圾回收 系统自动管理，核心机制如下：\n(1) 引用计数与可达性分析\n根对象（Roots）：通过 UPROPERTY() 标记的引用、全局对象等被视为“根”，不会被回收。 引用链追踪：GC 定期从根对象出发，标记所有可达对象，未被标记的对象会被回收。 托管对象：所有 UObject 派生类实例必须由 UE 引擎创建（通过 NewObject 或 CreateDefaultSubobject）。 (2) TArray 对 UObject 的管理\n当 TArray 存储 UObject 指针时，需显式声明引用关系以确保 GC 正确工作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 UCLASS() class MyActor : public AActor { GENERATED_BODY() public: UPROPERTY() // 必须标记 UPROPERTY()，否则 GC 可能误回收 TArray\u0026lt;UMyObject*\u0026gt; MyObjects; // 存储 UObject 指针 }; void AMyActor::ManageObjects() { UMyObject* Obj = NewObject\u0026lt;UMyObject\u0026gt;(this); // 创建对象 MyObjects.Add(Obj); // 添加引用 MyObjects.RemoveAt(0); // 移除引用（若对象不再被引用，可能被 GC 回收） } 规则 说明 UPROPERTY() 标记 容器内的 UObject 指针必须标记 UPROPERTY()，否则 GC 无法追踪引用。 手动销毁限制 禁止直接调用 delete 销毁 UObject，必须由 GC 自动回收。 弱引用 使用 TWeakObjectPtr\u0026lt;UMyObject\u0026gt; 存储弱引用，避免阻止 GC 回收。 生命周期：\n1 2 3 4 5 6 7 8 9 10 // 创建对象 UMyObject* Obj = NewObject\u0026lt;UMyObject\u0026gt;(this); MyObjects.Add(Obj); // Obj 被 MyObjects 引用 // 移除引用 MyObjects.Remove(Obj); // 此时若 Obj 无其他引用，GC 会将其标记为待回收 // 强制触发 GC（调试用） GetWorld()-\u0026gt;ForceGarbageCollection(true); 堆栈式操作\n在 UE 的 TArray 中，“堆栈式操作”指的是支持类似 栈（Stack）数据结构 的后进先出（LIFO）操作。尽管 TArray 本质是动态数组，但它提供了与栈一致的接口，允许开发者在数组末尾高效地添加或移除元素。\nTArray 内部使用连续内存（类似 std::vector），Push/Pop 操作仅需修改数组末尾指针。 这是通过以下方法实现的：\n方法 功能 时间复杂度 示例 Push / Add 在数组末尾添加元素 均摊 O(1) TArray\u0026lt;int\u0026gt; arr; arr.Add(1); Pop 移除并返回数组末尾元素 O(1) int val = arr.Pop(); Top / Last 获取数组末尾元素（不移除） O(1) int val = arr.Last(); Emplace 在末尾直接构造元素（避免拷贝） 均摊 O(1) arr.Emplace(42); 应用场景\n临时数据缓存：如子弹轨迹点、动画状态记录。 撤销/重做系统：将操作记录按栈顺序压入和弹出。 递归算法替代：手动管理调用栈，避免堆栈溢出。 最佳实践\n优先使用 TArray 的栈式接口：简化临时数据管理。 严格标记 UPROPERTY()：避免 UObject 被意外回收。 弱引用与强引用分离：使用 TWeakObjectPtr 管理非所有权引用。 堆栈式操作 与 UObject\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 在 Actor 中定义栈式 UObject 缓存 UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY() TArray\u0026lt;UMyObject*\u0026gt; ObjectStack; // 栈式缓存 void PushObject(UMyObject* Obj) { ObjectStack.Push(Obj); // 引用由 ObjectStack 持有 } UMyObject* PopObject() { if (ObjectStack.Num() == 0) return nullptr; UMyObject* Obj = ObjectStack.Pop(); // 移除引用 return Obj; // 调用者需确保新引用关系，否则 Obj 可能被 GC 回收 } }; 跨帧引用：若从栈中取出 UObject 后未重新建立有效引用（如赋值给 UPROPERTY() 变量），对象可能被 GC 回收。\n线程安全：GC 仅在游戏线程运行，异步操作中需谨慎处理 UObject 指针。\n二叉堆\nTArray 提供了对 二叉堆（Binary Heap） 的原生支持（通过 HeapPush、HeapPop 等方法），这使得 TArray 可以直接用于实现 优先队列（Priority Queue）。\n1. 二叉堆的核心特性\n数据结构：完全二叉树，通过数组（TArray）实现。 性质： 最小堆：父节点的值 \u0026lt;= 子节点的值（堆顶为最小值）。 最大堆：父节点的值 \u0026gt;= 子节点的值（堆顶为最大值）。 操作时间复杂度： 插入（HeapPush）：O(log n) 弹出堆顶（HeapPop）：O(log n) 获取堆顶（HeapTop）：O(1) 2. 使用 TArray 实现堆的优势\n优势 说明 内存高效 连续内存布局，缓存友好，适合高频操作。 内置接口 直接使用 HeapPush/HeapPop，无需手动实现堆调整逻辑。 灵活性 支持自定义比较规则（如按优先级、时间戳、权重排序）。 性能稳定 时间复杂度为 O(log n)，适合实时游戏逻辑。 使用场景与示例:\n(1) AI 行为优先级调度\n场景：AI 需要根据优先级处理多个任务（如“攻击”优先级高于“移动”）。 实现：使用 TArray 作为最小堆，按优先级排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 定义任务结构体 struct FAI_Task { FString Name; int32 Priority; // 优先级（值越小越优先） }; // 自定义比较规则（最小堆） struct FCompareTaskPriority { FORCEINLINE bool operator()(const FAI_Task\u0026amp; A, const FAI_Task\u0026amp; B) const { return A.Priority \u0026lt; B.Priority; } }; // AI 任务队列 TArray\u0026lt;FAI_Task\u0026gt; TaskHeap; // 添加任务 TaskHeap.HeapPush(FAI_Task{\u0026#34;Attack\u0026#34;, 1}, FCompareTaskPriority()); // 高优先级 TaskHeap.HeapPush(FAI_Task{\u0026#34;Move\u0026#34;, 3}, FCompareTaskPriority()); TaskHeap.HeapPush(FAI_Task{\u0026#34;Idle\u0026#34;, 5}, FCompareTaskPriority()); // 执行最高优先级任务 FAI_Task NextTask; TaskHeap.HeapPop(NextTask, FCompareTaskPriority(), false); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Executing task: %s\u0026#34;), *NextTask.Name); // 输出 \u0026#34;Attack\u0026#34; (2) 伤害事件处理队列\n场景：在战斗中，多个伤害事件需要按优先级处理（如“暴击”优先于“普通攻击”）。 实现：使用 TArray 作为最大堆，按伤害值排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 定义伤害事件结构体 struct FDamageEvent { float Damage; AActor* Source; }; // 使用 UE 内置的浮点数比较规则（最大堆） TArray\u0026lt;FDamageEvent\u0026gt; DamageHeap; // 添加伤害事件 DamageHeap.HeapPush({100.0f, Player}, TGreater\u0026lt;FDamageEvent\u0026gt;()); // 暴击 DamageHeap.HeapPush({50.0f, Enemy}, TGreater\u0026lt;FDamageEvent\u0026gt;()); // 处理最高伤害事件 FDamageEvent TopDamage; DamageHeap.HeapPop(TopDamage, TGreater\u0026lt;FDamageEvent\u0026gt;(), false); ApplyDamage(TopDamage.Source, TopDamage.Damage); // 先处理 100 点伤害 委托 示例:\n1 2 3 4 5 DECLARE_DELEGATE_OneParam(FStringDelegate, FString); class FMyClass { FStringDelegate WriteToLogDelegate; }; 乱七八糟 Log 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;, Package-\u0026gt;GetName(), ErrorCode); 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;,(\u0026#34;Name\u0026#34;, Package-\u0026gt;GetName()), (\u0026#34;Error\u0026#34;, ErrorCode),(\u0026#34;Flags\u0026#34;, LoadFlags)); 1 GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT(\u0026#34;This is an Example on-screen debug message.\u0026#34;)); 1 2 3 std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Hello, {}!\\n\u0026#34;, \u0026#34;World\u0026#34;); // std::format printf(\u0026#34;Hello, %s!\\n\u0026#34;, \u0026#34;World\u0026#34;); // printf std::cout \u0026lt;\u0026lt; \u0026#34;Hello, \u0026#34; \u0026lt;\u0026lt; \u0026#34;World\u0026#34; \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; // iostreams 私有变量访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; struct TAccessPrivate { static inline typename T::Type Value; }; template \u0026lt;class T,typename T::Type Value\u0026gt; struct TAccessPrivateStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivate\u0026lt;T\u0026gt;::Value = Value; } }; static inline FAccessPrivateStub AccessPrivateStub; }; //---------------------// struct AccessPalette { typedef TSharedPtr\u0026lt;class SMaterialPalette\u0026gt; (FMaterialEditor::*Type); }; template struct TAccessPrivateStub\u0026lt;AccessPalette,\u0026amp;FMaterialEditor::Palette\u0026gt;; //--------------------// TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 代码的目标\n这段代码的目标是访问一个类的私有成员变量（例如 FMaterialEditor::Palette），而不使用 friend 声明。它通过模板和静态初始化的技巧来实现这一点。\n代码结构\n代码分为以下几个部分：\nTAccessPrivate 模板：用于存储私有成员的指针。 TAccessPrivateStub 模板：用于在静态初始化时设置私有成员的指针。 AccessPalette 结构体：定义了一个类型别名，用于描述私有成员的类型。 模板特化：将 TAccessPrivateStub 特化为 AccessPalette 和 FMaterialEditor::Palette。 访问私有成员：通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 访问私有成员。 详细分析\n1. TAccessPrivate 模板\n1 2 3 4 5 template \u0026lt;class T\u0026gt; struct TAccessPrivate { static inline typename T::Type Value; }; 这是一个模板类，T 是一个类型参数。 T::Type 是一个嵌套类型别名，需要在特化时定义。 Value 是一个静态成员变量，类型是 T::Type，用于存储私有成员的指针。 作用：\nTAccessPrivate 的作用是提供一个全局的存储位置，用于保存私有成员的指针。 2. TAccessPrivateStub 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;class T, typename T::Type Value\u0026gt; struct TAccessPrivateStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivate\u0026lt;T\u0026gt;::Value = Value; } }; static inline FAccessPrivateStub AccessPrivateStub; }; 这是一个模板类，接受两个参数： T：一个类型，需要定义 T::Type。 Value：一个 T::Type 类型的值（通常是私有成员的指针）。 在 TAccessPrivateStub 内部，定义了一个嵌套类 FAccessPrivateStub，其构造函数将 Value 赋值给 TAccessPrivate\u0026lt;T\u0026gt;::Value。 AccessPrivateStub 是一个静态成员变量，类型是 FAccessPrivateStub。 作用：\nTAccessPrivateStub 的作用是在静态初始化时，通过 FAccessPrivateStub 的构造函数将私有成员的指针（Value）赋值给 TAccessPrivate\u0026lt;T\u0026gt;::Value。 由于 AccessPrivateStub 是静态的，它的构造函数会在程序启动时自动调用，从而完成赋值。 3. AccessPalette 结构体\n1 2 3 4 struct AccessPalette { typedef TSharedPtr\u0026lt;class SMaterialPalette\u0026gt; (FMaterialEditor::*Type); }; 这是一个结构体，定义了一个嵌套类型别名 Type。 Type 是一个指向 FMaterialEditor 成员函数的指针类型，返回值为 TSharedPtr\u0026lt;class SMaterialPalette\u0026gt;。 作用：\nAccessPalette 的作用是描述私有成员的类型。在这里，Type 表示 FMaterialEditor::Palette 的类型。 4. 模板特化\n1 template struct TAccessPrivateStub\u0026lt;AccessPalette, \u0026amp;FMaterialEditor::Palette\u0026gt;; 这里对 TAccessPrivateStub 进行了特化： T 被特化为 AccessPalette。 Value 被特化为 \u0026amp;FMaterialEditor::Palette（即私有成员的指针）。 由于 TAccessPrivateStub 的静态成员 AccessPrivateStub 会在程序启动时初始化，其构造函数会将 \u0026amp;FMaterialEditor::Palette 赋值给 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 作用：\n通过特化，TAccessPrivateStub 的静态初始化将私有成员的指针存储到 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 中。 5. 访问私有成员\n1 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value，可以访问到 FMaterialEditor::Palette，即使它是私有的。 这是因为 TAccessPrivateStub 的静态初始化已经将 \u0026amp;FMaterialEditor::Palette 赋值给了 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 为什么可以访问私有成员？\n关键点 1：静态初始化\nTAccessPrivateStub 的静态成员 AccessPrivateStub 会在程序启动时初始化。 在初始化时，FAccessPrivateStub 的构造函数会将 \u0026amp;FMaterialEditor::Palette 赋值给 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 静态初始化发生在 main 函数执行之前，此时编译器不会检查私有成员的访问权限。 关键点 2：绕过访问控制\n虽然 FMaterialEditor::Palette 是私有的，但 TAccessPrivateStub 的静态初始化在程序启动时完成了对私有成员指针的存储。 之后，通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 可以间接访问私有成员。 关键点 3：模板的特化\n模板特化允许在编译时为特定的类型和值生成代码。 在这里，特化将 AccessPalette 和 \u0026amp;FMaterialEditor::Palette 绑定在一起，使得 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 存储了私有成员的指针。 总结\n静态初始化：通过 TAccessPrivateStub 的静态成员，在程序启动时将私有成员的指针存储到 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 中。 模板特化：通过特化将 AccessPalette 和 \u0026amp;FMaterialEditor::Palette 绑定在一起。 间接访问：通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 访问私有成员。 这种方法虽然巧妙，但违背了 C++ 的封装原则，通常不建议在实际项目中使用。它依赖于静态初始化和模板特化的特性，绕过了访问控制机制。\n私有函数访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 目标类，包含私有成员函数 class MyClass { private: void VoidFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Private function called!\u0026#34; \u0026lt;\u0026lt; std::endl; } int IntVarFunc(int a) { cout \u0026lt;\u0026lt; \u0026#34;func: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 55; } }; // 模板类，用于存储私有成员函数的指针 template \u0026lt;typename T, typename FuncPtr\u0026gt; struct TAccessPrivateFunction { static inline FuncPtr Value; // 存储私有成员函数的指针 }; // 模板类，用于在静态初始化时设置私有成员函数的指针 template \u0026lt;typename T, typename FuncPtr, FuncPtr Value\u0026gt; struct TAccessPrivateFunctionStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivateFunction\u0026lt;T, FuncPtr\u0026gt;::Value = Value; // 在静态初始化时设置指针 } }; static inline FAccessPrivateStub AccessPrivateStub; // 静态成员，触发构造函数 }; // 定义私有成员函数的类型 using CallVoidFunc = void (MyClass::*)(); // 特化模板，将私有成员函数的指针存储到 TAccessPrivateFunction 中 template struct TAccessPrivateFunctionStub\u0026lt;MyClass, CallVoidFunc, \u0026amp;MyClass::VoidFunc\u0026gt;; void VoidFuncTemplate() { MyClass obj; // 获取私有成员函数的指针 auto pFunc = TAccessPrivateFunction\u0026lt;MyClass, CallVoidFunc\u0026gt;::Value; // 调用私有成员函数 (obj.*pFunc)(); } // 定义私有成员函数的类型 using CallIntVarFunc = int (MyClass::*)(int); // 特化模板，将私有成员函数的指针存储到 TAccessPrivateFunction 中 template struct TAccessPrivateFunctionStub\u0026lt;MyClass, CallIntVarFunc, \u0026amp;MyClass::IntVarFunc\u0026gt;; void IntVarFuncTemplate() { MyClass obj; // 获取私有成员函数的指针 auto pFunc = TAccessPrivateFunction\u0026lt;MyClass, CallIntVarFunc\u0026gt;::Value; // 调用私有成员函数，并传递参数 int result = (obj.*pFunc)(10); // 调用 PrivateFunction(10) std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } int main() { VoidFuncTemplate(); IntVarFuncTemplate(); return 0; } 替换为空函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;windows.h\u0026gt; class A { public: void Func() { std::cout \u0026lt;\u0026lt; \u0026#34;A::Func()\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 用于提取成员函数指针地址的工具函数 template \u0026lt;typename T, typename U\u0026gt; void* getMemberFunctionAddress(U T::* memberFunc) { union { U T::* ptr; void* addr; } u; u.ptr = memberFunc; return u.addr; } // 空函数的机器码（直接返回） const unsigned char emptyFunc[] = { 0xC3 }; // x86 的 RET 指令 int main() { A a; // 获取 Func 的地址 void* funcAddress = getMemberFunctionAddress(\u0026amp;A::Func); // 修改内存权限为可写 DWORD oldProtect; if (!VirtualProtect(funcAddress, sizeof(emptyFunc), PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect)) { std::cerr \u0026lt;\u0026lt; \u0026#34;VirtualProtect failed: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; return 1; } // 用空函数的机器码覆盖 Func std::memcpy(funcAddress, emptyFunc, sizeof(emptyFunc)); // 恢复内存权限 DWORD temp; if (!VirtualProtect(funcAddress, sizeof(emptyFunc), oldProtect, \u0026amp;temp)) { std::cerr \u0026lt;\u0026lt; \u0026#34;VirtualProtect failed: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; return 1; } // 调用 Func，此时不会打印任何内容 a.Func(); return 0; } ","date":"2000-01-20T20:37:57+08:00","permalink":"http://localhost:1313/p/u-/","title":"U++"},{"content":"简介 多线程 多线程是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。\n多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。\n关键概念\n线程：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。 并发：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。 并行：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。 并发，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。\n特性 并发（Concurrency） 并行（Parallelism） 定义 多个任务交替执行，看似同时运行。 多个任务真正同时执行。 硬件需求 单核 CPU 即可实现。 需要多核 CPU 或多个处理器。 目标 提高资源利用率，增强系统响应性。 提高计算性能，加快任务完成速度。 适用场景 I/O 密集型任务（如网络请求、文件读写）。 计算密集型任务（如科学计算、图像处理）。 实现方式 通过时间片轮转或事件循环实现。 通过多核 CPU 或分布式计算实现。 示例 单核 CPU 上运行多个线程。 多核 CPU 上同时运行多个线程。 并发示例：\n一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。 一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。 并行示例：\n使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。 使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。 多线程的作用\n提高性能：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。 提高响应性：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。 简化设计：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。 异步处理：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。 实际应用场景\nWeb 服务器： 场景：处理大量并发请求。 实现：每个请求由一个独立线程处理，主线程继续接收新请求。 优势：提高并发处理能力，减少响应时间。 图形用户界面（GUI）应用程序： 场景：执行耗时任务（如文件处理、网络请求）时保持界面响应。 实现：耗时任务在后台线程执行，主线程负责更新界面。 优势：避免界面卡顿，提升用户体验。 数据处理与计算： 场景：大数据处理或复杂计算（如图像处理、科学计算）。 实现：将数据分块，每个线程处理一块。 优势：充分利用多核 CPU，加快处理速度。 游戏开发： 场景：同时处理图形渲染、物理模拟、AI 计算等任务。 实现：不同任务由不同线程处理，通过同步机制协调。 优势：提高游戏性能和流畅度。 实时系统： 场景：需要快速响应的系统（如自动驾驶、工业控制）。 实现：关键任务由独立线程处理，确保实时性。 优势：提高系统响应速度和可靠性。 多线程与进程 在操作系统中，进程和线程是两个核心概念，而主线程是进程中的一个特殊线程。\n主线程是进程的一部分：进程是资源的容器，而主线程是进程内的执行单元。 主线程的生命周期与进程紧密相关： 当主线程开始执行时，进程开始运行。 当主线程执行完毕（main 函数返回）且没有其他非守护线程运行时，进程结束。 主线程与其他线程的关系： 主线程可以创建和管理其他线程。 主线程和其他线程共享进程的资源（如内存、文件句柄等）。 主线程的结束不会立即终止其他线程，但如果主线程结束且没有其他非守护线程，进程会终止。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void worker() { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread started.\u0026#34; \u0026lt;\u0026lt; std::endl; // 创建一个子线程 std::thread t(worker); // 主线程继续执行 std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; // 等待子线程结束 t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 输出\n1 2 3 4 5 Main thread started. Worker thread is running... Main thread is running... Worker thread finished. Main thread finished. 线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换要保存很多中间状态切换线程会耗费本该属于程序运行的时间.\n多线程-A 线程创建 线程的多种创建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;chrono\u0026gt; class Obj { public: Obj() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj is created\u0026#34; \u0026lt;\u0026lt; std::endl; } void operator()(int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Obj is called...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; } }; class Obj2 { public: Obj2() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj2 is created\u0026#34; \u0026lt;\u0026lt; std::endl; } void operator()() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj2 is called...\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Obj3 { public: void Func(int value) { std::cout\u0026lt;\u0026lt;\u0026#34;Obj3::Func() \u0026#34;\u0026lt;\u0026lt; value \u0026lt;\u0026lt;std::endl; } }; void worker(int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; } int main() { //------------------------// std::thread t(worker,1); t.join(); //------------------------// std::thread t2([](int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; }, 2); t2.join(); //------------------------// std::function\u0026lt;void(int)\u0026gt; Func = [](int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; }; std::thread t3(Func, 3); t3.join(); //------------------------// std::thread t4(Obj(), 4); t4.join(); //------------------------// Obj2 obj2; std::thread t5(obj2); t5.join(); //------------------------// Obj3 obj3; std::thread t6(\u0026amp;Obj3::Func,\u0026amp;obj3,233); //或 std::thread t6(\u0026amp;Obj3::Func,std::ref(obj3),233); t6.join(); return 0; } join 与 detach 行为 使用 join() 使用 detach() 主线程是否等待 是 否 子线程的生命周期 主线程等待子线程结束后才退出 子线程在后台运行，主线程不等待 资源管理 子线程资源在线程结束后自动释放 子线程资源在线程结束后自动释放 线程状态 主线程可以获取子线程的状态(如是否完成)。 主线程无法获取子线程的状态。 适用场景 需要确保子线程完成任务后再继续执行 子线程是独立任务，主线程无需等待 join() 的适用场景\n任务依赖： 主线程需要子线程的计算结果。 例如：并行计算中，主线程等待所有子线程完成并汇总结果。 资源清理： 主线程在退出前必须确保所有子线程已完成。 例如：多线程下载工具，主线程等待所有下载线程完成后再退出。 detach() 的适用场景\n后台任务： 子线程是独立任务，主线程无需关心其何时完成。 例如：日志记录线程、监控线程。 异步处理： 子线程执行耗时操作，主线程继续响应用户输入。 例如：GUI 应用程序中，后台线程处理文件读写，主线程保持界面响应。 如果需要确保子线程完成任务，使用 join()。 如果希望子线程在后台运行，使用 detach()。 不要既不调用 join() 也不调用 detach()，这会导致程序未定义行为。 被 detach() 的线程独立运行，主线程无法再控制或等待它。 子线程资源在线程结束后自动释放 当一个线程被 detach() 后，它变成了一个独立运行的线程，不再与创建它的线程（通常是主线程）关联。此时，线程的管理权交给了 C++ 运行时库 和 操作系统。\nC++ 运行时库：C++ 运行时库会负责管理线程的资源（如栈空间、线程 ID 等）。 操作系统：操作系统负责调度线程的执行，并在线程结束后回收其资源。 一旦线程被 detach()，就无法再通过 join() 等待其结束，也无法再获取其状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void task(int id) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时任务 std::cout \u0026lt;\u0026lt; \u0026#34;线程任务 \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; 完成.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { // 场景 1：使用 join() std::thread t1(task, 1); std::cout \u0026lt;\u0026lt; \u0026#34;主线程t1创建，调用join...\u0026#34; \u0026lt;\u0026lt; std::endl; t1.join(); // 主线程等待 t1 完成 std::cout \u0026lt;\u0026lt; \u0026#34;主线程在t1结束后继续.\u0026#34; \u0026lt;\u0026lt; std::endl; // 场景 2：使用 detach() std::thread t2(task, 2); std::cout \u0026lt;\u0026lt; \u0026#34;主线程t2创建，调用detach...\u0026#34; \u0026lt;\u0026lt; std::endl; t2.detach(); // 主线程不等待 t2，直接继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;t2已经分离，主线程继续运行...\u0026#34; \u0026lt;\u0026lt; std::endl; // 主线程等待一段时间，确保 t2 有机会运行 std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout \u0026lt;\u0026lt; \u0026#34;主线程完成.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 输出\n1 2 3 4 5 6 7 主线程t1创建，调用join... 线程任务 1 完成. 主线程在t1结束后继续. 主线程t2创建，调用detach... t2已经分离，主线程继续运行... 线程任务 2 完成. 主线程完成. 线程t1创建后 调用join()， t1在睡觉，主线程会卡住，2秒后 t1执行完毕 主线程才继续运行，线程t2创建后 调用detach()，此时 主线程不再等待t2，继续执行，与此同时t2在睡觉，2秒后睡醒 执行完毕.\njoinable() 用于检查一个线程对象是否可以被 join() 或 detach()。它的作用是判断线程对象是否关联了一个可执行的线程。管理线程生命周期的重要工具，尤其在多线程编程中需要确保资源正确释放时。\n检查线程状态： 如果线程对象关联了一个可执行的线程（即线程正在运行或尚未启动），则 joinable() 返回 true。 如果线程对象没有关联可执行的线程（即线程已经结束、被 join() 或 detach()），则 joinable() 返回 false。 在程序退出前，检查所有线程是否已完成，避免资源泄漏。 防止错误操作： 在调用 join() 或 detach() 之前，可以使用 joinable() 检查线程对象的状态，避免重复调用或无效调用。 如果线程已经被 join() 或 detach()，再次调用会导致程序崩溃。 线程状态 joinable() 返回值 线程已创建但未启动 true 线程正在运行 true 线程已结束但未调用 join() 或 detach() true 线程已被 join() false 线程已被 detach() false 默认构造的线程对象（未关联线程） false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void task() { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时任务 std::cout \u0026lt;\u0026lt; \u0026#34;Task finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(task); // 创建线程 // 检查线程是否可 join if (t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is joinable.\u0026#34; \u0026lt;\u0026lt; std::endl; t.join(); // 等待线程结束 } // 再次检查线程是否可 join if (!t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is no longer joinable.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 输出\n1 2 3 Thread is joinable. Task finished. Thread is no longer joinable. 线程传参 当一个线程被 detach() 后，它会独立运行，不再与创建它的线程（通常是主线程）关联。如果这个线程使用了 主线程或函数局部的资源（如局部变量、栈内存等），而主线程或函数结束后这些资源被销毁，会导致线程访问无效的内存，从而引发 未定义行为\n访问已释放的内存：\n如果线程访问了已经被销毁的局部变量或栈内存，可能会导致程序崩溃（如段错误）。 数据损坏：\n如果线程尝试修改已释放的内存，可能会导致数据损坏或其他不可预知的行为。 未定义行为：\n由于访问无效内存，程序的行为是不可预测的，可能表现为崩溃、输出错误结果，或者看似正常运行但隐藏严重问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; class MyString { public: MyString(const std::string\u0026amp; str) : str_(str) { std::cout \u0026lt;\u0026lt; \u0026#34;MyString 创建\u0026#34; \u0026lt;\u0026lt; std::endl; } // 显式定义拷贝构造函数 MyString(const MyString\u0026amp; other) : str_(other.str_) { std::cout \u0026lt;\u0026lt; \u0026#34;MyString 拷贝创建\u0026#34; \u0026lt;\u0026lt; std::endl; } std::string str_; }; // --------TaskA--------- // void TaskA(const MyString\u0026amp; message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskA: \u0026#34; \u0026lt;\u0026lt; message.str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskA() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskA, local_message); t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskA finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } // --------TaskA--------- // // --------TaskB--------- // void TaskB(MyString* message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskB: \u0026#34; \u0026lt;\u0026lt; message-\u0026gt;str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskB() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskB, \u0026amp;local_message); t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskB finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } // --------TaskB--------- // int main() { run_taskA(); run_taskB(); std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } TaskA成功运行，TaskB会发生错误.\n只调用TaskA的输出：发现有两个MyString创建了，\n1 2 3 4 5 MyString 创建 MyString 拷贝创建 run_taskA finished. TaskA: Hello, World! Main thread finished. 值传递：线程函数通过值传递的方式接收参数，线程内部会保存一份独立的拷贝，因此即使局部变量被销毁，线程仍然可以访问有效的数据。 拷贝构造函数：如果没有显式定义拷贝构造函数，编译器会生成默认的拷贝构造函数，执行浅拷贝，且不会输出日志。 生命周期：线程内部的拷贝对象的生命周期与线程绑定，在线程函数执行期间一直有效。 修复TaskB\n把detach改为join，run_taskB函数 会等待线程运行完成才结束.\n1 2 3 4 5 6 7 8 9 10 11 12 13 void TaskB(MyString* message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskB: \u0026#34; \u0026lt;\u0026lt; message-\u0026gt;str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskB() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskB, \u0026amp;local_message); t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskB finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 MyString 创建 TaskB: Hello, World! run_taskB finished. Main thread finished. 在这个例子中，TaskA创建了2个MyString，明明是常量引用，但实际上是值传递TaskB使用指针传递，两个MyString是同一个对象，那么在run_taskB结束后，这个MyString访问就错误了.detach子线程时 不能传递指针.\n在多线程编程中，正确传递函数参数非常重要，尤其是在涉及局部资源时。如果传递方式不当，可能会导致线程访问无效的内存，从而引发未定义行为。\n传递方式 适用场景 注意事项 值传递 大多数场景，确保线程安全 数据会被拷贝，可能有一定开销 引用传递 需要修改原始数据的场景 必须确保原始数据的生命周期长于线程 指针传递 需要共享数据的场景 使用智能指针（如 std::shared_ptr）管理资源，避免悬空指针 移动语义 大数据或不可拷贝的对象 转移所有权后，原始对象不再有效 Lambda 捕获 一次性使用的场景，简洁直观 通过值捕获或引用捕获传递参数 参数传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void func(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } int main() { char c[] = \u0026#34;world\u0026#34;; std::thread t(func, c); // 传递 C 风格字符串 t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } std::string 的创建时机：\n当线程函数 func 开始执行时，会尝试从 const char* 创建 std::string。 如果此时 c 已经被销毁，const char* 指向无效的内存，导致未定义行为。 情况 1：c 未被销毁\n如果线程在 c 被销毁之前完成了 std::string 的创建，程序会正常运行。 情况 2：c 被销毁\n如果线程在 c 被销毁之后才开始执行，尝试从已销毁的 c 创建 std::string，会导致未定义行为。 解决方法：\nstd::thread t(func, string(c))显式地将 char c[] 转换为 std::string. 1 2 char c[] = \u0026#34;world\u0026#34;; std::thread t(func, string(c)); string会在此时构造，在 c销毁之前 创建string。\nstd::thread t(func, string(c)) 构造了第一个string，传递给void func(const std::string\u0026amp; str)时，调用string的拷贝构造 又创建了第二个string.\n常量引用 在这个例子里，void func(const std::string\u0026amp; str)已经用常量引用了，还构造了2个string如果不使用常量引用，void func(std::string str) 不得构造3个string吗？\n不使用常量引用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; class A { public: int Value = -321; A() { cout \u0026lt;\u0026lt; \u0026#34;A 默认构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造 \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt;endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造 \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(A A) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; std::thread t(func, A(c)); t.detach(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 拷贝构造在 传入的a的基础上，将Value值加1，以此区分不同的拷贝构造.\n输出：\n1 2 3 4 5 6 7 A 初始化构造 1 A 拷贝构造 2 ~A 1 A 拷贝构造 3 Hello 3 ~A 3 ~A 2 拷贝构造了2个A， 一共有3个A被创造了，\n使用常量引用：\n把Func的参数改为常量引用\n1 2 3 4 void func(const A\u0026amp; A) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 A 初始化构造 1 A 拷贝构造 2 ~A 1 Hello 2 ~A 2 线程ID 线程 ID 是操作系统或运行时库为每个线程分配的唯一标识符,它用于区分和识别不同的线程。在多线程编程中，线程 ID 是一个重要的概念，可以帮助开发者调试、监控和管理线程。线程 ID 是唯一的、不可预测的，并且在线程销毁后失效。\n在 C++ 中，可以通过以下方式获取线程 ID：\n（1）当前线程的 ID\n使用 std::this_thread::get_id() 获取当前线程的 ID。 （2）线程对象的 ID\n使用 std::thread::get_id() 获取线程对象的 ID。如 t.get_id(); 使用线程ID 观察A类是在哪个线程里创建的，主线程还是子线程？\n常量引用版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } }; void func(const A\u0026amp; A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; int c = 1; std::thread t(func, A(c)); t.detach(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 输出：\n1 2 3 4 5 6 7 8 主线程ID: 2608 A 初始化构造1 线程ID: 2608 A 拷贝构造2 线程ID: 2608 A 析构1 线程ID: 2608 func子线程ID: 19240 Hello 2 A 析构2 线程ID: 19240 主线程ID:2608，子线程ID: 192402个A类的构造 都是在主线程完成的，但是第2个A类的析构却在子线程里.\n构造过程：\n在主线程中创建临时对象 A(c)。 由于函数参数是常量引用，编译器可能会进行一次拷贝构造以传递给子线程的函数。 因此，两个构造操作都在主线程中完成。 析构过程：\n第一个对象在主线程中被析构。 第二个对象在子线程中被析构。 值传递版本：\n1 2 3 4 5 void func(A A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 主线程ID: 12340 A 初始化构造1 线程ID: 12340 A 拷贝构造2 线程ID: 12340 A 析构1 线程ID: 12340 A 拷贝构造3 线程ID: 10368 func子线程ID: 10368 Hello 3 A 析构3 线程ID: 10368 A 析构2 线程ID: 10368 实际运行中，主线程ID:12340，子线程ID:10368，3个A类中， 前2个在主线程构造，第3个在子线程构造后2个都在子线程中析构.\n构造过程： 在主线程中创建临时对象 A(c)。 由于函数参数是按值传递，编译器会进行两次拷贝构造：一次是在主线程中创建临时对象，另一次是将该对象传递给子线程的函数。 因此，前两个构造操作在主线程中完成，第三个构造操作在子线程中完成。 析构过程： 第一个对象在主线程中被析构。 后两个对象在子线程中被析构。 上面测试的函数为 std::thread t(func, A(c));,如果是std::thread t(func, c); 会发生什么？\n常量引用版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void func(const A\u0026amp; A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; int c = 1; std::thread t(func, c); t.join(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 输出：\n1 2 3 4 5 6 主线程ID: 14908 A 初始化构造1 线程ID: 19900 func子线程ID: 19900 Hello 1 A 析构1 线程ID: 19900 构造过程： 由于直接传递整数 c，在子线程中通过构造函数 A(int V) 创建对象。 所有构造操作都在子线程中完成。 析构过程： 对象在子线程中被析构。 值传递版本：\n1 2 3 4 5 void func(A A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 6 主线程ID: 15064 A 初始化构造1 线程ID: 4928 func子线程ID: 4928 Hello 1 A 析构1 线程ID: 4928 构造过程： 类似于常量引用版本，所有构造操作都在子线程中完成。 析构过程： 对象在子线程中被析构。 可以看到，不管是 常量引用 还是 值传递，A类都在子线程中构造，并且只构造一次，虽然比std::thread t(func, A(c));构造次数的少，但是暗藏危机.\n总结\n常量引用版本 (std::thread t(func, A(c));): 构造操作主要在主线程中完成，但部分析构操作会在子线程中发生。 值传递版本 (std::thread t(func, A(c));): 构造操作分布在主线程和子线程中，析构操作主要在子线程中完成。 使用 std::thread t(func, c);: 不论是常量引用还是值传递，构造和析构操作都集中在子线程中完成。 在detach()情况下，使用常量引用版本的std::thread t(func, A(c)); 安全高效.\n线程传参-类对象 前面已经证实了，即便是常量引用，也会生成第二个类对象， 在常量引用的情况下，如果将类对象作为线程参数 在线程函数里面修改对象的数据，那么在主线程里面的那个 不会受到影响。\n主线程中有一个 A类型的 MyA 变量，在传给线程函数时，会调用拷贝构造 创建第二个A类，因此线程函数不会影响到MyA的数据。\n在线程中修改A对象 还有一个问题，因为是常量引用，所以无法修改，但是在变量前面添加mutable就能够修改.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: mutable int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(const A\u0026amp; A) { A.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; A MyA(5); std::thread t(func,MyA); t.join(); this_thread::sleep_for(chrono::seconds(1)); cout\u0026lt;\u0026lt;\u0026#34;主线程A的Value \u0026#34; \u0026lt;\u0026lt; MyA.Value \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 4 5 6 7 A 初始化构造5 A 拷贝构造6 子线程A的Value 123 A 析构123 主线程A的Value 5 A 析构5 虽然使用mutable让变量可修改，但是修改无效啊，并且如果要在线程中修改对象的内容，改的变量很多的话，那每个变量都要加mutable，这河里吗？\nstd::ref 在上面的例子中，要修改const的对象，并且修改了还无效， 双重错误，那有没有更好的办法呢？我们说 有的\nstd::ref 是 C++ 标准库中的一个工具，位于 \u0026lt;functional\u0026gt; 头文件中。它的主要作用是创建一个对象的引用包装器，使得函数参数可以按引用传递而不是按值传递。允许将引用传递给需要值传递的函数或对象这对于避免不必要的拷贝和确保对同一个对象进行操作非常有用，尤其是在使用标准库算法或线程时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(A\u0026amp; A) { A.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; A MyA(5); std::thread t(func,std::ref(MyA)); t.join(); this_thread::sleep_for(chrono::seconds(1)); cout\u0026lt;\u0026lt;\u0026#34;主线程A的Value \u0026#34; \u0026lt;\u0026lt; MyA.Value \u0026lt;\u0026lt; endl; return 0; } 输出:\n1 2 3 4 A 初始化构造5 子线程A的Value 123 主线程A的Value 123 A 析构123 std::ref为什么那么神奇？为什么会这样？\nstd::reference_wrapper 是一个模板类，其简化实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename T\u0026gt; class reference_wrapper { public: // 构造函数，接受一个引用并保存其地址 reference_wrapper(T\u0026amp; ref) : ptr(\u0026amp;ref) {} // 隐式类型转换运算符，将 reference_wrapper 转换为 T\u0026amp; operator T\u0026amp;() const { return *ptr; } private: T* ptr; // 保存引用的指针 }; 构造函数： reference_wrapper(T\u0026amp; ref) 接受一个引用，并将其地址保存到成员变量 ptr 中。 隐式类型转换运算符： operator T\u0026amp;() const 是一个类型转换运算符，它允许 reference_wrapper\u0026lt;T\u0026gt; 对象隐式转换为 T\u0026amp; 类型。 当需要 T\u0026amp; 类型时，编译器会自动调用这个运算符。 1 2 3 4 5 6 7 8 9 10 11 void func(A\u0026amp; a) { a.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; a.Value \u0026lt;\u0026lt; std::endl; } int main() { A MyA(5); std::thread t(func, std::ref(MyA)); // std::ref(MyA) 返回 reference_wrapper\u0026lt;A\u0026gt; t.join(); return 0; } 具体过程：\n传递参数： std::ref(MyA) 返回一个 std::reference_wrapper\u0026lt;A\u0026gt; 对象。 这个对象被传递给 std::thread 的构造函数。 线程内部存储： std::thread 将 std::reference_wrapper\u0026lt;A\u0026gt; 对象拷贝到线程的内部存储中。 调用线程函数： 当线程启动时，std::thread 会调用线程函数 func，并将存储的参数传递给它。 由于 func 的参数类型是 A\u0026amp;，而实际传递的是 std::reference_wrapper\u0026lt;A\u0026gt;，编译器会尝试将 std::reference_wrapper\u0026lt;A\u0026gt; 转换为 A\u0026amp;。 隐式转换： 编译器：编译器在调用线程函数时，发现参数类型不匹配（std::reference_wrapper\u0026lt;A\u0026gt; vs A\u0026amp;），于是尝试查找合适的转换方式。 隐式类型转换运算符：std::reference_wrapper\u0026lt;A\u0026gt; 中定义的 operator A\u0026amp;() 提供了从 std::reference_wrapper\u0026lt;A\u0026gt; 到 A\u0026amp; 的转换规则。 自动调用：编译器根据规则自动调用 operator A\u0026amp;()，完成类型转换。 总结\n隐式转换的触发：当 std::reference_wrapper\u0026lt;A\u0026gt; 需要转换为 A\u0026amp; 时，编译器会自动调用 operator A\u0026amp;()。 转换的实现：std::reference_wrapper 中定义的隐式类型转换运算符提供了转换规则。 应用场景：std::ref 通过 std::reference_wrapper 实现引用传递，适用于需要值传递但希望避免拷贝的场景。 智能指针 在多线程编程中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）可以有效地管理资源的生命周期，并避免内存泄漏和其他资源管理问题。\nshared_ptr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;memory\u0026gt; // 包含智能指针 class MyClass { public: MyClass(int value) : value_(value) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass 创建: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } ~MyClass() { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass 销毁: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } void print() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } int value_; }; void task(std::shared_ptr\u0026lt;MyClass\u0026gt; ptr) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 ptr-\u0026gt;print(); // 访问共享对象 ptr-\u0026gt;value_ = 100; } int main() { // 创建 shared_ptr auto ptr = std::make_shared\u0026lt;MyClass\u0026gt;(42); // 创建线程，传递 shared_ptr std::thread t(task, ptr); // 主线程继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;主线程继续执行...\u0026#34; \u0026lt;\u0026lt; std::endl; t.join(); // 等待线程结束 std::cout\u0026lt;\u0026lt;\u0026#34;主线程的Value:\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;value_\u0026lt;\u0026lt;std::endl; return 0; } 1 2 3 4 5 MyClass 创建: 42 主线程继续执行... Value: 42 主线程的Value:100 MyClass 销毁: 100 std::make_shared\u0026lt;MyClass\u0026gt;(42) 创建了一个 MyClass 对象，并由 std::shared_ptr 管理。 std::thread t(task, ptr) 将 ptr 传递给线程函数 task。 线程函数 task 通过 std::shared_ptr 访问 MyClass 对象。 当线程和主线程都结束时，std::shared_ptr 的引用计数变为 0，MyClass 对象被自动销毁。 std::unique_ptr\n1 2 3 4 5 // 创建 unique_ptr auto ptr = std::make_unique\u0026lt;MyClass\u0026gt;(42); // 创建线程，传递 unique_ptr（必须使用 std::move） std::thread t(task, std::move(ptr)); std::make_unique\u0026lt;MyClass\u0026gt;(42) 创建了一个 MyClass 对象，并由 std::unique_ptr 管理。 std::thread t(task, std::move(ptr)) 将 ptr 的所有权转移给线程函数 task。 线程函数 task 通过 std::unique_ptr 访问 MyClass 对象。 当线程结束时，std::unique_ptr 被销毁，MyClass 对象被自动销毁。 特性 std::shared_ptr std::unique_ptr 所有权 共享所有权，多个指针可以指向同一个对象 独占所有权，只能有一个指针指向对象 拷贝 可以拷贝 不能拷贝，只能移动 性能 有引用计数的开销 无额外开销 适用场景 需要共享所有权的场景 需要独占所有权的场景 线程安全：std::shared_ptr 的引用计数是线程安全的，但对象的访问需要额外的同步机制（如 std::mutex）。 多线程-B CPU 瞎jb转，线程跟了瞎jb干\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void MyPrint(int i) { cout \u0026lt;\u0026lt; \u0026#34;线程开始，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程结束，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;thread\u0026gt; threads; for (int i = 0; i \u0026lt; 10; i++) { threads.push_back(thread(MyPrint, i)); } for (auto\u0026amp; t : threads) { t.join(); } cout \u0026lt;\u0026lt; \u0026#34;main thread end\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 线程开始，编号：0线程开始，编号：线程开始，编号：线程开始，编号：线程开始，编号：6线程开始，编号：线程开始，编号：9 线程结束，编号：0 线程结束，编号：6 5 线程结束，编号：5 8 线程结束，编号：8 3线程开始，编号：1 线程结束，编号：1 线程开始，编号：2 线程结束，编号：2 线程结束，编号：9 4 线程结束，编号：4 线程开始，编号：7 线程结束，编号：7 线程结束，编号：3 main thread end 多个线程运行时确实会受到CPU时间片轮转（time-slicing）的影响。这是操作系统调度器用来管理多个线程或进程执行的一种机制。\n时间片轮转 是操作系统用于管理多线程环境下的CPU时间分配的一种机制。\n它会影响多线程程序的执行顺序和性能，尤其是上下文切换带来的开销。\n为了优化多线程程序，应该尽量减少不必要的上下文切换，合理分配任务，并使用合适的同步机制。\n数据共享 多个线程读取同一个数据\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; vec = { 1,2,3 }; void MyPrint(int i) { // cout \u0026lt;\u0026lt; \u0026#34;线程开始，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; \u0026#34;线程结束，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl cout\u0026lt;\u0026lt;\u0026#34;线程ID: \u0026#34;\u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; vec[0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; vec[1] \u0026lt;\u0026lt;\u0026#34; \u0026#34; \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; endl; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 线程ID: 线程ID: 线程ID: 21108线程ID: 线程ID: 线程ID: 21224线程ID: 线程ID: 183921 2 31 2 3 线程ID: 211761 2 3 线程ID: 222561 2 3 25601 2 3 1 2 3 220161 2 3 233601 2 3 229761 2 3 221361 2 3 main thread end 线程执行顺序不可控，如果一堆线程对同一个数据 有读有写，比如 多个线程读，同时有多个线程写，会造成错误。\n下面的代码会崩溃\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;format\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; class A { public: void InMsgQueue() { for (int i = 0;i \u0026lt; 100000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; MsgQueue.push_back(i); } } void OutMsgQueue() { for (int i = 0;i \u0026lt; 100000;i++) { if (!MsgQueue.empty()) { int Command = MsgQueue.front(); MsgQueue.pop_front(); } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } private: list\u0026lt;int\u0026gt; MsgQueue; }; int main() { A a; std::thread T_InMsg(\u0026amp;A::InMsgQueue, \u0026amp;a); std::thread T_OutMsg(\u0026amp;A::OutMsgQueue, \u0026amp;a); T_InMsg.join(); T_OutMsg.join(); return 0; } 互斥量 互斥量（Mutex）是一种同步机制，用于在并发编程中保护共享资源，确保在同一时间只有一个线程可以访问该资源。互斥量的主要目的是防止多个线程同时访问和修改共享数据，从而避免竞态条件（race condition）和其他并发问题。\n它的实现依赖于操作系统的底层同步机制，通常是对操作系统提供的原语（Windows 的 CRITICAL_SECTION）的封装。\n锁的状态通过原子操作或内存屏障来保证线程安全。\nstd::mutex 内部维护一个等待队列，用于存储被阻塞的线程。 当线程尝试获取锁时，如果锁已被其他线程持有，当前线程会被阻塞，并放入等待队列。 等待队列通常由另一个互斥锁（如 queue_mutex）保护，以确保线程安全。 当锁被释放时，操作系统会从等待队列中唤醒一个线程，使其继续执行。 当线程无法获取锁时，会调用操作系统的阻塞原语（如 futex 或 WaitForSingleObject）将线程挂起。 当锁被释放时，会调用操作系统的唤醒原语（如 futex_wake 或 WakeByAddressSingle）唤醒一个等待线程。 互斥量的工作原理\n锁定（Lock）：当一个线程想要访问共享资源时，它首先尝试获取互斥量的锁。如果互斥量当前没有被其他线程持有，则该线程成功获取锁，并开始访问共享资源。 解锁（Unlock）：当线程完成对共享资源的操作后，它会释放互斥量的锁，允许其他等待的线程获取锁并访问资源。 阻塞（Block）：如果一个线程尝试获取已经被其他线程持有的互斥量锁，该线程会被阻塞，直到持有锁的线程释放锁为止。 lock()：尝试获取互斥量的锁。如果锁已被其他线程持有，调用线程将被阻塞，直到锁可用。\ntry_lock()：尝试获取互斥量的锁，但不会阻塞。如果锁不可用，函数立即返回失败状态。\nunlock()：释放互斥量的锁，允许其他线程获取锁并访问共享资源。\nstd::mutex 是最基本的互斥量类型，适用于大多数场景。\nstd::recursive_mutex 支持递归锁定，适用于需要在一个线程中多次锁定同一个互斥量的情况。\nstd::timed_mutex 和 std::shared_timed_mutex 提供了带超时功能和共享锁的支持，适用于更复杂的同步需求。\n使用mutex，运行稳定，每次只有一个线程访问资源，但是线程运行顺序不稳定..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { private: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; mtx.lock(); MsgQueue.push_back(i); mtx.unlock(); } } bool OutMsg(int\u0026amp; InCommand) { mtx.lock(); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); mtx.unlock(); return true; } mtx.unlock(); return false; } void OutMsgQueue() { int command = 0; for (int i = 0;i \u0026lt; 2000;i++) { if (OutMsg(command)) { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } }; lock_guard 主播主播🥰你的牢锁确～实很强👍 但还是太吃操作了😇 有没有更加简单又强势的英雄推荐一下吗🧐 有的兄弟（战术停顿）有的😋 这么强势的英雄当～然是不止一个了🤓 一共有九位，都是当～前版本t～0.5的超～标英雄👉 告诉主播，你想学习哪个😤\nstd::lock_guard 通过 RAII 机制自动管理互斥量的锁定和解锁操作，从而避免手动管理锁可能导致的错误，如忘记释放锁或在异常情况下未能正确解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mtx); MsgQueue.push_back(i); } } bool OutMsg(int\u0026amp; InCommand) { std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mtx); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); return true; } return false; } lock_guard 构造时就上锁，析构时解锁.\n下面是lock_guard的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;class _Mutex\u0026gt; class _NODISCARD_LOCK lock_guard { // class with destructor that unlocks a mutex public: using mutex_type = _Mutex; explicit lock_guard(_Mutex\u0026amp; _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } lock_guard(_Mutex\u0026amp; _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don\u0026#39;t lock ~lock_guard() noexcept { _MyMutex.unlock(); } lock_guard(const lock_guard\u0026amp;) = delete; lock_guard\u0026amp; operator=(const lock_guard\u0026amp;) = delete; private: _Mutex\u0026amp; _MyMutex; }; 另一个构造函数是什么？ 两个构造函数的区别在于 第二个参数，\n1 2 lock_guard(_Mutex\u0026amp; _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don\u0026#39;t lock 当mutex已经上锁时，召唤lock_guard会再次对mutex上锁 就会错误， 因此有了这个版本的构造函数lock_guard构造时 不自动锁上mutex\n1 2 3 4 5 6 7 8 9 10 11 12 13 void thread_func() { // 手动锁定互斥量 mtx.lock(); // 使用 std::adopt_lock 告诉 lock_guard 互斥量已经被锁定 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 访问共享资源 std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock_guard 自动解锁互斥量 } 死锁 死锁（Deadlock）是并发编程中的一种常见问题，指的是两个或多个线程或进程在执行过程中，由于争夺资源而陷入无限等待的状态。每个线程都持有某些资源并等待获取其他线程持有的资源，导致所有这些线程都无法继续执行。\n有两个线程，都需要同时锁住两个互斥量，才可以进行某项操作，但它们分别都只锁住了一个互斥，都等着再给另一个互斥加锁。于是，双方毫无进展，因为它们同在苦苦等待对方解锁互斥，这种情形称为死锁。\n有两个线程A和B，两个锁L1和L2，两个线程都需要锁住L1、L2才能继续执行线程A执行时 先锁了L1，A正准备锁L2时 发生了上下文切换，此时，线程B开始执行，B锁住了L2，然后去锁L1， 此时 两个锁在两个不同的线程中锁住，发生死锁。\n这种情形下，没有任何一个线程能够同时拥有两个锁，没有任何一个线程能继续运行。\n因此，只要保证锁的顺序一致，就可避免死锁， 如:线程AB都先锁L1 再锁L2。\nstd::lock\nstd::lock 是 C++ 标准库提供的一个函数，用于原子化地锁定多个互斥量（mutex）。它的主要作用是避免在锁定多个互斥量时发生死锁。通过 std::lock，可以确保所有互斥量要么全部成功锁定，要么全部不锁定，从而避免了潜在的死锁问题。\n如果任何一个互斥量无法锁定，它会自动解锁之前已经锁定的所有互斥量，并重新尝试锁定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx1; std::mutex mtx2; void threadFuncA() { std::lock(mtx1, mtx2); // 原子化锁定两个互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); // 采用已锁定的互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 采用已锁定的互斥量 std::cout \u0026lt;\u0026lt; \u0026#34;Thread A acquired both mutexes.\u0026#34; \u0026lt;\u0026lt; std::endl; } void threadFuncB() { std::lock(mtx1, mtx2); // 原子化锁定两个互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); // 采用已锁定的互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 采用已锁定的互斥量 std::cout \u0026lt;\u0026lt; \u0026#34;Thread B acquired both mutexes.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(threadFuncA); std::thread t2(threadFuncB); t1.join(); t2.join(); return 0; } unique_lock std::unique_lock 是 C++ 标准库提供的一个通用的互斥量管理类，比 std::lock_guard 更加灵活。它提供了更丰富的功能来管理互斥量的锁定和解锁操作，适用于更复杂的并发场景。\n灵活性：与 std::lock_guard 不同，std::unique_lock 允许延迟锁定、尝试锁定和递归锁定等高级操作。 可移动但不可复制：std::unique_lock 可以通过移动语义进行转移，但不能被复制。 支持多种锁定策略：除了基本的锁定和解锁操作外，还支持尝试锁定（try_lock）、超时锁定（try_lock_for/try_lock_until）等功能。 手动管理锁状态：允许显式地锁定和解锁互斥量，这在某些需要更精细控制锁状态的场景中非常有用。 特性 std::unique_lock std::lock_guard 锁定时机 可以延迟锁定 总是在构造时锁定 解锁时机 可以手动解锁 总是在析构时解锁 锁定策略 支持多种锁定策略 仅支持锁定和解锁 可移动性 可移动 不可移动 适用场景 复杂的同步需求 简单的同步需求 使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 创建并锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } int main() { std::thread t1(threadFunc); std::thread t2(threadFunc); t1.join(); t2.join(); return 0; } unique_lock的构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 explicit unique_lock(_Mutex\u0026amp; _Mtx) // 构造并且锁住 unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) // 加强版 构造，假设已经锁定 unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) // 构造但不锁 unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) // 构造，尝试锁住 template \u0026lt;class _Rep, class _Period\u0026gt; unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) // 构造 超时锁 template \u0026lt;class _Clock, class _Duration\u0026gt; unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) // 构造 超时锁 ~unique_lock() noexcept { if (_Owns) { _Pmtx-\u0026gt;unlock(); }} 构造函数 功能 explicit unique_lock(_Mutex\u0026amp; _Mtx) 构造时立即锁定互斥锁。 unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) 接管已经锁定的互斥锁。 unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) 构造时不锁定互斥锁，后续手动锁定。 unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) 构造时尝试锁定互斥锁，失败不阻塞。 unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) 构造时尝试在指定相对时间内锁定互斥锁，超时失败。 unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) 构造时尝试在指定绝对时间点前锁定互斥锁，超时失败。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //unique_lock(_Mutex\u0026amp; _Mtx) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 创建并锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) void threadFunc() { mtx.lock(); // 手动锁定 mtx std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 假设 mtx 已经被锁定 std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 创建但不锁定 mtx std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟一些工作负载 lock.lock(); // 显式锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); // 尝试锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex.\u0026#34; \u0026lt;\u0026lt; std::endl; } } //unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::chrono::seconds(2)); // 尝试在2秒内锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex within 2 seconds.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex within 2 seconds.\u0026#34; \u0026lt;\u0026lt; std::endl; } } //unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) void threadFunc() { auto now = std::chrono::system_clock::now(); auto timeout = now + std::chrono::seconds(2); // 设置超时时间为当前时间加上2秒 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, timeout); // 尝试在指定时间点前锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex before the timeout.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex before the timeout.\u0026#34; \u0026lt;\u0026lt; std::endl; } } 其它函数\n名称 描述 lock 阻止调用线程，直到线程获取关联的 mutex 的所有权。 mutex 检索指向关联的 mutex 的存储指针。 owns_lock 指定调用线程是否拥有关联的 mutex。 release 解除 unique_lock 对象与关联的 mutex 对象的关联。 swap 将关联的 mutex 和所有权状态与指定对象的互换。 try_lock 在不阻止的情况下尝试获取关联 mutex 的所有权。 try_lock_for 在不阻止的情况下尝试获取关联 mutex 的所有权。 try_lock_until 在不阻止的情况下尝试获取关联 mutex 的所有权。 unlock 释放关联的 mutex 的所有权。 operator= 从指定对象复制存储的 mutex 指针和关联的所有权状态。 所有权转移：\nunique_lock重载运算符，接收一个右值unique_lock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 unique_lock\u0026amp; operator=(unique_lock\u0026amp;\u0026amp; _Other) noexcept /* strengthened */ { if (this != _STD addressof(_Other)) { if (_Owns) { _Pmtx-\u0026gt;unlock(); } _Pmtx = _Other._Pmtx; _Owns = _Other._Owns; _Other._Pmtx = nullptr; _Other._Owns = false; } return *this; } std::mutex mutexA; std::unique_lock\u0026lt;std::mutex\u0026gt; ulA(mutexA); std::unique_lock\u0026lt;std::mutex\u0026gt; ulB(std::move(mutexA)); 从函数返回局部unique_lock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::mutex mtx; std::unique_lock\u0026lt;std::mutex\u0026gt; get_unlocked_lock() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 创建但不锁定 mtx return lock; // 返回未锁定的 unique_lock } void threadFunc() { auto lock = get_unlocked_lock(); lock.lock(); // 显式锁定 mutex std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; lock.unlock(); // 显式解锁 mutex } 线程安全的cout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; // 定义一个全局互斥锁 std::mutex coutMutex; // 定义一个线程安全的输出类 class SafeCout { public: // 构造函数 SafeCout() = default; // 重载 \u0026lt;\u0026lt; 运算符，支持各种基本类型 template\u0026lt;typename T\u0026gt; SafeCout\u0026amp; operator\u0026lt;\u0026lt;(const T\u0026amp; value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(coutMutex); // 自动管理锁 std::cout \u0026lt;\u0026lt; value; return *this; // 返回当前对象，以便链式调用 } }; // 全局实例化 SafeCout 对象 SafeCout cout_f; condition_variable std::condition_variable 是 C++11 标准库中提供的一个同步原语，用于线程间的通信。它允许一个线程等待某个条件变为真，而另一个线程在条件满足时通知等待的线程继续执行。std::condition_variable 通常与 std::mutex 一起使用，以确保对共享资源的安全访问。\n基本概念\nstd::condition_variable：这是一个类模板，提供了等待和通知机制。它允许一个或多个线程等待某个条件变量被通知。 std::mutex：互斥锁，用于保护共享资源，防止多个线程同时访问导致数据竞争。 std::unique_lock\u0026lt;std::mutex\u0026gt;：与 std::mutex 配合使用，提供更灵活的锁定机制，并且可以与 std::condition_variable 结合使用。 主要方法\nstd::condition_variable 提供了以下主要方法：\nwait()：使当前线程阻塞，直到条件变量被通知。通常与 std::unique_lock 一起使用。 notify_one()：唤醒一个等待该条件变量的线程（如果有）。 notify_all()：唤醒所有等待该条件变量的线程。 wait函数： _Pred是谓词\n1 2 3 4 5 6 7 8 9 10 11 void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; _Lck) noexcept /* strengthened */ { // wait for signal // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow _Cnd_wait(_Mycnd(), _Lck.mutex()-\u0026gt;_Mymtx()); } template \u0026lt;class _Predicate\u0026gt; void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; _Lck, _Predicate _Pred) { while (!_Pred()) { wait(_Lck); } } 谓词返回 true： 初始检查时 _Pred() 返回 true，因此不会进入 while 循环，也不会调用 wait(_Lck)。 锁 _Lck 保持锁定状态，没有释放也没有重新获取。 谓词返回 false： 初始检查时 _Pred() 返回 false，进入 while 循环并调用 wait(_Lck)。 wait(_Lck) 会释放互斥锁 _Lck，使当前线程进入等待状态，直到被其他线程通过 notify_one() 或 notify_all() 唤醒。 被唤醒后，线程会重新获取互斥锁 _Lck 并再次检查谓词，直到谓词返回 true。 如果调用了没有谓词的wait版本，也就是第一个，那么相当于 谓词 返回了false. 解锁互斥量.\n使用场景\nstd::condition_variable 适用于以下几种常见场景：\n生产者-消费者问题：生产者生成数据并放入队列，消费者从队列中取出数据进行处理。当队列为空时，消费者等待；当队列中有数据时，生产者通知消费者。 任务调度：主线程等待子线程完成任务后继续执行。 事件驱动系统：一个线程等待某个事件发生，另一个线程在事件发生时通知等待的线程。 问题代码：不停的判断list是否为空，占用资源，有没有一种方法 当队列为空时，取队列的方法应该等待，有数据时 才进行读取，而不是不断的判空？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class A { private: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout \u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; unique_lock\u0026lt;mutex\u0026gt; lock(mtx); MsgQueue.push_back(i); } } bool OutMsg(int\u0026amp; InCommand) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); return true; } return false; } void OutMsgQueue() { int command = 0; for (int i = 0;i \u0026lt; 2000;i++) { if (OutMsg(command)) { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } }; 使用condition_variable\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class A { public: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; std::condition_variable cv; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); MsgQueue.push_back(i); cout \u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; list size:\u0026#34; \u0026lt;\u0026lt; MsgQueue.size() \u0026lt;\u0026lt; endl; cv.notify_all(); //把wait的线程唤醒,OutMsgQueue()里面的wait被唤醒 //...其它处理代码 } } void OutMsgQueue() { int command = 0; while (true) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); //返回false 解锁互斥量，堵塞在这里，直到其它线程调用notify_one()或notify_all()为止 //返回true 锁上，往下执行 cv.wait(lock, [this] {return !MsgQueue.empty();}); command = MsgQueue.front(); MsgQueue.pop_front(); cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt;\u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; list size:\u0026#34; \u0026lt;\u0026lt; MsgQueue.size() \u0026lt;\u0026lt; endl; lock.unlock(); } } }; 线程执行是反复横跳的，这一段运行起来的效果是，InMsgQueue已经给List插入了N个元素后，OutMsgQueue才执行，例如：InMsgQueue执行了2秒，然后才执行OutMsgQueue.notify_one也不会每次都生效，例如OutMsgQueue已经被唤醒了，正在执行wait之后的操作，没有卡在wait()，\n那么notify_one就不会唤醒OutMsgQueue，因为没有东西可以唤醒。\n有2个OutMsgQueue线程函数，线程A堵塞在wait，线程B已经被唤醒且正在执行一些被唤醒后的操作\nnotify_one() 的行为\n等待状态：\n只有当线程处于等待状态（即调用了 wait() 方法并且尚未返回）时，它才能被 notify_one() 唤醒。 如果一个线程已经从 wait() 返回并重新获得了互斥锁，则它不再是等待状态，不会被 notify_one() 唤醒 唤醒机制：\nnotify_one() 只会发出一次通知信号，尝试唤醒一个等待的线程。 操作系统会选择一个等待的线程来唤醒（如果有多个等待的线程，选择哪个线程是未定义的行为）。 如果没有等待的线程或被唤醒的线程没有实际开始运行（例如因为它已经被唤醒），则通知信号将被忽略。 谁决定了 notify_one() 唤醒哪一个线程？这是由操作系统级别的条件变量机制决定的：\n等待队列：所有等待在条件变量上的线程会被放入一个等待队列中。 选择机制：当 notify_one() 被调用时，操作系统会从等待队列中选择一个线程来唤醒。具体选择哪个线程是未定义的行为，通常取决于操作系统的调度策略。 notify_all() 的行为\n调用 notify_all()：所有等待的线程（如线程 A）会被唤醒，并尝试重新获取互斥锁。线程 B 不受影响，因为它不在等待状态。 竞争互斥锁：被唤醒的线程会竞争互斥锁，只有一个线程能够成功获取锁并继续执行，其他线程将继续等待。 可以确保所有等待的线程都有机会被唤醒并处理新的消息或任务。 单例模式 Magic Static\nC++11 引入了局部静态变量的线程安全初始化特性，即所谓的“Magic Static”。当一个函数内的局部静态变量被首次访问时，编译器会确保其初始化是线程安全的，并且只执行一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Singleton { public: // 获取单例对象的静态方法 static Singleton\u0026amp; getInstance() { static std::unique_ptr\u0026lt;Singleton\u0026gt; instance(new Singleton()); return *instance; } // 示例方法 void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton is doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数和析构函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton destroyed!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 禁用拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; }; 双重检查锁定（DCLP）\n双重检查锁定是一种优化的懒加载单例模式实现方式，通过减少锁的竞争来提高性能。它的核心思想是先检查指针是否为空，如果不是空则直接返回实例；如果是空，则进入临界区再次检查并创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: static Singleton* getInstance() { if (instance == nullptr) // 第一次检查 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); if (instance == nullptr) // 第二次检查 { instance = new Singleton(); } } return instance; } private: Singleton() {} // 私有构造函数防止外部实例化 static Singleton* instance; static std::mutex mutex_; }; Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex_; 在并发编程和计算机体系结构中，\u0026ldquo;reorder\u0026rdquo;（重排序）指的是编译器或处理器对指令执行顺序进行调整的过程。这种重排序旨在优化程序性能，但如果不加以适当控制，可能会导致多线程程序中的数据竞争和不一致问题。\n编译器重排序（Compiler Reordering）\n编译器为了优化代码的执行效率，可能会改变源代码中指令的实际执行顺序。这种优化通常基于静态分析，目的是减少指令依赖、提高流水线利用率等。例如：\n1 2 3 4 5 6 7 int a = 0; int b = 0; void foo() { a = 1; // 操作1 b = 2; // 操作2 } 编译器可能将 b = 2 放在 a = 1 之前执行，因为这两个操作是独立的，不会互相影响。然而，在多线程环境中，这样的重排序可能会导致不可预期的行为。\n处理器重排序（Processor Reordering）\n现代处理器为了提高指令吞吐量和执行效率，也会对指令执行顺序进行重排。处理器重排序通常发生在以下几种情况下：\n指令级并行：处理器可以同时执行多个独立的指令。 内存访问重排序：处理器可以重新安排读写内存的操作顺序，以减少缓存未命中和等待时间。 1 2 3 4 5 6 7 8 // 线程1 a = 1; flag = true; // 线程2 if (flag) { assert(a == 1); } 如果没有适当的同步机制，处理器可能会先执行 flag = true，然后再执行 a = 1，这会导致线程2在检查 flag 时看到 true，但在读取 a 时仍然看到旧值 0，从而导致断言失败。\n内存模型（Memory Model）\n为了处理这些重排序问题，C++ 标准引入了内存模型的概念。内存模型定义了多线程程序中可见性和顺序的规则。C++11 及之后的标准提供了多种内存顺序（memory order），用于显式地控制指令的执行顺序和可见性。\nstd::memory_order_relaxed：最宽松的内存顺序，仅保证原子操作本身的原子性，不提供任何同步或顺序保证。 std::memory_order_consume：消费操作，依赖于其他线程的写操作，并确保这些写操作在当前线程中可见。 **std::memory_order_acquire：获取操作，保证在此操作之后的所有读写操作都不会被重排到此操作之前。 std::memory_order_release：释放操作，保证在此操作之前的所有读写操作都不会被重排到此操作之后。 std::memory_order_acq_rel：结合获取和释放操作，适用于读-修改-写操作。 std::memory_order_seq_cst：最严格的内存顺序，提供全局顺序一致性，但可能会带来较大的性能开销。 volatile 关键字告诉编译器不要对该变量进行重排序和优化。然而，C++ 中的 volatile 并不能解决所有重排序问题，尤其是处理器级别的重排序问题。\n这种方法并不推荐，因为它无法解决所有重排序问题，特别是处理器级别的重排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton { public: static Singleton* getInstance() { if (instance == nullptr) { // 第一次检查 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); if (instance == nullptr) { // 第二次检查 instance = new Singleton(); } } return instance; } private: Singleton() {} static volatile Singleton* instance; // 使用 volatile static std::mutex mutex_; }; volatile Singleton* Singleton::instance = nullptr; 更推荐的方法是使用 std::atomic 和适当的内存顺序来显式地控制指令的执行顺序和可见性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; class Singleton { public: static Singleton* getInstance() { Singleton* tmp = instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire); if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Singleton(); std::atomic_thread_fence(std::memory_order_release); instance.store(tmp, std::memory_order_relaxed); } } return tmp; } private: Singleton() {} // 私有构造函数防止外部实例化 static std::atomic\u0026lt;Singleton*\u0026gt; instance; static std::mutex mutex_; }; std::atomic\u0026lt;Singleton*\u0026gt; Singleton::instance(nullptr); std::mutex Singleton::mutex_; std::memory_order_relaxed：用于初步检查 instance 是否为 nullptr，因为此时只需要保证原子性，不需要严格的同步保证。 std::atomic_thread_fence(std::memory_order_acquire)：在进入临界区之前使用获取内存屏障，确保读取到的 instance 值是最新的。 std::atomic_thread_fence(std::memory_order_release)：在存储 instance 之后使用释放内存屏障，确保所有写操作已经完成，其他线程可以看到最新的值。 特性 Magic Static 双重检查锁定 (DCLP) 实现复杂度 简单 复杂 线程安全性 内置线程安全 需要显式加锁 懒加载 支持，但不可控 完全可控 性能 高（无锁） 中等（较少锁竞争） 资源管理 自动管理生命周期 需要手动管理 依赖环境 需要 C++11 及以上标准 标准 C++，但需注意内存顺序问题 call_once std::call_once 是 C++11 标准库提供的一个工具，用于确保某个函数或可调用对象在多线程环境中仅被调用一次。它通常与 std::once_flag 一起使用，以实现线程安全的单次初始化。\nstd::call_once：这是一个函数模板，接受一个 std::once_flag 对象和一个可调用对象（如函数、lambda 表达式或函数对象）。它保证传入的可调用对象只会被执行一次，即使在多线程环境下多个线程同时尝试调用。 std::once_flag：这是一个特殊的标记对象，用来标识某个操作是否已经执行过。每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例。 std::once_flag 必须是全局或静态变量：每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例，并且该实例必须具有持久的生命周期（即不能是局部变量）。 std::call_once 和 std::once_flag 主要用于以下场景：\n单例模式：确保单例对象的初始化只发生一次。 全局变量初始化：确保某些全局资源或配置只初始化一次。 其他一次性操作：任何需要确保只执行一次的操作都可以使用 std::call_once。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; std::once_flag onceFlag; int initializedValue = 0; void initialize() { std::call_once(onceFlag, []() { initializedValue = 42; std::cout \u0026lt;\u0026lt; \u0026#34;Initialization complete.\u0026#34; \u0026lt;\u0026lt; std::endl; }); } void threadFunc(int threadId) { initialize(); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; threadId \u0026lt;\u0026lt; \u0026#34;: initializedValue = \u0026#34; \u0026lt;\u0026lt; initializedValue \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(threadFunc, 1); std::thread t2(threadFunc, 2); t1.join(); t2.join(); return 0; } 输出\n1 2 3 Initialization complete. Thread 1: initializedValue = 42 Thread 2: initializedValue = 42 单例使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { public: static Singleton\u0026amp; getInstance() { std::call_once(initFlag, []() { instance.reset(new Singleton()); std::cout \u0026lt;\u0026lt; \u0026#34;Singleton instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; }); return *instance; } void doSomething() const { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton instance doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } private: Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;) = delete; // 禁止拷贝构造 Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; // 禁止赋值操作 static std::unique_ptr\u0026lt;Singleton\u0026gt; instance; static std::once_flag initFlag; }; // 初始化静态成员变量 std::unique_ptr\u0026lt;Singleton\u0026gt; Singleton::instance = nullptr; std::once_flag Singleton::initFlag; int main() { std::thread t1([]() { Singleton\u0026amp; singleton = Singleton::getInstance(); singleton.doSomething(); }); std::thread t2([]() { Singleton\u0026amp; singleton = Singleton::getInstance(); singleton.doSomething(); }); t1.join(); t2.join(); return 0; } 异步 async \u0026amp; future std::async 是 C++11 标准引入的一个函数模板，用于启动异步任务。它允许你以一种简便的方式创建和管理异步任务，并且可以获取这些任务的返回值。std::async 返回一个 std::future 对象，该对象可以在稍后用来获取任务的结果。\nstd::future 是 C++11 标准库中的一部分，用于处理异步操作的结果。它提供了一种机制来获取异步任务的返回值或异常，并允许你等待任务完成。\n创建future\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //带有_Policy的构造 template \u0026lt;class Function, class... _ArgTypes\u0026gt; future\u0026lt;_Invoke_result_t\u0026lt;decay_t\u0026lt;Function\u0026gt;, decay_t\u0026lt;_ArgTypes\u0026gt;...\u0026gt;\u0026gt; async(launch _Policy, Function\u0026amp;\u0026amp; _Fnarg, _ArgTypes\u0026amp;\u0026amp;... _Args) //不指定_Policy 就会调用这个版本的构造，此版本将会调用带有_Policy的构造， //并且_Policy策略是launch::async+launch::deferred template \u0026lt;class Function, class... _ArgTypes\u0026gt; future\u0026lt;_Invoke_result_t\u0026lt;decay_t\u0026lt;Function\u0026gt;, decay_t\u0026lt;_ArgTypes\u0026gt;...\u0026gt;\u0026gt; async(Function\u0026amp;\u0026amp; _Fnarg, _ArgTypes\u0026amp;\u0026amp;... _Args) { return async(launch::async | launch::deferred, forward\u0026lt;Function\u0026gt;(_Fnarg), forward\u0026lt;_ArgTypes\u0026gt;(_Args)...); } _Policy：指定任务的执行策略，可以是 std::launch::async 或 std::launch::deferred，或者两者的组合（默认情况下是 std::launch::async | std::launch::deferred）。 _Fnarg：要异步执行的函数或可调用对象。 _Args：传递给函数 f 的参数。 1 2 3 4 STD enum class launch { // names for launch options passed to async async = 0x1, deferred = 0x2 }; 如果选择了 std::launch::async，则立即在一个新线程中启动任务。\n如果选择了 std::launch::deferred，则延迟执行任务，直到调用 get() 或 wait() 方法。\n调用 std::future::get() 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。\n如果任务已经完成，则直接返回结果。\nfuture的函数\n名称 描述 get 检索存储在关联异步状态中的结果。 share 将对象转换为 shared_future。 valid 指定对象是否不为空。 wait 阻止当前线程，直到关联异步状态为准备就绪。 wait_for 进行阻止，直到关联异步状态为准备就绪或已过指定时间。 wait_until 进行阻止，直到关联异步状态为准备就绪或直到指定时间点。 阻塞行为：当调用 get() 方法时，如果异步任务尚未完成，当前线程会被阻塞，直到任务完成并返回结果。 异常处理：如果异步任务抛出异常，get() 方法会重新抛出该异常，并且当前线程会被阻塞直到异常被抛出。 延迟执行：如果使用 std::launch::deferred 策略，get() 方法不仅会阻塞，还会触发任务的实际执行。 超时等待：可以使用 wait_for 或 wait_until 方法设置超时时间，避免无限期等待。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool loop = true; int add(int a, int b) { this_thread::sleep_for(std::chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;add\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; loop = false; return a + b; } int main() { // 启动异步任务 std::future\u0026lt;int\u0026gt; result = std::async(add, 5, 3); // 主线程继续做其他事情 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else.\\n\u0026#34;; while (loop) { std::cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; this_thread::sleep_for(std::chrono::milliseconds(1)); } // 获取异步任务的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread Get Result.\\n\u0026#34;; int sum = result.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 4 5 6 7 8 9 Main thread is doing something else. ..................................... .................................... ..................................... ......................................... .......................................... .....................................add .Main thread Get Result. Result: 8 异步不会卡主线程，主线程一直在打印\u0026hellip;. 直到子线程执行完毕，\n假如调用异步任务的结果时，异步线程还没有执行完成，主线程会堵塞 直到异步线程执行完毕。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int add(int a, int b) { this_thread::sleep_for(std::chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;add\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return a + b; } int main() { // 启动异步任务 std::future\u0026lt;int\u0026gt; result = std::async(add, 5, 3); // 主线程继续做其他事情 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else.\\n\u0026#34;; // 获取异步任务的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread Get Result.\\n\u0026#34;; int sum = result.get();//卡在这里 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 1 2 3 4 5 Main thread is doing something else. Main thread Get Result. //在这里卡住，等待异步结果出来 才继续执行。 add Result: 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyClass { public: // 成员函数，接受两个整数并返回它们的和 int computeSum(int a, int b) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 return a + b; } }; int main() { MyClass obj; // 创建类的对象 // 使用 std::async 启动异步任务，调用成员函数 computeSum auto future = std::async(\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); std::cout \u0026lt;\u0026lt; \u0026#34;Doing some work in the main thread.\u0026#34; \u0026lt;\u0026lt; std::endl; // 获取异步任务的结果 int result = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } std::launch\n1 2 3 4 STD enum class launch { // names for launch options passed to async async = 0x1, deferred = 0x2 }; 如果选择了 std::launch::async，则立即在一个新线程中启动任务。\n如果选择了 std::launch::deferred，则延迟执行任务，直到调用 get() 或 wait() 方法。\n调用 std::future::get() 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。\n如果任务已经完成，则直接返回结果。\n如果将上面创建future的函数改为\n1 auto future = std::async(std::launch::deferred,\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); 那么future的函数将会在主线程中执行，因为没有用launch::async.\n下面的两种方式都会在新线程中执行，\n1 2 3 4 //新线程延迟到get()时执行 auto future = std::async(\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); //新线程立即执行 auto future = std::async(std::launch::async,\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); async vs thread\n使用std::thread，如果系统资源紧张，线程创建会失败，执行std::thread可能导致程序崩溃.std::async是创建异步任务，使用launch::deferred时不创建新线程，\nasync构造函数 默认使用了 launch::async | launch::deferred，\n如果系统资源充足，可能会选择 std::launch::async 并创建一个新线程来立即执行任务。 如果系统资源紧张或任务数量较多，可能会选择 std::launch::deferred，延迟任务的执行，直到你请求其结果时才执行。 判断是否创建线程\n1 2 3 4 5 6 7 8 std::thread thread; std::future\u0026lt;int\u0026gt; future = std::async(func); std::future_status status = future.wait_for(std::chrono::seconds(0)); if (status == std::future_status::deferred) { //线程被延迟执行 std::cout\u0026lt;\u0026lt;future.get()\u0026lt;\u0026lt;std::endl; } wait_for\nwait_for 方法，允许你在指定的时间内等待异步任务完成。如果在指定时间内任务完成了，wait_for 会返回一个指示任务状态的枚举值；如果超时，则返回一个表示超时的状态。\n应用场景：当你希望避免无限期等待异步任务完成时，可以使用 wait_for 方法设置超时时间，并根据任务状态采取不同的操作。 1 2 template\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; 参数：timeout_duration 是一个时间间隔，指定了你愿意等待的最大时间。 返回值：返回枚举值，表示当前任务的状态： std::future_status::ready：任务已经完成。 std::future_status::timeout：任务未完成，并且达到了超时时间。 std::future_status::deferred：任务被延迟执行（仅适用于使用 std::launch::deferred 启动的任务）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; int longComputation(int x) { std::this_thread::sleep_for(std::chrono::seconds(3)); // 模拟长时间计算 return x * x; } int main() { // 使用 std::async 启动异步任务，并获取 std::future 对象 auto future = std::async(std::launch::async, longComputation, 5); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for the result with timeout...\u0026#34; \u0026lt;\u0026lt; std::endl; // 设置超时时间为1秒 auto status = future.wait_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;End Wait...\u0026#34; \u0026lt;\u0026lt; std::endl; switch (status) { case std::future_status::ready: std::cout \u0026lt;\u0026lt; \u0026#34;Result is ready: \u0026#34; \u0026lt;\u0026lt; future.get() \u0026lt;\u0026lt; std::endl; break; case std::future_status::timeout: std::cout \u0026lt;\u0026lt; \u0026#34;Timeout occurred before the result was ready.\u0026#34; \u0026lt;\u0026lt; std::endl; break; case std::future_status::deferred: std::cout \u0026lt;\u0026lt; \u0026#34;The task has been deferred and will be executed on call to get().\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return 0; } 输出： 函数执行需要3秒，但是只等待了1秒，超时。\n1 2 3 Waiting for the result with timeout... End Wait... Timeout occurred before the result was ready. std::packaged_task std::packaged_task 是 C++11 标准库中的一个类模板，用于封装可调用对象（如函数、lambda 表达式或函数对象），并允许你异步执行这些对象。它与 std::future 配合使用，可以获取任务的执行结果。\n主要用途\n封装可调用对象：将可调用对象（如函数、lambda 表达式或函数对象）封装到 std::packaged_task 中。 异步执行：可以在不同的线程中执行封装的任务，并通过 std::future 获取结果。 异常处理：如果任务抛出异常，可以通过 std::future::get() 捕获并重新抛出该异常。 名称 描述 get_future 返回具有相同关联异步状态的 future 对象。 make_ready_at_thread_exit 调用存储在关联异步状态中的可调用的对象，并以原子方式存储返回值。 reset 替换关联异步状态。 swap 将关联异步状态与指定对象交换。 valid 指定对象是否具有关联异步状态。 简单使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; int add(int a, int b) { return a + b; } int main() { // 创建一个 packaged_task，包装 add 函数 std::packaged_task\u0026lt;int(int, int)\u0026gt; task(add); // 获取与任务关联的 future std::future\u0026lt;int\u0026gt; result = task.get_future(); // 在另一个线程中执行任务 //move(task) 或 ref(task) std::thread t(std::move(task), 2, 3); t.join(); // 获取任务结果 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; std::endl; return 0; } promise std::promise 是 C++11 标准库中的一个类模板，用于在不同的线程之间设置异步结果或异常。它通常与 std::future 配合使用，以便在一个线程中设置值或异常，并在另一个线程中获取这些值或异常。\n主要用途\n设置异步结果：在一个线程中通过 std::promise 设置某个值。 获取异步结果：在另一个线程中通过关联的 std::future 获取该值。 异常处理：如果任务抛出异常，可以通过 std::promise 将异常传递给 std::future。 名称 描述 get_future 返回与此 promise 关联的 future。 set_exception 以原子方式设置此 promise 的结果以指示异常。 set_exception_at_thread_exit 以原子方式设置此 promise 的结果以指示异常，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。 set_value 以原子方式设置此 promise 的结果以指示值。 set_value_at_thread_exit 以原子方式设置此 promise 的结果以指示值，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。 swap 用指定的 promise 对象的关联的异步状态交换此 promise 的关联的异步状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void computeSum(std::promise\u0026lt;int\u0026gt;\u0026amp; prom, int a, int b) { int sum = a + b; prom.set_value(sum); // 设置结果 } int main() { std::promise\u0026lt;int\u0026gt; prom; std::thread t1(computeSum,std::ref(prom),2,3); t1.join(); std::future\u0026lt;int\u0026gt; fut = prom.get_future(); auto sum = fut.get(); std::cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 多个线程之间传值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void step1(std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = 10; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 1 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt;std::endl; } void step2(int input, std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = input * 2; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 2 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } void step3(int input, std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = input + 5; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 3 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } int main() { std::promise\u0026lt;int\u0026gt; p1, p2, p3; std::future\u0026lt;int\u0026gt; f1 = p1.get_future(); std::future\u0026lt;int\u0026gt; f2 = p2.get_future(); std::future\u0026lt;int\u0026gt; f3 = p3.get_future(); // 启动第一个步骤，并将结果存储在p1中 std::thread t1(step1, std::move(p1)); // 启动第二个步骤，并等待第一个步骤的结果，将结果存储在p2中 std::thread t2(step2, f1.get(),std::move(p2)); // 启动第三个步骤，并等待第二个步骤的结果，将结果存储在p3中 std::thread t3(step3, f2.get(), std::move(p3)); // 获取最终结果 int final_result = f3.get(); // 如果任务未完成，这里会阻塞 std::cout \u0026lt;\u0026lt; \u0026#34;Final result: \u0026#34; \u0026lt;\u0026lt; final_result \u0026lt;\u0026lt; std::endl; t1.join(); t2.join(); t3.join(); return 0; } 输出：\n1 2 3 4 Step 1 completed,Value:10 Step 2 completed,Value:20 Step 3 completed,Value:25 Final result: 25 shared_future std::shared_future 是 C++11 标准库中的一个类模板，它是 std::future 的扩展版本，允许多个线程共享同一个异步结果。与 std::future 不同的是，std::shared_future 可以被多次拷贝，并且每个拷贝都可以独立地获取异步任务的结果或异常。\nstd::shared_future 通常通过 std::future 的 share() 方法获得。一旦你有了 std::shared_future 对象，就可以在多个线程中使用它来获取异步结果。\n主要用途\n共享异步结果：允许多个线程共享同一个异步结果。 多次获取结果：可以在多个地方调用 get() 方法来获取同一个异步任务的结果，而不会导致阻塞或重复执行任务。 异常处理：如果任务抛出异常，可以通过 std::shared_future::get() 捕获并重新抛出该异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;Tool.h\u0026#34; int computeSum(int a, int b) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return a + b; } void printResult(const std::shared_future\u0026lt;int\u0026gt;\u0026amp; fut) { printf(\u0026#34;Result:%d \\n\u0026#34;, fut.get()); // 获取异步任务的结果 } int main() { // 使用 std::async 启动异步任务，并获取 std::future 对象 auto future = std::async(std::launch::async, computeSum, 5, 3); // 将 std::future 转换为 std::shared_future std::shared_future\u0026lt;int\u0026gt; sharedFut = future.share(); // 在多个线程中获取异步任务的结果 std::thread t1(printResult, sharedFut); std::thread t2(printResult, sharedFut); t1.join(); t2.join(); std::this_thread::sleep_for(std::chrono::seconds(3)); printf(\u0026#34;Main thread value:%d\u0026#34;, sharedFut.get()); return 0; } 输出：\n1 2 3 Result:8 Result:8 Main thread value:8 atomic std::atomic 是 C++11 标准库中的一个模板类，用于提供原子操作的支持。原子操作是指不可分割的操作，在多线程环境中可以保证对共享数据的访问是安全的，不会出现竞态条件（race condition）。\n原语：操作系统或编程语言提供的基本构建块或不可再分的操作单元。要么完全执行，要么完全不执行 原子：指那些不可分割的操作或数据结构，在并发环境中保持一致性。 原子化：将一系列操作视为一个不可分割的整体，确保这些操作要么全部成功，要么全部失败。 原子操作：在执行过程中不会被中断的操作，通常用于确保并发环境下的线程安全性。\n主要用途\n线程安全：确保对共享变量的操作在多线程环境中是线程安全的。 无锁编程：通过原子操作实现高效的无锁编程。 内存顺序控制：允许你控制内存顺序，以优化性能或确保特定的内存可见性。 基本概念\n原子类型：std::atomic\u0026lt;T\u0026gt; 是一个模板类，其中 T 是你要进行原子操作的数据类型。\n原子操作：包括读取、写入、交换、比较并交换等操作，这些操作都是原子性的，即它们不会被其他线程中断。\n函数：\nload()：获取当前值（原子读取）。\nstore(value)：设置新值（原子写入）。\nfetch_add(arg) 和 fetch_sub(arg)：增加或减少当前值，并返回旧值。\nfetch_and(arg), fetch_or(arg), fetch_xor(arg)：按位与、或、异或操作，并返回旧值。\ncompare_exchange_weak(expected, desired)\n如果 atomic 的当前值 (currentValue) 等于 expected： 将 atomicPoint 更新为 desired。 返回 true。更新成功。 如果 atomic 的当前值 (currentValue) 不等于 expected： 更新 expected 为 atomicPoint 的当前值 (currentValue)。 返回 false。更新失败。 compare_exchange_strong(expected, desired)\n与 compare_exchange_weak 类似，但没有伪失败的情况。\n基础操作\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::atomic\u0026lt;int\u0026gt; atomicInt(0); // 定义一个原子整型变量，并初始化为0 std::cout \u0026lt;\u0026lt; \u0026#34;Initial value: \u0026#34; \u0026lt;\u0026lt; atomicInt.load() \u0026lt;\u0026lt; std::endl; atomicInt.store(42); // 设置值为42 std::cout \u0026lt;\u0026lt; \u0026#34;Updated value: \u0026#34; \u0026lt;\u0026lt; atomicInt.load() \u0026lt;\u0026lt; std::endl; return 0; } 写数值\n每个线程让Value+10000, 5个线程的执行结果应该为：50000，但是每次运行的Value结果是随机的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; int Value = 0; void incrementCounter(int id) { for (int i = 0; i \u0026lt; 10000; ++i) { Value++; } } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都增加计数器 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(incrementCounter, i + 1); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } std::cout \u0026lt;\u0026lt; \u0026#34;Final counter value: \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; return 0; } 使用atomic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; std::atomic\u0026lt;int\u0026gt; atomicCounter(0); void incrementCounter(int id) { for (int i = 0; i \u0026lt; 10000; ++i) { atomicCounter.fetch_add(1); // 原子增加 } printf(\u0026#34;Thread %d done \\n\u0026#34;, id); } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都增加计数器 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(incrementCounter, i + 1); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } std::cout \u0026lt;\u0026lt; \u0026#34;Final counter value: \u0026#34; \u0026lt;\u0026lt; atomicCounter.load() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 4 5 6 Thread 2 done Thread 5 done Thread 4 done Thread 1 done Thread 3 done Final counter value: 50000 1 2 3 4 5 6 7 8 9 10 11 12 std::atomic\u0026lt;int\u0026gt; atm(0); atm += 1; //原子操作 atm = atm + 1;//不是原子操作 //读atm是原子操作，但这一行不是原子操作 cout\u0026lt;\u0026lt; atm \u0026lt;\u0026lt; endl; //使用load原子读值 atomic\u0026lt;int\u0026gt; atm2(atm.load()); auto atm3(atm.load()); //store原子写入 atm2.store(12); 自定义类型的原子操作\n虽然 std::atomic 支持大多数基本数据类型，但对于自定义类型，需要满足一些条件才能使用原子操作：\n类型必须是可平凡复制的（Trivially Copyable）。 类型必须有一个公共的默认构造函数。 如果你需要对自定义类型进行原子操作，可以通过封装和手动实现 CAS 操作来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; struct Point { int x, y; Point(int x_ = 0, int y_ = 0) : x(x_), y(y_) {} }; std::atomic\u0026lt;Point\u0026gt; atomicPoint(Point(0, 0)); void updatePoint(int dx, int dy) { Point oldVal, newVal; do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都更新点的位置 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(updatePoint, i, i); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } Point finalValue = atomicPoint.load(); std::cout \u0026lt;\u0026lt; \u0026#34;Final point position: (\u0026#34; \u0026lt;\u0026lt; finalValue.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; finalValue.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 有一个全局的原子变量 atomicPoint，它是一个 Point 结构体类型的对象。多个线程可能会同时尝试修改这个变量。为了确保这些修改是安全且没有冲突的，需要使用原子操作来实现这一点。\n1 2 3 4 5 6 7 8 9 std::atomic\u0026lt;Point\u0026gt; atomicPoint(Point(0, 0)); void updatePoint(int dx, int dy) { Point oldVal, newVal; do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); } 1 2 oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); load()：这是一个原子操作，用来读取 atomicPoint 当前的值，并将其存储在 oldVal 中，以便在此基础上计算新的值\nnewVal：基于 oldVal 和增量值 dx 和 dy 计算出的新 Point 对象。\n1 2 3 4 do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); compare_exchange_weak(oldVal, newVal)：这是一个关键的原子操作，用于比较并交换（CAS，Compare-And-Swap）。\n比较部分：首先检查 atomicPoint 当前的值是否与 oldVal 相等。 交换部分：如果相等，则将 atomicPoint 更新为 newVal，返回true；如果不相等，则不会更新 atomicPoint，而是更新 oldVal 为 atomicPoint 的当前值，返回false。 循环机制：\n如果 compare_exchange_weak 返回 false，说明在我们读取 oldVal 和尝试更新之间，有其他线程已经修改了 atomicPoint 的值。 此时，我们需要重新加载最新的 oldVal，重新计算 newVal，然后再次尝试更新。 如果在尝试更新时发现 atomicPoint 已经被其他线程修改，则重新加载最新值并重新计算新值，直到成功为止。 检查 atomicPoint 和 刚才读取的 atomicPoint (oldVal) 的值是否相同，如果值不一样，那就说明atomicPoint被其它线程篡改了。相等 ， 说明没有线程修改atomicPoint，可以把newVal给它，函数返回true不相等，说明有线程修改了atomicPoint ，此时就要把oldval给它，返回false，重新进入循环体计算newVal的值。\n多线程-C 线程池\n服务器 \u0026mdash;\u0026gt; 客户端， 每来一个客户端 就创建一个新线程给客户服务.网络游戏 2万个玩家，不可能给每个玩家创建一个线程，创建线程可能会因为资源不够而失败，也有线程切换造成的消耗，\n线程池是一种设计模式，用于管理和复用一组工作线程，以提高应用程序的性能和资源利用率。它通过预先创建一组线程，并将这些线程放入一个“池”中，以便在需要执行任务时可以快速分配和重用这些线程，而不需要频繁地创建和销毁线程。\n通过复用一组工作线程来处理多个任务，减少了线程创建和销毁的开销，提高了系统的响应速度和资源利用率。\n线程数量过多，因为线程切换时 需要切换上下文，所以性能效率下降，\n线程池的主要优点\n减少线程创建和销毁的开销： 创建和销毁线程是一个相对昂贵的操作，涉及内存分配、上下文切换等。使用线程池可以避免频繁创建和销毁线程，从而提高性能。 提高响应速度： 当有新的任务到达时，线程池中的空闲线程可以立即开始处理任务，而不是等待新线程的创建。这使得应用程序能够更快地响应请求。 控制并发线程数量： 线程池允许你设定最大并发线程数，防止系统因为创建过多线程而导致资源耗尽或系统崩溃。 资源管理： 线程池可以更好地管理系统资源，确保不会因为过度创建线程而导致内存或其他资源的耗尽。 线程池的基本组成\n一个典型的线程池通常包含以下几个部分：\n任务队列（Task Queue）： 存储待执行的任务。当有新的任务提交到线程池时，任务会被加入到这个队列中。 工作线程（Worker Threads）： 预先创建的一组线程，负责从任务队列中取出任务并执行。 线程池管理器（Pool Manager）： 负责管理线程池的状态，包括创建和销毁线程、监控线程状态、处理任务队列等。 任务调度机制： 决定如何从任务队列中取出任务并分配给空闲的工作线程。 线程池的工作流程\n初始化线程池： 在程序启动时，线程池会根据配置预先创建一组工作线程，并将它们放入池中。 提交任务： 当有新的任务需要执行时，任务会被提交到线程池的任务队列中。 任务分配： 空闲的工作线程会从任务队列中取出任务并开始执行。 如果所有线程都在忙于执行任务，则新任务会被暂时存储在任务队列中，直到有线程空闲下来。 任务完成： 工作线程完成任务后，会返回线程池中继续等待下一个任务。 关闭线程池： 当不再需要线程池时，可以通过调用相应的 API 来关闭线程池，释放所有资源。 线程池的应用场景\nWeb服务器： 处理客户端请求时，每个请求都可以作为一个独立的任务交给线程池中的线程处理。 数据库查询： 数据库查询操作通常比较耗时，可以将查询请求提交到线程池中异步执行，避免阻塞主线程。 图像处理： 对大量图像进行处理时，可以将每张图像的处理任务提交到线程池中并发执行。 批量数据处理： 批量处理大量数据时，可以将每个数据块的处理任务提交到线程池中并行执行。 飞升 构造与析构\n1 2 3 4 5 6 int main() { thread t1([]() {cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; }); t1.join(); return 0; } 传入Lambda时，调用thread的构造函数:\n1 2 3 4 5 template \u0026lt;class _Fn, class... _Args, enable_if_t\u0026lt;!is_same_v\u0026lt;_Remove_cvref_t\u0026lt;_Fn\u0026gt;, thread\u0026gt;, int\u0026gt; = 0\u0026gt; explicit thread(_Fn\u0026amp;\u0026amp; _Fx, _Args\u0026amp;\u0026amp;... _Ax) { _Start(_STD forward\u0026lt;_Fn\u0026gt;(_Fx), _STD forward\u0026lt;_Args\u0026gt;(_Ax)...); } 目的: 创建一个新线程，并在该线程中执行给定的可调用对象及其参数。 模板参数: _Fn: 可调用对象的类型。 _Args...: 可变参数模板，表示传递给可调用对象的参数类型列表。 SFINAE机制: 使用 enable_if_t 和 is_same_v 确保此构造函数不会被用来递归地构造 std::thread 对象，即防止将 std::thread 对象本身作为第一个参数传入。 explicit关键字: 确保构造函数只能用于显式的类型转换，避免隐式转换带来的潜在错误。 完美转发: 利用 右值引用 (\u0026amp;\u0026amp;) 和 std::forward 保留原参数的左右值属性，以高效且正确的方式将可调用对象及其参数传递给内部的启动方法 _Start。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class _Fn, class... _Args\u0026gt; void _Start(_Fn\u0026amp;\u0026amp; _Fx, _Args\u0026amp;\u0026amp;... _Ax) { // 使用std::tuple将可调用对象及其参数存储在一个元组中， //使用std::decay_t去除引用和cv限定符以确保正确的拷贝和存储。 using _Tuple = tuple\u0026lt;decay_t\u0026lt;_Fn\u0026gt;, decay_t\u0026lt;_Args\u0026gt;...\u0026gt;; //使用std::make_unique创建一个包含上述元组的智能指针，确保资源管理的安全性，并通过std::forward进行完美转发。 auto _Decay_copied = _STD make_unique\u0026lt;_Tuple\u0026gt;(_STD forward\u0026lt;_Fn\u0026gt;(_Fx), _STD forward\u0026lt;_Args\u0026gt;(_Ax)...); //获取一个调用器（即线程执行的入口点），这个过程涉及到元编程技巧， //通过std::index_sequence生成一个索引序列来帮助解包元组中的元素。 constexpr auto _Invoker_proc = _Get_invoke\u0026lt;_Tuple\u0026gt;(make_index_sequence\u0026lt;1 + sizeof...(_Args)\u0026gt;{}); //使用_beginthreadex函数创建新线程，传入调用器_Invoker_proc和元组的指针_Decay_copied.get()作为\t参数。 //_Thr._Hnd保存线程句柄，_Thr._Id保存线程ID。 _Thr._Hnd = reinterpret_cast\u0026lt;void*\u0026gt;(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, \u0026amp;_Thr._Id)); //--// if (_Thr._Hnd) { // ownership transferred to the thread (void) _Decay_copied.release(); } else { // failed to start thread _Thr._Id = 0; _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN); } //如果线程创建成功（即_Thr._Hnd非空），则释放智能指针_Decay_copied的所有权，因为线程会接管该资源的生\t命周期。 //如果线程创建失败，则设置线程ID为0，并抛出异常_RESOURCE_UNAVAILABLE_TRY_AGAIN，指示资源不可用，\t请重试。 } _Start 函数通过模板编程实现了对可调用对象及其参数的灵活处理。 使用 std::tuple 和 std::unique_ptr 确保资源管理和类型安全。 利用 _beginthreadex 和元编程技术创建了一个新的线程，并在线程中执行给定的可调用对象及其参数。 处理了线程创建成功和失败的情况，提供了良好的错误处理机制。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 thread t1([]() {cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; }); cout \u0026lt;\u0026lt; t1.joinable() \u0026lt;\u0026lt; endl; t1.join(); cout \u0026lt;\u0026lt; t1.joinable() \u0026lt;\u0026lt; endl; ~thread() noexcept{ if (joinable()){ _STD terminate(); // per N4950 [thread.thread.destr]/1 } } bool joinable() const noexcept { return _Thr._Id != 0; } // thread::_Thrd_t _Thr; // _Thr 的类型 就是一个结构体 using _Thrd_id_t = unsigned int; struct _Thrd_t { // thread identifier for Win32 void* _Hnd; // Win32 HANDLE _Thrd_id_t _Id; }; 如果 joinable() 为 true，在析构时就会崩溃报错.\n如果 Id 不为 0 ，joinable() 为 true. 如果 Id = 0 ，joinable() 为 false.\nId在什么情况下等于0？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void join() { //判断可加入 if (!joinable()) { _Throw_Cpp_error(_INVALID_ARGUMENT); } //检查当前线程ID是否与调用join()的线程ID相同。 //如果是相同的线程尝试自我连接，会导致死锁，因此抛出错误。 if (_Thr._Id == _Thrd_id()) { _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR); } //调用底层的线程等待函数_Thrd_join，该函数会阻塞当前线程直到指定线程完成其执行。 //如果线程成功完成，返回成功状态；否则抛出错误。 if (_Thrd_join(_Thr, nullptr) != _Thrd_result::_Success) { _Throw_Cpp_error(_NO_SUCH_PROCESS); } //如果线程成功完成，将 _Thr 重置为空（即设置 _Thr._Hnd 和 _Thr._Id 为0）， //表示该线程对象不再关联任何活动线程。 _Thr = {}; } void detach() { //判断可加入 if (!joinable()) { _Throw_Cpp_error(_INVALID_ARGUMENT); } //调用底层的线程分离函数_Thrd_detach，该函数将线程从其创建者（即当前线程对象）中分离出来。 //分离后的线程将在后台独立运行，不再受创建它的线程对象管理。 if (_Thrd_detach(_Thr) != _Thrd_result::_Success) { _Throw_Cpp_error(_INVALID_ARGUMENT); } //重置线程状态 _Thr = {}; } join detach 最终都会把 _Thr 设为空，此时 Id = 0 .\njoinable() 就是根据 thread 里面保存的 _Thr 是否为空 进行判断的.\n总结\n线程状态管理: 线程对象的状态由内部结构体_Thrd_t的成员变量_Id决定。如果_Id不为0，表示线程是可连接的（joinable()返回true）；如果_Id为0，则表示线程不可连接（joinable()返回false）。 线程对象的生命周期管理: 在线程对象析构时，如果线程仍然可连接(即joinable()为true),调用terminate()终止程序。因此，在析构前必须确保调用了join()或detach()方法之一。 join() 和 detach() 方法的作用: join()方法等待线程完成，并将线程对象的内部状态重置，使得_Id变为0，从而joinable()返回false。 detach()方法分离线程，使其独立运行，并同样将线程对象的内部状态重置，使得_Id变为0，从而joinable()返回false。 这些机制共同确保了线程的安全管理和资源释放，避免了潜在的资源泄露和未定义行为。\n分离的线程去了哪里？生命周期谁来管？\n进程终止时强制结束\n所有线程（包括分离的线程）会在进程退出时被操作系统强制终止。\n触发条件： 主线程返回（main 函数结束）。 调用 exit() 或 std::terminate()。 进程收到终止信号（如 SIGTERM）。 示例：主线程结束后，分离线程被终止\n1 2 3 4 5 6 7 8 9 void infinite_loop() { while (true) { /* 无限循环 */ } } int main() { std::thread t(infinite_loop); t.detach(); // 分离线程 return 0; // 主线程结束，进程终止，分离线程被强制终止 } 通过协作式退出条件终止\n为无限循环的线程设计退出条件，例如：\n使用原子变量或标志位通知线程退出。 通过条件变量或信号量控制循环终止。 示例：使用原子标志位终止线程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; std::atomic\u0026lt;bool\u0026gt; stop(false); // 原子标志位 void infinite_loop() { while (!stop) { // 检查退出条件 // 执行任务... } } int main() { std::thread t(infinite_loop); t.detach(); // 一段时间后通知线程退出 std::this_thread::sleep_for(std::chrono::seconds(5)); stop = true; // 设置退出标志 // 主线程继续运行... return 0; } 总结\n场景 线程如何终结？ 资源回收方式 分离线程正常结束 线程函数返回 操作系统自动回收 分离线程无限循环 进程终止时强制结束 操作系统强制回收 协作式退出条件 线程检测到退出条件后主动结束 操作系统自动回收 强制终止（不推荐） 调用平台特定 API（如 pthread_cancel） 可能泄漏资源 最佳实践：\n避免使用无限循环的分离线程，除非有明确的退出机制。 优先使用协作式退出条件（原子变量、条件变量等）。 确保线程内部资源（如动态内存、文件句柄）能被正确释放。 mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static mutex g_mutex; static void func() { g_mutex.lock(); cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; g_mutex.unlock(); } int main() { for (int i = 0; i \u0026lt; 10; i++) { thread t(func); t.detach(); } while (true){} return 0; } 10个线程同时输出，输出结果是乱的. 需要一个 mutex.\nstd::mutex 为什么这么神奇？\nlock 与 unlock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 伪代码展示内部逻辑 void mutex::lock() { // 第一步：用户态快速路径（无竞争） if (atomic_cas(state, 0, 1) == success) return; // 第二步：慢速路径（存在竞争） while (true) { if (atomic_cas(state, 0, 1) return; // 将线程加入等待队列（内核操作） futex_wait(\u0026amp;state, 1); // 当 unlock() 触发唤醒后，回到循环开始 } } void mutex::unlock() { atomic_store(state, 0); // 释放锁 futex_wake(\u0026amp;state, 1); // 唤醒一个等待线程 } 特性 说明 底层机制 依赖操作系统的同步原语（如 futex、CRITICAL_SECTION）和原子操作。 特殊性 独占性、不可递归、RAII 支持、不可复制。 线程对锁的“识别” 通过共享内存中的锁状态和操作系统调度实现。 解决竞争的原理 互斥访问临界区，保证原子性、可见性和有序性。 线程并发执行流程:\n时间 线程 t1 线程 t2 锁状态 (0x55a1a2b3c000) T0 调用 g_mtx.lock() 调用 g_mtx.lock() 0 → 1 (原子操作) T1 成功获取锁，进入临界区 自旋等待/进入内核阻塞 1 (锁定) T2 执行临界区代码 等待状态 1 T3 调用 g_mtx.unlock() 仍处于阻塞 1 → 0 (原子操作) T4 退出临界区 被唤醒，尝试重新获取锁 0 → 1 (原子操作) T5 线程结束 进入临界区 1 总结：全局锁的协同机制\n空间绑定：通过共享内存地址实现物理锁的可见性 原子操作：CPU 硬件保证状态修改的不可分割性 内核调度：操作系统管理线程的阻塞/唤醒队列 状态机转换： 锁定状态 → 修改内存值 + 维护等待队列 解锁状态 → 触发唤醒信号 这种三层次（硬件原子操作+内存共享+内核调度）的协作，使得看似简单的 lock/unlock 能够精确协调线程执行顺序。\n","date":"1074-01-04T13:05:38+08:00","permalink":"http://localhost:1313/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"C++多线程"},{"content":"C++ STL 库中使用的设计模式 C++ 标准模板库（STL）的设计以泛型编程为核心，但其中也巧妙融入了多种经典设计模式的思想。以下是 STL 中一些典型设计模式的应用及示例：\n1. 迭代器模式 (Iterator Pattern)\n目的：提供一种统一的方式遍历容器元素，无需暴露容器内部结构。 STL 实现： 所有容器（如 vector, list, map）均提供 begin() 和 end() 方法返回迭代器。 算法（如 for_each, copy）通过迭代器操作容器，与具体容器类型解耦。 1 2 3 4 5 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3}; // 使用迭代器遍历 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2. 适配器模式 (Adapter Pattern)\n目的：转换接口以兼容不同组件。 STL 实现： 容器适配器：stack, queue, priority_queue 基于底层容器（如 deque）适配接口。 迭代器适配器：reverse_iterator 反向遍历容器，back_insert_iterator 用于尾部插入。 1 2 3 4 // 基于 deque 实现栈 std::stack\u0026lt;int, std::deque\u0026lt;int\u0026gt;\u0026gt; stk; stk.push(1); stk.pop(); 3. 策略模式 (Strategy Pattern)\n目的：动态切换算法或策略。 STL 实现： 算法（如 sort, transform）通过函数对象（Functor）或 Lambda 接受自定义策略。 分配器（Allocator）允许自定义内存管理策略。 1 2 3 // 自定义排序策略：降序排列 std::vector\u0026lt;int\u0026gt; vec = {3, 1, 4}; std::sort(vec.begin(), vec.end(), [](int a, int b) { return a \u0026gt; b; }); 工厂方法模式 (Factory Method Pattern) 目的：将对象创建逻辑封装到子类。 STL 实现： 容器通过 emplace() 或 insert() 方法内部构造对象。 分配器（Allocator）的 allocate() 和 construct() 方法封装内存分配与对象构造。 1 2 3 std::allocator\u0026lt;int\u0026gt; alloc; int* p = alloc.allocate(1); // 分配内存 alloc.construct(p, 42); // 构造对象 模板方法模式 (Template Method Pattern) 目的：定义算法骨架，子类实现具体步骤。 STL 实现： 流库（\u0026lt;iomanip\u0026gt;）通过虚函数（如 std::streambuf::overflow()）定义流程，子类重写具体行为。 分配器提供统一接口，用户可自定义内存管理细节。 1 2 3 4 5 class CustomAllocator : public std::allocator\u0026lt;int\u0026gt; { public: // 自定义内存分配逻辑 int* allocate(size_t n) { /* ... */ } }; 享元模式 (Flyweight Pattern) 目的：共享细粒度对象以减少内存开销。 STL 实现： std::string 的短字符串优化（SSO）：小字符串直接存储在对象内部，大字符串使用堆内存。 std::function 通过类型擦除（Type Erasure）共享调用逻辑。 代理模式 (Proxy Pattern) 目的：通过代理对象控制对原对象的访问。 STL 实现： std::vector\u0026lt;bool\u0026gt; 的特化版本使用代理类压缩存储（每个 bool 占 1 bit）。 std::reference_wrapper 提供引用的代理，用于在容器中存储引用。 1 2 3 4 std::vector\u0026lt;std::reference_wrapper\u0026lt;int\u0026gt;\u0026gt; refs; int a = 1, b = 2; refs.push_back(a); refs.push_back(b); // 代理引用，避免拷贝 总结\n设计模式 STL 应用场景 关键技术 迭代器模式 容器遍历 (vector, map) 迭代器接口 (begin(), end()) 适配器模式 stack, queue, 反向迭代器 组合 + 接口转换 策略模式 算法自定义行为 (sort, transform) 函数对象 + Lambda 工厂方法模式 对象构造 (allocator, emplace()) 模板 + 分配器 模板方法模式 流缓冲区 (streambuf) 虚函数 + 继承 享元模式 std::string 优化 短字符串优化 (SSO) 代理模式 vector\u0026lt;bool\u0026gt;, reference_wrapper 特化模板 + 类型代理 关键点\n泛型编程优先：STL 通过模板和编译时多态实现灵活性，而非传统面向对象的多态。 模式隐式应用：许多模式以泛型方式实现（如策略模式通过模板参数传递函数对象）。 性能至上：STL 设计避免虚函数开销，强调零成本抽象（Zero-overhead Abstraction）。 理解这些模式在 STL 中的应用，能帮助你更高效地使用标准库，并在自定义组件时借鉴其设计思想。\n现代C++设计模式 一、创建型模式（5种） 1. 工厂方法模式 (Factory Method)\n核心思想：延迟对象创建到子类 解决问题：避免代码与具体类耦合\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename T\u0026gt; class Creator { public: virtual std::unique_ptr\u0026lt;T\u0026gt; create() = 0; }; class WidgetFactory : public Creator\u0026lt;Widget\u0026gt; { public: std::unique_ptr\u0026lt;Widget\u0026gt; create() override { return std::make_unique\u0026lt;ConcreteWidget\u0026gt;(); // 使用智能指针管理 } }; 2. 抽象工厂模式 (Abstract Factory)\n核心思想：创建相关对象家族 解决问题：跨平台UI组件生成\n1 2 3 4 5 6 7 8 9 10 11 12 class GUIFactory { public: virtual std::unique_ptr\u0026lt;Button\u0026gt; createButton() = 0; virtual std::unique_ptr\u0026lt;Menu\u0026gt; createMenu() = 0; }; class WinFactory : public GUIFactory { std::unique_ptr\u0026lt;Button\u0026gt; createButton() override { return std::make_unique\u0026lt;WinButton\u0026gt;(); } // ...其他方法 }; 3. 单例模式 (Singleton)\n核心思想：全局唯一实例 解决问题：配置管理、日志系统\n1 2 3 4 5 6 7 8 9 10 11 12 class Logger { public: static Logger\u0026amp; instance() { static Logger logger; // Meyer\u0026#39;s单例 (线程安全) return logger; } // 删除拷贝构造函数和赋值操作符 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; private: Logger() = default; }; 4. 建造者模式 (Builder)\n核心思想：分步构建复杂对象 解决问题：简化多参数对象构造\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Pizza { public: class Builder { public: Builder\u0026amp; setSize(int size) { /*...*/ return *this; } Builder\u0026amp; addTopping(const std::string\u0026amp; topping) { /*...*/ return *this; } Pizza build() { return Pizza{*this}; } }; private: Pizza(const Builder\u0026amp; builder) { /* 初始化逻辑 */ } }; // 使用示例 Pizza p = Pizza::Builder().setSize(12).addTopping(\u0026#34;Cheese\u0026#34;).build(); 5. 原型模式 (Prototype)\n核心思想：通过克隆创建对象 解决问题：避免重复初始化开销\n1 2 3 4 5 6 7 8 9 10 11 class Shape { public: virtual std::unique_ptr\u0026lt;Shape\u0026gt; clone() const = 0; }; class Circle : public Shape { public: std::unique_ptr\u0026lt;Shape\u0026gt; clone() const override { return std::make_unique\u0026lt;Circle\u0026gt;(*this); // 利用拷贝构造函数 } }; 二、结构型模式（7种） 6. 适配器模式 (Adapter)\n核心思想：转换接口兼容性 解决问题：整合旧版API\n1 2 3 4 5 6 7 8 9 10 11 12 13 class LegacyPrinter { public: void printDocument(const char* text) { /*...*/ } }; class PrinterAdapter { public: void print(const std::string\u0026amp; text) { legacy_.printDocument(text.c_str()); } private: LegacyPrinter legacy_; }; 7. 桥接模式 (Bridge)\n核心思想：分离抽象与实现 解决问题：多维度扩展问题\n1 2 3 4 5 6 7 8 9 10 11 12 class Renderer { // 实现部分 public: virtual void drawCircle(float x, float y, float radius) = 0; }; class Shape { // 抽象部分 public: Shape(Renderer\u0026amp; renderer) : renderer_(renderer) {} virtual void draw() = 0; protected: Renderer\u0026amp; renderer_; }; 8. 组合模式 (Composite)\n核心思想：统一处理树形结构 解决问题：文件系统管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FileSystemComponent { public: virtual void list(int indent = 0) const = 0; }; class Directory : public FileSystemComponent { public: void add(std::unique_ptr\u0026lt;FileSystemComponent\u0026gt; comp) { children_.push_back(std::move(comp)); } void list(int indent) const override { for (const auto\u0026amp; child : children_) { child-\u0026gt;list(indent + 2); } } private: std::vector\u0026lt;std::unique_ptr\u0026lt;FileSystemComponent\u0026gt;\u0026gt; children_; }; 9. 装饰器模式 (Decorator)\n核心思想：动态添加职责 解决问题：流处理增强\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class DataStream { public: virtual void write(const std::string\u0026amp; data) = 0; }; class CompressedStream : public DataStream { public: explicit CompressedStream(DataStream\u0026amp; stream) : stream_(stream) {} void write(const std::string\u0026amp; data) override { auto compressed = compress(data); stream_.write(compressed); } private: DataStream\u0026amp; stream_; }; 10. 外观模式 (Facade)\n核心思想：简化复杂子系统接口 解决问题：简化数据库操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 class DatabaseFacade { public: void executeQuery(const std::string\u0026amp; sql) { connection_.connect(); parser_.parse(sql); executor_.execute(); connection_.disconnect(); } private: ConnectionManager connection_; QueryParser parser_; QueryExecutor executor_; }; 11. 享元模式 (Flyweight)\n核心思想：共享细粒度对象 解决问题：大量重复对象的内存优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Font { public: Font(const std::string\u0026amp; name) : name_(name) { /*...*/ } // ...字体属性 }; class FontFactory { public: Font\u0026amp; getFont(const std::string\u0026amp; name) { auto it = fonts_.find(name); if (it == fonts_.end()) { it = fonts_.emplace(name, std::make_unique\u0026lt;Font\u0026gt;(name)).first; } return *it-\u0026gt;second; } private: std::unordered_map\u0026lt;std::string, std::unique_ptr\u0026lt;Font\u0026gt;\u0026gt; fonts_; }; 12. 代理模式 (Proxy)\n核心思想：控制对象访问 解决问题：延迟加载、权限控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Image { public: virtual void display() = 0; }; class RealImage : public Image { public: RealImage(const std::string\u0026amp; filename) { loadFromDisk(filename); } void display() override { /* 显示图片 */ } }; class ProxyImage : public Image { public: ProxyImage(const std::string\u0026amp; filename) : filename_(filename) {} void display() override { if (!realImage_) { realImage_ = std::make_unique\u0026lt;RealImage\u0026gt;(filename_); } realImage_-\u0026gt;display(); } private: std::unique_ptr\u0026lt;RealImage\u0026gt; realImage_; std::string filename_; }; 三、行为型模式（11种） （以下为部分实现示例）\n13. 策略模式 (Strategy)\n核心思想：封装可互换算法 解决问题：支付方式切换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using PaymentStrategy = std::function\u0026lt;bool(double)\u0026gt;; class PaymentProcessor { public: void setStrategy(PaymentStrategy strategy) { strategy_ = std::move(strategy); } bool processPayment(double amount) { return strategy_(amount); } private: PaymentStrategy strategy_; }; // 使用示例 PaymentProcessor processor; processor.setStrategy([](double amt) { /* 信用卡逻辑 */ return true; }); processor.processPayment(100.0); 14. 观察者模式 (Observer)\n核心思想：状态变更通知 解决问题：事件处理系统\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;typename T\u0026gt; class Observable { public: void subscribe(std::function\u0026lt;void(const T\u0026amp;)\u0026gt; observer) { observers_.push_back(std::move(observer)); } void notify(const T\u0026amp; data) { for (auto\u0026amp; obs : observers_) obs(data); } private: std::vector\u0026lt;std::function\u0026lt;void(const T\u0026amp;)\u0026gt;\u0026gt; observers_; }; // 使用示例 Observable\u0026lt;int\u0026gt; counter; counter.subscribe([](int value) { std::cout \u0026lt;\u0026lt; \u0026#34;Value changed: \u0026#34; \u0026lt;\u0026lt; value; }); counter.notify(42); 15. 命令模式 (Command)\n核心思想：将请求封装为对象 解决问题：撤销/重做功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class EditorCommand { public: virtual void execute() = 0; virtual void undo() = 0; }; class InsertCommand : public EditorCommand { public: InsertCommand(Document\u0026amp; doc, size_t pos, char c) : doc_(doc), pos_(pos), c_(c) {} void execute() override { doc_.insert(pos_, c_); } void undo() override { doc_.erase(pos_, 1); } private: Document\u0026amp; doc_; size_t pos_; char c_; }; 16. 模板方法模式 (Template Method)\n核心思想：定义算法骨架 解决问题：流程标准化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class DataExporter { public: void exportData() { openConnection(); fetchData(); formatData(); // 虚函数钩子 closeConnection(); } protected: virtual void formatData() = 0; // ...其他步骤实现 }; class CSVExporter : public DataExporter { protected: void formatData() override { /* CSV格式处理 */ } }; 17. 状态模式 (State)\n核心思想：封装状态行为 解决问题：订单状态流转\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class OrderState { public: virtual void handle(OrderContext\u0026amp; context) = 0; }; class OrderContext { public: void transitionTo(std::unique_ptr\u0026lt;OrderState\u0026gt; state) { state_ = std::move(state); } void process() { state_-\u0026gt;handle(*this); } private: std::unique_ptr\u0026lt;OrderState\u0026gt; state_; }; 四、现代C++关键优化技术 智能指针管理资源 std::unique_ptr/std::shared_ptr替代原始指针 Lambda表达式 替代小型策略类和命令对象 移动语义 优化对象传递效率 类型推导 (auto) 简化模板代码 可变参数模板 支持任意参数的工厂方法 std::function 统一回调接口 五、模式选择建议表 问题场景 推荐模式 现代C++特性应用 需要运行时算法切换 策略模式 std::function + lambda 需要撤销/重做功能 命令模式 智能指针管理命令历史 处理复杂对象创建流程 建造者模式 Fluent接口链式调用 需要优化大量相似对象 享元模式 unordered_map缓存管理 跨平台UI组件生成 抽象工厂模式 模板特化不同平台实现 通过结合现代C++特性，传统设计模式可以实现更简洁、更高效、更安全的代码结构。每个模式的核心价值在于解耦变化方向，而现代语言特性则提供了更优雅的实现手段。\n第一章 软件设计的艺术 什么是软件设计？为什么你应该关心它？\n在这一章中，我将为本书关于软件设计的内容奠定基础。我会解释什么是软件设计，帮助你理解为什么它是项目成功的关键因素，并且为什么它是你必须做对的一件事。同时，你会看到软件设计是非常复杂的，事实上，它是软件开发中最复杂的部分。因此，我还会介绍几种软件设计原则，帮助你在正确的道路上前行。\n准则1：理解软件设计的重要性\n在“准则1：理解软件设计的重要性”中，我会聚焦于大局观并解释软件预期会经历变化。因此，软件应该能够应对这些变化。然而，说起来容易做起来难，因为在现实中，耦合和依赖关系使得开发者的工作变得复杂得多。这些问题可以通过软件设计来解决。我将介绍软件设计作为管理依赖关系和抽象的艺术——这是软件工程的一个重要组成部分。\n准则2：为变化而设计\n在“准则2：为变化而设计”中，我将明确讨论耦合和依赖关系，并帮助你理解如何设计以适应变化，使软件更具适应性。为此，我将介绍单一职责原则（SRP）和不要重复自己（DRY）原则，这两个原则可以帮助你实现这一目标。\n单一职责原则 (SRP)：每个模块或类应只有一个改变的理由，即只负责一个功能。 不要重复自己 (DRY)：避免代码重复，确保逻辑只在一个地方实现。 准则3：分离接口以避免人为耦合\n在“准则3：分离接口以避免人为耦合”中，我会进一步讨论耦合问题，特别是通过接口产生的耦合。我还会介绍接口隔离原则（ISP），这是一种减少由接口引起的人为耦合的方法。\n接口隔离原则 (ISP)：客户端不应被迫依赖于它们不使用的接口。这意味着接口应该尽量小而具体，而不是大而泛。 准则4：为可测试性设计\n在“准则4：为可测试性设计”中，我会关注由于人为耦合导致的可测试性问题。特别是，我会提出如何测试私有成员函数的问题，并演示分离关注点的应用是唯一的解决方案。\n分离关注点：将不同功能分离到不同的模块或类中，以便更容易进行单元测试和集成测试。 准则5：为扩展性设计\n在“准则5：为扩展性设计”中，我会讨论一种重要的变化类型：扩展。就像代码应该易于更改一样，它也应该易于扩展。我会给你一些实现这一目标的想法，并展示开闭原则（OCP）的价值。\n开闭原则 (OCP)：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着你可以通过添加新功能来扩展系统，而不需要修改现有的代码。 准则1：理解软件设计的重要性 如果我问你哪些代码属性对你来说最重要，经过一些思考后，你可能会说诸如可读性、可测试性、可维护性、可扩展性、可复用性和可扩展性之类的东西。我完全同意。但是，如果我现在问你如何实现这些目标，很有可能你会开始列举一些C++特性：RAII、算法、lambda表达式、模块等等。\n特性不是软件设计\n是的，C++ 提供了很多特性。非常多！大约一半的近2000页印刷版C++标准都用于解释语言机制和特性。自C++11发布以来，有一个明确的承诺：每三年，C++标准化委员会都会给我们带来一个新的C++标准，其中包含额外的全新特性。鉴于此，C++社区非常强调特性和语言机制并不令人意外。大多数书籍、讲座和博客都集中在特性、新库和语言细节上。\n几乎感觉像是特性是用C++编程中最重要的东西，并且对C++项目的成功至关重要。但说实话，它们并不是。无论是对所有特性的了解还是C++标准的选择，都不是项目成功的关键因素,你不应该指望特性来拯救你的项目。相反，一个项目即使使用较旧的C++标准，甚至只使用可用特性的一小部分，也可以非常成功。撇开软件开发中的人为因素不谈，对于项目成败更重要的问题是软件的整体结构。\n最终，正是这种结构决定了可维护性：修改代码、扩展代码和测试代码有多容易？如果没有轻松修改代码、添加新功能并对其正确性有信心的能力，项目将走到生命周期的尽头。结构还决定了项目的可扩展性：项目在崩溃之前能增长到多大？在大家开始互相干扰之前，有多少人可以参与实现项目的愿景？\n整体结构就是项目的设计,设计在项目成功中的作用远比任何特性都要重要得多。好的软件不仅仅在于正确使用某个特性,而是关于坚实的架构和设计。良好的软件设计可以容忍一些糟糕的实现决策，但糟糕的软件设计不能仅靠英雄式的使用（旧或新的）特性来挽救。\n软件设计：管理依赖关系和抽象的艺术\n为什么软件设计对项目的质量如此重要？\n假设目前一切运行良好，只要软件没有变化且不需要添加新功能，你就可以高枕无忧。\n然而，这种状态通常不会持续很久，可以合理预期，某些事情将会发生变化，毕竟，在软件开发中唯一不变的就是变化，它是所有问题及解决方案背后的驱动力。\n这就是为什么软件被称为“软”件：因为它相对硬件来说是柔软且可塑的。尽管我们期望软件能轻松适应变化，但现实往往并非如此。\n为了说明这一点，假设你从问题跟踪系统中选择了一个评估为2的任务，无论2代表什么，它听起来都不是大任务，所以你有信心可以很快完成。\n怀着良好的愿望，你先理解预期要求，然后开始在一个实体A上进行修改。由于测试反馈（你很幸运有测试！），你很快意识到还需解决实体B的问题，这令人惊讶，因为你没预料到B会涉及其中。\n尽管如此，你还是继续调整B，然而，夜间构建显示这导致了C和D停止工作。深入调查后，你发现问题的根源遍布代码库的很大一部分。这个看似简单的任务已演变成大规模且高风险的代码修改。你解决问题的信心消失，本周的工作计划也被打乱。\n也许这个故事听起来很熟悉\n也许这个故事对你来说很熟悉，也许你甚至可以贡献一些你自己经历的“战争故事”。事实上，大多数开发者都有类似的经历。而这些经历的问题通常都源自同一个根源：依赖关系。正如Kent Beck在他的测试驱动开发一书中所表达的：\n依赖关系是所有规模软件开发中的关键问题。\n依赖关系是每个软件开发者存在的祸根 “但是当然会有依赖关系，” 你可能会争辩道，“总是会有依赖关系，否则不同的代码片段如何协同工作呢？” 当然，你是对的。不同的代码片段需要协同工作，这种交互总会产生某种形式的耦合。然而，虽然存在必要且不可避免的依赖关系，但也存在我们因缺乏对问题的理解、没有清晰的整体视角或只是不够注意而无意引入的人为依赖关系。不用说，这些人造依赖关系会带来麻烦，它们使得理解我们的软件、修改软件、添加新功能和编写测试变得更加困难。因此，作为软件开发者的主要任务之一（如果不是最重要的任务），就是尽量减少人为依赖关系。\n这种依赖关系的最小化是软件架构和设计的目标。用Robert C. Martin的话来说：\n软件架构的目标是将构建和维护所需系统所需的人力资源最小化。\n架构和设计是减少任何项目工作量所需的工具。它们处理依赖关系并通过抽象来降低复杂性。用我自己的话来说：\n软件设计是管理软件组件之间相互依赖的艺术。它旨在最小化人为（技术）依赖，并引入必要的抽象和妥协。\n是的，软件设计是一门艺术，它不是一门科学，也没有一套简单而明确的答案。很多时候，设计的整体图景会让我们难以捉摸，我们会被软件实体之间复杂的相互依赖所压倒，但我们试图应对这种复杂性，并通过引入适当的抽象来减少它。这样，我们将细节的层次保持在一个合理的水平。然而，很多时候团队中的个别开发者可能对架构和设计有不同的想法。我们可能无法实现自己对设计的愿景，并被迫做出妥协以继续前进。\n在前面的引用中，架构和设计这两个词可以互换使用，因为它们非常相似且目标相同。然而，它们并不是完全一样的，如果你看一下软件开发的三个层次，相似性和差异性就会变得清晰起来。\n软件开发的三个层次\n软件架构和软件设计是软件开发三个层次中的两个，第三个层次是实现细节。为了让你更直观地理解这三个层次，我们以建筑领域为例，类比架构、设计和实现细节的关系。假设你是一名建筑设计师（是的，不是坐在电脑前喝着咖啡的软件架构师，而是在工地现场的房屋建筑师）。你的职责包括：\n确保房屋与周围环境协调； 保证结构稳固性； 规划房间布局、管道系统等； 兼顾美观与功能性（例如宽敞的客厅、厨房与餐厅的便捷动线）。 这些工作属于架构和设计层面。两者的界限往往是模糊的——架构关注全局且难以后期更改的决策，而设计处理更细粒度的部分（如门窗位置）。但无论是架构还是设计，你都不会操心冰箱、电视的摆放或装饰细节——这些属于实现细节，对应软件开发中的具体编码实现。\n实现细节：最具体的层次\n在软件中，实现细节是如何解决问题的层面，涉及：\n选择C++标准或语言特性（如std::make_unique工厂函数、std::enable_if实现SFINAE）； 处理内存管理、异常安全和性能优化； 应用惯用法（如“复制-交换”惯用法、RAII）。 关键点：实现细节通常不引入抽象或解耦，而是通过封装（如RAII将资源管理与业务逻辑隔离）提升代码健壮性。\n软件设计：关注交互与可维护性\n软件设计聚焦于：\n可维护性、可扩展性、可测试性； 软件实体（类、函数）的物理与逻辑依赖关系； 应用设计模式（如访问者模式、策略模式、装饰模式）解耦复杂系统。 关键点：设计模式通常是语言无关的，帮助将复杂逻辑分解为可管理的模块。\n软件架构：模糊但关键的“大决策”\n软件架构是三个层次中最难定义的，但核心在于：\n制定难以后期更改的重大决策（如选择微服务架构或客户端-服务器架构）； 确保系统各部分变更时互不影响； 使用架构模式（如微服务、事件驱动）定义模块或组件间的结构与依赖。 关键洞见：\n“架构是你希望能在项目初期就正确决策，但实际未必比其他决策更容易正确。” ——Ralph Johnson\n挑战：随着微服务等技术的普及，“大”与“小”的界限变得模糊，架构常由项目中的核心开发者凭经验界定。\n惯用法：跨越层次的模式\n惯用法（Idiom）是语言特定的常见解决方案，可能属于设计或实现细节。例如：\n实现细节惯用法：RAII、复制-交换； 设计惯用法：非虚接口（NVI，基于模板方法模式）、Pimpl（基于桥接模式）。 核心区别：\n抽象（设计层）通过隐藏细节简化交互； 封装（实现层）通过集中管理逻辑提升安全性 对语言特性的过度关注\n如果软件架构和软件设计如此重要，为何C++社区却如此痴迷于语言特性？为何我们总营造一种错觉，认为C++标准、语言机制和特性能决定项目的成败？我认为有三个主要原因：\n第一，特性的复杂性与惯性塑造 C++语言特性数量庞大且细节复杂，社区需要大量时间讨论如何正确使用它们，建立对“良好实践”和“不良实践”的共识。我们需要共同塑造符合C++惯用法的编程文化。\n第二，对特性的错误期望 以C++20模块（Modules）为例——它无疑是自C++诞生以来最重大的技术革新之一，可能终结头文件包含的繁琐模式。但许多人误以为模块能修复代码的结构性问题，甚至拯救项目。然而，模块的作用是反映现有结构，而非改进设计。它无法掩盖设计缺陷，反而可能暴露问题。\n第三，软件设计的复杂性远超语言特性 相比软件设计中解耦实体、管理依赖的复杂性，语言特性的规则（无论有多少例外情况）更容易解释。关于特性的问题通常有明确答案，而软件设计的答案往往是 “视情况而定”。如何让代码更可维护、可扩展、可测试，高度依赖项目具体情境。正如那句名言：\n“设计与编程是人类活动；忘记这一点，一切将失去意义。”\n为何我们仍需关注特性？\n这三个原因共同导致了社区对特性的过度关注。但请注意，特性本身并非不重要。正确理解和使用它们至关重要，但仅凭特性无法拯救项目。\n回归软件设计与原则的核心\n特性固然重要，但软件设计才是项目成功的基石。本书将聚焦于：\n软件设计决策背后的逻辑； 设计原则（如SOLID、DRY）； 依赖管理与抽象设计； 现代C++代码的合理应用（如C++20概念），而非盲目追求noexcept或滥用constexpr。 关键结论\n优秀的软件开发者必须深入理解软件设计。因为：\n优秀软件成本低廉，糟糕软件代价高昂； 语言特性是工具，设计能力才是核心竞争力； 真正的挑战在于平衡特性使用与设计决策，构建可持续演进的系统。 本节总结\n将软件设计视为编写软件的一个重要部分。 减少对C++语言细节的关注，更多地关注软件设计。 避免不必要的耦合和依赖，使软件更能适应频繁的变化。 理解软件设计是管理依赖关系和抽象的艺术。认识到软件设计与软件架构之间的界限是流动的。 准则 2：为变化而设计 优秀软件的核心特征之一是易变更性。这一特性甚至隐含在\u0026quot;软件\u0026quot;（software）一词中——与硬件（hardware）不同，软件应能轻松适应需求变化（参见准则 1：理解软件设计的重要性）。然而，实际开发中我们常发现：看似简单的代码变更，往往需要耗费数天甚至数周。\n分离关注点\n降低人为耦合、简化变更的最佳实践是分离关注点。其核心思想是：\n将功能拆分为高内聚、低耦合的独立模块，每个模块专注单一职责。 ——《程序员修炼之道》\n这种思想通过不同术语被反复强调：\n正交性（Orthogonality）：分离软件中正交的维度 内聚性（Cohesion）：模块内部元素的关联强度（高内聚模块应作为整体处理） 单一职责原则（SRP）：一个类只有一个变更理由 关键洞察：\n将因不同原因而变化的部分分离 仅将真正相关的内容聚合 减少人为耦合，使变更只需修改一处 人为耦合的代码示例\n1 2 3 4 5 6 7 8 9 10 //#include \u0026lt;some_json_library.h\u0026gt; // Potential physical dependency class Document { public: // ... virtual ~Document() = default; virtual void exportToJSON( /*...*/ ) const = 0; virtual void serialize( ByteStream\u0026amp;, /*...*/ ) const = 0; // ... }; 看似合理的设计：\n基类提供exportToJSON()和serialize()等通用功能 派生类（如PDF、Word文档）实现具体逻辑 用户无需了解具体文档类型即可操作 实际隐藏的三大耦合问题：\n1. 第三方库的强制绑定\nJSON导出的陷阱： 每个派生类必须实现exportToJSON()，导致强制依赖某个JSON库（如rapidjson或simdjson）\n1 2 3 4 5 6 7 class PDFDocument : public Document { public: void exportToJSON() const override { rapidjson::Document json; // 直接依赖特定JSON库 // 实现细节... } }; 后果： 所有文档类型被同一JSON库绑定 更换库需修改所有派生类 系统变得臃肿，复用性降低 2. 接口签名泄漏实现细节\n隐式耦合示例： 假设exportToJSON()参数设计受限于当前JSON库：\n1 virtual void exportToJSON(rapidjson::PrettyWriter\u0026amp; writer) const = 0; 后果： 更换JSON库时，接口签名被迫修改 所有调用方代码需同步调整 变更影响范围超出预期 3. 序列化与文档类型的全局耦合\n枚举导致的连锁反应： 序列化需要标识文档类型，引入全局枚举：\n1 enum class DocumentType { pdf, word, /*...*/ }; 派生类实现序列化时依赖此枚举： 1 2 3 4 void PDFDocument::serialize(ByteStream\u0026amp; stream) const { stream.write(static_cast\u0026lt;int\u0026gt;(DocumentType::pdf)); // 所有文档类知晓其他类型 // 其他序列化逻辑... } 后果： 添加新文档类型需修改全局枚举 所有现有文档类的序列化逻辑被影响 违反开闭原则（对扩展开放，对修改关闭） 设计缺陷总结\n问题类型 引发原因 维护代价 第三方库绑定 派生类直接实现具体库逻辑 更换技术栈需全量重写 接口泄漏实现细节 接口参数与特定库强关联 调用方代码随实现库变更而修改 全局类型耦合 序列化依赖共享枚举 新增类型导致连锁代码修改 优化方向：解耦设计\n分离数据与操作\n将JSON导出、序列化等能力拆分为独立组件 1 2 3 4 5 6 class JSONExporter { // 独立JSON处理类 public: virtual void export(const Document\u0026amp; doc) = 0; }; class PDFDocument : public Document { /*...*/ }; // 不再实现JSON逻辑 依赖注入取代继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 class DocumentProcessor { public: DocumentProcessor(JSONExporter\u0026amp; exporter, Serializer\u0026amp; serializer) : exporter_(exporter), serializer_(serializer) {} void process(const Document\u0026amp; doc) { exporter_.export(doc); serializer_.serialize(doc); } private: JSONExporter\u0026amp; exporter_; Serializer\u0026amp; serializer_; }; 使用适配器模式隔离第三方库\n1 2 3 4 5 6 7 class RapidJSONAdapter : public JSONExporter { public: void export(const Document\u0026amp; doc) override { rapidjson::Document json; // 转换逻辑封装在此 } }; 关键启示\n警惕\u0026quot;全能基类\u0026quot;：继承不是代码复用的唯一手段 延迟技术决策：通过抽象层隔离具体实现细节 正交性设计：确保不同功能维度相互独立，变更互不影响 \u0026ldquo;好的系统设计不是避免变更，而是让变更发生在正确的地方。\u0026rdquo; ——《领域驱动设计》\n我应该明确指出，Document 类对选定 JSON 库存在潜在的物理依赖。\n如果 \u0026lt;Document.h\u0026gt; 头文件包含了所选 JSON 库中的任何头文件（如“人工耦合的例子”代码片段所示），\n例如因为 exportToJSON() 函数期望基于该库的一些参数，那么就存在对该库的明确依赖。\n然而，如果接口能够正确抽象这些细节，并且 \u0026lt;Document.h\u0026gt; 头文件不包含来自 JSON 库的任何内容，那么这种物理依赖可能会被避免。\n因此，这取决于依赖关系能否被（以及如何被）良好地抽象。\n“高层次、低层次——我现在有点糊涂了，”你抱怨道。是的，我知道这两个术语通常会让人感到困惑。在我们继续之前，先让我们明确这两个术语的定义。\n这两个术语的起源与我们用统一建模语言（UML）绘制图表的方式有关：我们认为稳定的功能出现在顶部（高层次），而更常变化、具有可变性或可塑性的功能出现在底部（低层次）。\n遗憾的是，当我们绘制架构图时，通常会试图展示各部分如何相互构建，因此最稳定的部分会出现在架构的底部。这自然会引起一些混淆。\n不论如何绘制，请记住这两个术语：高层次指的是架构中稳定的部分，低层次指的是更常变化或更可能变化的方面。\n回到问题本身：单一职责原则（SRP）建议我们分离关注点和那些不属于同一职责的部分，即缺乏内聚性的部分。换句话说，它建议我们将因不同原因而变化的部分分离为变化点。\n根据这一建议，Document类被重构如下：\n1 2 3 4 5 6 7 8 9 class Document { public: // ... virtual ~Document() = default; // 不再有\u0026#39;exportToJSON()\u0026#39;和\u0026#39;serialize()\u0026#39;函数 // 仅保留不会导致强耦合的最基本文档操作 // ... }; JSON和序列化方面不再属于Document类的核心功能。\nDocument类应仅代表不同类型文档的最基本操作，所有正交关注点都应被分离，这将使修改更加容易。\n例如，通过将JSON方面隔离为一个独立的变化点和新JSON组件，更换JSON库只会影响该组件。\n修改可以集中在一个地方进行，与其他正交关注点完全隔离。\n同时，使用多个JSON库支持JSON格式也会更简单。\n此外，任何关于文档序列化的修改只会影响代码中的一个组件：新的序列化组件。序列化组件将作为变化点，实现隔离且简单的修改。这是最理想的情况。\n虽然你对Document示例最初感到失望，但现在似乎又有了信心，也许你脸上还带着\u0026quot;我早该想到！\u0026ldquo;的微笑。\n但你仍未完全满意：\u0026ldquo;是的，我认同分离关注点的总体思路，但如何在软件结构中实现这种分离？具体该怎么做？\u0026ldquo;这是一个极好的问题，但答案众多，我将在后续章节中逐一解答，最关键的第一步是识别变化点，即代码中预期会发生变化的部分。这些变化点应被提取、隔离和封装，消除对这些变化的依赖。这将最终使修改更容易。\n\u0026ldquo;但这仍只是表面建议！\u0026ldquo;你说得对，遗憾的是，没有唯一或简单的答案，具体情况具体分析，但我承诺在后续章节中给出许多具体方案（毕竟这是一本关于软件设计——管理依赖关系的书）。\n作为预告，第3章将介绍解决这一问题的通用实用方法：设计模式。通过访问者模式、策略模式、外部多态等模式，我将展示如何分离关注点。这些模式各有优缺点，但共同点是通过引入抽象来减少依赖。此外，我将详细探讨如何在现代C++中实现这些模式。\n不要重复自己（DRY原则）\n可修改性还有第二个重要方面。为说明这一点，我将引入另一个示例：物品类层次结构。\n层次结构的顶端是Item基类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //---- \u0026lt;Money.h\u0026gt; ---------------- class Money { /*...*/ }; Money operator*( Money money, double factor ); Money operator+( Money lhs, Money rhs ); //---- \u0026lt;Item.h\u0026gt; ---------------- #include \u0026lt;Money.h\u0026gt; class Item { public: virtual ~Item() = default; virtual Money price() const = 0; }; Item基类代表具有价格标签（由Money类表示）的各类物品的抽象。\n通过price()函数可以查询价格。虽然实际可能有多种物品，但为简化说明，我们仅以CppBook和ConferenceTicket为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //---- \u0026lt;CppBook.h\u0026gt; ---------------- #include \u0026lt;Item.h\u0026gt; #include \u0026lt;Money.h\u0026gt; #include \u0026lt;string\u0026gt; class CppBook : public Item { public: explicit CppBook( std::string title, std::string author, Money price ) : title_( std::move(title) ) , author_( std::move(author) ) , priceWithTax_( price * 1.15 ) // 15%税率 {} std::string const\u0026amp; title() const { return title_; } std::string const\u0026amp; author() const { return author_; } Money price() const override { return priceWithTax_; } private: std::string title_; std::string author_; Money priceWithTax_; }; CppBook类的构造函数接收书名、作者（字符串形式）和价格（Money形式）。它通过title()、author()和price()函数提供访问接口。特别的是price()函数：由于书籍需缴税，原始价格需按15%税率调整。\nConferenceTicket类是第二个Item示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //---- \u0026lt;ConferenceTicket.h\u0026gt; ---------------- #include \u0026lt;Item.h\u0026gt; #include \u0026lt;Money.h\u0026gt; #include \u0026lt;string\u0026gt; class ConferenceTicket : public Item { public: explicit ConferenceTicket( std::string name, Money price ) : name_( std::move(name) ) , priceWithTax_( price * 1.15 ) // 15%税率 {} std::string const\u0026amp; name() const { return name_; } Money price() const override { return priceWithTax_; } private: std::string name_; Money priceWithTax_; }; ConferenceTicket与CppBook类似，但构造函数只需会议名称和价格。同样，会议门票价格也按15%税率调整。\n通过这个设计，我们可以在main()函数中创建多个物品并计算总价：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;CppBook.h\u0026gt; #include \u0026lt;ConferenceTicket.h\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;std::unique_ptr\u0026lt;Item\u0026gt;\u0026gt; items{}; items.emplace_back( std::make_unique\u0026lt;CppBook\u0026gt;(\u0026#34;Effective C++\u0026#34;, 19.99) ); items.emplace_back( std::make_unique\u0026lt;CppBook\u0026gt;(\u0026#34;C++ Templates\u0026#34;, 49.99) ); items.emplace_back( std::make_unique\u0026lt;ConferenceTicket\u0026gt;(\u0026#34;CppCon\u0026#34;, 999.0) ); items.emplace_back( std::make_unique\u0026lt;ConferenceTicket\u0026gt;(\u0026#34;Meeting C++\u0026#34;, 699.0) ); items.emplace_back( std::make_unique\u0026lt;ConferenceTicket\u0026gt;(\u0026#34;C++ on Sea\u0026#34;, 499.0) ); Money const total_price = std::accumulate( begin(items), end(items), Money{}, []( Money accu, auto const\u0026amp; item ){ return accu + item-\u0026gt;price(); } ); // ... return EXIT_SUCCESS; } 在main()中创建了两个书籍和三个会议门票，并计算含税总价。这看似良好的设计实现了关注点分离，每个物品类独立处理价格计算，符合SRP原则并隔离了变化点。然而，该设计存在重大缺陷：税率变更将影响所有派生类。例如，若税率从15%调整为12%或16%，需要修改每个类的计算逻辑，导致改动遍布代码库。\n正如SRP建议分离变化点，我们还应避免在代码库中重复信息。每个职责应在系统中仅存在一次，这就是\u0026quot;不要重复自己\u0026rdquo;（DRY）原则。理想情况下，税率应仅在一处表示，便于统一修改。SRP与DRY通常相辅相成，但有时需要额外步骤来实现两者。我将在后续章节（参见\u0026quot;准则35：使用装饰器实现层次化定制\u0026rdquo;）详细探讨该问题的解决方案。\n避免过早的分离关注点\n在这一点上，我希望已经说服你遵守 SRP（单一职责原则）和 DRY（不要重复自己）是一个非常合理的想法。\n你甚至可能会如此坚定地计划将所有类和函数分离成最小的功能单元，毕竟，这就是目标，对吧？如果你现在正在这么想，请停下来！深呼吸一下。再来一次。然后请仔细聆听 Katerina Trajchevska 的智慧：\n“不要试图实现 SOLID，而是用 SOLID 来实现可维护性。”\nSRP 和 DRY 都是你实现更好可维护性和简化变更的工具，而不是你的目标，虽然从长远来看这两者都非常重要，但在没有明确了解哪些变化会影响你的情况下分离实体可能会适得其反。\n为变化而设计通常有利于某一种特定的变化，但不幸的是，这可能会使其他种类的变化变得更加困难。这种理念是众所周知的 YAGNI 原则（You Aren’t Gonna Need It，你不会需要它）的一部分，该原则警告你避免过度设计（参见“指导原则 5：为扩展而设计”）。\n如果你有一个明确的计划，并且知道预期的变化类型，那么应用 SRP 和 DRY 来简化那种变化。然而，如果你不知道会有什么样的变化，请不要猜测——只需等待，等到你清楚地知道预期的变化类型，然后再进行重构以使变化尽可能简单。\n总之，软件中的变化是预期的，因此为变化而设计是至关重要的。分离关注点并最小化重复，以便你可以轻松地进行更改，而不必担心会破坏其他正交的方面。\n本节总结\n预期软件中的变化。 为易于更改而设计，使软件更具适应性。 避免将不相关的正交方面组合在一起，以防止耦合。 理解耦合增加了变更的可能性，并使变更更加困难。 遵循单一职责原则（SRP）来分离关注点。 遵守不要重复自己（DRY）原则以最小化重复。 如果你不确定下一次变更，避免过早抽象。 准则3：分离接口以避免人为耦合 接口隔离：解耦正交功能\n让我们重新审视准则2：为变更而设计中的Document类案例。尽管已拆分JSON导出和序列化功能，但接口设计仍存在更深层的耦合问题。\n问题：全能接口引发的连锁反应\n原Document接口强制派生类实现所有方法：\n1 2 3 4 5 6 7 class Document { public: virtual ~Document() = default; virtual void exportToJSON(/*...*/) const = 0; // JSON导出 virtual void serialize(ByteStream\u0026amp;, /*...*/) const = 0; // 序列化 // ... 其他方法 }; 缺陷示例：\n1 2 3 void exportDocument(const Document\u0026amp; doc) { doc.exportToJSON(/*...*/); // 仅需JSON导出功能 } 隐性依赖： exportDocument()函数被迫依赖Document的所有接口（包括无关的serialize()） 修改ByteStream类或serialize()签名会导致所有Document用户重新编译 新增接口（如XML导出）会波及所有客户端代码 解决方案：接口隔离原则（ISP）\n核心思想：\n客户端不应被迫依赖其不使用的方法。\n重构步骤：\n拆分正交接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // JSON导出能力 class JSONExportable { public: virtual ~JSONExportable() = default; virtual void exportToJSON(/*...*/) const = 0; }; // 序列化能力 class Serializable { public: virtual ~Serializable() = default; virtual void serialize(ByteStream\u0026amp;, /*...*/) const = 0; }; // 组合式Document接口 class Document : public JSONExportable, public Serializable { public: // ... 其他基础功能 }; 客户端按需依赖 cpp\n复制\n1 2 3 void exportDocument(const JSONExportable\u0026amp; exportable) { exportable.exportToJSON(/*...*/); // 仅依赖所需接口 } 优势：\n解耦编译依赖：修改Serializable不影响仅使用JSONExportable的客户端 接口扩展安全：新增接口（如XMLExportable）不会导致现有客户端被迫适配 符合SRP：每个接口专注单一能力维度 ISP与SRP的关系\n原则 关注点 应用场景 SRP 类/模块的职责单一性 整体架构设计 ISP 接口方法的正交性 接口抽象层设计 关键洞察：\nISP是SRP在接口设计中的特例 违反ISP必然违反SRP，但反之不成立 接口聚合的诱惑普遍存在（如\u0026quot;全能基类\u0026rdquo;），需通过设计评审提前规避 模板设计中的ISP思想\nISP不仅适用于面向对象设计，也影响模板编程。以std::copy为例：\n不良设计：过度约束迭代器类型\n1 2 template\u0026lt;typename ForwardIt\u0026gt; void copy(ForwardIt first, ForwardIt last, ForwardIt d_first); // 要求前向迭代器 问题：无法适配输入流迭代器（仅支持单向遍历） 优化设计：最小化模板约束\n1 2 template\u0026lt;typename InputIt, typename OutputIt\u0026gt; void copy(InputIt first, InputIt last, OutputIt d_first); // 仅要求输入/输出迭代器 C++20概念增强：\n1 2 template\u0026lt;std::input_iterator InputIt, std::output_iterator OutputIt\u0026gt; OutputIt copy(InputIt first, InputIt last, OutputIt d_first); 设计启示：\n精准表达需求：模板参数仅声明必要操作（如input_iterator只需++和*） 提升泛用性：支持更广泛的适配器（如文件流、网络流迭代器） 减少隐式依赖：避免强制用户实现无关接口 最佳实践清单\n接口设计时： 为每个正交功能维度定义独立接口 通过多重继承组合复杂能力（而非单一庞大接口） 客户端编码时： 依赖最具体的接口类型（如JSONExportable而非Document） 模板设计时： 使用C++概念精准约束模板参数 优先选择最宽松的迭代器类别（输入/输出迭代器 \u0026gt; 前向迭代器） 重构策略： 识别被强制实现的\u0026quot;空方法\u0026rdquo;（如抛出异常），提示接口需拆分 使用适配器模式包装遗留接口，逐步迁移 \u0026ldquo;良好的接口设计如同精确的手术刀——只切开必要的部分，保持其他组织的完整。\u0026rdquo; ——《C++软件设计》\n本节总结\n注意耦合也会影响接口。 遵守接口隔离原则（ISP）以分离接口中的关注点。 将 ISP 视为单一职责原则（SRP）的一个特例。 理解 ISP 既适用于继承层次结构，也适用于模板。 准则4：为可测试性而设计 正如准则1：理解软件设计的重要性所述，软件必然面临变更。但每次修改都可能意外破坏现有功能——尽管我们尽力避免，风险始终存在。作为开发者，我们依赖测试作为安全网：\n测试是软件变更的保护层，是确保功能完整性的救生衣。\n然而，编写测试的前提是软件必须可测试。本准则将揭示如何通过设计提升可测试性。\n挑战：如何测试私有成员函数？\n考虑以下Widget类，其私有方法updateCollection()需要测试：\n1 2 3 4 5 6 class Widget { private: void updateCollection(/*参数*/); // 需测试的私有方法 std::vector\u0026lt;Blob\u0026gt; blobs_; // 数据成员 // ... 其他可能的数据成员 }; 常见错误方案：\n白盒测试：通过公有方法间接测试\n1 2 3 4 void addBlob(const Blob\u0026amp; blob) { // ... updateCollection(); // 内部调用私有方法 } 问题：测试依赖实现细节，实现变更会导致测试失效。\n友元类：授予测试类特殊权限\n1 2 3 4 5 class Widget { friend class TestWidget; // 声明测试类为友元 private: void updateCollection(); }; 问题：生产代码反向依赖测试代码，形成循环依赖。\n继承暴露：将方法改为protected并派生测试类\n1 2 3 class TestWidget : private Widget { // 通过继承访问protected方法 void testUpdate() { updateCollection(); } }; 问题：滥用继承机制，破坏封装性。\n终极方案：关注点分离\n核心思想：将需测试的功能从类中解耦，使其独立可测。\n方案1：提取为自由函数\n1 2 3 4 5 6 7 8 9 10 // 将更新逻辑提取为独立函数 void updateCollection(std::vector\u0026lt;Blob\u0026gt;\u0026amp; blobs, /*参数*/) { // 实现原私有方法逻辑 } class Widget { private: std::vector\u0026lt;Blob\u0026gt; blobs_; // 数据成员仍封装在类内 // 调用方式：updateCollection(blobs_, ...); }; 优势：\n直接测试：无需依赖Widget类即可测试updateCollection 增强封装：自由函数仅能通过公有接口访问数据，减少对私有成员的暴露 方案2：封装为独立类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 namespace widget_details { // 细节命名空间隔离实现 class BlobCollection { public: void updateCollection(/*参数*/); // 公开可测试方法 private: std::vector\u0026lt;Blob\u0026gt; blobs_; }; } // namespace widget_details class Widget { private: widget_details::BlobCollection blobs_; // 组合代替继承 }; 优势：\n职责清晰：BlobCollection专注集合管理，符合SRP 测试友好：可直接实例化BlobCollection进行单元测试 设计原则的协同效应\n原则 应用场景 收益 SRP 分离集合管理与Widget核心逻辑 功能变更互不影响 封装性 限制自由函数/类对私有数据的访问 降低意外修改风险 组合优于继承 使用BlobCollection组合 避免继承链的脆弱性 关键实践建议\n警惕\u0026quot;测试后门\u0026rdquo;： 避免使用友元、继承或预处理宏破坏封装 优先通过设计而非权限突破实现可测试性 函数提取标准： 当私有方法逻辑复杂到需要独立测试时，即应解耦 虚函数需特殊处理（后续章节讨论） 测试驱动设计(TDD)： 编写测试前思考：如何最小化被测单元的外部依赖？ 通过测试用例反推模块边界是否合理 \u0026ldquo;可测试性不是事后补救，而是优秀设计的自然结果。\u0026rdquo; ——《修改代码的艺术》\n从封装性看函数提取\nScott Meyers在《Effective C++》中指出：\n优先选择非成员非友元函数\n成员函数可访问所有私有成员，削弱封装 自由函数仅通过公有接口交互，增强封装 示例对比：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 方案A：成员函数 class WidgetA { public: void update() { /* 直接访问blobs_ */ } private: std::vector\u0026lt;Blob\u0026gt; blobs_; }; // 方案B：自由函数 class WidgetB { public: std::vector\u0026lt;Blob\u0026gt;\u0026amp; getBlobs() { return blobs_; } private: std::vector\u0026lt;Blob\u0026gt; blobs_; }; void update(WidgetB\u0026amp; widget) { /* 通过getBlobs()访问 */ } 方案B中，update函数无法直接访问blobs_，必须通过公有接口，封装性更优。 本节总结\n测试即设计指标：难以测试的代码往往暗示设计缺陷 解耦为王：通过分离关注点使组件独立可测 平衡之道：在封装性与可测试性间寻找最优解 工具辅助：利用依赖注入、策略模式等提升可测试性（后续章节详解） 通过本准则，我们学会将可测试性融入设计DNA，让变更更安全、系统更健壮。\n准则5：为扩展而设计 关于软件变更，还有一个重要方面尚未强调：可扩展性。可扩展性应成为设计的首要目标。因为坦率地说，若代码无法添加新功能，就意味着其生命周期的终结。因此，添加新功能——扩展代码库——具有根本重要性。正因如此，可扩展性理应成为优秀软件设计的核心目标与驱动力。\n开放-封闭原则（OCP）\n可扩展性不会凭空实现，而是需要在设计时显式考虑。回顾\u0026quot;准则2：为变化而设计\u0026quot;中的文档序列化示例，我们曾使用带有纯虚函数serialize()的Document基类：\n1 2 3 4 5 6 7 8 class Document { public: // ... virtual ~Document() = default; virtual void serialize( ByteStream\u0026amp; bs, /*...*/ ) const = 0; // ... }; 派生类（如PDF）需实现serialize()：\n1 2 3 4 5 6 7 class PDF : public Document { public: // ... void serialize( ByteStream\u0026amp; bs, /*...*/ ) const override; // ... }; 关键问题在于如何实现序列化。为实现反序列化，需在字节流开头存储文档类型标识。我们曾使用枚举类型：\n1 2 3 4 5 6 enum class DocumentType { pdf, word, // ... 更多文档类型 }; 但此设计导致所有文档类（PDF、Word等）耦合于同一枚举。当新增XML文档类型时，必须修改枚举：\n1 2 3 4 5 6 7 enum class DocumentType { pdf, word, xml, // 新增类型 // ... }; 这会导致所有现有文档类重新编译，且限制了外部扩展能力（无法修改枚举则无法添加新类型）。这显然违反了开放-封闭原则（OCP）——软件实体应对扩展开放，对修改关闭。\n解决方案：分离关注点\n通过将序列化逻辑提取为独立组件（如图1-6所示），我们解除了文档类型间的耦合：\n序列化组件依赖所有文档类型，但文档类型彼此独立。新增XML类时，仅需在序列化组件中处理新类型，无需修改现有文档类。这种自下而上的依赖符合架构层级原则——低层组件可依赖高层组件，反之则不然。\n编译期扩展性\n扩展性设计同样适用于编译期多态。C++标准库通过以下方式实现扩展性：\n函数重载 std::swap允许为自定义类型特化交换逻辑：\n1 2 3 4 5 6 7 8 9 namespace custom { class CustomType { /*...*/ }; void swap(CustomType\u0026amp; a, CustomType\u0026amp; b) { /* 定制实现 */ } } // 使用方式： using std::swap; // 启用ADL查找 swap(a, b); // 优先调用定制版本 模板与概念 标准算法（如std::find）通过模板参数接受自定义迭代器和谓词：\n1 2 3 4 5 template\u0026lt;typename InputIt, typename T\u0026gt; InputIt find(InputIt first, InputIt last, const T\u0026amp; value); template\u0026lt;typename InputIt, typename UnaryPredicate\u0026gt; InputIt find_if(InputIt first, InputIt last, UnaryPredicate p); 模板特化 std::hash允许为自定义类型特化哈希计算：\n1 2 3 4 5 6 template\u0026lt;\u0026gt; struct std::hash\u0026lt;CustomType\u0026gt; { size_t operator()(const CustomType\u0026amp; v) const noexcept { return /* 定制哈希计算 */; } }; 避免过度设计\n尽管可扩展性至关重要，但需警惕过早抽象。遵循YAGNI（You Ain\u0026rsquo;t Gonna Need It）原则：若不确定未来需求，优先保持简单。过度设计可能导致：\n不必要的复杂性 限制未来扩展方向（如偏重类型扩展却阻碍操作扩展） 平衡策略：\n明确预期扩展点时，预先设计扩展接口 不确定时，通过重构逐步引入扩展机制 准则5要点\n✅ 提倡\n采用开放-封闭原则（OCP），通过基类、模板、重载或特化支持扩展 识别预期扩展点并设计易扩展结构 ❌ 避免\n修改现有代码实现扩展（违反OCP） 不确定需求时的过度抽象 核心提示： 可扩展性是可持续软件的关键。通过分离关注点、合理使用多态与模板机制，构建适应演进的系统架构。\n本节总结\n优先设计便于扩展代码。 遵守开放封闭原则（OCP），使代码对扩展开放，但对修改关闭。 通过基类、模板、函数重载或模板特化来设计以支持代码添加。 如果你不确定下一个添加是什么，请避免过早抽象。 第二章 建立抽象的艺术 抽象在软件设计与架构中的核心地位\n抽象是软件设计与架构的基石。优秀的抽象是管理复杂性的关键，没有它们，良好的设计与合理的架构将无从谈起。然而，构建并正确运用抽象绝非易事——这更像是一门艺术而非精确科学，充满了精妙权衡。本章将深入探讨抽象的本质及其构建之道。\n准则6：遵循抽象的预期行为\n抽象的本质在于表达一组需求与契约。每个抽象背后都隐含了特定的行为承诺，遵循这些预期是维护系统一致性的关键。本准则将引入 里氏替换原则(LSP)，阐释为何子类必须完全遵循基类的行为契约。\n准则7：理解基类与概念的共性\n作为最常用的两种抽象机制，基类（继承) 与 概念(模板约束) 在语义层面具有深层相似性。二者都能定义行为规范，但实现方式迥异。本准则将对比二者的共性与差异，揭示抽象表达的普适规律。\n准则8：把握重载集合的语义契约\n函数重载构成第三种抽象形式。每个重载函数都需遵循重载集合的语义契约，其行为必须满足调用方的统一预期。本准则将扩展LSP原则，探讨重载机制中的行为一致性要求。\n准则9：关注抽象的所有权归属\n从架构视角看，抽象的所有权归属直接影响系统结构。本准则引入依赖倒置原则（DIP），阐明如何通过抽象实现层级解耦。仅引入抽象并不足够——必须确保高层模块拥有抽象定义，低层实现依赖高层接口。\n准则10：构建架构设计文档\n架构设计文档是抽象体系的蓝图。本准则将探讨文档化的价值：明确抽象边界、记录设计决策、促进团队共识。即使采用轻量级形式，架构文档也能显著提升系统的可维护性与演进能力。\n抽象构建的艺术在于平衡表达力与约束力。通过这五大准则，我们将逐步掌握定义精确契约、管理依赖方向、实现可持续演进的实践方法。每一层精心设计的抽象，都是对抗软件熵增的坚实屏障。\n准则6：遵循抽象的预期行为 解耦软件的核心在于引入抽象，而构建良好的抽象却充满挑战。本节通过经典示例揭示抽象行为预期的重要性，并阐释 里氏替换原则(LSP) 的核心要义。\n违反行为预期的典型案例\n考虑一个Rectangle基类：\n1 2 3 4 5 6 7 8 9 10 11 12 class Rectangle { public: virtual ~Rectangle() = default; int getWidth() const; int getHeight() const; virtual void setWidth(int); virtual void setHeight(int); virtual int getArea() const; private: int width; int height; }; 作为基类，提供虚析构函数确保多态正确性 包含宽高属性和对应的访问/修改方法 setWidth与setHeight可独立修改维度 getArea返回宽高乘积 派生类Square继承Rectangle：\n1 2 3 4 5 6 class Square : public Rectangle { public: void setWidth(int) override; void setHeight(int) override; int getArea() const override; }; 数学上正方形是矩形特例，但代码实现需保持宽高相等 重写setWidth和setHeight同步修改另一维度 问题爆发点：\n1 2 3 4 5 6 7 8 9 10 11 void transform(Rectangle\u0026amp; rect) { rect.setWidth(7); rect.setHeight(4); assert(rect.getArea() == 28); // 断言失败！ } int main() { Square s; s.setWidth(6); transform(s); // 传入正方形实例 } transform函数预期独立修改宽高后面积为28 传入Square时，两次set调用强制同步宽高，导致面积计算错误 里氏替换原则（LSP）详解\nLSP要求子类必须完全遵守基类的行为契约，具体体现为：\n前置条件不可强化 子类方法不能施加比基类更严格的输入约束\n1 2 3 4 5 // 基类接受i\u0026gt;0 virtual void Base::f(int i) { assert(i \u0026gt; 0); } // 错误：子类要求i\u0026gt;10，违反LSP void Derived::f(int i) override { assert(i \u0026gt; 10); } 后置条件不可弱化 子类方法需满足基类承诺的输出保证\n1 2 3 4 5 // 基类保证返回正值 virtual int Base::f() { ... assert(result \u0026gt; 0); } // 错误：子类可能返回任意值 int Derived::f() override { ... /* 无约束 */ } 返回类型协变(Covariant) 子类方法可返回 基类返回类型 的派生类\n1 2 3 4 5 class Base {}; class Derived : public Base {}; virtual Base* Base::create() { ... } Derived* Derived::create() override { ... } // 合法协变 参数类型逆变(Contravariant) 子类方法应接受基类参数的超类型（C++语法不支持）\n1 2 3 4 virtual void Base::process(Derived* d) { ... } // 理想情况：参数可为Base*，但C++不允许 void Derived::process(Base* b) override { ... } 保持不变量(Invariants) 子类必须维护基类定义的状态约束\n1 2 3 4 5 6 7 8 9 class Base { protected: int value_; // 不变量：1 \u0026lt;= value_ \u0026lt;= 10 }; class Derived : public Base { public: Derived() { value_ = 11; } // 破坏不变量！ }; 对LSP的常见误解与误用\n数学IS-A ≠ 编程IS-A 尽管几何学中正方形属于矩形，但代码中的行为契约破坏使继承关系失效\n动态类型检查是设计异味\n1 2 3 4 5 6 7 void process(Base\u0026amp; b) { if (auto d = dynamic_cast\u0026lt;Derived*\u0026gt;(\u0026amp;b)) { // 特殊处理Derived类型 } else { // 常规处理 } } 这种针对具体子类的特殊处理，暴露抽象泄露，应视为严重设计缺陷\n构建可靠抽象的关键\n明确契约 通过代码注释、断言或契约编程框架（如C++20 Contracts）显式定义前置/后置条件 封装不变性 避免protected数据成员，通过接口强制约束状态有效性（遵循核心准则C.133） 谨慎使用继承 优先组合优于继承，仅在严格满足LSP时建立继承层次 文档化预期 参考C++标准库对迭代器概念的规范，清晰描述抽象的行为要求 准则6要点 ✅ 遵循\n将抽象视为行为契约集合 通过LSP确保子类无缝替换基类 显式定义并验证前置/后置条件 ❌ 避免\n基于数学直觉盲目建立继承 在子类中弱化后置条件或强化前置条件 通过运行时类型检查规避LSP 设计启示： 抽象是软件工程的基石，而LSP是确保抽象可靠性的核心机制。每一次继承决策都应伴随对行为契约的严格验证，唯有如此，才能构建出经得起演进的软件系统。\n准则7：理解基类与概念的深层共性 在准则6中，我们聚焦于继承体系的行为契约，但里氏替换原则（LSP）的适用范围远不止于此。\n本节将揭示 动态多态(基类) 与 静态多态(概念) 在抽象语义上的本质统一。\n动态与静态抽象的语义对等性\n对比两个代码片段：\n片段1：基于继承的动态多态\n1 2 3 4 5 6 7 8 9 10 class Document { public: virtual ~Document() = default; virtual void exportToJSON() const = 0; virtual void serialize(ByteStream\u0026amp;) const = 0; }; void useDocument(const Document\u0026amp; doc) { doc.exportToJSON(); // 依赖基类接口 } 片段2：基于概念的静态多态\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; concept Document = requires(T t, ByteStream b) { t.exportToJSON(); t.serialize(b); }; template\u0026lt;Document T\u0026gt; void useDocument(const T\u0026amp; doc) { doc.exportToJSON(); // 依赖概念约束 } 关键洞察： 两段代码均要求doc对象满足exportToJSON和serialize的行为契约。无论通过虚函数还是模板概念，抽象的核心在于定义预期行为集合。基类与概念在此层面实现语义等价。\nC++概念的LSP实践\n以标准库std::copy算法为例：\n1 2 3 4 5 6 7 template\u0026lt;typename InputIt, typename OutputIt\u0026gt; constexpr OutputIt copy(InputIt first, InputIt last, OutputIt d_first) { while (first != last) { *d_first++ = *first++; } return d_first; } InputIt与OutputIt虽非C++20概念，但通过命名模板参数隐含行为契约： InputIt需支持递增、解引用及终止条件判断 OutputIt需支持解引用赋值与递增 任何不满足这些隐式契约的迭代器类型将导致算法失效，构成对LSP的违反 C++20概念的演进： 标准库通过分层概念精确定义迭代器要求：\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename I\u0026gt; concept input_or_output_iterator = /*...*/; template\u0026lt;typename I\u0026gt; concept input_iterator = input_or_output_iterator\u0026lt;I\u0026gt; \u0026amp;\u0026amp; /* 细化要求 */; template\u0026lt;typename I\u0026gt; concept forward_iterator = input_iterator\u0026lt;I\u0026gt; \u0026amp;\u0026amp; /* 新增前向迭代特性 */; 这种分层设计践行接口隔离原则（ISP），允许按需组合抽象约束。\n概念作为静态抽象的语义载体\n尽管C++20概念无法在语法层面强制语义，但仍通过以下方式表达预期行为：\n操作可行性：通过requires子句规定必须存在的成员函数/操作符 行为约定：依赖命名约定（如InputIt暗示输入迭代器语义） 文档化契约：标准规范明确概念的行为预期（如迭代器有效性保证） 示例：自定义概念\n1 2 3 4 5 template\u0026lt;typename T\u0026gt; concept Renderable = requires(const T\u0026amp; obj, RenderTarget\u0026amp; target) { { obj.render(target) } -\u0026gt; std::same_as\u0026lt;void\u0026gt;; // 语法约束 // 隐含语义：render()应将对象绘制到target且无副作用 }; 使用方代码可安全假定所有Renderable类型遵循此契约。\n设计启示\n统一设计原则 LSP适用于所有抽象形式，无论动态（虚函数）还是静态（模板/概念）。子类或模板参数必须完全遵守抽象层的行为约定。 概念即契约 将C++20概念及传统命名模板参数视为编译期接口规范。设计时应： 明确概念的最小化约束集合 通过分层组合构建复杂抽象（如迭代器体系） 在文档中详述语义预期 静态多态的优势 相比继承体系，概念提供： 零运行时开销 更强的类型安全性 对值语义的原生支持 准则7要点 ✅ 实践建议\n将LSP原则同步应用于动态与静态多态设计 使用C++20概念或命名模板参数定义编译期抽象 为每个概念编写清晰的行为契约文档 ❌ 规避陷阱\n在模板代码中忽略语义约束（如假定operator++必然前进） 创建\u0026quot;巨无霸\u0026quot;概念（违反接口隔离原则） 核心思维： 抽象的本质是行为契约的具象化。无论是运行时通过虚函数分发，还是编译期通过概念约束，对契约的忠诚度决定系统的健壮性。领悟这一共性，方能游刃于多范式设计之间。\n准则8：理解重载集合的语义要求 在准则6中，我们强调抽象层的行为契约重要性。\n本节将揭示函数重载这一编译时抽象机制如何承载语义要求，以及违反这些要求可能引发的设计风险。\n自由函数的抽象力量\n以标准库的begin()/end()为例，非成员函数重载展现出独特的优势：\n1 2 3 4 5 6 7 8 template\u0026lt;typename Range\u0026gt; void traverseRange(const Range\u0026amp; range) { using std::begin; // 启用ADL的参数依赖查找 using std::end; for (auto pos = begin(range); pos != end(range); ++pos) { // 遍历逻辑 } } 非侵入式扩展：无需修改容器类即可为内置数组添加迭代支持 开放封闭原则：通过新增自由函数扩展功能，无需改动现有代码 通用性提升：支持所有提供begin/end重载的类型（包括第三方库） 对比成员函数局限：\n1 2 3 4 5 6 // 传统成员函数实现（仅支持特定容器） void traverseMember(const std::vector\u0026lt;int\u0026gt;\u0026amp; vec) { for (auto it = vec.begin(); it != vec.end(); ++it) { // 遍历逻辑 } } 无法处理内置数组或自定义容器类型 违反开放封闭原则，新增容器需修改遍历逻辑 重载集合的隐式契约\n以swap函数为例，不当实现将引发灾难：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Widget { int i, j; }; // 错误：仅交换部分成员变量 void swap(Widget\u0026amp; a, Widget\u0026amp; b) { using std::swap; swap(a.i, b.i); // 忽略j的交换 } // 使用方代码 Widget x{1, 11}, y{2, 22}; swap(x, y); // 预期：x=(2,22), y=(1,11) // 实际：x=(2,11), y=(1,22) → 违反行为契约！ 语义预期：swap应交换对象全部可观察状态 违反后果：调用方无法正确推理程序行为，导致隐蔽缺陷 重载命名的核心准则\n语义一致性原则\nC.162：对语义等价的操作进行重载\n1 2 3 4 5 6 // 正确：提供多种构造方式 class File { public: File(const std::string\u0026amp; path); File(FILE* handle); }; C.163：避免对语义不同的操作使用相同名称\n1 2 3 // 错误：find可能暗示线性搜索 template\u0026lt;typename Range\u0026gt; auto binary_find(Range\u0026amp;\u0026amp; r, const auto\u0026amp; value); // 应命名为binary_search 标准库命名约定\nbegin()/end()必须返回可遍历的迭代器对 size()应返回元素数量，而非字节大小 find()默认表示线性查找，有序查找需使用lower_bound等 重载设计的实践要点\n✅ 正确实践\n遵守现有重载集合的语义约定（如std::swap的全状态交换） 通过ADL实现非侵入式扩展 为自定义类型提供标准接口重载（如begin/end支持范围for循环） ❌ 规避陷阱\n在重载函数中实现与命名不符的行为（如sort不保证稳定性） 忽略参数依赖查找（ADL）导致自定义类型无法被通用算法识别 滥用重载导致接口语义模糊（如process()既处理数据又管理资源） 本节总结\n函数重载是编译时多态的重要形式，承载隐式行为契约 重载命名必须传递准确语义，遵循既有约定 任何对重载集合的扩展都需严格遵循LSP原则 自由函数重载是实现开放封闭原则的利器，但需谨慎维护语义一致性 准则9：关注抽象的所有权归属 在软件架构中，抽象的所有权归属直接影响系统依赖方向。本节通过经典案例揭示 依赖倒置原则(DIP) 的核心实践：通过高层掌控抽象定义，实现架构级解耦。\n依赖倒置原则（DIP）精要\n核心主张：\n高层模块不应依赖低层模块，两者都应依赖抽象 抽象不应依赖细节，细节应依赖抽象 ATM系统反例剖析：\n问题：存款、取款、转账等交易类直接调用UI类的具体方法（如requestDepositAmount()） 后果：新增VIP快速转账功能需修改UI类，导致所有交易类重新编译，违反开放封闭原则 解决方案：\n为每个交易定义专属接口（如DepositUI） 将接口声明置于高层模块（交易逻辑层） 具体UI实现继承高层接口，形成自下而上的依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //---- \u0026lt;高层/DepositUI.h\u0026gt; ---------------- class DepositUI { public: virtual int requestAmount() = 0; virtual void confirm() = 0; }; //---- \u0026lt;低层/ConsoleUI.h\u0026gt; ---------------- #include \u0026lt;高层/DepositUI.h\u0026gt; class ConsoleDepositUI : public DepositUI { public: int requestAmount() override { /* 控制台输入逻辑 */ } void confirm() override { /* 确认提示 */ } }; 插件架构的正向设计\n错误模式：\n编辑器Editor直接引用VimModePlugin类 缺陷：每新增插件需修改编辑器代码，无法扩展 正确实践：\n高层定义插件接口\n1 2 3 4 5 6 //---- \u0026lt;编辑器/Plugin.h\u0026gt; ---------------- class Plugin { public: virtual void activate(Editor\u0026amp;) = 0; virtual void deactivate() = 0; }; 低层实现具体插件\n1 2 3 4 5 6 7 //---- \u0026lt;第三方/VimModePlugin.h\u0026gt; ---------------- #include \u0026lt;编辑器/Plugin.h\u0026gt; class VimModePlugin : public Plugin { public: void activate(Editor\u0026amp; e) override { /* Vim模式激活逻辑 */ } void deactivate() override { /* 清理资源 */ } }; 编辑器仅依赖抽象接口\n1 2 3 4 5 6 7 //---- \u0026lt;编辑器/Editor.h\u0026gt; ---------------- #include \u0026lt;Plugin.h\u0026gt; class Editor { std::vector\u0026lt;Plugin*\u0026gt; plugins; public: void addPlugin(Plugin* p) { plugins.push_back(p); } }; 模板与重载的依赖倒置\nSTL算法范例：\n1 2 3 4 template\u0026lt;typename InputIt, typename OutputIt\u0026gt; void copy(InputIt first, InputIt last, OutputIt d_first) { while (first != last) *d_first++ = *first++; } 倒置逻辑：算法定义InputIt/OutputIt概念（高层约束），容器迭代器（低层）需满足这些概念 依赖方向：容器实现依赖STL算法定义的标准，而非反之 swap重载实现：\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; struct Widget { T value; }; template\u0026lt;typename T\u0026gt; void swap(Widget\u0026lt;T\u0026gt;\u0026amp; a, Widget\u0026lt;T\u0026gt;\u0026amp; b) { using std::swap; swap(a.value, b.value); // 依赖类型T的swap实现 } 契约传递：Widget的swap行为依赖T类型的swap实现，所有相关方遵循同一套交换语义 设计启示\n✅ 正确实践\n将关键抽象接口置于架构高层（如核心业务模块） 低层模块通过实现高层接口建立依赖 使用模板约束时，在高层定义概念要求 ❌ 规避陷阱\n让具体实现模块定义抽象接口（导致反向依赖） 在低层模块间共享抽象接口（引发横向耦合） 核心公式： 抽象所有权 == 架构控制权 掌握抽象定义权，方能掌控依赖方向，构建可持续演进的系统架构。\n准则10：建议创建架构设计文档 让我们聊聊你的软件架构。\n先问一个简单的问题：你是否有架构设计文档？这份文档是否清晰描述了系统核心模块、架构层级及依赖关系？\n如果你的回答是肯定的，请跳过本准则。\n若答案是否定的，请继续思考以下问题：你是否建立了持续集成（CI）环境？是否使用自动化测试？是否应用静态代码分析工具？如果这些都已实现，说明你的工程基础良好，但为何独缺架构文档？\n\u0026ldquo;何必小题大做？没有架构文档天又不会塌！我们采用敏捷开发，随时可以调整！\u0026quot;——若这是你的心声，请容我指出一个常见的认知误区，敏捷方法的本质是快速获取反馈 ，而非纵容无序修改。持续集成、测试驱动开发等技术实践确实能快速暴露问题，但架构质量决定了修改的难易程度 。\n优秀的架构设计如同精密的城市管网系统，能让变更如同更换路灯般从容，而非动辄\u0026quot;开膛破肚\u0026rdquo;。\n架构文档的核心价值\n软件大师Ralph Johnson的洞见揭示了架构的本质：\n成功的软件项目中，核心开发者对系统设计有着共同认知，这种共识即架构。\n试想这样的场景：\n团队新成员是否准确理解现有架构？ 资深工程师离职是否导致架构智慧流失？ 各模块负责人是否对系统演进方向达成共识？ 没有书面化的架构文档，这些问题的答案往往令人不安，就像建筑工地没有设计蓝图，不同工种的工人对\u0026quot;左侧车库\u0026quot;的理解可能南辕北辙。\n架构文档正是团队的\u0026quot;认知锚点\u0026quot;，确保所有人朝着同一目标前进。\n架构文档的实践智慧\n破除两大迷思：\n文档必然过时 聚焦宏观设计而非实现细节：记录模块划分、通信机制、关键技术选型等稳定要素，避免陷入API参数之类的易变细节。就像城市地图无需标注每间商铺，但必须清晰展现主干道和功能区。 编写成本高昂 采用渐进式构建： 初始阶段：用1页图文描述核心模块与数据流向 迭代过程：通过架构评审会议逐步补充设计决策 维护策略：每双周由技术负责人同步更新关键变更 示例：微服务架构文档框架\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 系统架构概览 ## 核心服务 - 订单服务：处理交易生命周期（领域驱动设计） - 库存服务：采用事件溯源模式管理库存 - 支付服务：通过适配器模式集成第三方支付网关 ## 通信机制 ![架构拓扑图] - 服务间通信：gRPC（proto3协议） - 事件总线：Kafka集群（分区策略：订单ID哈希） - 缓存层：Redis哨兵模式（缓存穿透防护策略） ## 关键技术决策 - 数据库选型： - 订单服务：PostgreSQL（ACID事务需求） - 商品服务：MongoDB（灵活Schema支持） - 部署架构： - K8s多可用区部署 - 服务网格使用Istio实现金丝雀发布 文档即资产\n优秀架构文档如同保险箱中的地契：\n知识传承：新成员通过文档快速建立系统全景认知 决策溯源：记录技术选型的权衡过程（如选择REST而非GraphQL的原因） 质量护栏：结合ArchUnit等工具自动化验证架构约束 实施建议：\n可视化工具：使用C4模型或UML绘制架构图 版本化管理：将文档纳入代码仓库，与实现同步演进 活文档机制：在关键模块添加架构守护测试 准则10要点 ✅ 价值认知\n架构文档是团队的技术宪法，维护认知一致性 避免\u0026quot;口口相传\u0026quot;导致的知识衰减 为系统演进提供可靠基线 ❌ 规避误区\n将架构文档等同于API文档 因追求完美而延迟文档化 允许文档与实现长期偏离 终极启示： 架构文档不是敏捷的对立面，而是工程专业性的体现。它如同航海图，让团队在快速迭代的惊涛骇浪中保持航向，让每次架构演进都成为精心策划的升级，而非慌不择路的逃亡。\n第三章 设计模式的核心价值 访问者（Visitor）、策略（Strategy）、装饰器（Decorator）——这些设计模式将在后续章节深入探讨。但在逐一解析之前，我们需先理解设计模式的本质意义。本章将揭示设计模式的核心特征、应用价值及其普遍存在性。\n准则11：理解设计模式的根本目的\n在\u0026quot;准则1：认识软件设计的重要性\u0026quot;中，我们已提及设计模式的作用层级。设计模式的本质在于：\n模式命名表达意图：如\u0026quot;工厂模式\u0026quot;直指对象创建逻辑的封装 引入解耦抽象层：通过中间层隔离变化，降低模块间耦合 久经考验的解决方案：经多年实践验证的通用问题应对策略 例如，观察者模式（Observer）通过解耦发布者与订阅者，实现事件驱动的松耦合架构。\n准则12：警惕设计模式认知误区\n破除常见误解：\n❌ 非实现细节：设计模式是架构层面的蓝图，而非具体代码模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 错误认知：策略模式必须用虚函数实现 class Strategy { public: virtual void execute() = 0; }; // 正确实践：策略可以是函数指针、模板参数等 template\u0026lt;typename Strategy\u0026gt; class Context { Strategy strategy_; public: void run() { strategy_(); } }; ❌ 不限于OOP：函数式编程中同样存在模式（如闭包实现状态模式）\n❌ 非语言特性：模式解决的是通用设计问题，与语言语法无关\n准则13：设计模式无处不在\nC++标准库中的模式应用实例：\n迭代器模式（Iterator）\n1 2 std::vector\u0026lt;int\u0026gt; vec{1,2,3}; for(auto it=vec.begin(); it!=vec.end(); ++it) { /*...*/ } 适配器模式（Adapter） std::stack基于deque/list实现栈接口\n组合模式（Composite） std::filesystem::path统一处理文件与目录路径\n准则14：以模式名称传递设计意图\n在代码中显式使用模式命名：\n1 2 3 4 5 6 7 8 9 10 11 // 明确声明使用工厂模式 class WidgetFactory { public: virtual std::unique_ptr\u0026lt;Widget\u0026gt; create() = 0; }; // 通过类型名传达访问者模式应用 class ElementVisitor { public: virtual void visit(ConcreteElement\u0026amp;) = 0; }; 优势：\n提升代码自解释性 促进团队设计共识 方便架构评审与重构 设计模式的终极价值\n设计模式是软件工程的经验结晶，其核心价值在于：\n提供设计词汇表：如\u0026quot;采用观察者模式处理事件通知\u0026quot; 封装变化维度：将易变部分隔离在模式抽象层后 促进架构演进：通过模式组合应对需求变化 理解模式本质，方能超越形式模仿，实现灵活优雅的架构设计。接下来的章节将深入解析各模式在现代C++中的实践应用。\n准则 11：理解设计模式的核心价值 有很大可能您之前听说过设计模式，并且在您的编程职业生涯中很有可能使用过其中的一些。\n设计模式并不是新事物：它们至少自“四人组”（Gang of Four，简称GoF）在1994年发布他们的设计模式书籍以来就存在了。\n尽管一直有批评者，但设计模式的特殊价值在整个软件行业中得到了广泛认可。\n然而，尽管设计模式已经存在很长时间并且非常重要，尽管积累了大量的知识和智慧，在C++社区中仍然存在许多关于设计模式的误解。\n要有效地使用设计模式，第一步需要理解什么是设计模式。设计模式具有以下特征：\n有一个名称：每个设计模式都有一个明确的名称，这有助于开发人员快速识别和讨论该模式。 带有意图：设计模式不仅仅是解决某个问题的技术手段，它还传达了一个特定的设计意图或目标。例如，单例模式的意图是确保一个类只有一个实例，并提供一个全局访问点。 引入一个抽象：设计模式通过定义接口、基类或其他形式的抽象来解决问题。这种抽象使得代码更加灵活和可扩展，能够适应未来的变化。 经过验证：设计模式不是凭空想象出来的，而是基于实际项目中的经验和最佳实践发展而来的。它们已经被证明在多种场景下有效，并且可以在不同的项目中复用。 设计模式有一个名称\n首先，设计模式有一个名称。虽然这听起来非常显而易见且必要，但确实是设计模式的一个基本属性。\n假设我们两个人在一个项目上合作，并被分配解决一个问题。\n想象一下，如果我对您说：“我会用一个Visitor来解决这个问题。” 这不仅告诉了您我理解的实际问题是什么，还给您提供了一个关于我提出的解决方案的精确概念。\n设计模式的名称使我们能够在非常高的层次上进行沟通，并用极少的词汇传达大量信息：\n我：我会用一个Visitor来解决这个问题。 你：我不确定。我考虑使用一个Strategy。 我：是的，您可能有道理。但是由于我们需要频繁扩展操作，我们可能还需要考虑使用一个Decorator。\n通过仅仅使用Visitor、Strategy和Decorator这些名称，我们就讨论了代码库的演变，并描述了我们期望在未来几年内如何扩展和变化。\n如果没有这些名称，我们将很难表达我们的想法：\n我：我认为我们应该创建一个系统，允许我们在不反复修改现有类型的情况下扩展操作。 你：我不确定。与其增加新的操作，我预计会频繁添加新的类型。因此，我更倾向于一种允许我轻松添加类型的解决方案，为了减少与实现细节的耦合（这是可以预期的），我建议引入一个变体点来提取现有类型的实现细节。 我：是的，您可能有道理。但是由于我们需要频繁扩展操作，我们可能需要设计系统，以便能够轻松构建和重用给定的实现。\n看到区别了吗？感觉到区别了吗？没有名称，我们必须明确地讨论更多的细节。\n显然，这种精确的沟通只有在我们对设计模式有相同的理解时才可能实现。这就是为什么了解设计模式并讨论它们如此重要的原因。\n设计模式带有意图\n通过使用设计模式的名称，您可以简洁地表达您的意图，并限制可能的误解。\n这引出了设计模式的第二个属性：意图。设计模式的名称传达了它的意图。\n如果您使用设计模式的名称，您隐含地表达了您认为的问题以及您所看到的解决方案，\n希望您已经意识到，在我们简短的对话中，我们并没有讨论任何具体的实现，我们没有谈论实现细节、任何特性或任何特定的C++标准，我们甚至没有讨论任何特定的编程语言，请不要假设通过给您一个设计模式的名称，我就隐含地告诉了您如何实现解决方案，这不是设计模式的目的。\n相反，名称应该告诉您我提议的结构、我计划如何管理依赖关系以及我对系统演化的期望，这就是意图。\n实际上，许多设计模式具有类似的结构，在GoF（四人组）的书中，许多设计模式看起来非常相似，这当然会引起很多困惑和问题。\n例如，从结构上看，Strategy（策略）、Command（命令）和Bridge（桥接）设计模式几乎没有什么区别。\n然而，它们的意图非常不同，因此您会用它们来解决不同的问题。\n正如您将在接下来的章节中的各种示例中看到的那样，几乎总是有多种不同的实现可以选择。\n设计模式引入抽象\n设计模式总是通过引入某种形式的抽象来减少依赖，这意味着设计模式始终关注于管理软件实体之间的交互和解耦软件的不同部分。\n例如，考虑GoF（四人组）最初的设计模式之一 策略设计模式 （Strategy）\n不深入细节，策略设计模式通过引入一个名为“Strategy”的基类来提供抽象。这个基类将策略用户（架构高层中的Context类）与具体策略的实现细节（架构低层中的ConcreteStrategyA和ConcreteStrategyB）解耦。\n因此，策略模式符合设计模式的特性。\n另一个类似的例子是 工厂方法设计模式，工厂方法的意图是解耦对象创建的具体产品。\n为此，它引入了两个抽象：Product和Creator基类，这些基类在架构的高层中存在，具体的实现细节由ConcreteProduct 和 ConcreteCreator类提供，它们位于架构的低层。\n通过这种架构结构，工厂方法也符合设计模式的标准：它有一个名称、解耦的意图，并且引入了抽象。\n需要注意的是，设计模式引入的抽象并不一定是通过基类实现的，正如我在接下来的部分和章节中会展示的那样，抽象可以通过多种方式引入，例如通过模板或简单的函数重载。\n再次强调，设计模式并不暗示任何特定的实现。\n作为反例，让我们考虑一下std::make_unique()函数：\n1 2 3 4 5 namespace std { template\u0026lt; typename T, typename... Args \u0026gt; unique_ptr\u0026lt;T\u0026gt; make_unique( Args\u0026amp;\u0026amp;... args ); } // namespace std 在C++社区中，我们经常谈论std::make_unique()函数作为一个工厂函数，重要的是要注意，尽管术语“工厂函数”给人一种std::make_unique()是工厂方法设计模式的一个例子的印象，但这种印象是错误的。\n设计模式通过引入抽象来帮助您解耦，这允许您自定义并推迟实现细节。\n特别是，工厂方法设计模式的意图是为对象实例化引入一个自定义点，std::make_unique()并没有提供这样的自定义点，如果您使用std::make_unique()，你知道你会得到一个指向你请求类型的std::unique_ptr，并且实例将通过new生成：\n1 2 // 这将通过调用 \u0026#39;new\u0026#39; 创建一个 \u0026#39;Widget\u0026#39; auto ptr = std::make_unique\u0026lt;Widget\u0026gt;( /* 一些 Widget 参数 */ ); 由于std::make_unique()没有为您提供任何自定义行为的方式，它无法帮助减少实体之间的耦合，因此不能满足设计模式的目的。\n然而，std::make_unique()是针对特定问题的一种常见解决方案，换句话说，它是一种模式，但它不是设计模式，而是实现模式。\n它是封装实现细节（在这种情况下，生成一个Widget实例）的流行解决方案，但它并未从您获得的内容或如何创建它进行抽象。\n因此，它属于实现细节级别，而不是软件设计级别。\n抽象的引入是解耦软件实体、设计变更和扩展的关键，std::make_unique()函数模板中没有任何抽象，因此您无法扩展其功能（甚至无法正确地重载或特化）。\n相比之下，工厂方法设计模式确实提供了关于创建什么以及如何创建（包括实例化前后的行为）的抽象。由于这种抽象，你可以在以后编写新的工厂，而无需更改现有代码。\n因此，设计模式帮助你解耦和扩展你的软件，而std::make_unique()只是一个实现模式。\n设计模式已被证明有效\n最后但同样重要的是，设计模式经过多年验证，四人组（Gang of Four）并没有收集所有可能的解决方案，\n只有那些在不同代码库中常用以解决相同问题的方案（尽管实现可能有所不同），\n因此，一个解决方案必须多次证明其价值，才能被视为一种模式。\n总结一下：设计模式是一种经过验证、有名称的解决方案，它表达了一个非常具体的意图。\n它引入某种形式的抽象，有助于解耦软件实体，从而帮助管理这些实体之间的交互，正如我们应该使用“设计”一词来表示管理和解耦依赖关系的艺术（参见“准则1：理解软件设计的重要性”），我们也应该准确且有目的地使用“设计模式”这一术语。\n本节总结\n理解设计模式是经过验证的、有名称的解决方案，其意图是解耦。 认识到设计模式引入某种形式的抽象。 记住设计模式的目标是软件设计，即帮助管理依赖关系。 注意区分设计模式和实现模式。 准则12：警惕设计模式的误解 上一节重点解释了设计模式的目的：名称、意图和某种形式的抽象相结合，以解耦软件实体。然而，正如理解什么是设计模式很重要一样，理解什么不是设计模式也同样重要。不幸的是，关于设计模式存在一些常见的误解：\n有些人认为设计模式是一种目标，并且是实现良好软件质量的保证。 有些人认为设计模式基于特定的实现，因此是特定语言的习惯用法。 有些人说设计模式仅限于面向对象编程和动态多态性。 有些人认为设计模式已经过时甚至被淘汰。 这些误解并不令人惊讶，因为我们很少谈论设计，而是更多地关注功能和语言机制（参见“准则1：理解软件设计的重要性”）。因此，在本准则中，我将澄清前三种误解，并在下一节中处理第四种误解。\n设计模式不是目标\n一些开发者非常喜欢设计模式，他们对设计模式如此着迷，以至于试图通过设计模式解决所有问题，无论是否合理。\n当然，这种思维方式可能会增加代码的复杂性并降低其可理解性，这最终可能适得其反。\n因此，过度使用设计模式可能导致其他开发者的挫败感，损害设计模式的整体声誉，甚至导致对模式概念的拒绝。\n明确地说：设计模式不是目标，它们是实现目标的手段，它们可能是解决方案的一部分，但它们不是目标。\n正如Venkat Subramaniam所说：如果你早上起床时想着 “今天我会用哪种设计模式？”，那么这是一个明显的信号，表明你误解了设计模式的目的，没有奖励或奖章是因为使用尽可能多的设计模式。\n设计模式的使用不应该增加复杂性，而应该相反，减少复杂性，代码应该变得更简单、更易理解，并且更容易更改和维护，因为设计模式应该帮助解决依赖关系并创建更好的结构。\n如果使用设计模式导致更高的复杂性并给其他开发者带来问题，那显然不是正确的解决方案。\n为了澄清：我不是告诉你不要使用设计模式，我只是告诉你不要过度使用它们，就像我也会告诉你不要过度使用任何其他工具一样。\n这总是取决于具体的问题，例如，锤子是一个很好的工具，只要你的问题是钉子，一旦你的问题变成了螺丝，锤子就变成了一种不太优雅的工具，要正确使用设计模式，了解何时使用它们以及何时不使用它们，掌握它们的意图和结构特性，并明智地应用它们是非常重要的。\n设计模式不关乎实现细节\n关于设计模式最常见的误解之一是它们基于特定的实现，这包括认为设计模式或多或少是特定语言的习惯用法。\n这种误解是可以理解的，因为许多设计模式，特别是四人组（GoF）模式，通常在面向对象的环境中呈现，并通过面向对象的例子进行解释。\n在这种背景下，很容易将实现细节误认为是特定模式，并假设两者是相同的。\n幸运的是，也很容易证明设计模式并不关乎实现细节、任何特定的语言特性或任何C++标准。\n让我们看看同一个设计模式的不同实现，是的，我们将从经典、面向对象的版本开始。\n考虑以下场景：我们想要绘制一个给定的形状。代码片段通过一个圆来演示这一点，当然它也可以是任何其他形状，如正方形或三角形。为了绘制，Circle类提供了draw()成员函数：\n1 2 3 4 5 6 class Circle { public: void draw( /*...*/ ); // 使用某种图形库实现 // ... }; 现在似乎很明显你需要实现draw()函数。未经进一步思考，你可能会通过常见的图形库（如OpenGL、Metal、Vulkan或其他图形库）来实现。\n然而，如果Circle类自己实现了draw()功能，那将是一个大的设计缺陷：直接实现draw()函数会引入对所选图形库的强耦合。这会带来一些缺点：\n对于Circle的每一个可能应用，你总是需要图形库可用，即使你可能只对几何图元感兴趣而不是图形。 图形库的每一次更改都可能影响到Circle类，导致必要的修改、重新测试和重新部署等。 未来切换到另一个库将意味着一切都不再顺利。 这些问题都有一个共同的根源：在Circle类中直接实现draw()函数违反了单一职责原则（SRP；参见“准则2：为变更而设计”），该类不再因单一原因而改变，并且强烈依赖于那个设计决策。\n这个问题的经典面向对象解决方案是提取如何绘制圆的决策，并通过基类引入抽象，引入这样的变化点是策略设计模式的效果。\n应用于绘制圆的策略设计模式\n策略设计模式的意图是定义一组算法并将每个算法封装起来，从而使它们可以互换。\n策略使算法独立于使用它的客户端而变化，通过引入DrawStrategy基类，使得轻松改变给定Circle的draw()实现成为可能。\n这也使得每个人，而不仅仅是你自己，无需修改现有代码就能实现新的绘制行为，并从外部注入到Circle中。\n这就是我们常说的依赖注入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;OpenGLStrategy.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;utility\u0026gt; int main() { // 创建所需的圆的绘制策略。 auto strategy = std::make_unique\u0026lt;OpenGLStrategy\u0026gt;( /* OpenGL 特定参数 */ ); // 将策略注入到圆中；圆不需要知道具体的策略类型，但可以通过 \u0026#39;DrawStrategy\u0026#39; 抽象愉快地使用它。 Circle circle(4.2, std::move(strategy)); circle.draw(/*...*/); return EXIT_SUCCESS; } 这种方法大大提高了不同绘制行为的灵活性：它分离了对特定库和其他实现细节的所有依赖，从而使代码更易于更改和扩展。\n例如，现在很容易提供一个专门用于测试目的的实现（即TestStrategy）。\n这表明改进的灵活性对设计的可测试性有非常积极的影响。\n策略设计模式是经典的GoF设计模式之一。因此，它常被称为面向对象设计模式，并且通常被认为需要一个基类。\n然而，策略的意图不限于面向对象编程。就像可以使用基类进行抽象一样，同样可以依赖模板参数：\n1 2 3 4 5 6 template\u0026lt; typename DrawStrategy \u0026gt; class Circle { public: void draw( /*...*/ ); }; 在这种形式下，决定如何绘制圆是在编译时发生的：不是编写一个基类DrawStrategy并在运行时传递一个指向DrawStrategy的指针，而是通过DrawStrategy模板参数提供绘制的实现细节。\n请注意，虽然模板参数允许你从外部注入实现细节，但Circle仍然不依赖于任何实现细节。\n因此，你仍然将Circle类与使用的图形库解耦，然而，与运行时方法相比，每次DrawStrategy更改时都需要重新编译。\n虽然基于模板的解决方案从根本上改变了示例的属性（即没有基类和虚函数，没有运行时决策，没有单一的Circle类，而是每个具体的DrawStrategy都有一个Circle类型），但它仍然完美地实现了策略设计模式的意图。\n因此，这表明设计模式并不局限于特定的实现或抽象的具体形式。\n设计模式不仅限于面向对象编程或动态多态\n让我们考虑策略设计模式的另一个用例：来自 \u0026lt;numeric\u0026gt; 头文件的标准库 accumulate() 函数模板：\n1 2 std::vector\u0026lt;int\u0026gt; v{ 1, 2, 3, 4, 5 }; auto const sum = std::accumulate(begin(v), end(v), int{0}); 默认情况下，std::accumulate() 将给定范围内的所有元素相加，第三个参数指定总和的初始值，由于 std::accumulate() 使用该参数的类型作为返回类型，因此显式地将类型指定为 int{0} 而不是简单的 0，以防止微妙的误解。\n然而，累加元素只是冰山一角：如果你需要，可以通过提供第四个参数来指定如何累加元素。\n例如，你可以使用 \u0026lt;functional\u0026gt; 头文件中的 std::plus 或 std::multiplies：\n1 2 3 std::vector\u0026lt;int\u0026gt; v{ 1, 2, 3, 4, 5 }; auto const sum = std::accumulate(begin(v), end(v), int{0}, std::plus\u0026lt;\u0026gt;{}); auto const product = std::accumulate(begin(v), end(v), int{1}, std::multiplies\u0026lt;\u0026gt;{}); 通过第四个参数，std::accumulate() 可用于任何类型的归约操作，因此第四个参数代表了归约操作的实现。\n这样，它允许我们通过从外部注入归约操作的细节来改变实现。\n因此，std::accumulate() 不依赖于单一的具体实现，而是可以根据特定需求进行定制，这正是策略设计模式的意图。\nstd::accumulate() 的强大之处在于其通用形式的策略设计模式，如果没有能力改变这种行为，它的用处将非常有限。由于策略设计模式，可能的用途是无限的。\nstd::accumulate() 的例子表明，设计模式，即使是经典的GoF模式，也不局限于一种特定的实现，并且不限于面向对象编程。\n显然，许多这些模式的意图对于其他范式（如函数式编程或泛型编程）也是有用的。\n因此，设计模式不仅限于动态多态性，相反，它们同样适用于静态多态性，并且可以与C++模板结合使用。\n为了进一步强调这一点并展示策略设计模式的另一个例子，考虑 std::vector 和 std::set 类模板的声明：\n1 2 3 4 5 6 7 8 namespace std { template\u0026lt; class T, class Allocator = std::allocator\u0026lt;T\u0026gt; \u0026gt; class vector; template\u0026lt; class Key, class Compare = std::less\u0026lt;Key\u0026gt;, class Allocator = std::allocator\u0026lt;Key\u0026gt; \u0026gt; class set; } // namespace std 标准库中的所有容器（除了 std::array）都提供了指定自定义分配器的机会。\n对于 std::vector 来说，它是第二个模板参数；对于 std::set 来说，它是第三个参数。\n容器的所有内存请求都通过给定的分配器处理。\n通过暴露一个模板参数用于分配器，标准库容器为你提供了从外部自定义内存分配的机会，它们使你能够定义一组算法（在这种情况下，是一个内存获取算法），并将每个算法封装起来，从而使它们可互换。\n因此，你可以独立于使用这些算法的客户端（在这种情况下是容器）来更改这个算法。\n阅读了上述描述后，你应该能识别出策略设计模式。在这个例子中，策略再次基于静态多态性并通过模板参数实现。显然，策略不限于动态多态性。\n虽然很明显设计模式总体上并不局限于面向对象编程或动态多态性，但仍然应该明确指出，有些设计模式的意图是为了缓解面向对象编程中的常见问题（例如，访问者模式和原型模式）。\n当然，也有一些专注于函数式编程或泛型编程的设计模式（例如，递归模板模式 [CRTP] 和表达式模板）。\n虽然大多数设计模式并不是特定于某个范式的，其意图可以在多种实现中使用，但有些模式则更加具体。\n在接下来的章节中，你会看到这两类的例子，你会看到一些具有非常普遍意图的设计模式，因此具有广泛的实用性。\n此外，你还会看到一些更特定于某种范式的模式，由于其特性，它们在目标领域之外可能没有用处。\n尽管如此，它们都具有设计模式的主要特征：名称、意图和某种形式的抽象。\n总结来说：设计模式不仅限于面向对象编程，也不限于动态多态性，更具体地说，设计模式不关乎特定的实现，也不是特定语言的习惯用法。相反，它们完全关注以特定方式解耦软件实体的意图。\n本节总结\n将设计模式视为解决设计问题的工具，而不是目标。 请注意，设计模式不仅限于面向对象编程。 记住，设计模式不仅限于动态多态性。 理解设计模式不是特定于某种语言的习惯用法。 准则13：设计模式无处不在 上一节已经表明，设计模式不仅限于面向对象编程或动态多态性，它们也不是特定语言的习惯用法，并且不局限于某种特定的实现。\n然而，由于这些常见的误解以及我们不再将C++视为纯粹的面向对象编程语言，有些人甚至声称设计模式已经过时或被淘汰。\n我想象你现在可能有些怀疑。“过时？这难道不是有点夸张吗？”你可能会问。好吧，不幸的是并非如此。\n让我讲一个小故事，在2021年初，我有幸在一个德国C++用户组中做了一次关于设计模式的虚拟演讲，我的主要目标是解释什么是设计模式，并说明它们在今天仍然非常有用。\n在演讲过程中，我感到很好，充满动力，希望能帮助人们看到设计模式带来的所有好处。\n然而，几天后，当演讲在YouTube上发布后，有一位用户评论说：“真的吗？2021年的设计模式？”\n我非常希望你现在正在摇头表示不相信，是的，我也无法相信这一点，尤其是在展示了C++标准库中有数百个设计模式的例子之后。不，设计模式既不过时也不淘汰，事实远非如此。\n为了证明设计模式仍然非常活跃和相关，让我们考虑C++标准库中更新的分配器设施。\n请看下面使用来自 std::pmr（多态内存资源）命名空间的分配器的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory_resource\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::array\u0026lt;std::byte, 1000\u0026gt; raw; // 注意：未初始化！ std::pmr::monotonic_buffer_resource buffer{raw.data(), raw.size(), std::pmr::null_memory_resource()}; std::pmr::vector\u0026lt;std::pmr::string\u0026gt; strings{\u0026amp;buffer}; strings.emplace_back(\u0026#34;String longer than what SSO can handle\u0026#34;); strings.emplace_back(\u0026#34;Another long string that goes beyond SSO\u0026#34;); strings.emplace_back(\u0026#34;A third long string that cannot be handled by SSO\u0026#34;); return EXIT_SUCCESS; } 这个例子展示了如何使用 std::pmr::monotonic_buffer_resource 作为分配器，将所有的内存分配重定向到一个预定义的字节缓冲区。\n首先，我们创建了一个大小为1000字节的缓冲区，形式是一个 std::array（注意：未初始化）。该缓冲区通过传递第一个元素的指针（通过 raw.data()）和缓冲区的大小（通过 raw.size()）提供给 std::pmr::monotonic_buffer_resource 作为内存源。monotonic_buffer_resource 的第三个参数代表一个备份分配器，当 monotonic_buffer_resource 耗尽内存时使用。因为我们在这个例子中不需要额外的内存，所以我们使用 std::pmr::null_memory_resource() 函数，它返回一个总是分配失败的标准分配器的指针。这意味着无论你怎么请求内存，由 std::pmr::null_memory_resource() 返回的分配器都会在请求内存时抛出异常。创建的缓冲区作为分配器传递给字符串向量，该向量现在将从初始字节缓冲区获取所有内存。\n此外，由于向量将其分配器转发给其元素，即使我们通过 emplace_back() 函数添加的三个字符串都太长而不能依赖小字符串优化（SSO），它们也将从字节数组中获取所有内存。\n因此，在整个示例中没有使用动态内存；所有内存都将从字节数组中获取。\n乍一看，这个例子似乎不需要任何设计模式就能工作。然而，这个例子中使用的分配器功能至少使用了四种不同的设计模式：模板方法设计模式、装饰器设计模式、适配器设计模式和（再次）策略设计模式。\n如果你计算单例模式，甚至有五种设计模式：null_memory_resource() 函数是基于单例模式实现的：它返回一个静态存储持续时间对象的指针，用于保证最多只有一个此类分配器实例。\n所有来自 pmr 命名空间的C++分配器，包括由 null_memory_resource() 和 monotonic_buffer_resource 返回的分配器，都是从 std::pmr::memory_resource 基类派生的。\n如果你查看 memory_resource 类的定义，第一个设计模式就变得可见了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace std::pmr { class memory_resource { public: // ... 虚析构函数、一些构造函数和赋值运算符 [[nodiscard]] void* allocate(size_t bytes, size_t alignment); void deallocate(void* p, size_t bytes, size_t alignment); bool is_equal(memory_resource const\u0026amp; other) const noexcept; private: virtual void* do_allocate(size_t bytes, size_t alignment) = 0; virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0; virtual bool do_is_equal(memory_resource const\u0026amp; other) const noexcept = 0; }; } // namespace std::pmr 你可能会注意到，类的公共部分中的三个函数在类的私有部分中有一个对应的虚函数。\n虽然公共的 allocate()、deallocate() 和 is_equal() 函数代表了类的用户接口，但 do_allocate()、do_deallocate() 和 do_is_equal() 函数代表了派生类的接口。\n这种关注点分离是 非虚拟接口（NVI） 模式的例子，它本身也是 模板方法设计模式 的一个例子。\n第二个设计模式：装饰器设计模式\n我们隐式使用的第二个设计模式是 装饰器设计模式。装饰器帮助你构建分配器的层次结构，并将一个分配器的功能扩展到另一个分配器。这个想法在这行代码中变得更加清晰：\n1 std::pmr::monotonic_buffer_resource buffer{ raw.data(), raw.size(), std::pmr::null_memory_resource() }; 通过将 null_memory_resource() 函数返回的分配器传递给 monotonic_buffer_resource，我们增强了它的功能。\n每当我们通过 allocate() 函数请求 monotonic_buffer_resource 分配内存时，它可能会将调用转发给其备份分配器。\n这样，我们可以实现许多不同类型的分配器，这些分配器可以轻松组合形成一个具有不同分配策略层的完整内存子系统。这种结合和重用功能的方式正是 装饰器设计模式 的优势所在。\n第三个设计模式：适配器设计模式\n你可能已经注意到，在示例代码中我们使用了 std::pmr::vector 和 std::pmr::string。\n我假设你还记得 std::string 只是 std::basic_string\u0026lt;char\u0026gt; 的类型别名。知道这一点后，下面的内容应该不会让你感到意外：\n1 2 3 4 5 6 7 namespace std::pmr { template \u0026lt;class CharT, class Traits = std::char_traits\u0026lt;CharT\u0026gt;\u0026gt; using basic_string = std::basic_string\u0026lt;CharT, Traits, std::pmr::polymorphic_allocator\u0026lt;CharT\u0026gt;\u0026gt;; template \u0026lt;class T\u0026gt; using vector = std::vector\u0026lt;T, std::pmr::polymorphic_allocator\u0026lt;T\u0026gt;\u0026gt;; } // namespace std::pmr 这些类型别名仍然指向常规的 std::vector 和 std::basic_string 类，但不再暴露分配器的模板参数。\n相反，它们使用 std::pmr::polymorphic_allocator 作为分配器。\n这是一个 适配器设计模式 的例子，适配器的目的是帮助你将两个不匹配的接口粘合在一起。\n在这种情况下，polymorphic_allocator 帮助在经典静态接口（传统C++分配器所需）和新的动态分配器接口（std::pmr::memory_resource 所需）之间进行转换。\n第四个设计模式：策略设计模式\n我们示例中使用的第四个也是最后一个设计模式，再次是 策略设计模式。\n通过公开分配器的模板参数，标准库容器如 std::vector 和 std::string 让你可以从外部自定义内存分配。\n这是 策略设计模式 的静态形式，与自定义算法的目的相同（参见“准则12：注意设计模式的误解”）。\n本节总结\n理解任何类型的抽象和任何解耦尝试很可能代表了一种已知的设计模式。 了解不同的设计模式及其解耦的意图。 根据设计模式的意图，在必要时应用它们。 准则14：使用设计模式的名称来传达意图 在前两节中，你了解了什么是设计模式，它不是什么，以及设计模式无处不在。\n你还了解到每个设计模式都有一个名称，这个名称表达了清晰、简洁且明确的意图。因此，名称承载着意义。通过使用设计模式的名称，你可以表达问题是什么，选择了哪种解决方案来解决问题，并描述代码预期如何演变。\n例如，考虑标准库中的 accumulate() 函数：\n1 2 template\u0026lt; class InputIt, class T, class BinaryOperation \u0026gt; constexpr T accumulate( InputIt first, InputIt last, T init, BinaryOperation op ); 第三个模板参数名为 BinaryOperation，虽然这确实传达了传递的可调用对象需要接受两个参数的事实，但名称并没有传达参数的意图。\n为了更清晰地表达意图，可以将其命名为 BinaryReductionStrategy：\n1 2 template\u0026lt; class InputIt, class T, class BinaryReductionStrategy \u0026gt; constexpr T accumulate( InputIt first, InputIt last, T init, BinaryReductionStrategy op ); 术语“Reduction”和名称“Strategy”对每个C++程序员来说都具有意义，因此，你现在更清晰地捕捉并表达了你的意图：该参数允许依赖注入一个二元操作，从而允许你指定归约操作的工作方式。因此，该参数解决了自定义的问题。\n然而，正如你将在第5章看到的，策略设计模式传达了对该操作有一定的期望，你只能指定归约操作的工作方式；不能重新定义 accumulate() 的功能。\n如果你想表达这一点，你应该使用命令设计模式的名称：\n1 2 template\u0026lt; class InputIt, class UnaryCommand \u0026gt; constexpr UnaryCommand for_each( InputIt first, InputIt last, UnaryCommand f ); std::for_each() 算法允许你将任何一元操作应用于一系列元素，为了表达这一意图，第二个模板参数可以命名为 UnaryCommand，这明确表示对该操作几乎没有预期的要求。\n另一个来自标准库的例子展示了设计模式名称能为一段代码带来多少价值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;variant\u0026gt; struct Print { void operator()(int i) const { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(double d) const { std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(std::string const\u0026amp; s) const { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { std::variant\u0026lt;int, double, std::string\u0026gt; v{}; v = \u0026#34;C++ Variant example\u0026#34;; std::visit(Print{}, v); return EXIT_SUCCESS; } 在 main() 函数中，我们创建了一个包含三个选项（int、double 和 std::string）的 std::variant。\n接下来一行，我们分配了一个C风格字符串字面量，它会在变体内部转换为 std::string。\n然后我们通过 std::visit() 函数和 Print 函数对象打印变体的内容。\n注意 std::visit() 函数的名称，该名称直接引用了访问者设计模式，因此明确表达了其意图：你可以对变体实例中包含的封闭类型集应用任何操作。此外，你可以非侵入式地扩展操作集。\n本节总结\n使用设计模式的名称来传达解决方案的意图。 使用设计模式的名称来提高可读性。 第四章 访问者设计模式 本章完全专注于访问者设计模式，如果你已经听说过访问者设计模式，甚至在自己的设计中使用过它，你可能会好奇为什么我选择访问者作为第一个详细解释的设计模式。\n是的，访问者肯定不是最耀眼的设计模式之一，然而，它绝对是一个很好的例子，可以展示你在实现设计模式时拥有的多种选择，以及这些实现方式可以有多么不同。\n它还将作为一个有效的例子，展示现代C++的优势。\n准则15：为添加类型或操作进行设计\n首先，我们在“准则15：为添加类型或操作进行设计”中讨论当你涉足动态多态性领域时需要做出的基本设计决策：关注类型还是操作。在这个准则中，我们还会讨论编程范式的内在优势和劣势。\n准则16：使用访问者扩展操作\n在“准则16：使用访问者扩展操作”中，我会向你介绍访问者设计模式。我将解释它的意图是扩展操作而不是类型，并向你展示经典访问者模式的优点和缺点。\n准则17：考虑使用 std::variant 实现访问者\n在“准则17：考虑使用 std::variant 实现访问者”中，你会了解到访问者设计模式的现代实现。我将向你介绍 std::variant 并解释这种特定实现的许多优点。\n准则18：警惕无环访问者的性能问题\n在“准则18：警惕无环访问者的性能问题”中，我会向你介绍无环访问者。乍一看，这种方法似乎解决了访问者模式的一些基本问题，但仔细观察后我们会发现，运行时开销可能使这种实现不适用。\n准则15：为添加类型或操作进行设计 对于你来说，动态多态性这个术语可能听起来像是有很多自由，它可能让你感觉像小时候一样：有无尽的可能性，没有任何限制！\n然而，你已经长大了并面对现实：你不可能拥有一切，总是需要做出选择。\n不幸的是，动态多态性也是如此，尽管听起来像是完全的自由，但仍然有一个限制性的选择：你是想扩展类型还是操作？\n为了更好地理解我的意思，让我们回到第三章中的场景：我们希望绘制一个给定的形状，我们坚持使用动态多态性，并且在初次尝试中，我们将使用传统的过程式编程来实现这个问题。\n过程式解决方案\n第一个头文件 Point.h 提供了一个相当简单的 Point 类，这主要是为了使代码完整，但也给了我们一个提示，即我们正在处理二维形状：\n1 2 3 4 5 6 //---- \u0026lt;Point.h\u0026gt; ---------------- struct Point { double x; double y; }; 第二个概念性的头文件 Shape.h 显得更加有趣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //---- \u0026lt;Shape.h\u0026gt; ---------------- enum ShapeType { circle, square }; class Shape { protected: explicit Shape( ShapeType type ) : type_( type ) {} public: virtual ~Shape() = default; ShapeType getType() const { return type_; } private: ShapeType type_; }; 首先，我们引入了枚举 ShapeType，它目前列出了两个枚举值：circle 和 square，显然，我们最初只处理圆形和方形。\n其次，我们引入了类 Shape。考虑到保护构造函数和虚析构函数，你可以预见 Shape 是作为基类使用的。但这并不是 Shape 最令人惊讶的细节：Shape 有一个类型为 ShapeType 的数据成员，这个数据成员通过构造函数初始化，并可以通过 getType() 成员函数查询。\n显然，Shape 将其类型以 ShapeType 枚举的形式存储。\nShape 基类的一个使用示例是 Circle 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; class Circle : public Shape { public: explicit Circle( double radius ) : Shape( circle ) , radius_( radius ) { /* Checking that the given radius is valid */ } double radius() const { return radius_; } Point center() const { return center_; } private: double radius_; Point center_{}; }; Circle 公开继承自 Shape，因此由于 Shape 缺少默认构造函数，需要初始化基类。因为它是圆形，所以它使用 circle 枚举值作为基类构造函数的参数。\n正如之前所述，我们希望绘制形状。因此，我们引入了用于圆形的 draw() 函数。为了避免与任何绘图实现细节紧密耦合，draw() 函数在概念性头文件 DrawCircle.h 中声明，在对应的源文件中定义：\n1 2 3 4 5 6 7 8 9 10 11 12 //---- \u0026lt;DrawCircle.h\u0026gt; ---------------- class Circle; void draw( Circle const\u0026amp; ); //---- \u0026lt;DrawCircle.cpp\u0026gt; ---------------- #include \u0026lt;DrawCircle.h\u0026gt; #include \u0026lt;Circle.h\u0026gt; #include /* some graphics library */ void draw( Circle const\u0026amp; c ) { // ... Implementing the logic for drawing a circle } 当然，不仅仅是圆形，如 square 枚举所示，还有一个 Square 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; class Square : public Shape { public: explicit Square( double side ) : Shape( square ) , side_( side ) { /* Checking that the given side length is valid */ } double side() const { return side_; } Point center() const { return center_; } private: double side_; Point center_{}; // Or any corner, if you prefer }; //---- \u0026lt;DrawSquare.h\u0026gt; ---------------- class Square; void draw( Square const\u0026amp; ); //---- \u0026lt;DrawSquare.cpp\u0026gt; ---------------- #include \u0026lt;DrawSquare.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include /* some graphics library */ void draw( Square const\u0026amp; s ) { // ... Implementing the logic for drawing a square } Square 类与 Circle 类非常相似。主要区别在于 Square 使用 square 枚举值初始化其基类。\n现在有了圆形和方形，我们希望绘制整个不同形状的向量。为此，我们引入了 drawAllShapes() 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //---- \u0026lt;DrawAllShapes.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; class Shape; void drawAllShapes( std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; const\u0026amp; shapes ); //---- \u0026lt;DrawAllShapes.cpp\u0026gt; ---------------- #include \u0026lt;DrawAllShapes.h\u0026gt; #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; void drawAllShapes( std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; const\u0026amp; shapes ) { for( auto const\u0026amp; shape : shapes ) { switch( shape-\u0026gt;getType() ) { case circle: draw( static_cast\u0026lt;Circle const\u0026amp;\u0026gt;( *shape ) ); break; case square: draw( static_cast\u0026lt;Square const\u0026amp;\u0026gt;( *shape ) ); break; } } } drawAllShapes() 接受一个 std::unique_ptr\u0026lt;Shape\u0026gt; 形式的形状向量，指向基类的指针是为了容纳不同种类的具体形状，而 std::unique_ptr 则用于通过 RAII 惯用法自动管理这些形状。\n在函数内部，我们开始遍历向量以绘制每个形状。不幸的是，此时我们只有 Shape 指针。因此，我们需要通过 getType() 函数询问每个形状：你是什么类型的形状？如果形状回复 circle，我们知道必须将其绘制为 Circle 并执行相应的 static_cast。如果形状回复 square，我们将其绘制为 Square。\n我感觉你对这个解决方案不太满意。但在讨论其不足之处之前，让我们先看看 main() 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;DrawAllShapes.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; int main() { using Shapes = std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt;; // Creating some shapes Shapes shapes; shapes.emplace_back( std::make_unique\u0026lt;Circle\u0026gt;( 2.3 ) ); shapes.emplace_back( std::make_unique\u0026lt;Square\u0026gt;( 1.2 ) ); shapes.emplace_back( std::make_unique\u0026lt;Circle\u0026gt;( 4.1 ) ); // Drawing all shapes drawAllShapes( shapes ); return EXIT_SUCCESS; } 它确实可以工作！使用这个 main() 函数，代码编译并绘制三个形状（两个圆形和一个方形）。这不是很好吗？是的，但它不会阻止你对此方案进行抱怨：“多么原始的解决方案！不仅使用 switch 来区分不同种类的形状是个糟糕的选择，而且还没有默认情况！还有谁有这个疯狂的想法，通过未限定范围的枚举来编码形状的类型？”\n你怀疑地看向我的方向……\n好吧，我能理解你的反应。但让我们更详细地分析这个问题。让我猜一下：你记得“准则5：设计扩展”，你现在想象添加第三种形状需要做什么。首先，你需要扩展枚举。例如，我们需要添加新的枚举值 triangle：\n1 2 3 4 5 6 enum ShapeType { circle, square, triangle }; 请注意，这种添加不仅会影响 drawAllShapes() 函数中的 switch 语句（现在真正不完整），还会影响所有从 Shape 继承的类（Circle 和 Square）。这些类依赖于枚举，因为它们依赖于 Shape 基类并且直接使用该枚举。因此，更改枚举将导致所有相关源文件重新编译，你应该认识到这是一个严重的问题。\n事实上，问题的核心是所有形状类和函数对枚举的直接依赖，任何对枚举的更改都会引发连锁反应，要求依赖文件重新编译。显然，这直接违反了开放封闭原则（OCP）（见“准则5：设计扩展”）。这看起来不对：添加一个 Triangle 不应该导致 Circle 和 Square 类重新编译。\n还有更多问题。除了实际编写一个 Triangle 类（这个留给你自己想象），你还需要更新 switch 语句以处理三角形：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void drawAllShapes( std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; const\u0026amp; shapes ) { for( auto const\u0026amp; shape : shapes ) { switch( shape-\u0026gt;getType() ) { case circle: draw( static_cast\u0026lt;Circle const\u0026amp;\u0026gt;( *shape ) ); break; case square: draw( static_cast\u0026lt;Square const\u0026amp;\u0026gt;( *shape ) ); break; case triangle: draw( static_cast\u0026lt;Triangle const\u0026amp;\u0026gt;( *shape ) ); break; } } } 我可以想象你的抗议：“复制粘贴！重复！”是的，在这种情况下，开发者很可能会使用复制粘贴来实现新逻辑，这样做很方便，因为新情况与前两种情况非常相似。\n实际上，这表明设计可以改进。然而，我看到一个更为严重的缺陷：在一个更大的代码库中，这不会是唯一的 switch 语句。相反，会有其他需要更新的 switch 语句。有多少个？十几个？五十个？超过一百个？你如何找到所有这些？好吧，你可能会争辩说编译器会帮助你完成这项任务。对于 switch 语句可能是这样，但如果也有 if-else-if 级联呢？然后，在更新马拉松结束后，当你认为已经完成时，如何保证你真正更新了所有必要的部分？\n是的，我能理解你的反应以及为什么你不喜欢这种代码：这种显式处理类型的方式是一个维护噩梦。引用 Scott Meyers 的话：\n这种基于类型的编程在 C 语言中有很长的历史，我们知道它会导致基本上不可维护的程序。\n面向对象解决方案\n那么让我问一下：你会怎么做？你会如何实现形状的绘制？我猜你可能会使用面向对象的方法，这意味着你会抛弃枚举，并在 Shape 基类中添加一个纯虚函数 draw()。这样，Shape 就不再需要记住它的类型了：\n1 2 3 4 5 6 7 8 9 10 11 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: Shape() = default; virtual ~Shape() = default; virtual void draw() const = 0; }; 有了这个基类，派生类现在只需要实现 draw() 成员函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; class Circle : public Shape { public: explicit Circle( double radius ) : radius_( radius ) { /* Checking that the given radius is valid */ } double radius() const { return radius_; } Point center() const { return center_; } void draw() const override; private: double radius_; Point center_{}; }; //---- \u0026lt;Circle.cpp\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include /* some graphics library */ void Circle::draw() const { // ... Implementing the logic for drawing a circle } //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; class Square : public Shape { public: explicit Square( double side ) : side_( side ) { /* Checking that the given side length is valid */ } double side() const { return side_; } Point center() const { return center_; } void draw() const override; private: double side_; Point center_{}; }; //---- \u0026lt;Square.cpp\u0026gt; ---------------- #include \u0026lt;Square.h\u0026gt; #include /* some graphics library */ void Square::draw() const { // ... Implementing the logic for drawing a square } 一旦 virtual draw() 函数到位并由所有派生类实现，就可以用它来重构 drawAllShapes() 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---- \u0026lt;DrawAllShapes.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; class Shape; void drawAllShapes( std::vector\u0026lt; std::unique_ptr\u0026lt;Shape\u0026gt; \u0026gt; const\u0026amp; shapes ); //---- \u0026lt;DrawAllShapes.cpp\u0026gt; ---------------- #include \u0026lt;DrawAllShapes.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; void drawAllShapes( std::vector\u0026lt; std::unique_ptr\u0026lt;Shape\u0026gt; \u0026gt; const\u0026amp; shapes ) { for( auto const\u0026amp; shape : shapes ) { shape-\u0026gt;draw(); } } 我可以看见你放松下来，开始微笑，这看起来好多了，更加简洁。虽然我知道你喜欢这个解决方案，并希望在这个舒适区多待一会儿，但不幸的是，我必须指出其中的一个缺陷。是的，这个解决方案也可能有缺点。\n正如本节开头所提到的，通过面向对象的方法，我们现在可以非常容易地添加新类型，我们只需要编写一个新的派生类即可，我们不需要修改或重新编译任何现有代码(除了 main() 函数),这完美地满足了开放封闭原则(OCP)。\n然而，你是否注意到我们不能再轻松地添加操作了？例如，假设我们需要一个 virtual serialize() 函数 将 Shape 转换为字节流，我们如何在不修改现有代码的情况下添加这个功能？任何人如何在不修改 Shape 基类的情况下轻松添加这个操作？\n不幸的是，这已经不可能了，我们现在处理的是一个封闭的操作集，这意味着我们在添加操作时违反了 OCP。要添加虚拟函数，基类需要被修改，所有派生类（圆形、方形等）都需要实现新的函数，即使该函数可能永远不会被调用。总之，面向对象解决方案在添加类型方面符合 OCP，但在添加操作方面违反了它。\n我知道你以为我们已经彻底告别了过程式解决方案，但让我们再看一眼，在过程式方法中，添加新操作实际上非常简单。新操作可以通过自由函数或独立类的形式添加，不需要修改 Shape 基类或任何派生类。因此，在过程式解决方案中，我们在添加操作方面符合 OCP，但是如我们所见，过程式解决方案在添加类型时违反了 OCP。\n因此，它似乎是面向对象解决方案的倒置，反之亦然。\n注意动态多态性中的设计选择\n这个例子的关键在于使用动态多态性时存在一个设计选择：要么你可以通过固定操作的数量来轻松添加类型，要么你可以通过固定类型的数量来轻松添加操作。\n因此，开放封闭原则（OCP）有两个维度：在设计软件时，你必须有意识地决定你期望哪种扩展。\n面向对象编程的优势在于可以轻松添加新的类型，但其弱点是添加操作变得更加困难。\n过程式编程的优势在于可以轻松添加操作，但添加类型则非常麻烦（见表4-1）。\n这取决于你的项目：如果你预计会频繁添加新类型而不是操作，你应该努力实现一种将操作视为封闭集、类型视为开放集的OCP解决方案。如果你预计会添加操作，你应该努力实现一种将类型视为封闭集、操作视为开放集的过程式解决方案。如果做出了正确的选择，你将节省自己和同事的时间，并且扩展将会变得自然和容易。\n表4-1. 不同编程范式的优缺点\n编程范式 优点 缺点 过程式编程 添加操作 添加（多态）类型 面向对象编程 添加（多态）类型 添加操作 注意这些优势：基于你对代码库如何演化的预期，选择合适的设计方法以支持扩展。不要忽视这些弱点，也不要让自己陷入不幸的维护噩梦。\n我猜你现在可能在想是否有可能同时拥有两个开放集，据我所知，这不是不可能的，但通常不切实际。例如，在“准则18：警惕无环访问者的性能”中，我会展示性能可能会受到显著影响。\n由于你可能是基于模板的编程和类似的编译时工作的粉丝，我也应该明确指出静态多态性并没有相同的限制。虽然在动态多态性中，设计轴之一（类型和操作）需要固定，但在静态多态性中，这两类信息在编译时都是可用的。因此，两方面都可以轻松扩展（如果你做得正确）。\n本节总结\n注意不同编程范式的优缺点。\n利用范式的优势，但避免其弱点。\n理解动态多态性中类型或操作的添加选择。\n当你主要想添加类型时，优先选择面向对象解决方案。\n当你主要想添加操作时，优先选择过程式/函数式解决方案。\n准则16：使用访问者模式扩展操作 在上一节中，你看到面向对象编程（OOP）的优势在于可以轻松添加类型，而其弱点在于难以添加操作。当然，OOP对此有一个解决方案：访问者设计模式。\n访问者设计模式是Gang of Four（GoF）所描述的经典设计模式之一。它的重点在于允许你频繁地添加操作而不是类型。让我通过前面的示例（形状绘制）来解释访问者设计模式。\n在图4-1中，你看到了形状层次结构。Shape类再次作为多个具体形状的基类。在这个例子中，只有两个类：Circle和Square，但当然也可以有更多的形状类，例如Triangle、Rectangle或Ellipse类。\n分析设计问题\n假设你确定已经拥有了所有你需要的形状，也就是说，你认为形状集合是一个封闭集。然而，你缺少的是额外的操作，例如，你缺少一个旋转形状的操作，你也希望序列化形状，即将形状实例转换为字节流。当然，你还希望绘制形状。此外，你希望任何人能够添加新的操作。\n因此，你期望有一个开放的操作集，每一个新的操作现在都需要你在基类中插入一个新的虚函数。不幸的是，这在不同的方面可能会带来麻烦，最明显的是，并不是每个人都能在 Shape 基类中添加一个虚函数。\n例如，我不能简单地去修改你的代码。因此，这种方法无法满足任何人都能添加操作的期望，虽然你可能已经将此视为最终的负面结论，但让我们详细分析一下虚函数的问题。\n如果你决定使用纯虚函数，你将不得不在每个派生类中实现该函数。对于你自己定义的派生类型来说，这可能只是多了一些工作量。但对于其他人通过继承 Shape 基类创建的新形状来说，这可能会增加额外的工作量。而这是面向对象编程的优势之一：任何人都可以轻松添加新类型。由于这种情况是可以预期的，因此这可能是不使用纯虚函数的一个原因。\n作为替代方案，你可以引入一个普通的虚函数，即带有默认实现的虚函数。虽然 rotate() 函数的默认行为听起来像是一个非常合理的想法，但 serialize() 函数的默认实现听起来并不容易。\n我承认我必须仔细考虑如何实现这样的函数，你现在可能会建议默认情况下抛出异常，但这意味着派生类必须再次实现缺失的行为，这实际上就是一个伪装的纯虚函数，或者明确违反了里氏替换原则（见“准则6：遵循抽象的预期行为”）。\n无论哪种方式，在 Shape 基类中添加新操作都是困难的，甚至根本不可能。\n其根本原因是添加虚函数违反了开放封闭原则（OCP），如果你确实需要频繁添加新操作，那么你应该设计一种使得操作扩展变得容易的方式。这就是访问者设计模式试图实现的目标。\n访问者设计模式解释\n访问者设计模式的意图是允许添加操作。\n除了 Shape 层次结构外，我现在在图4-2的左侧引入了 ShapeVisitor 层次结构。\nShapeVisitor 基类代表形状操作的抽象，因此，你可以认为 ShapeOperation 可能是这个类更好的名字。然而，应用“准则14：使用设计模式的名字来传达意图”是有益的，名字 Visitor 将帮助其他人理解设计。\nShapeVisitor 基类为 Shape 层次结构中的每个具体形状提供一个纯虚函数 visit()：\n1 2 3 4 5 6 7 8 class ShapeVisitor { public: virtual ~ShapeVisitor() = default; virtual void visit(Circle const\u0026amp;, /*...*/) const = 0; virtual void visit(Square const\u0026amp;, /*...*/) const = 0; // 可能有更多的 visit() 函数，每个具体形状一个 }; 在这个例子中，有一个用于 Circle 的 visit() 函数和一个用于 Square 的 visit() 函数。当然，可能有更多 visit() 函数——例如，一个用于 Triangle，一个用于 Rectangle，一个用于 Ellipse——假设这些也是从 Shape 基类派生的类。\n有了 ShapeVisitor 基类后，你现在可以轻松地添加新操作，要添加一个操作，只需添加一个新的派生类。\n例如，为了启用旋转形状，你可以引入 Rotate 类并实现所有 visit() 函数。为了启用绘制形状，你只需要引入一个 Draw 类：\n1 2 3 4 5 6 7 class Draw : public ShapeVisitor { public: void visit(Circle const\u0026amp; c, /*...*/) const override; void visit(Square const\u0026amp; s, /*...*/) const override; // 可能有更多的 visit() 函数，每个具体形状一个 }; 你可以考虑引入多个 Draw 类，每个图形库一个。你可以轻松做到这一点，因为你不需要修改任何现有代码。只需通过添加新代码扩展 ShapeVisitor 层次结构即可。\n因此，这种设计在添加操作方面符合开放封闭原则（OCP）。\n要完全理解访问者的设计特性，重要的是理解为什么访问者设计模式能够满足 OCP。\n最初的问题是每次添加新操作都需要修改 Shape 基类，访问者将操作的添加识别为变化点，通过提取这个变化点，即将其作为一个独立的类，你遵循了单一职责原则（SRP）：Shape 不需要为每个新操作而改变。\n这避免了频繁修改 Shape 层次结构，并使得添加新操作变得容易。\n因此，SRP 成为了 OCP 的推动者。\n要在形状上使用访问者（从 ShapeVisitor 基类派生的类），你现在必须在 Shape 层次结构中添加最后一个函数：accept() 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Shape { public: virtual ~Shape() = default; virtual void accept(ShapeVisitor const\u0026amp; v) = 0; // ... }; class Circle : public Shape { public: explicit Circle(double radius) : radius_(radius) { /* 检查给定半径的有效性 */ } void accept(ShapeVisitor const\u0026amp; v) override { v.visit(*this); } double radius() const { return radius_; } private: double radius_; }; class Square : public Shape { public: explicit Square(double side) : side_(side) { /* 检查给定边长的有效性 */ } void accept(ShapeVisitor const\u0026amp; v) override { v.visit(*this); } double side() const { return side_; } private: double side_; }; accept() 函数的实现很简单，它只是根据具体 Shape 的类型调用给定访问者的相应 visit() 函数。\n这是通过将 this 指针作为参数传递给 visit() 来实现的，因此，每个派生类中的 accept() 实现相同，但由于不同类型的 this 指针，它会触发给定访问者中 visit() 函数的不同重载。\n因此，Shape 基类不能提供默认实现。\n现在可以在需要执行操作的地方使用这个 accept() 函数。\n例如，drawAllShapes() 函数使用 accept() 来绘制给定形状向量中的所有形状：\n1 2 3 4 5 6 7 void drawAllShapes(std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; const\u0026amp; shapes) { for(auto const\u0026amp; shape : shapes) { shape-\u0026gt;accept(Draw{}); } } 通过添加 accept() 函数，你现在可以轻松地扩展 Shape 层次结构以支持更多的操作。\n你现在设计了一个开放的操作集，太棒了！然而，没有万能药，也没有总是有效的设计，每种设计都有优点，但也有缺点。\n所以在你开始庆祝之前，我应该告诉你访问者设计模式的不足之处，以便让你全面了解。\n分析访问者设计模式的不足\n访问者设计模式远非完美。考虑到访问者实际上是为了弥补面向对象编程（OOP）内在的弱点而设计的一种变通方案，而不是基于OOP的优势构建的，这一点是可以预料到的。\n第一个缺点：低实现灵活性\n第一个缺点是实现灵活性较低。\n如果你考虑实现一个 Translate 访问者，这种缺点就变得很明显，Translate 访问者需要通过给定的偏移量移动每个形状的中心点。为此，Translate 需要为每个具体形状实现一个 visit() 函数。\n特别是对于 Translate，你可以想象这些 visit() 函数的实现会非常相似，甚至完全相同：旋转一个圆形和旋转一个方形没有什么不同。\n然而，你仍然需要编写所有的 visit() 函数，当然，你可以根据DRY原则将逻辑从 visit() 函数中提取出来，并在第三个独立函数中实现以减少重复代码。\n但不幸的是，基类的严格要求不允许你将这些 visit() 函数实现为一个统一的函数。结果是一些样板代码：\n1 2 3 4 5 6 7 8 class Translate : public ShapeVisitor { public: // 移动圆形和方形有什么区别？你仍然需要实现所有虚函数... void visit(Circle const\u0026amp; c, /*...*/) const override; void visit(Square const\u0026amp; s, /*...*/) const override; // 可能有更多的 visit() 函数，每个具体形状一个 }; 类似的实现不灵活还包括 visit() 函数的返回类型，返回类型的决定是在 ShapeVisitor 基类中做出的，派生类无法更改。通常的做法是将结果存储在访问者中并在稍后访问它。\n第二个缺点：难以添加新类型\n第二个缺点是使用访问者设计模式后，添加新类型变得困难。\n之前我们假设你确定已经拥有了所有你需要的形状，这个假设现在变成了限制。\n在 Shape 层次结构中添加新的形状需要更新整个 ShapeVisitor 层次结构：你必须在 ShapeVisitor 基类中添加一个新的纯虚函数，并且这个虚函数需要由所有派生类实现。\n当然，这带来了我们之前讨论的所有缺点，特别是，你会迫使其他开发人员更新他们的操作。\n因此，访问者设计模式要求有一个封闭的类型集，并以此交换开放的操作集。\n底层的原因是 ShapeVisitor 基类、具体形状（如 Circle 和 Square 等）以及 Shape 基类之间存在循环依赖。\n第三个缺点：侵入性\n第三个缺点是访问者的侵入性，要在现有层次结构中添加访问者，你需要在该层次结构的基类中添加virtual accept() 函数。\n虽然这通常是可能的，但它仍然存在向现有层次结构添加纯虚函数的常见问题（见“准则15：设计以支持类型或操作的添加”）。\n然而，如果不能添加 accept() 函数，则这种形式的访问者不可行。如果是这种情况，不要担心：我们将在“准则17：考虑使用 std::variant 实现访问者”中看到另一种非侵入性的访问者设计模式。\n第四个缺点：继承的 accept() 函数\n第四个缺点（尽管较为隐蔽）是 accept() 函数是由派生类继承的。\n如果有人后来添加了另一层派生类（可能是你自己）并忘记重写 accept() 函数，访问者将被应用到错误的类型上。不幸的是，你不会得到任何警告。\n这只是进一步证明添加新类型变得更加困难。一种可能的解决方案是将 Circle 和 Square 类声明为 final，但这将限制未来的扩展。\n第五个缺点：双重分派性能开销\n第五个缺点在我们考虑每次操作都需要调用两个虚函数时变得明显。\n最初，我们既不知道操作的类型也不知道形状的类型。\n第一个虚函数是 accept() 函数，它接收一个抽象的 ShapeVisitor。accept() 函数现在解析具体的形状类型。\n第二个虚拟函数是 visit() 函数，它接收一个具体的 Shape 类型。visit() 函数现在解析具体的操作类型。\n这种所谓的双重分派不幸并不是免费的。相反，在性能方面，你应该认为访问者设计模式相对较慢。我将在下一个准则中提供一些性能数据。\n在谈论性能时，我还应该提到另外两个对性能有负面影响的方面：\n频繁的小内存分配：我们通常单独分配每个形状和访问者。考虑以下 main() 函数：\n1 2 3 4 5 6 7 8 9 10 11 int main() { using Shapes = std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt;; Shapes shapes; shapes.emplace_back(std::make_unique\u0026lt;Circle\u0026gt;(2.3)); shapes.emplace_back(std::make_unique\u0026lt;Square\u0026gt;(1.2)); shapes.emplace_back(std::make_unique\u0026lt;Circle\u0026gt;(4.1)); drawAllShapes(shapes); // ... return EXIT_SUCCESS; } 在这个 main() 函数中，所有分配都是通过 std::make_unique() 进行的\n（例如 shapes.emplace_back(std::make_unique\u0026lt;Circle\u0026gt;(2.3))）。\n这些许多小的分配本身就会消耗运行时间，并且最终会导致内存碎片化。\n此外，内存布局可能不利于缓存友好，因此，我们通常使用指针来处理生成的形状和访问者。\n由此产生的间接性使得编译器更难进行任何形式的优化，并会在性能基准测试中显现出来。\n然而，老实说，这不是访问者特有的问题，而是面向对象编程中常见的两个方面。\n最后的缺点：复杂性和维护难度\n最后的缺点是经验表明，这种设计模式相当难以完全理解和维护。这是一个比较主观的缺点，但两个层次结构之间复杂的相互作用往往让人感觉更像是负担而不是真正的解决方案。\n总结\n请记住，在现有继承层次结构中添加新操作是困难的。\n应用访问者设计模式的意图是允许轻松添加操作。\n要注意访问者设计模式的不足。\n准则17：考虑使用 std::variant 实现访问者 在“准则16：使用访问者扩展操作”中，我向你介绍了访问者设计模式。\n我想你并不会立刻爱上它：尽管访问者确实具有一些独特的特性，但它也是一个相当复杂的设计模式，具有较强的内部耦合和性能缺陷。\n不，绝对不是爱！然而，不用担心，经典形式并不是实现访问者设计模式的唯一方式。\n在本节中，我想向你介绍一种不同的实现访问者的方式。我相信这种方法会更符合你的喜好。\nstd::variant 简介\n在本章的开头，我们讨论了不同范式（面向对象编程与过程式编程）的优点和缺点。\n特别是，我们谈到了过程式编程在为现有类型集添加新操作方面特别擅长。\n那么，与其试图在OOP中寻找变通方法，为什么不利用过程式编程的优势呢？\n不，不用担心；当然我不是建议回到最初的解决方案。那种方法太容易出错。相反，我指的是 std::variant：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;variant\u0026gt; struct Print { void operator()(int value) const { std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(double value) const { std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(const std::string\u0026amp; value) const { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { // 创建一个默认包含 \u0026#39;int\u0026#39; 初始化为 0 的 variant std::variant\u0026lt;int, double, std::string\u0026gt; v{}; v = 42; // 分配整数 42 给 variant v = 3.14; // 分配双精度浮点数 3.14 给 variant v = 2.71F; // 分配浮点数，会被提升为双精度浮点数 v = \u0026#34;Bjarne\u0026#34;; // 分配字符串字面量 \u0026#39;Bjarne\u0026#39; 给 variant v = 43; // 分配整数 43 给 variant int const i = std::get\u0026lt;int\u0026gt;(v); // 直接访问值 int* const pi = std::get_if\u0026lt;int\u0026gt;(\u0026amp;v); // 直接访问值 std::visit(Print{}, v); // 应用 Print 访问者 return EXIT_SUCCESS; } 由于你可能还没有机会接触 C++17 的 std::variant，请允许我简要介绍一下。\n一个 variant 表示几种备选方案中的一种。\n例如，在上述代码示例中的 main() 函数开始时，variant 可以包含一个 int、一个 double 或一个 std::string。请注意我说的是 “或” ：一个 variant 只能包含这三种备选方案中的一种，它永远不会同时包含多个，通常情况下也不应该为空。\n因此，我们将 variant 称为一种 “总和类型” ：可能状态的集合是各备选方案可能状态的总和。\n默认的 variant 也不是空的。它被初始化为第一个备选方案的默认值。在这个例子中，默认的 variant 包含一个值为 0 的整数。\n改变 variant 的值很简单：你可以直接分配新值。例如，我们可以分配值 42，这意味着 variant 存储了一个值为 42 的整数。\n如果我们随后分配双精度浮点数 3.14，则 variant 将存储一个值为 3.14 的双精度浮点数。\n如果你想分配一个不属于这些备选方案之一的类型的值，则应用常规转换规则。\n例如，如果你想分配一个浮点数，基于常规转换规则，它会被提升为双精度浮点数。\n为了存储备选方案，variant 提供了刚好足够的内部缓冲区来容纳最大的备选方案。\n在我们的例子中，最大的备选方案是 std::string，通常是 24 到 32 字节（取决于标准库的具体实现）。\n因此，当你分配字符串字面量 \u0026ldquo;Bjarne\u0026rdquo; 时，variant 首先清理之前的值（这里没什么需要做的，只是一个双精度浮点数），\n然后 构造 std::string 并将其放置在其自身的缓冲区内。\n当你改变主意并分配整数 43 时，variant 会通过其 析构函数 正确销毁 std::string 并重用内部缓冲区用于整数。\n是不是很神奇？variant 是类型安全且始终正确初始化的。我们还能要求什么呢？\n当然，你想要对 variant 中的值进行一些操作，如果只是存储值而不做任何事情，那将毫无意义。\n不幸的是，你不能简单地将 variant 赋值给其他任何值，例如 int，以获取回你的值。不，访问值有点复杂。\n有几种访问存储值的方法，最直接的方法是使用 std::get()。通过 std::get()，你可以查询特定类型的值。\n如果 variant 包含该类型的值，它将返回对该值的引用。\n如果不包含，则抛出 std::bad_variant_exception。\n这看起来是一个相当粗鲁的响应，毕竟你是礼貌地请求的，但我们应该感到高兴的是，当 variant 确实不包含某个值时，它不会假装持有该值。至少它是诚实的。\n还有一种更友好的方式是 std::get_if()。与 std::get() 不同，std::get_if() 返回一个指针而不是引用。\n如果你请求的类型是 std::variant 当前未持有的类型，它不会抛出异常，而是返回 nullptr。\n然而，还有第三种方式，这种方式对我们来说特别有趣：std::visit()。\nstd::visit() 允许你在存储的值上执行任何操作，更准确地说，它允许你传递一个自定义访问者来对封闭类型集的存储值执行任何操作。听起来熟悉吗？\n我们作为第一个参数传递的 Print 访问者必须为每个可能的备选方案提供一个函数调用运算符（operator()）。\n在这个例子中，这是通过提供三个 operator() 来实现的：一个用于 int，一个用于 double，一个用于 std::string。\n值得注意的是，Print 不必继承自任何基类，也没有任何虚函数。因此，没有强耦合到任何要求。\n如果我们愿意，我们也可以将 int 和 double 的函数调用运算符合并为一个，因为 int 可以转换为 double：\n1 2 3 4 5 6 7 struct Print { void operator()(double value) const { std::cout \u0026lt;\u0026lt; \u0026#34;int or double: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(const std::string\u0026amp; value) const { std::cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; 虽然关于哪个版本是我们应该首选的问题目前对我们来说并不特别重要，但你会注意到我们有很多实现灵活性。\n只有非常松散的耦合，基于这样一个约定：对于每一个备选方案，都需要有一个 operator()，而不论其确切形式如何。\n我们不再有一个强制我们以非常具体方式做事的访问者基类，我们也没有任何备选方案的基类：我们可以自由使用基本类型如 int 和 double，以及任意类类型如 std::string。\n也许最重要的是，任何人都可以轻松添加新的操作，不需要修改现有代码。\n因此，我们可以认为这是一种过程式解决方案，只不过比最初的基于枚举的解决方案更加优雅，后者使用基类来保存区分器。\n重构形状绘制为基于值的非侵入式解决方案\n凭借这些特性，std::variant 非常适合我们的绘图示例。让我们使用 std::variant 重新实现形状的绘制。\n首先，我们重构 Circle 和 Square 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; class Circle { public: explicit Circle(double radius) : radius_(radius) { /* 检查给定半径是否有效 */ } double radius() const { return radius_; } Point center() const { return center_; } private: double radius_; Point center_{}; }; //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; class Square { public: explicit Square(double side) : side_(side) { /* 检查给定边长是否有效 */ } double side() const { return side_; } Point center() const { return center_; } private: double side_; Point center_{}; }; Circle 和 Square 类都被大大简化了：不再需要 Shape 基类，也不再需要实现任何虚函数——特别是 accept() 函数。\n因此，这种访问者方法是非侵入式的：这种形式的访问者可以轻松添加到现有类型中！而且不需要为这些类准备任何即将进行的操作。\n我们可以完全专注于将这两个类实现为它们本来的样子：几何基本体。\n然而，重构中最精彩的部分是实际使用 std::variant：\n1 2 3 4 5 6 7 8 9 10 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;variant\u0026gt; #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; using Shape = std::variant\u0026lt;Circle, Square\u0026gt;; //---- \u0026lt;Shapes.h\u0026gt; ---------------- #include \u0026lt;vector\u0026gt; #include \u0026lt;Shape.h\u0026gt; using Shapes = std::vector\u0026lt;Shape\u0026gt;; 由于我们的封闭类型集是一组形状，variant 现在包含一个 Circle 或 Square。\n那么代表形状类型的抽象集合的好名字是什么呢？嗯……Shape。代替抽象出具体形状类型的基类，std::variant 现在承担了这一任务。如果你是第一次看到这一点，你可能会感到非常惊讶。\n但请稍等，还有更多：这也意味着我们现在可以放弃 std::unique_ptr。记住：我们使用（智能）指针的唯一原因是能够将不同种类的形状存储在同一个向量中。但现在 std::variant 使我们能够做到这一点，我们可以简单地将 variant 对象存储在一个单一的向量中。\n有了这个功能，我们可以编写自定义操作来处理形状。我们仍然对绘制形状感兴趣。\n为此，我们现在实现 Draw 访问者：\n1 2 3 4 5 6 7 8 9 10 //---- \u0026lt;Draw.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include /* 一些图形库 */ struct Draw { void operator()(const Circle\u0026amp; c) const { /* 实现绘制圆的逻辑 */ } void operator()(const Square\u0026amp; s) const { /* 实现绘制正方形的逻辑 */ } }; 再次，我们遵循期望为每个备选方案实现一个 operator()：一个是 Circle，另一个是 Square。\n但这次我们有选择，不需要实现任何基类，也不需要重写任何虚函数。因此，不需要为每个备选方案精确实现一个 operator()。\n虽然在这个例子中，拥有两个函数似乎是合理的，但我们也可以选择将两个 operator() 合并为一个函数，我们还可以选择操作的返回类型，我们可以本地决定应该返回什么，并且不是由基类独立于特定操作做出全局决策。实现了灵活性。松散耦合，令人惊叹！\n最后一块拼图是 drawAllShapes() 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //---- \u0026lt;DrawAllShapes.h\u0026gt; ---------------- #include \u0026lt;Shapes.h\u0026gt; void drawAllShapes(const Shapes\u0026amp; shapes); //---- \u0026lt;DrawAllShapes.cpp\u0026gt; ---------------- #include \u0026lt;DrawAllShapes.h\u0026gt; void drawAllShapes(const Shapes\u0026amp; shapes) { for(auto const\u0026amp; shape : shapes) { std::visit(Draw{}, shape); } } drawAllShapes() 函数被重构以利用 std::visit()。在这个函数中，我们现在将 Draw 访问者应用于存储在向量中的所有 variant。\nstd::visit() 的工作是为你执行必要的类型调度，如果给定的 std::variant 包含一个 Circle，它将调用 Draw::operator() 来绘制圆。否则，它会调用 Draw::operator() 来绘制正方形。\n如果你想的话，你可以手动实现相同的调度，使用 std::get_if()：\n1 2 3 4 5 6 7 8 9 10 11 12 void drawAllShapes(const Shapes\u0026amp; shapes) { for(auto const\u0026amp; shape : shapes) { if(Circle* circle = std::get_if\u0026lt;Circle\u0026gt;(\u0026amp;shape)) { // ... 绘制一个圆 } else if(Square* square = std::get_if\u0026lt;Square\u0026gt;(\u0026amp;shape)) { // ... 绘制一个正方形 } } } 我知道你在想什么：“荒谬！为什么我会想要这样做？这会导致与基于枚举的解决方案相同的维护噩梦。”\n我完全同意你的观点：从软件设计的角度来看，这将是一个糟糕的想法。尽管如此，我不得不说，在这本书的上下文中承认这一点有些困难，有时可能有一个很好的理由这样做：性能。\n我知道，现在我已经引起了你的兴趣，但由于我们几乎准备好讨论性能问题，允许我暂时推迟这个讨论几段文字。我保证会回到这个问题！\n有了所有这些细节，我们终于可以重构 main() 函数了，但这不需要做太多工作：不再通过 std::make_unique() 创建圆和正方形，而是直接创建圆和正方形，并将它们添加到向量中。\n这得益于 variant 的非显式构造函数，它允许隐式转换任何备选方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;Shapes.h\u0026gt; #include \u0026lt;DrawAllShapes.h\u0026gt; int main() { Shapes shapes; shapes.emplace_back(Circle{2.3}); shapes.emplace_back(Square{1.2}); shapes.emplace_back(Circle{4.1}); drawAllShapes(shapes); return EXIT_SUCCESS; } 这种基于值的解决方案的最终结果令人惊叹：没有任何基类。没有虚函数，没有指针。没有手动内存分配。\n事情尽可能地直接，几乎没有样板代码。此外，尽管代码看起来与之前的解决方案非常不同，但架构属性是相同的：每个人都可以在不修改现有代码的情况下添加新操作（参见图 4-4）。\n因此，我们在添加操作方面仍然满足 OCP（开闭原则）。\n如前所述，这种方法是非侵入式的。从架构角度来看，这给你带来了另一个显著的优势，相比于经典的访问者模式。\n如果你比较经典访问者的依赖关系图（见图 4-3）和 std::variant 解决方案的依赖关系图（见图 4-4），你会看到 std::variant 解决方案的依赖关系图有一个额外的架构边界。\n这意味着 std::variant 及其备选方案之间没有循环依赖，我应该重复一遍以强调其重要性：std::variant 及其备选方案之间没有循环依赖！这看似一个小细节，但实际上是一个巨大的架构优势，巨大！例如，你可以即时创建基于 std::variant 的抽象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;variant\u0026gt; #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; using Shape = std::variant\u0026lt;Circle, Square\u0026gt;; //---- \u0026lt;SomeHeader.h\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Ellipse.h\u0026gt; #include \u0026lt;variant\u0026gt; using RoundShapes = std::variant\u0026lt;Circle, Ellipse\u0026gt;; //---- \u0026lt;SomeOtherHeader.h\u0026gt; ---------------- #include \u0026lt;Square.h\u0026gt; #include \u0026lt;Rectangle.h\u0026gt; #include \u0026lt;variant\u0026gt; using AngularShapes = std::variant\u0026lt;Square, Rectangle\u0026gt;; 除了我们已经创建的 Shape 抽象外，你还可以创建所有圆形的 std::variant，以及所有角度形状的 std::variant，这两者都可能远离 Shape 抽象。\n你可以轻松做到这一点，因为不需要从多个访问者基类派生。相反，形状类不会受到影响。因此，std::variant 解决方案的非侵入性具有最高的架构价值。\n性能基准测试\n我知道你现在的感觉，是的，这就是一见钟情的感觉。但信不信由你，还有更多内容。有一个我们还没有讨论的话题，这是每个C++开发者都关心的，那就是性能。\n虽然这本书并不是专门讨论性能的，但仍然值得一提的是，你不需要担心 std::variant 的性能。我可以向你保证它非常快。\n然而，在我向你展示基准测试结果之前，请允许我对这些基准测试做一些评论。性能——唉。不幸的是，性能总是一个棘手的话题。总有人抱怨性能问题。因此，我很乐意完全跳过这个话题。\n但另一方面，也有人抱怨缺少性能数据。唉，既然无论如何总会有一些抱怨，并且结果实在太好了不容错过，我会向你展示一些基准测试的结果。\n但有两个条件：首先，你不应将这些结果视为代表绝对真理的定量值，而只是指向正确方向的定性值。其次，你不会因为我没有使用你最喜欢的编译器、编译标志或IDE而在我的房子前抗议。答应吗？\n你：点头并承诺不会抱怨琐碎的事情！\n好的，太棒了，那么表4-2给出了基准测试的结果。\n表4-2 不同访问者实现的基准测试结果\n访问者实现 GCC 11.1 Clang 11.1 经典访问者设计模式 1.6161 s 1.8015 s 面向对象解决方案 1.5205 s 1.1480 s 枚举解决方案 1.2179 s 1.1200 s std::variant（使用 std::visit()） 1.1992 s 1.2279 s std::variant（使用 std::get_if()） 1.0252 s 0.6998 s 为了更好地理解这些数字，我应该给你一些背景信息。为了让场景更加现实，我不仅使用了圆和正方形，还使用了矩形和椭圆。\n然后在10,000个随机创建的形状上运行了25,000次操作，我没有绘制这些形状，而是通过随机向量更新中心点。\n这是因为这种平移操作非常便宜，可以让我更好地展示所有这些解决方案的内在开销（如间接寻址和虚函数调用的开销）。\n一个昂贵的操作，如 draw()，会掩盖这些细节，并可能给人以所有方法都非常相似的印象。\n我使用了GCC 11.1和Clang 11.1，并为这两种编译器仅添加了 -O3 和 -DNDEBUG 编译标志。使用的平台是macOS Big Sur（版本11.4），搭载8核Intel Core i7处理器，主频3.8 GHz，内存64 GB。\n从基准测试结果中最明显的结论是，variant 解决方案比 经典访问者 解决方案更高效。这并不令人惊讶：由于双重分派，经典访问者实现包含了很多间接寻址，因此也很难优化。\n此外，形状对象的内存布局非常完美：与其他所有解决方案（包括基于枚举的解决方案）相比，所有形状都在内存中连续存储，这是你可以选择的最有利于缓存的布局。\n第二个结论是，std::variant 确实非常高效，甚至可以说是出乎意料地高效。\n然而，令人惊讶的是效率高度依赖于我们是否使用 std::get_if() 或 std::visit()（我答应会回到这一点）。\n无论是GCC还是Clang，在使用 std::visit() 时生成的代码都要慢得多。我假设 std::visit() 在这一点上并没有被完美实现和优化。但是，正如我之前所说，性能总是很复杂，我不打算深入探讨这个谜题。\n最重要的是，std::variant 的美丽并没有因为糟糕的性能数据而受到破坏。\n相反：性能结果有助于加深你与 std::variant 新建立的关系。\n分析 std::variant 解决方案的不足之处\n虽然我不想危及这种关系，但我认为指出一些缺点是我的责任，如果你使用基于 std::variant 的解决方案，你将不得不面对这些问题。\n首先，我应该再次指出显而易见的事实：作为一种类似于访问者设计模式且基于过程编程的解决方案，std::variant 也专注于提供一组开放的操作，其缺点是你必须处理一个封闭的类型集。\n添加新类型会引发与我们在 “准则15：为类型或操作的添加进行设计” 中提到的基于枚举的解决方案类似的问题。首先，你必须更新 variant 本身，这可能会触发所有使用该 variant 类型的代码重新编译（还记得更新枚举吗？）。此外，你还必须更新所有操作，并为新的备选方案添加可能缺失的 operator()。好的一面是，如果缺少这些操作符之一，编译器会报错。坏的一面是，编译器不会生成一条友好、易读的错误信息，而是生成接近所有模板相关错误消息之母的东西。\n总的来说，这真的非常像我们之前使用基于枚举的解决方案时的经历。\n第二个潜在问题需要注意的是，你应该避免在 variant 中放置大小差异很大的类型。\n如果至少有一个备选方案比其他的大得多，存储许多较小的备选方案可能会浪费大量空间。这会对性能产生负面影响，解决方案是不直接存储较大的备选方案，而是通过代理对象或使用桥接设计模式来存储它们。\n当然，这会引入间接寻址，这也会影响性能。与存储不同大小的值相比，这种方法在性能上的劣势与否需要你自己进行基准测试。\n最后但同样重要的是，你应该始终意识到 variant 可以揭示很多信息。虽然它代表了一种运行时抽象，但包含的类型仍然清晰可见。这可能会创建对 variant 的物理依赖，即当你修改其中一个备选类型时，可能需要重新编译任何依赖它的代码。\n解决方案同样是存储指针或代理对象，这样可以隐藏实现细节。不幸的是，这也会对性能产生影响，因为很多性能提升来自于编译器了解这些细节并相应地优化它们。\n因此，在性能和封装之间总是存在权衡。\n尽管存在这些不足，总体而言，std::variant 被证明是一个很好的替代面向对象编程（OOP）的访问者设计模式。它大大简化了代码，几乎消除了所有的样板代码，并封装了丑陋且维护密集的部分，同时带来了卓越的性能。\n此外，std::variant 还证明了一个事实，即设计模式关注的是意图，而不是实现细节。\n本节总结\n理解经典Visitor和std::variant之间的架构相似性。 注意std::variant与面向对象访问者解决方案相比的优势。 使用std::variant的非侵入性来动态创建抽象。 记住std::variant的缺点，并在不合适的时候避免使用它 准则18：警惕无环访问者的性能 正如你在“准则15：为类型或操作的添加进行设计”中看到的，当你使用动态多态性时，你必须做出一个决定：你可以支持开放的类型集或开放的操作集。\n你不能两者兼得，好吧，我特别提到过，据我所知，同时拥有两者并不是不可能的，但通常不切实际。\n为了说明这一点，让我向你介绍访问者设计模式的另一种变体：无环访问者（Acyclic Visitor）。\n在 “准则16：使用访问者扩展操作”中，你看到了访问者设计模式的关键参与者之间存在循环依赖：访问者基类依赖于形状的具体类型（如 Circle、Square 等），具体类型的形状依赖于 Shape 基类，而 Shape 基类又依赖于访问者基类。\n由于这种循环依赖，将所有这些关键角色锁定在一个架构层次上，使得向访问者添加新类型变得困难。\n无环访问者的想法是打破这种依赖关系。\n图4-5 显示了无环访问者的UML图。\n与GoF访问者相比，虽然图片右侧只有很小的区别，但在左侧有一些根本性的变化。\n最重要的是，访问者基类被拆分成了多个基类：AbstractVisitor 基类和每个具体形状类型的一个基类（在这个例子中是 CircleVisitor 和 SquareVisitor）。\n所有访问者都必须继承自 AbstractVisitor 基类，但现在也有选择可以继承自具体的形状访问者基类。\n如果一个操作想要支持圆形，它就继承自 CircleVisitor 基类并实现针对 Circle 的 visit() 函数。\n如果它不想支持圆形，则只需不继承 CircleVisitor。\n以下代码片段展示了访问者基类的一种可能实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //---- \u0026lt;AbstractVisitor.h\u0026gt; ---------------- class AbstractVisitor { public: virtual ~AbstractVisitor() = default; }; //---- \u0026lt;Visitor.h\u0026gt; ---------------- template\u0026lt; typename T \u0026gt; class Visitor { protected: ~Visitor() = default; public: virtual void visit( T const\u0026amp; ) const = 0; }; AbstractVisitor 基类只是一个带有虚析构函数的空基类。不需要其他任何函数。正如你将看到的，AbstractVisitor 仅作为一个通用标记来识别访问者，并不需要提供任何操作。在C++中，我们倾向于以类模板的形式实现具体的形状访问者基类。Visitor 类模板根据特定的形状类型进行参数化，并为该特定形状引入纯虚函数 visit()。\n在我们的 Draw 访问者的实现中，我们现在将继承自三个基类：\nAbstractVisitor、Visitor\u0026lt;Circle\u0026gt; 和 Visitor\u0026lt;Square\u0026gt; ，因为我们希望支持 Circle 和 Square：\n1 2 3 4 5 6 7 8 9 10 11 class Draw : public AbstractVisitor, public Visitor\u0026lt;Circle\u0026gt;, public Visitor\u0026lt;Square\u0026gt; { public: void visit( Circle const\u0026amp; c ) const override { /* ... 实现绘制圆的逻辑 ... */ } void visit( Square const\u0026amp; s ) const override { /* ... 实现绘制正方形的逻辑 ... */ } }; 这种实现选择打破了循环依赖。如图4-6所示，架构的高层不再依赖于具体的形状类型。无论是形状（Circle 和 Square）还是操作现在都位于架构边界的低层。我们现在可以同时添加类型和操作。\n此刻，你看起来非常怀疑，几乎是责备地看向我。我不是说过两者兼得是不可能的吗？显然，这是可能的，对吧？好吧，再一次强调，我没有声称这是不可能的。我更倾向于说这可能是不切实际的。现在你已经看到了无环访问者的优势，让我向你展示这种方法的缺点。\n首先，让我们看一下 Circle 中 accept() 函数的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //---- \u0026lt;Circle.h\u0026gt; ---------------- class Circle : public Shape { public: explicit Circle(double radius) : radius_(radius) { /* 检查给定的半径是否有效 */ } void accept(AbstractVisitor const\u0026amp; v) override { if (auto const* cv = dynamic_cast\u0026lt;Visitor\u0026lt;Circle\u0026gt; const*\u0026gt;(\u0026amp;v)) { cv-\u0026gt;visit(*this); } } double radius() const { return radius_; } Point center() const { return center_; } private: double radius_; Point center_{}; }; 你可能已经注意到 Shape 层次结构中的一个小变化：虚函数 accept() 现在接受一个 AbstractVisitor。\n你还记得 AbstractVisitor 本身并不实现任何操作。因此，Circle 不是在 AbstractVisitor 上调用 visit() 函数，而是通过执行 dynamic_cast 来确定给定的访问者是否支持圆形（Visitor\u0026lt;Circle\u0026gt; ）。\n请注意，它执行的是指针转换，这意味着 dynamic_cast 将返回一个有效的 Visitor\u0026lt;Circle\u0026gt; 指针或 nullptr。如果返回一个有效的 Visitor\u0026lt;Circle\u0026gt; 指针，它将调用相应的 visit() 函数。\n虽然这种方法确实有效，并且是打破访问者设计模式循环依赖的一部分，但使用 dynamic_cast 总会让人感到不安。\ndynamic_cast 应该总是让人有点怀疑，因为如果使用不当，它可能会破坏架构。这种情况发生在我们从架构的高层对位于架构低层的东西进行强制类型转换时。在我们的例子中，实际上是可以使用的，因为我们是在架构的低层使用它。因此，通过将低层的知识插入到高层并不会破坏架构。\n真正的缺陷在于运行时的开销。当我们运行与“准则17：考虑使用 std::variant 实现访问者”相同的基准测试时，你会发现无环访问者的运行时间几乎比循环访问者高出一个数量级（见表4-3）。\n原因是 dynamic_cast 很慢，非常慢。对于这个应用尤其如此。我们在这里进行的是交叉转换（cross-cast）。我们不仅仅是在向下转换到特定的派生类，而是在继承层次结构的另一个分支上进行转换。这种交叉转换，再加上虚拟函数调用，比简单的向下转换要昂贵得多。\n访问者实现 GCC 11.1 Clang 11.1 无环访问者 14.3423 s 7.3445 s 循环访问者 1.6161 s 1.8015 s 面向对象解决方案 1.5205 s 1.1480 s 枚举解决方案 1.2179 s 1.1200 s std::variant（使用 std::visit()） 1.1992 s 1.2279 s std::variant（使用 std::get_if()） 1.0252 s 0.6998 s 本节总结\n了解无循环访问器的架构优势。 请注意该解决方案的显著性能缺点。 第五章 策略和命令设计模式 本章专门讨论两种最常用的设计模式：策略设计模式 和 命令设计模式。事实上，它们是非常常用的：C++ 标准库本身就使用了这两种模式数十次，而且很有可能你自己也多次使用过它们。这两种模式可以被视为每个开发者的基石工具。\n在“准则19：使用策略隔离事物的实现方式”中，我将向你介绍策略设计模式。我将展示为什么它是最有用和最重要的设计模式之一，并解释为什么你会在许多场景中发现它非常有用。\n在“准则20：优先使用组合而非继承”中，我们将探讨继承以及为什么许多人对它有抱怨。你会发现继承本身并不是坏的，但和其他任何东西一样，它有其优点和局限性。最重要的是，我将解释许多经典设计模式的力量并非来源于继承，而是来源于组合。\n在“准则21：使用命令隔离事物的操作内容”中，我将向你介绍命令设计模式。我将展示如何高效地使用该设计模式，并给你一个关于命令与策略之间比较的概念。\n在“准则22：优先使用值语义而非引用语义”中，我们将深入探讨引用语义的领域。然而，我们会发现这个领域并不特别友好和好客，并且会让我们担心代码的质量。因此，我们将迁移到值语义的领域，这将为我们提供许多对代码库有益的功能。\n在“准则23：优先使用基于值的策略和命令实现”中，我们将再次回顾策略和命令模式。我将展示如何应用我们在值语义领域获得的见解，并基于 std::function 实现这两种设计模式。\n通过这些指南，你将更好地理解如何在实际项目中有效使用策略和命令设计模式，并学会如何选择适当的实现方式以优化代码质量和性能。希望这些内容对你有所帮助！\n准则19：使用策略隔离事物的实现方式 让我们假设你和你的团队即将实现一个新的2D图形工具。除了其他需求外，它需要处理简单的几何图元，如圆形、正方形等，并且这些图元需要被绘制（见图5-1）。\n图5-1. 初始的Shape继承层次结构\n一些类已经实现了，例如一个 Shape 基类、一个 Circle 类和一个 Square 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: virtual ~Shape() = default; virtual void draw(/* some arguments */) const = 0; }; //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; class Circle : public Shape { public: explicit Circle(double radius) : radius_(radius) { /* 检查给定的半径是否有效 */ } double radius() const { return radius_; } Point center() const { return center_; } void draw(/* some arguments */) const override; private: double radius_; Point center_{}; }; //---- \u0026lt;Circle.cpp\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include /* 一些图形库 */ void Circle::draw(/* some arguments */) const { // ... 实现绘制圆的逻辑 } //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Point.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; class Square : public Shape { public: explicit Square(double side) : side_(side) { /* 检查给定的边长是否有效 */ } double side() const { return side_; } Point center() const { return center_; } void draw(/* some arguments */) const override; private: double side_; Point center_{}; }; //---- \u0026lt;Square.cpp\u0026gt; ---------------- #include \u0026lt;Square.h\u0026gt; #include /* 一些图形库 */ void Square::draw(/* some arguments */) const { // ... 实现绘制正方形的逻辑 } 最重要的方面是 Shape 基类中的纯虚函数 draw()（）。\n在你休假期间，你的团队成员已经为 Circle 和 Square 类实现了这个 draw() 成员函数，使用的是OpenGL（和）。\n该工具已经能够绘制圆形和正方形，并且整个团队一致认为生成的图形看起来非常整洁。每个人都感到满意！\n分析设计问题 除了你之外的每个人，从假期回来后，你当然立即意识到已实现的解决方案违反了单一职责原则（SRP）。\n目前来看，Shape 层次结构并没有为变化而设计。\n首先，改变形状的绘制方式并不容易，在当前实现中，只有一种固定的绘制形状的方式，并且无法非侵入性地更改这些细节。因为你已经预测到该工具将需要支持多个图形库，这绝对是一个问题。其次，如果你最终进行更改，则需要在多个不相关的地点修改行为。\n但还有更多问题。由于绘制功能是在 Circle 和 Square 类中实现的，因此 Circle 和 Square 类依赖于 draw() 的实现细节，这意味着它们依赖于 OpenGL。\n尽管圆和正方形应该主要是简单的几何图元，但现在这两个类在所有使用的地方都必须承担使用 OpenGL 的负担。\n当你向同事们指出这些问题时，他们一开始有些不知所措。同时也有点恼火，因为他们没有预料到你会指出他们美丽解决方案中的任何缺陷。然而，你有一个非常好的解释问题的方法，最终他们同意了你的观点并开始思考更好的解决方案。\n没过多久，他们就想出了一个更好的方法。几天后的下一次团队会议上，他们展示了他们的新想法：在继承层次结构中增加一层（见图5-2）。\n为了演示这个想法，他们已经实现了 OpenGLCircle 和 OpenGLSquare 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; class Circle : public Shape { public: // ... 不再实现 draw() 成员函数 }; //---- \u0026lt;OpenGLCircle.h\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; class OpenGLCircle : public Circle { public: explicit OpenGLCircle(double radius) : Circle(radius) {} void draw(/* some arguments */) const override; }; //---- \u0026lt;OpenGLCircle.cpp\u0026gt; ---------------- #include \u0026lt;OpenGLCircle.h\u0026gt; #include /* OpenGL 图形库头文件 */ void OpenGLCircle::draw(/* some arguments */) const { // ... 使用 OpenGL 实现绘制圆的逻辑 } //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; class Square : public Shape { public: // ... 不再实现 draw() 成员函数 }; //---- \u0026lt;OpenGLSquare.h\u0026gt; ---------------- #include \u0026lt;Square.h\u0026gt; class OpenGLSquare : public Square { public: explicit OpenGLSquare(double side) : Square(side) {} void draw(/* some arguments */) const override; }; //---- \u0026lt;OpenGLSquare.cpp\u0026gt; ---------------- #include \u0026lt;OpenGLSquare.h\u0026gt; #include /* OpenGL 图形库头文件 */ void OpenGLSquare::draw(/* some arguments */) const { // ... 使用 OpenGL 实现绘制正方形的逻辑 } 继承！当然！通过简单地从 Circle 和 Square 派生，并将 draw() 函数的实现进一步下移到层次结构中，可以很容易地以不同的方式实现绘制。\n例如，可能会有 MetalCircle 和 VulkanCircle，假设需要支持 Metal 和 Vulkan 库。突然之间，改变变得容易了，对吧？\n虽然你的同事们仍然为他们的新解决方案感到非常自豪，但你已经意识到这种方法不会长期有效。并且很容易展示其缺点：你只需要考虑另一个需求，例如一个 serialize() 成员函数：\n1 2 3 4 5 6 7 class Shape { public: virtual ~Shape() = default; virtual void draw(/* some arguments */) const = 0; virtual void serialize(/* some arguments */) const = 0; }; serialize() 成员函数旨在将形状转换为字节序列，可以存储在文件或数据库中，然后可以从字节序列反序列化以重新创建完全相同的形状。就像 draw() 成员函数一样，serialize() 成员函数也可以以多种方式实现。例如，你可以使用 protobuf 或 Boost.serialization 库。\n使用将实现细节向下移动到继承层次结构的相同策略，这将很快导致一个相当复杂且相当人为的层次结构（见图5-3）。考虑以下类名：OpenGLProtobufCircle、MetalBoostSerialSquare 等等。\n可笑吧？我们该如何组织这种结构呢？我们应该在层次结构中添加另一层（如 Square 分支所示）吗？\n这种方法会迅速导致一个深层次且复杂的层次结构，或者我们是否应该更平坦地展开层次结构（如 Circle 分支所示）？关于重用实现细节又该怎么办呢？例如，如何在 OpenGLProtobufCircle 和 OpenGLBoostSerialCircle 类之间重用 OpenGL 代码？\n策略设计模式解释\n你意识到你的同事们过于迷恋继承，而你需要拯救这一天。\n他们似乎需要有人向他们展示如何为这种变化进行正确的设计，并为他们提供一个适当的解决方案。\n正如两位务实的程序员所言：“继承很少是答案。” 问题仍然是违反了单一职责原则（SRP），因为你需要计划如何改变不同形状的绘制方式，你应该将绘制方面识别为一个变化点。\n有了这个认识，正确的做法是为变化设计，遵循SRP，并提取变化点。这就是策略设计模式的意图，它是经典GoF设计模式之一。\n意图：“定义一组算法，封装每个算法，并使它们可以互换。策略模式允许算法独立于使用它的客户端进行变化。” 而不是在派生类中实现虚函数 draw()，你可以引入另一个类来专门用于绘制形状。\n在经典的面向对象（OO）形式的策略设计模式中，这是通过引入 DrawStrategy 基类来实现的（见图5-4）。\n现在将绘制方面隔离出来，使得我们可以在不修改形状类的情况下更改绘制的实现。这实现了SRP的思想。你现在也可以在不修改任何其他代码的情况下引入新的 draw() 实现。这满足了开放封闭原则（OCP）。再一次，在这种面向对象设置中，SRP是OCP的推动者。\n以下代码片段展示了 DrawStrategy 基类的一个简单实现：\n1 2 3 4 5 6 7 8 9 10 //---- \u0026lt;DrawStrategy.h\u0026gt; ---------------- class Circle; class Square; class DrawStrategy { public: virtual ~DrawStrategy() = default; virtual void draw(Circle const\u0026amp; circle, /* some arguments */) const = 0; virtual void draw(Square const\u0026amp; square, /* some arguments */) const = 0; }; DrawStrategy 类带有虚拟析构函数和两个纯虚函数 draw()，一个用于圆形，一个用于正方形。\n为了编译这个基类，你需要前向声明 Circle 和 Square 类。\n由于策略设计模式，Shape 基类没有变化。它仍然代表所有形状的抽象，并因此提供了一个纯虚函数 draw()。策略模式旨在提取实现细节，因此只影响派生类：\n1 2 3 4 5 6 7 8 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: virtual ~Shape() = default; virtual void draw(/* some arguments */) const = 0; // ... 可能还有其他函数，例如 \u0026#39;serialize()\u0026#39; 成员函数 }; 虽然由于策略模式 Shape 基类没有变化，但 Circle 和 Square 类受到了影响：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;DrawStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; class Circle : public Shape { public: explicit Circle(double radius, std::unique_ptr\u0026lt;DrawStrategy\u0026gt; drawer) : radius_(radius) , drawer_(std::move(drawer)) { /* 检查给定的半径是否有效且给定的 std::unique_ptr 实例不是 nullptr */ } void draw(/* some arguments */) const override { drawer_-\u0026gt;draw(*this, /* some arguments */); } double radius() const { return radius_; } private: double radius_; std::unique_ptr\u0026lt;DrawStrategy\u0026gt; drawer_; }; //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;DrawStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; class Square : public Shape { public: explicit Square(double side, std::unique_ptr\u0026lt;DrawStrategy\u0026gt; drawer) : side_(side) , drawer_(std::move(drawer)) { /* 检查给定的边长是否有效且给定的 std::unique_ptr 实例不是 nullptr */ } void draw(/* some arguments */) const override { drawer_-\u0026gt;draw(*this, /* some arguments */); } double side() const { return side_; } private: double side_; std::unique_ptr\u0026lt;DrawStrategy\u0026gt; drawer_; }; 现在，Circle 和 Square 都期望在其构造函数中接收一个指向 DrawStrategy 的 unique_ptr。\n这允许我们从外部配置绘制行为，通常称为依赖注入。unique_ptr 被移动到相同类型的新的数据成员中。\n还可以提供相应的 setter 函数，这将允许你在稍后的时间点更改绘制行为。draw() 成员函数现在不需要自己实现绘制逻辑，只需调用给定 DrawStrategy 的 draw() 函数。\n分析朴素解决方案的不足\n太棒了！有了这个实现，你现在可以在本地、隔离地改变形状绘制的行为，并让每个人都能实现新的绘制行为。然而，目前我们的策略实现有一个严重的设计缺陷。\n为了分析这个缺陷，假设你需要添加一种新的形状，比如三角形。这应该很容易，因为正如我们在“准则15：设计以增加类型或操作”中讨论的那样，面向对象编程（OOP）的优势在于能够轻松添加新类型。\n当你开始引入三角形时，你会发现添加新类型的形状并不像预期的那么简单。\n首先，你需要编写新类。这是可以预料的，也不是问题。但随后你必须更新 DrawStrategy 基类，以便也能绘制三角形。反过来，这会对圆形和正方形产生不幸的影响：Circle 和 Square 类都需要重新编译、重新测试并可能重新部署。更广泛地说，所有形状都会受到影响。而这种情况应该是有问题的。为什么在添加一个 Triangle 类时，圆形和正方形需要重新编译？\n技术上的原因是通过 DrawStrategy 基类，所有形状隐式地知道彼此。\n因此，添加一个新的形状会影响所有其他形状。根本的设计原因是违反了接口分离原则（ISP）（见“准则3：分离接口以避免人为耦合”）。\n通过定义单一的 DrawStrategy 基类，你人为地将圆形、正方形和三角形耦合在一起。由于这种耦合，你使得添加新类型变得更加困难，从而限制了OOP的优势。相比之下，你创造了一种与我们讨论过程化解决方案时非常相似的情况（见“准则15：设计以增加类型或操作”）。\n“难道我们无意中重新实现了访问者设计模式吗？”你可能会问。\n我明白你的意思：DrawStrategy 确实看起来很像访问者。但不幸的是，它并不能满足访问者的意图，因为你不能轻易地添加其他操作。要做到这一点，你需要侵入性地在 Shape 层次结构中添加一个虚拟成员函数。“而且它也不是策略模式，因为我们无法添加类型，对吧？”是的，正确。从设计的角度来看，这是最糟糕的情况。\n要正确实现策略设计模式，你必须分别提取每个形状的实现细节。你需要为每种形状引入一个 DrawStrategy 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //---- \u0026lt;DrawCircleStrategy.h\u0026gt; ---------------- class Circle; class DrawCircleStrategy { public: virtual ~DrawCircleStrategy() = default; virtual void draw(Circle const\u0026amp; circle, /*some arguments*/) const = 0; }; //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;DrawCircleStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; class Circle : public Shape { public: explicit Circle(double radius, std::unique_ptr\u0026lt;DrawCircleStrategy\u0026gt; drawer) : radius_(radius) , drawer_(std::move(drawer)) { /* 检查给定的半径是否有效且给定的 \u0026#39;std::unique_ptr\u0026#39; 不是 nullptr */ } void draw(/*some arguments*/) const override { drawer_-\u0026gt;draw(*this, /*some arguments*/); } double radius() const { return radius_; } private: double radius_; std::unique_ptr\u0026lt;DrawCircleStrategy\u0026gt; drawer_; }; //---- \u0026lt;DrawSquareStrategy.h\u0026gt; ---------------- class Square; class DrawSquareStrategy { public: virtual ~DrawSquareStrategy() = default; virtual void draw(Square const\u0026amp; square, /*some arguments*/) const = 0; }; //---- \u0026lt;Square.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;DrawSquareStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; class Square : public Shape { public: explicit Square(double side, std::unique_ptr\u0026lt;DrawSquareStrategy\u0026gt; drawer) : side_(side) , drawer_(std::move(drawer)) { /* 检查给定的边长是否有效且给定的 \u0026#39;std::unique_ptr\u0026#39; 不是 nullptr */ } void draw(/*some arguments*/) const override { drawer_-\u0026gt;draw(*this, /*some arguments*/); } double side() const { return side_; } private: double side_; std::unique_ptr\u0026lt;DrawSquareStrategy\u0026gt; drawer_; }; 对于 Circle 类，你需要引入 DrawCircleStrategy 基类，而对于 Square 类，则是 DrawSquareStrategy 基类。\n随着 Triangle 类的添加，你也需要添加一个 DrawTriangleStrategy 基类。只有这样，你才能正确分离关注点，并仍然允许每个人添加新类型和形状绘制的新实现。\n有了这些功能，你可以轻松实现用于绘制圆形、正方形甚至三角形的新策略类。例如，考虑实现 DrawCircleStrategy 接口的 OpenGLCircleStrategy：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //---- \u0026lt;OpenGLCircleStrategy.h\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;DrawCircleStrategy.h\u0026gt; #include /* OpenGL 图形库 */ class OpenGLCircleStrategy : public DrawCircleStrategy { public: explicit OpenGLCircleStrategy(/* 绘制相关的参数 */); void draw(Circle const\u0026amp; circle, /*...*/) const override; private: /* 绘制相关的数据成员，例如颜色、纹理等 */ }; 请注意，Circle 和 DrawCircleStrategy 类位于相同的架构级别。\n更值得注意的是它们之间的循环依赖关系：Circle 依赖于 DrawCircleStrategy，但 DrawCircleStrategy 也依赖于 Circle。但是不要担心：虽然乍一看这似乎是个问题，但实际上并不是。这是一个必要的关系，表明 Circle 真正拥有 DrawCircleStrategy 并由此创建了所需依赖倒置，如“准则9：注意抽象的所有权”中所讨论的那样。\n“使用类模板实现不同的 draw 策略类是否可行？我想象中的类似于用于无环访问者的访问者类”：\n1 2 3 4 5 6 7 8 //---- \u0026lt;DrawStrategy.h\u0026gt; ---------------- template\u0026lt;typename T\u0026gt; class DrawStrategy { public: virtual ~DrawStrategy() = default; virtual void draw(T const\u0026amp;) const = 0; }; 这是一个好主意，也正是你应该做的。通过此类模板，你可以将 DrawStrategy 提升到更高的架构级别，重用代码，并遵循DRY原则（见图5-6）。此外，如果从一开始就采用这种方法，我们将不会陷入人为耦合不同类型的问题。是的，我真的喜欢这个！\n尽管这是我们如何实现这样一个策略类的方式，但你仍然不应该期望这会减少基类的数量（仍然是相同的，只是生成的），或者这会为你节省很多工作。\nDrawStrategy 的实现，例如 OpenGLCircleStrategy 类，代表了大部分的工作，并且几乎不会改变：\n1 2 3 4 5 6 7 8 //---- \u0026lt;OpenGLCircleStrategy.h\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;DrawStrategy.h\u0026gt; #include /* OpenGL 图形库 */ class OpenGLCircleStrategy : public DrawStrategy\u0026lt;Circle\u0026gt; { // ... }; 假设类似实现的 OpenGLSquareStrategy，我们现在可以将所有内容放在一起，并再次绘制形状，这次是使用策略设计模式正确解耦的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;OpenGLCircleStrategy.h\u0026gt; #include \u0026lt;OpenGLSquareStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; int main() { using Shapes = std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt;; Shapes shapes{}; // 创建一些形状，每个形状都配备了相应的OpenGL绘制策略 shapes.emplace_back( std::make_unique\u0026lt;Circle\u0026gt;( 2.3, std::make_unique\u0026lt;OpenGLCircleStrategy\u0026gt;(/*...红色...*/) ) ); shapes.emplace_back( std::make_unique\u0026lt;Square\u0026gt;( 1.2, std::make_unique\u0026lt;OpenGLSquareStrategy\u0026gt;(/*...绿色...*/) ) ); shapes.emplace_back( std::make_unique\u0026lt;Circle\u0026gt;( 4.1, std::make_unique\u0026lt;OpenGLCircleStrategy\u0026gt;(/*...蓝色...*/) ) ); // 绘制所有形状 for(auto const\u0026amp; shape : shapes) { shape-\u0026gt;draw(/*some arguments*/); } return EXIT_SUCCESS; } 访问者模式与策略模式的比较\n既然你已经了解了访问者设计模式和策略设计模式，你可能会疑惑这两者的区别是什么。毕竟，它们的实现看起来相当相似。然而，尽管在实现上有一些相似之处，这两种设计模式的特性是非常不同的。\n使用访问者设计模式时，我们将一般操作的添加视为变化点。因此，我们为操作创建了一个抽象，这反过来允许每个人添加操作。不幸的副作用是，添加新的形状类型变得不再容易。\n使用策略设计模式时，我们将单个函数的实现细节视为变化点。引入这些实现细节的抽象后，我们仍然能够轻松地添加新的形状类型，但无法轻松地添加新操作。添加一个操作仍然需要侵入性地添加一个虚拟成员函数。因此，策略设计模式的意图与访问者设计模式的意图正好相反。\n将这两种设计模式结合起来以获得两者的优点（使添加类型和操作都变得容易）听起来很有前景。不幸的是，这种方法行不通：无论你先应用哪种设计模式，都会固定两个自由轴中的一个。因此，你应该记住这两种设计模式的优点和缺点，并根据你对代码库演化的预期来应用它们。\n分析策略设计模式的不足\n我已经向你展示了策略设计模式的优势：它通过引入一个抽象来减少对特定实现细节的依赖。然而，在软件设计中没有万能药，每种设计都有其一系列的缺点。策略设计模式也不例外，考虑潜在的缺点同样重要。\n首先，虽然某个操作的实现细节已经被提取和隔离，但该操作本身仍然是具体类型的一部分。这一事实证明了上述限制，即我们仍然不能轻易地添加操作。与访问者不同，策略保留了OOP的优势，使你可以轻松添加新类型。\n其次，尽早识别这些变化点是有回报的。否则需要进行大规模重构。当然，这并不意味着你应该一开始就用策略模式实现一切以防未来需要重构。这样做可能会导致过度设计。但在有迹象表明实现细节可能发生变化，或者有多重实现的需求时，应该尽快实施必要的修改。最好的建议，虽然是有点不具体的，就是保持事情尽可能简单（KISS原则；保持简单，愚蠢）。\n第三，如果你通过基类实现策略模式，性能肯定会因为额外的运行时间接调用而受到影响。性能还受到许多手动分配（std::make_unique() 调用）、由此产生的内存碎片以及由于众多指针造成的各种间接调用的影响。这是可以预料的，但你的实现的灵活性以及每个人都可以添加新实现的机会可能会超过这种性能损失。当然，这取决于具体情况，你需要逐案决定。如果你使用模板实现策略模式（见“基于策略的设计”讨论），这种缺点就不成问题。\n最后但并非最不重要的，策略设计模式的主要缺点是单一策略应处理单一操作或一组紧密相关的函数。否则，你又会违反单一职责原则（SRP）。如果需要提取多个操作的实现细节，则需要有多个策略基类和多个数据成员，可以通过依赖注入设置。例如，考虑有一个额外的 serialize() 成员函数的情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 //---- \u0026lt;DrawCircleStrategy.h\u0026gt; ---------------- class Circle; class DrawCircleStrategy { public: virtual ~DrawCircleStrategy() = default; virtual void draw(Circle const\u0026amp; circle, /*some arguments*/) const = 0; }; //---- \u0026lt;SerializeCircleStrategy.h\u0026gt; ---------------- class Circle; class SerializeCircleStrategy { public: virtual ~SerializeCircleStrategy() = default; virtual void serialize(Circle const\u0026amp; circle, /*some arguments*/) const = 0; }; //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;DrawCircleStrategy.h\u0026gt; #include \u0026lt;SerializeCircleStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; class Circle : public Shape { public: explicit Circle(double radius, std::unique_ptr\u0026lt;DrawCircleStrategy\u0026gt; drawer, std::unique_ptr\u0026lt;SerializeCircleStrategy\u0026gt; serializer /* 可能还有更多与策略相关的参数 */) : radius_(radius) , drawer_(std::move(drawer)) , serializer_(std::move(serializer)) // ... { /* 检查给定的半径是否有效且给定的 std::unique_ptrs 不是 nullptrs */ } void draw(/*some arguments*/) const override { drawer_-\u0026gt;draw(*this, /*some arguments*/); } void serialize(/*some arguments*/) const override { serializer_-\u0026gt;serialize(*this, /*some arguments*/); } double radius() const { return radius_; } private: double radius_; std::unique_ptr\u0026lt;DrawCircleStrategy\u0026gt; drawer_; std::unique_ptr\u0026lt;SerializeCircleStrategy\u0026gt; serializer_; // ... 可能还有更多与策略相关的数据成员 }; 虽然这会导致基类的大量增加以及由于多个指针而导致实例变大，但也提出了如何设计类以便方便地分配多个不同策略的问题。因此，策略设计模式在需要隔离少量实现细节的情况下最为强大。如果你遇到需要提取许多操作细节的情况，最好考虑其他方法（例如第7章的外部多态设计模式或第8章的类型擦除设计模式）。\n基于策略的设计\n正如前面章节所展示的，策略设计模式不仅限于动态多态性。相反，策略的意图可以通过使用模板在静态多态性中完美实现。例如，考虑标准库中的以下两个算法：\n1 2 3 4 5 6 7 8 9 namespace std { template\u0026lt;typename ForwardIt, typename UnaryPredicate\u0026gt; constexpr ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p); template\u0026lt;typename RandomIt, typename Compare\u0026gt; constexpr void sort(RandomIt first, RandomIt last, Compare comp); } // namespace std std::partition() 和 std::sort() 算法都使用了策略设计模式。std::partition() 的 UnaryPredicate 参数和 std::sort() 的 Compare 参数代表了一种从外部注入部分行为的方法。更具体地说，这两个参数允许你指定元素如何排序。因此，这两个算法提取了其特定行为的一部分，并以概念的形式为这些行为提供了抽象（见“指南7：理解基类与概念之间的相似性”）。这与面向对象形式的策略不同，不会产生任何运行时性能损失。\n类似的思路也可以在 std::unique_ptr 类模板中看到：\n1 2 3 4 5 6 7 8 9 namespace std { template\u0026lt;typename T, typename Deleter = std::default_delete\u0026lt;T\u0026gt;\u0026gt; class unique_ptr; template\u0026lt;typename T, typename Deleter\u0026gt; class unique_ptr\u0026lt;T[], Deleter\u0026gt;; } // namespace std 对于基础模板和数组专用模板，都可以指定第二个模板参数为显式的 Deleter。通过这个参数，你可以决定是否要通过 delete、free() 或其他释放函数来释放资源。甚至可以“滥用” std::unique_ptr 来执行完全不同的清理操作。\n这种灵活性也是策略设计模式的证据。模板参数允许你将一些清理行为注入到类中。这种形式的策略也被称为基于策略的设计，这是安德烈·亚历山德雷斯库在2001年提出的一种设计理念。其思想相同：提取并隔离类模板的具体行为，以提高可变性、可扩展性、可测试性和可重用性。因此，基于策略的设计可以被视为策略设计模式的静态多态形式。显然，这种设计非常有效，如标准库中众多应用所展示的那样。\n你还可以将基于策略的设计应用于形状绘制的例子。考虑以下 Circle 类的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;DrawCircleStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; template\u0026lt;typename DrawCircleStrategy\u0026gt; class Circle : public Shape { public: explicit Circle(double radius, DrawCircleStrategy drawer) : radius_(radius) , drawer_(std::move(drawer)) { /* 检查给定的半径是否有效 */ } void draw(/*some arguments*/) const override { drawer_(*this, /*some arguments*/); } double radius() const { return radius_; } private: double radius_; DrawCircleStrategy drawer_; // 如果假定给定的策略是无状态的，则可能可以省略。 }; 与其在构造函数中传递 std::unique_ptr 到 DrawCircleStrategy 基类，不如通过模板参数指定策略。最大的优势是由于较少的指针间接调用而带来的性能提升：你可以直接调用由 DrawCircleStrategy 提供的具体实现，而不是通过 std::unique_ptr 调用。缺点是你会失去在运行时调整特定 Circle 实例绘制策略的灵活性。此外，你不会再有一个单一的 Circle 类。你会为每个绘制策略有一个 Circle 的实例化。最后但并非最不重要的是，你应该记住类模板通常完全位于头文件中。因此，你可能会失去在源文件中隐藏实现细节的机会。一如既往，没有完美的解决方案，选择“正确”的解决方案取决于实际上下文。\n本节总结\n要明白，继承很少能解决问题。 应用Strategy设计模式的目的是提取一组内聚功能的实现细节。 为每个操作实现一个策略，以避免人为耦合。 将基于策略的设计视为策略设计模式的编译时形式。 准则20：优先使用组合而非继承 在90年代和21世纪初面向对象编程（OOP）热潮之后，如今的OOP处于守势。反对OOP并强调其缺点的声音越来越强烈。这不仅限于C++社区，也包括其他编程语言社区。虽然OOP整体确实有一些局限性，但让我们聚焦于引起最多争议的一个特性：继承。正如Sean Parent所说：\n“继承是万恶之源。”\n虽然继承被宣传为一种非常自然且直观的方式去模拟现实世界的关系，但实际上它比承诺的要难用得多。当你我们在讨论Liskov替换原则（LSP）时已经看到了继承的微妙失败（见“指南6：遵循抽象的预期行为”）。但继承还有其他方面常常被误解。\n首先，继承总是被认为简化了可重用性。这似乎是直观的，因为从另一个类继承代码看起来很容易重用。不幸的是，这种重用并不是继承带来的那种重用。继承不是关于重用基类中的代码；相反，它是关于通过使用基类多态地重用其他代码。例如，假设有一个稍微扩展的 Shape 基类，以下函数适用于所有类型的形状，并因此可以被 Shape 基类的所有实现重用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Shape { public: virtual ~Shape() = default; virtual void translate(/*some arguments*/) = 0; virtual void rotate(/*some arguments*/) = 0; virtual void draw(/*some arguments*/) const = 0; virtual void serialize(/*some arguments*/) const = 0; // ... 可能有其他成员函数 ... }; void rotateAroundPoint(Shape\u0026amp; shape); void mergeShapes(Shape\u0026amp; s1, Shape\u0026amp; s2); void writeToFile(Shape const\u0026amp; shape); void sendViaRPC(Shape const\u0026amp; shape); // ... 所有四个函数（rotateAroundPoint、mergeShapes、writeToFile 和 sendViaRPC）都是基于 Shape 抽象构建的。所有这些函数仅耦合到所有类型形状的公共接口，而不是任何特定的形状。所有类型的形状都可以围绕一个点旋转、合并、写入文件并通过RPC发送。每种形状都“重用”了此功能。\n正是通过抽象表达功能的能力创造了代码重用的机会。与基类中包含的小量代码相比，这种功能预计会产生大量的代码。因此，真正的可重用性是由类型的多态使用创建的，而不是由多态类型创建的。\n其次，继承被认为有助于解耦软件实体。虽然这绝对是正确的（例如，回想一下“指南9：注意抽象的所有权”中关于依赖倒置原则（DIP）的讨论），但往往没有解释继承也会产生耦合。你之前已经看到过这一点。在实现访问者设计模式时，你体验到了继承如何强制某些实现细节给你。在一个经典的访问者模式中，你必须实现访问者基类的纯虚函数，即使这对你的应用程序来说并不理想。你对函数参数或返回类型也没有太多选择。这些都是固定的。\n你在讨论策略设计模式开始时也体验到了这种耦合。在这种情况下，继承强制了一种结构耦合，导致了更深的继承层次结构，导致了可疑的类命名，并损害了重用性。\n在此时，你可能会觉得我在试图完全诋毁继承。好吧，说实话，我只是想让它看起来有点不好，但只是必要的程度。明确地说：继承并不坏，也不意味着不应该使用它。相反：继承是一个非常强大的特性，如果使用得当，你可以用它做令人难以置信的事情。然而，“如果使用得当”这部分是个问题。继承已经被证明很难正确使用（肯定比我们被告知的要难得多；参见我之前的理由），因此经常被无意中误用。它也被过度使用，因为许多开发人员习惯于用它来解决各种问题。这种过度使用似乎是许多问题的根源，正如Michael Feathers所言：\n“[编程差异]在1990年代失宠，当时许多人注意到如果过度使用继承会相当麻烦。”\n在许多情况下，继承既不是正确的解决方案也不是正确的工具。大多数时候，使用组合更为可取。你应该不会对此感到惊讶，因为你已经看到这是事实。组合是OO形式的策略设计模式如此有效的根本原因，而不是继承。引入抽象和聚合相应的数据成员使策略设计模式如此强大，而不是基于继承的不同策略实现。实际上，你会发现许多设计模式坚实地基于组合，而不是继承。所有这些模式都能通过继承进行扩展，但它们本身是通过组合实现的。\n委托给服务：拥有优于是。 ——Andrew Hunt和David Thomas，《实用程序员》\n这是许多设计模式的一般要点。我建议你将这一见解牢记在心，因为它将对你理解本书剩余部分中看到的设计模式非常有用，并将提高你实现的质量。\n本节总结\n要明白继承经常被过度使用，有时甚至被误用。 请记住，继承创建了紧密耦合。 要认识到许多设计模式是通过组合而不是继承来实现的。 准则21：使用命令模式隔离操作内容 在我们开始这条指南之前，让我们先做一个实验。\n打开你喜欢的电子邮件客户端，给我写一封电子邮件。添加以下内容：“我爱您的书！它让我整晚都睡不着，并且让我忘记了所有的烦恼。” 好的，很好。现在点击发送。\n干得不错！给我几秒钟检查我的邮箱……还没有收到……还是没有……让我们再试一次：点击重新发送。还是没有。\n嗯，我猜有些服务器可能出了问题。或者是我这边的所有命令都失败了：WriteCommand（写命令）、SendCommand（发送命令）、ResendCommand（重新发送命令），等等。真不幸。\n但尽管这个实验失败了，你现在应该对另一个GoF设计模式有了一个很好的理解：命令设计模式。\n命令设计模式解析\n命令设计模式专注于封装和隔离工作包，这些工作包通常只执行一次，并且通常是立即执行的。为此，它识别不同类型的工作包作为变化点，并引入相应的抽象，允许轻松实现新的工作包类型。\n意图：“将请求封装为对象，从而让你可以使用不同的请求参数化客户端，队列或记录请求，并支持可撤销的操作。”\n以计算器为例，下面是命令设计模式的一个实现。第一个代码片段展示了CalculatorCommand基类的实现，它代表了对给定整数进行数学运算的抽象：\n1 2 3 4 5 6 7 8 9 10 //---- \u0026lt;CalculatorCommand.h\u0026gt; ---------------- class CalculatorCommand { public: virtual ~CalculatorCommand() = default; virtual int execute(int i) const = 0; virtual int undo(int i) const = 0; }; CalculatorCommand类期望派生类实现纯虚函数execute()和undo()。对于undo()的预期是它实现了必要的操作来逆转execute()函数的效果。\n加法和减法类都代表了计算器可能的命令，因此它们实现了CalculatorCommand基类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //---- \u0026lt;Add.h\u0026gt; ---------------- #include \u0026lt;CalculatorCommand.h\u0026gt; class Add : public CalculatorCommand { public: explicit Add(int operand) : operand_(operand) {} int execute(int i) const override { return i + operand_; } int undo(int i) const override { return i - operand_; } private: int operand_{}; }; //---- \u0026lt;Subtract.h\u0026gt; ---------------- #include \u0026lt;CalculatorCommand.h\u0026gt; class Subtract : public CalculatorCommand { public: explicit Subtract(int operand) : operand_(operand) {} int execute(int i) const override { return i - operand_; } int undo(int i) const override { return i + operand_; } private: int operand_{}; }; Add类实现了execute()函数用于加法操作，并实现了undo()函数用于减法操作。Subtract类则实现了相反的操作。\n由于CalculatorCommand层次结构的存在，Calculator类本身可以保持相当简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //---- \u0026lt;Calculator.h\u0026gt; ---------------- #include \u0026lt;CalculatorCommand.h\u0026gt; #include \u0026lt;stack\u0026gt; class Calculator { public: void compute(std::unique_ptr\u0026lt;CalculatorCommand\u0026gt; command); void undoLast(); int result() const; void clear(); private: using CommandStack = std::stack\u0026lt;std::unique_ptr\u0026lt;CalculatorCommand\u0026gt;\u0026gt;; int current_{}; CommandStack stack_; }; //---- \u0026lt;Calculator.cpp\u0026gt; ---------------- #include \u0026lt;Calculator.h\u0026gt; void Calculator::compute(std::unique_ptr\u0026lt;CalculatorCommand\u0026gt; command) { current_ = command-\u0026gt;execute(current_); stack_.push(std::move(command)); } void Calculator::undoLast() { if(stack_.empty()) return; auto command = std::move(stack_.top()); stack_.pop(); current_ = command-\u0026gt;undo(current_); } int Calculator::result() const { return current_; } void Calculator::clear() { current_ = 0; CommandStack{}.swap(stack_); // 清空栈 } 我们只需要两个函数来进行计算活动：compute()和undoLast()。\ncompute()函数接收一个CalculatorCommand实例，立即执行它以更新当前值，并将其存储在栈中。undoLast()函数通过从栈中弹出最后一个执行的命令并调用其undo()方法来撤销最后一次操作。\nmain()函数将所有部分组合在一起：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Calculator.h\u0026gt; #include \u0026lt;Add.h\u0026gt; #include \u0026lt;Subtract.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { Calculator calculator{}; auto op1 = std::make_unique\u0026lt;Add\u0026gt;(3); auto op2 = std::make_unique\u0026lt;Add\u0026gt;(7); auto op3 = std::make_unique\u0026lt;Subtract\u0026gt;(4); auto op4 = std::make_unique\u0026lt;Subtract\u0026gt;(2); calculator.compute(std::move(op1)); // 计算 0 + 3，存储并返回 3 calculator.compute(std::move(op2)); // 计算 3 + 7，存储并返回 10 calculator.compute(std::move(op3)); // 计算 10 - 4，存储并返回 6 calculator.compute(std::move(op4)); // 计算 6 - 2，存储并返回 4 calculator.undoLast(); // 撤销最后一次操作，存储并返回 6 int const res = calculator.result(); // 获取最终结果：6 // ... return EXIT_SUCCESS; } 首先创建一个计算器，并创建一系列操作，依次应用这些操作。\n之后，通过undo()操作撤销op4，然后查询最终结果。\n这种设计很好地遵循了SOLID原则。它遵守单一职责原则（SRP），因为通过命令设计模式已经提取了变化点。因此，compute()和undo()不需要是虚函数。SRP也促进了开闭原则（OCP），使我们可以添加新操作而无需修改现有代码。\n最后，如果正确分配了Command基类的所有权，则设计也符合依赖倒置原则（DIP）。\n命令设计模式的第二个经典示例：线程池\n命令设计模式的另一个经典示例是线程池。\n线程池的作用是维护多个线程，等待任务以便并行执行。\n这一想法通过以下ThreadPool类实现：它提供了一些成员函数来将某些任务分配给特定数量的可用线程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Command { /* 执行和撤销任何类型操作的抽象接口 */ }; class ThreadPool { public: explicit ThreadPool(size_t numThreads); inline bool isEmpty() const; inline size_t size() const; inline size_t active() const; inline size_t ready() const; void schedule(std::unique_ptr\u0026lt;Command\u0026gt; command); // 安排一个任务 void wait(); // ... }; 最重要的是，ThreadPool允许你通过schedule()函数安排一个任务。\n这个任务可以是任何类型的：ThreadPool完全不关心其线程需要执行什么类型的工作。\n通过Command基类，它与实际调度的任务类型完全解耦。\n只需从Command派生，就可以制定任意任务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class FormattingCommand : public Command { /* 实现磁盘格式化 */ }; class PrintCommand : public Command { /* 实现打印任务 */ } int main() { // 创建一个初始有两个工作线程的线程池 ThreadPool threadpool(2); // 安排两个并发任务 threadpool.schedule(std::make_unique\u0026lt;FormattingCommand\u0026gt;(/* 一些参数 */)); threadpool.schedule(std::make_unique\u0026lt;PrintCommand\u0026gt;(/* 一些参数 */)); // 等待线程池完成所有命令 threadpool.wait(); return EXIT_SUCCESS; } 例如，FormattingCommand任务会获取必要的信息，通过操作系统触发磁盘格式化。\n另一种情况是PrintCommand，它接收所有数据以触发打印作业。\n在这个线程池示例中，你也能够识别出命令设计模式的效果：不同类型的任务被识别为变化点，并被提取出来（这也遵循了单一职责原则），这使你可以实现不同类型的任务而无需修改现有代码（符合开闭原则）。\n当然，标准库中也有一些例子展示了命令设计模式的应用。\n例如，在std::for_each()算法中可以看到命令设计模式的实际应用：\n1 2 3 4 namespace std { template\u0026lt;typename InputIt, typename UnaryFunction\u0026gt; constexpr UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f); } // namespace std 第三个参数指定了算法应对所有给定元素执行什么任务。这个任务可以是任何操作，从操作元素到打印它们，可以通过简单的函数指针或强大的lambda表达式指定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; void multBy10(int\u0026amp; i) { i *= 10; } int main() { std::vector\u0026lt;int\u0026gt; v{1, 2, 3, 4, 5}; // 将所有整数乘以10 std::for_each(begin(v), end(v), multBy10); // 打印所有整数 std::for_each(begin(v), end(v), [](int\u0026amp; i){ std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }); return EXIT_SUCCESS; } 在上述代码中，std::for_each的第一个调用将向量中的每个整数乘以10，第二个调用则打印这些整数。通过使用不同的函数或lambda表达式作为第三个参数，你可以轻松地改变std::for_each的行为，从而实现高度灵活的操作。这种灵活性正是命令设计模式的核心优势之一。\n命令设计模式与策略设计模式的对比\n“等一下！”你可能会喊道，“你不是刚刚解释过标准库算法是通过策略设计模式实现的吗？这不是完全与之前的陈述矛盾吗？” 是的，你是对的。就在几页之前，我确实解释了std::partition()和std::sort()算法是通过策略设计模式实现的。\n因此，我承认现在看起来像是自相矛盾。然而，我没有声称所有算法都基于策略模式。让我解释一下。\n从结构上看，策略设计模式和命令设计模式是相同的：无论是使用动态多态还是静态多态。\n从实现角度来看，策略和命令之间没有区别。两者的差异完全在于它们的设计意图。\n策略设计模式指定某件事应该如何完成，而命令设计模式则指定应该完成什么。\n例如，考虑std::partition()和std::for_each()算法：\n1 2 3 4 5 6 7 namespace std { template\u0026lt;typename ForwardIt, typename UnaryPredicate\u0026gt; constexpr ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p); template\u0026lt;typename InputIt, typename UnaryFunction\u0026gt; constexpr UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f); } // namespace std 在std::partition()算法中，你只能控制如何选择元素，而在std::for_each()算法中，你可以控制对给定范围内每个元素应用什么操作。\n在形状示例中，你只能指定如何绘制某种形状，而在线程池示例中，你完全负责决定安排什么操作。\n此外，还有两个指标可以帮助你区分这两种设计模式的应用：\n依赖注入：如果你有一个对象并通过动作（执行依赖注入）配置它，那么你很可能在使用策略设计模式。如果你不使用动作来配置对象，而是直接执行该动作，那么你很可能在使用命令设计模式。在我们的计算器示例中，我们没有传递动作来配置计算器，而是立即评估了该动作。因此，我们基于命令模式构建。\n另外，我们也可以通过策略模式实现计算器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //---- \u0026lt;CalculatorStrategy.h\u0026gt; ---------------- class CalculatorStrategy { public: virtual ~CalculatorStrategy() = default; virtual int compute(int i) const = 0; }; //---- \u0026lt;Calculator.h\u0026gt; ---------------- #include \u0026lt;CalculatorStrategy.h\u0026gt; class Calculator { public: void set(std::unique_ptr\u0026lt;CalculatorStrategy\u0026gt; operation); void compute(int value); // ... private: int current_{}; std::unique_ptr\u0026lt;CalculatorStrategy\u0026gt; operation_; // 需要一个默认值！ }; //---- \u0026lt;Calculator.cpp\u0026gt; ---------------- #include \u0026lt;Calculator.h\u0026gt; void Calculator::set(std::unique_ptr\u0026lt;CalculatorStrategy\u0026gt; operation) { operation_ = std::move(operation); } void Calculator::compute(int value) { current_ = operation_-\u0026gt;compute(value); } 在这个计算器实现中，策略是通过set()函数注入的。compute()函数使用注入的策略进行计算。但是请注意，这种方法使得实现合理的撤销机制更加困难。\n撤销操作：如果你的动作提供了一个撤销操作来回滚它所做的工作，并封装了执行撤销所需的一切，那么你很可能在处理命令设计模式。\n如果你的动作没有提供撤销操作，因为它专注于如何完成某事或缺乏回滚操作的信息，那么你很可能在处理策略设计模式。\n然而，我要明确指出的是，缺少撤销操作并不能作为策略模式的结论性证据。如果意图是指定应该做什么，即使没有撤销操作，仍然可能是命令模式的一种实现。\n例如，std::for_each()算法仍然期望一个命令，尽管不需要撤销操作。\n撤销操作应被视为命令设计模式的一个可选特性，而不是定义性的特征。在我看来，撤销操作并不是命令设计模式的优势，而是一种纯粹的必要性：如果一个动作有完全自由做任何它想做的事情，那么只有这个动作本身才能回滚操作（当然，假设你不希望为每次调用命令存储完整的副本）。\n我承认这两个模式之间没有明确的分界线，而且它们之间存在灰色地带。然而，争论某事物是命令还是策略并没有意义，甚至可能失去一些朋友。更重要的是利用它们提取实现细节和分离关注点的能力。两种设计模式都可以帮助你隔离变化和扩展，从而遵循单一职责原则（SRP）和开闭原则（OCP）。\n毕竟，这可能是为什么在C++标准库中有如此多这两种设计模式的例子的原因。\n分析命令设计模式的不足之处\n命令设计模式的优点类似于策略设计模式的优点：命令模式通过引入某种抽象（例如基类或概念）帮助你解耦具体任务的实现细节。这种抽象允许你轻松添加新任务。因此，命令模式同时满足了SRP和OCP。\n然而，命令设计模式也有其缺点。与策略设计模式相比，其缺点列表相当短。唯一真正的缺点是由于额外的间接层导致的运行时性能开销，尤其是在通过基类实现命令模式时（经典的GoF风格）。再次强调，由你决定增加的灵活性是否超过了运行时性能的损失。\n总之，就像策略设计模式一样，命令设计模式是设计模式目录中最基本和最有用的模式之一。你会在许多不同的情况下遇到命令模式的实现，无论是静态的还是动态的。因此，理解命令模式的意图、优点和缺点将在许多时候证明是有用的。\n本节总结\n应用Command设计模式，目的是抽象和封装一个（可能是可撤销的）操作。 请注意，命令和策略设计模式之间的界限是可变的。 对动态和静态应用程序都使用Command。 准则22：优先使用值语义而非引用语义 在“准则19：使用策略模式隔离如何完成任务”和“准则21：使用命令模式隔离应该完成什么任务”中，我分别向你介绍了策略设计模式和命令设计模式。\n在这两种情况下，示例都是基于经典的GoF风格构建的：它们通过继承层次结构使用动态多态性。这种经典面向对象的风格缺乏现代感，可以想象你现在可能已经因为咬指甲而惹恼了你的美甲师。\n你可能会想：“难道没有另一种更好的方式来实现策略和命令模式吗？一种更‘现代’的方法？” 是的，放心；确实有。这种方法对于我们现在称之为 现代C++ 的哲学非常重要，以至于它值得一个单独的指南来解释其优点。\n我相信你的美甲师会理解这次小插曲的原因。\nGoF风格的不足：引用语义\n由四人组（Gang of Four）收集并在他们的书中介绍的设计模式是作为面向对象设计模式引入的。\n他们书中描述的23种设计模式几乎都使用至少一个继承层次结构，因此牢牢扎根于面向对象编程领域。\n模板作为显而易见的第二选择，在GoF的书中并没有扮演任何角色，这种纯粹的面向对象风格就是我所称的GoF风格。\n从今天的视角来看，这种风格可能显得老旧、过时，但我们需要记住这本书是在1994年10月发布的。那时，模板可能已经是语言的一部分（至少在《注释参考手册》(ARM)中有正式描述），但我们还没有与模板相关的惯用法，C++仍然普遍被视为一种面向对象的编程语言。因此，使用C++的常见方式是主要使用继承。\n今天我们知道，GoF风格存在一些缺点。其中最重要且通常被提到最多的是性能问题：\n虚函数增加了运行时开销，并减少了编译器优化的机会。 小型多态对象的多次分配消耗额外的运行时间，导致内存碎片化，并导致缓存使用不佳。 数据的排列方式通常不利于数据访问方案。 性能确实不是GoF风格的强项。不进行全面讨论所有可能的GoF风格的不足之处，让我们关注另一个我认为特别有趣的缺点：GoF风格属于我们今天所说的引用语义（有时也称为指针语义）。\n这种风格因其主要使用指针和引用来命名。\n为了展示术语引用语义的含义及其通常带有的负面含义，让我们看一下以下使用C++20 std::span 类模板的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;span\u0026gt; #include \u0026lt;vector\u0026gt; void print(std::span\u0026lt;int\u0026gt; s) { std::cout \u0026lt;\u0026lt; \u0026#34; (\u0026#34;; for(int i : s) { std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i; } std::cout \u0026lt;\u0026lt; \u0026#34; )\\n\u0026#34;; } int main() { std::vector\u0026lt;int\u0026gt; v{ 1, 2, 3, 4 }; std::vector\u0026lt;int\u0026gt; const w{ v }; std::span\u0026lt;int\u0026gt; const s{ v }; w[2] = 99; // 编译错误！ s[2] = 99; // 成功！ // 输出 ( 1 2 99 4 ); print(s); v = { 5, 6, 7, 8, 9 }; s[2] = 99; // 成功！ // 输出 ? print(s); return EXIT_SUCCESS; } print() 函数展示了 std::span 的用途。std::span 类模板表示数组的抽象。\nprint() 函数可以与任何类型的数组（内置数组、std::array、std::vector 等）一起使用，而不耦合到任何特定类型的数组。\n在具有动态范围的 std::span 示例中（没有第二个模板参数表示数组大小），典型的 std::span 实现包含两个数据成员：指向数组第一个元素的指针 和 数组的大小。\n因此，std::span 很容易复制，通常按值传递。除此之外，print() 只是遍历 std::span 的元素（在我们的例子中是整数）并通过 std::cout 打印它们。\n在 main() 函数中，我们首先创建 std::vector\u0026lt;int\u0026gt; v 并立即填充整数 1、2、3 和 4。然后我们创建另一个 std::vector w 作为 v 的副本 和 std::span s。\nw 和 s 都被声明为 const，紧接着，我们尝试修改 w 和 s 在索引 2 处的值。尝试更改 w 失败并出现编译错误：w 被声明为 const，因此无法更改包含的元素。然而，尝试更改 s 则成功。尽管 s 被声明为 const，也不会出现编译错误。\n原因是： s 不是 v 的副本，不代表一个值。相反，它代表对 v 的引用。它实际上充当指向 v 第一个元素的指针。因此，const 限定符在语义上等同于声明指针 const：\n1 2 std::span\u0026lt;int\u0026gt; const s{ v }; // s 作为指向 v 第一个元素的指针 int* const ptr{ v.data() }; // 等效语义 虽然指针 ptr 不能被改变，并且在其生命周期内将始终指向 v 的第一个元素，但引用的整数可以轻松修改。要防止对整数进行赋值，需要为 int 添加额外的 const 限定符：\n1 2 std::span\u0026lt;int const\u0026gt; const s{v}; // s 表示指向常量整数的常量指针 int const* const ptr{ v.data() }; // 等效语义 由于指针和 std::span 的语义是等价的，std::span 显然属于引用语义的范畴。这带来了一些额外的风险，如 main() 函数剩余部分所示。下一步，我们打印 s 引用的元素。注意，你也可以直接传递向量 v，因为 std::span 提供了必要的转换构造函数来接受 std::vector。print() 函数将正确输出：\n1 ( 1 2 99 4 ) 因为我们可以（并且现在数字 1 到 4 可能听起来有点无聊），我们现在将一组新数字赋给向量 v。诚然，选择 5、6、7、8 和 9 既不特别有创意也不有趣，但它会达到目的。紧接着，我们再次通过 s 写入第二个索引并再次打印 s 引用的元素。当然，我们期望输出是 ( 5 6 99 8 9 )，但不幸的是并非如此。我们可能会得到以下输出：\n1 ( 1 2 99 4 ) 也许你会完全震惊，并因此多出几根白发，也许你会感到惊讶，或者你会心知肚明地微笑并点头：是的，当然，未定义行为！\n当我们将新值赋给 std::vector v 时，我们不仅改变了值，还改变了向量的大小。原本存储四个值的向量现在需要存储五个元素，因此，向量可能进行了重新分配，从而改变了其第一个元素的地址。不幸的是，std::span s 没有收到通知，并且仍然紧紧持有旧的第一个元素的地址。因此，当我们尝试通过 s 向 v 写入时，我们并不是写入当前的 v 数组，而是写入了一个已经被丢弃的内存区域，该区域曾经是 v 的内部数组。这是典型的未定义行为，也是引用语义的经典问题。\n“嘿，你是不是在试图诋毁 std::span？”你问。不，我并不是在暗示 std::span 和 std::string_view 是不好的。\n相反，我实际上非常喜欢这两个工具，因为它们提供了非常简单且廉价的抽象，分别用于各种数组和字符串。然而，请记住每个工具都有其优缺点。当我使用它们时，我会有意识地使用它们，完全意识到任何非拥有引用类型都需要仔细注意其所引用值的生命周期。例如，虽然我认为它们作为函数参数非常有用，但我倾向于不在数据成员中使用它们。生命周期问题的风险太高了。\n引用语义：第二个示例\n“当然，我知道这一点，”你争辩道。“我也不会长时间存储 std::span。然而，我仍然不相信引用和指针是个问题。” 好的，如果第一个例子还不足以让你震惊，我还有一个第二个例子。\n这次我将使用 STL 算法之一 std::remove()。std::remove() 算法接受三个参数：一个用于遍历以移除特定值的所有元素的范围的迭代器对，以及第三个表示要移除的值的参数。特别注意，第三个参数是通过常量引用传递的：\n1 2 template\u0026lt; typename ForwardIt, typename T \u0026gt; constexpr ForwardIt remove( ForwardIt first, ForwardIt last, T const\u0026amp; value ); 让我们来看下面的代码示例：\n1 2 3 std::vector\u0026lt;int\u0026gt; vec{ 1, -3, 27, 42, 4, -8, 22, 42, 37, 4, 18, 9 }; auto const pos = std::max_element(begin(vec), end(vec)); vec.erase(std::remove(begin(vec), end(vec), *pos), end(vec)); 我们从初始化了一些随机数字的 std::vector v 开始。\n现在我们感兴趣的是移除向量中代表最大值的所有元素。在我们的例子中，这个值是 42，并且在向量中出现了两次。执行移除的第一步是使用 std::max_element() 算法确定最大值。std::max_element() 返回指向最大值的迭代器。如果范围内有多个元素等同于最大元素，则返回指向第一个此类元素的迭代器。\n移除最大值的第二步是对 std::remove() 的调用。我们通过 begin(vec) 和 end(vec) 传递元素范围，并通过解引用 pos 迭代器传递最大值。最后，我们通过调用成员函数 erase() 完成操作：我们删除由 std::remove() 算法返回的位置到向量末尾之间的所有值。这一系列操作通常被称为 erase-remove 惯用法。\n我们期望从向量中移除两个 42，并因此期望得到以下结果：\n1 ( 1 -3 27 4 -8 22 37 4 18 9 ) 不幸的是，这个期望并不成立。相反，向量现在包含以下值：\n1 ( 1 -3 27 4 -8 22 42 37 18 9 ) 请注意，向量仍然包含一个 42，但现在缺少了一个 4。这种行为不当的根本原因仍然是引用语义：通过将解引用的迭代器传递给 remove() 算法，我们隐式地指定了该位置存储的值应该被移除。然而，在移除了第一个 42 后，该位置现在存储的是值 4。remove() 算法会移除所有值为 4 的元素。因此，下一个被移除的值不是下一个 42，而是下一个 4，依此类推。\n“好的，我明白了！但这个问题已经成为历史了！今天，我们不再使用 erase-remove 惯用法了。C++20 终于为我们提供了自由的 std::erase() 函数！” 我希望同意这个说法，但遗憾的是，我只能确认 std::erase() 函数的存在：\n1 2 3 template\u0026lt; typename T, typename Alloc, typename U \u0026gt; constexpr typename std::vector\u0026lt;T,Alloc\u0026gt;::size_type erase( std::vector\u0026lt;T,Alloc\u0026gt;\u0026amp; c, U const\u0026amp; value ); std::erase() 函数也通过常量引用传递其第二个参数，即要移除的值。因此，我刚才描述的问题仍然存在。解决这个问题的唯一方法是显式地确定最大元素并将其传递给 std::remove() 算法：\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec{ 1, -3, 27, 42, 4, -8, 22, 42, 37, 4, 18, 9 }; auto const pos = std::max_element(begin(vec), end(vec)); auto const greatest = *pos; vec.erase(std::remove(begin(vec), end(vec), greatest), end(vec)); “你是不是在认真建议我们不要再使用引用参数了？” 不，绝对不是！当然你应该使用引用参数，例如出于性能考虑。然而，我希望引起一定的意识，希望你现在理解了问题所在：引用，尤其是指针，让我们的生活变得复杂得多，理解代码变得更加困难，因此更容易在代码中引入错误。特别是指针引发了很多问题：它是一个有效的指针还是 nullptr？谁拥有指针背后的资源并管理其生命周期？当然，由于我们扩展了工具箱并拥有了智能指针，生命周期问题不再是大问题。正如核心指南 R.3 清楚指出的那样：原始指针（T*）是非拥有的。\n结合知道智能指针承担了所有权的责任，这大大清理了指针的语义。但是，尽管智能指针当然是非常有价值的工具，并且因其优点而被誉为“现代 C++”的重大成就，它们最终只是修补引用语义在我们推理代码能力上撕开的漏洞。是的，引用语义使理解代码和推理重要细节变得更加困难，因此是我们希望避免的东西。\n现代C++哲学：值语义\n“但是等等，”我能听到你反驳，“我们还有什么其他选择？我们应该怎么做？我们如何处理继承层次结构？我们不能避免使用指针，对吧？” 如果你有类似的想法，那么我有一个非常好的消息告诉你：是的，有更好的解决方案。\n这个解决方案使你的代码更容易理解、推理，并且可能对性能产生积极影响（还记得我们讨论过的引用语义的负面性能影响）。这个解决方案就是值语义。\n值语义在C++中并不是新鲜事物。这个想法已经是原始STL的一部分。让我们考虑最著名的STL容器之一 std::vector：\n1 2 3 4 5 6 7 8 std::vector\u0026lt;int\u0026gt; v1{ 1, 2, 3, 4, 5 }; auto v2{ v1 }; assert( v1 == v2 ); assert( v1.data() != v2.data() ); v2[2] = 99; assert( v1 != v2 ); auto const v3{ v1 }; v3[2] = 99; // 编译错误! 我们从一个名为 v1 的 std::vector 开始，包含五个整数。接下来，我们创建 v1 的副本，称为 v2。向量 v2 是一个真正的副本，有时也称为深拷贝，它现在拥有自己的内存块和整数，不引用 v1 中的整数。我们可以通过比较两个向量来验证这一点（它们被证明是相等的），但第一个元素的地址不同。修改 v2 中的一个元素会导致两个向量不再相等。是的，两个向量都有自己的数组，它们不共享内容，即不试图“优化”复制操作。\n你可能听说过一些技术，例如写时复制（copy-on-write）。确实，在C++11之前，这曾是 std::string 的常见实现。然而，自C++11以来，由于C++标准中的要求，std::string 不再允许使用写时复制。原因是这种“优化”在一个多线程世界中很容易变成劣化。因此，我们可以确信复制构造会创建一个真正的副本。\n最后，我们创建另一个名为 v3 的副本，并将其声明为 const。如果我们尝试修改 v3 的值，将会得到编译错误。这表明一个 const 向量不仅防止添加和删除元素，而且所有元素也被视为 const。从语义角度来看，这意味着 std::vector 和任何STL容器一样，被视为一个值。是的，一个值，就像一个 int。如果我们复制一个值，我们不会只复制部分值，而是整个值。如果我们使一个值 const，它不仅仅是部分 const，而是完全 const。这就是值语义的基本原理。我们已经看到了一些优点：与指针和引用相比，值更容易推理。例如，改变一个值不会影响其他值。变化是局部的，而不是发生在别处。这是一个编译器用于其优化工作的优势。此外，值不需要我们考虑所有权问题。值负责自己的内容。值还使得思考线程问题变得更加容易。这并不意味着没有问题了（你希望如此！），但代码肯定更容易理解。值不会给我们留下很多疑问。\n“好的，我明白了代码清晰性的要点，”你争辩道，“但是关于性能呢？频繁处理复制操作是不是非常昂贵？” 是的，你是正确的；复制操作可能是昂贵的。然而，只有当它们真正发生时才会昂贵。在实际代码中，我们通常可以依赖于复制省略、移动语义和按引用传递。此外，我们已经看到，从性能角度来看，值语义可能会给我们带来性能提升。当然，我指的是“指南17：考虑使用 std::variant 实现访问者模式”中的 std::variant 示例。在这个例子中，使用 std::variant 类型的值显著提高了我们的性能，因为减少了指针导致的间接寻址和更好的内存布局及访问模式。\n让我们来看第二个示例。这次我们考虑以下 to_int() 函数：\n1 int to_int(std::string_view); 这个函数解析给定的字符串（是的，我使用 std::string_view 以提高性能）并将其转换为 int。对我们来说最有趣的问题是如何处理错误，或者说，如果字符串无法转换为 int，函数应该做什么。第一个选项是在这种情况下返回 0。然而，这种方法有问题，因为 0 是 to_int() 函数的有效返回值。我们将无法区分成功和失败。\n另一种可能的方法是抛出异常。尽管异常可能是C++原生的错误信号工具，但对于这个问题，根据个人风格和偏好，这可能显得过于复杂。同时，考虑到很大一部分C++社区不能使用异常，这一选择可能会限制函数的可用性。\n第三种可能性是稍微改变签名：\n1 bool to_int(std::string_view s, int\u0026amp;); 现在函数接受一个可变 int 的引用作为第二个参数，并返回一个 bool。如果成功，函数返回 true 并设置传入的整数；如果失败，函数返回 false 并保持整数不变。虽然这对你来说似乎是一个合理的折衷方案，但我认为我们现在进一步进入了引用语义的领域（包括所有潜在的误用）。同时，代码的清晰度有所下降：返回结果最自然的方式是通过返回值，但现在结果是由输出值产生的。例如，这阻止我们将结果赋值给 const 值。因此，我认为这是迄今为止最不利的方法。\n第四种方法是通过指针返回：\n1 std::unique_ptr\u0026lt;int\u0026gt; to_int(std::string_view); 从语义上讲，这种方法非常吸引人：如果成功，函数返回指向 int 的有效指针；如果失败，返回 nullptr。因此，代码的清晰度得到了改善，因为我们能清楚地区分这两种情况。然而，我们在动态内存分配和使用 std::unique_ptr 进行生命周期管理方面付出了代价，仍然停留在引用语义的领域。所以问题是：如何利用语义上的优势但仍坚持值语义？解决方案的形式是 std::optional：\n1 std::optional\u0026lt;int\u0026gt; to_int(std::string_view); std::optional 是一种值类型，表示另一个值，在我们的例子中是 int。因此，std::optional 可以取 int 能取的所有值。std::optional 的特殊之处在于它为封装的值增加了一个状态，表示无值的状态。因此，我们的 std::optional 是一个可能存在也可能不存在的 int：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;charconv\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;optional\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; std::optional\u0026lt;int\u0026gt; to_int(std::string_view sv) { std::optional\u0026lt;int\u0026gt; oi{}; int i{}; auto const result = std::from_chars(sv.data(), sv.data() + sv.size(), i); if(result.ec != std::errc::invalid_argument) { oi = i; } return oi; } int main() { std::string value = \u0026#34;42\u0026#34;; if(auto optional_int = to_int(value)) { // ... 成功：返回的 std::optional 包含一个整数值 } else { // ... 失败：返回的 std::optional 不包含值 } } 从语义上讲，这等同于指针方法，但我们不需要支付动态内存分配的成本，也不需要处理生命周期管理。这个解决方案语义清晰、易于理解且高效。\n使用值语义实现设计模式\n“那设计模式呢？”你问。“几乎所有的GoF模式都基于继承层次结构，因此是引用语义。我们应该如何处理这个问题？” 这是一个非常好的问题。并且为我们提供了一个完美的桥梁到下一个指南。简短的回答是：你应该优先使用值语义来实现设计模式。是的，认真地说！这些解决方案通常会带来更全面、可维护的代码，并且（通常）具有更好的性能。\n准则23：优先使用基于值的策略和命令实现 在“准则19：使用策略模式隔离操作方式”中，我向你介绍了策略设计模式；在“准则21：使用命令模式隔离操作内容”中，我介绍了命令设计模式。\n我展示了这两种设计模式是你日常工具箱中的重要解耦工具。然而，在“指南22：优先使用值语义而非引用语义”中，我提出了使用值语义比引用语义更好的观点。这当然引发了一个问题：如何将这一智慧应用于策略和命令设计模式？这里有一个可能的基于值语义的解决方案：利用 std::function 的抽象能力。\nstd::function 简介\n如果你还没有听说过 std::function，让我来介绍一下。std::function 是对可调用对象（例如函数指针、函数对象或lambda表达式）的抽象。唯一的要求是该可调用对象满足特定的函数类型，这是作为唯一的模板参数传递给 std::function 的。以下代码给出了一个印象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;iostream\u0026gt; void foo(int i) { std::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { // 创建一个默认的 std::function 实例。调用它会导致 std::bad_function_call 异常 std::function\u0026lt;void(int)\u0026gt; f{}; // 将一个可调用对象赋值给 \u0026#39;f\u0026#39; f = [](int i) { std::cout \u0026lt;\u0026lt; \u0026#34;lambda: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; f(1); // 使用整数 \u0026#39;1\u0026#39; 调用 \u0026#39;f\u0026#39; auto g = f; // 将 \u0026#39;f\u0026#39; 复制到 \u0026#39;g\u0026#39; f = foo; // 将不同的可调用对象赋值给 \u0026#39;f\u0026#39; f(2); // 使用整数 \u0026#39;2\u0026#39; 调用 \u0026#39;f\u0026#39; g(3); // 使用整数 \u0026#39;3\u0026#39; 调用 \u0026#39;g\u0026#39; return EXIT_SUCCESS; } 在 main() 函数中，我们创建了一个名为 f 的 std::function 实例。模板参数指定了所需的函数类型。在我们的例子中，这是 void(int)。“函数类型……”你说。“你不指的是函数指针类型吗？” 好吧，由于这可能是你以前很少见过的东西，让我解释一下什么是函数类型，并将其与你可能更常见的函数指针类型进行对比。以下示例同时使用了函数类型和函数指针类型：\n1 2 3 4 using FunctionType = double(double); using FunctionPointerType = double(*)(double); // 或者： // using FunctionPointerType = FunctionType*; 第一行显示了一个函数类型。此类型表示任何接受 double 并返回 double 的函数。这种函数类型的例子包括 std::sin、std::cos、std::log 或 std::sqrt 的相应重载。第二行显示了一个函数指针类型。注意括号中的小星号——这使得它成为指针类型。此类型表示函数类型的 FunctionType 函数的地址。因此，函数类型和函数指针类型之间的关系非常类似于 int 和指向 int 的指针之间的关系：虽然有许多 int 值，但指向 int 的指针存储的是恰好一个 int 的地址。\n回到 std::function 示例：最初，实例是空的，因此你不能调用它。如果你仍然尝试这样做，std::function 实例会抛出 std::bad_function_call 异常。最好别惹它。让我们为它分配一些满足函数类型要求的可调用对象，例如一个（可能是有状态的）lambda。这个lambda接受一个 int 并不返回任何东西。相反，它通过描述性的输出消息打印出它已被调用：\n1 lambda: 1 好的，这工作得很好。让我们试试别的：我们现在通过 f 创建另一个 std::function 实例 g。然后我们将另一个可调用对象分配给 f。这次，我们分配了 foo() 函数的指针。同样，这个可调用对象满足 std::function 实例的要求：它接受一个 int 并不返回任何东西。直接在分配后，你用整数 2 调用 f，这触发了预期的输出：\n1 foo: 2 这可能是一个简单的例子。然而，下一个函数调用要有趣得多。如果你用整数 3 调用 g，输出表明 std::function 坚实地基于值语义：\n1 lambda: 3 在初始化 g 期间，实例 f 被复制。并且它是按照值应该被复制的方式复制的：它没有执行“浅拷贝”，这会导致当 f 随后改变时影响 g，而是执行了一个完整的复制（深拷贝），包括lambda的复制。因此，改变 f 不会影响 g。这就是值语义的好处：代码简单直观，你不必担心意外破坏其他地方的内容。\n在此基础上，std::function 的功能可能会让人感觉有点像魔法：它是如何能够接受任何类型的可调用对象，包括像lambda这样的东西？它是如何存储任何可能的类型，甚至是它不知道的类型，即使这些类型显然没有任何共同点？不用担心：在第8章，我会详细介绍一种称为类型擦除的技术，它是 std::function 背后的魔法。\n重构绘制形状的代码\nstd::function 提供了我们需要的一切来重构我们在“指南19：使用策略模式隔离操作方式”中的绘图示例。它表示单个可调用对象的抽象，这正是我们替换 DrawCircleStrategy 和 DrawSquareStrategy 层次结构所需要的，每个层次结构都包含一个单一的虚函数。因此，我们依赖于 std::function 的抽象能力：\nShape.h\n1 2 3 4 5 6 class Shape { public: virtual ~Shape() = default; virtual void draw(/* some arguments */) const = 0; }; Circle.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;utility\u0026gt; class Circle : public Shape { public: using DrawStrategy = std::function\u0026lt;void(Circle const\u0026amp;, /*...*/)\u0026gt;; explicit Circle(double radius, DrawStrategy drawer) : radius_(radius), drawer_(std::move(drawer)) { // 检查给定半径的有效性以及 \u0026#39;std::function\u0026#39; 实例是否不为空 } void draw(/* some arguments */) const override { drawer_(*this, /* some arguments */); } double radius() const { return radius_; } private: double radius_; DrawStrategy drawer_; }; Square.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;utility\u0026gt; class Square : public Shape { public: using DrawStrategy = std::function\u0026lt;void(Square const\u0026amp;, /*...*/)\u0026gt;; explicit Square(double side, DrawStrategy drawer) : side_(side), drawer_(std::move(drawer)) { // 检查给定边长的有效性以及 \u0026#39;std::function\u0026#39; 实例是否不为空 } void draw(/* some arguments */) const override { drawer_(*this, /* some arguments */); } double side() const { return side_; } private: double side_; DrawStrategy drawer_; }; 首先，在 Circle 类中，我们为期望的 std::function 类型添加了一个类型别名（）。这个 std::function 类型表示任何可以接受 Circle 对象和可能几个与绘图相关的参数，并且不返回任何东西的可调用对象。当然，我们在 Square 类中也添加了相应的类型别名（）。在 Circle 和 Square 的构造函数中，我们现在接受一个 std::function 类型的实例（）作为指向策略基类（DrawCircleStrategy 或 DrawSquareStrategy）指针的替代。这个实例立即被移动（）到数据成员 drawer_ 中，该成员也是 DrawStrategy 类型（）。\n“嘿，为什么你通过值传递 std::function 实例？这不是非常低效吗？我们应该优先通过引用传递吗？” 简短回答：不，通过值传递并不低效，而是对替代方案的一种优雅妥协。我承认，这可能令人惊讶。由于这是一个值得注意的实现细节，让我们仔细看看。\n如果我们使用常量引用，我们会遇到 rvalue 不必要地被复制的缺点。如果传递给我们的是一个 rvalue，这个 rvalue 将绑定到（lvalue）常量引用。然而，当我们把这个常量引用传递给数据成员时，它会被复制。这不是我们的意图：我们自然希望它是移动的。简单的原因是我们不能从 const 对象移动（即使使用 std::move）。因此，为了高效处理 rvalue，我们必须提供接受 rvalue 引用的 Circle 和 Square 构造函数重载（DrawStrategy\u0026amp;\u0026amp;）。为了性能，我们将为 Circle 和 Square 提供两个构造函数。\n提供两个构造函数（一个用于 lvalue，一个用于 rvalue）确实有效且高效，但我不会称之为优雅。此外，我们应该让同事避免处理这些问题。\n为此，我们利用了 std::function 的实现。std::function 提供了拷贝构造函数和移动构造函数，因此我们知道它可以高效地移动。当我们通过值传递 std::function 时，要么会调用拷贝构造函数，要么会调用移动构造函数。如果我们传递的是一个 lvalue，拷贝构造函数会被调用，复制 lvalue。然后我们将这个副本移动到数据成员中。总共，我们将执行一次拷贝和一次移动来初始化 drawer_ 数据成员。如果我们传递的是一个 rvalue，移动构造函数会被调用，移动 rvalue。结果参数策略将被移动到数据成员 drawer_ 中。总共，我们将执行两次移动操作来初始化 drawer_ 数据成员。因此，这种形式代表了一种很好的妥协：它优雅，几乎没有效率上的差异。\n一旦我们重构了 Circle 和 Square 类，我们可以以任何形式实现不同的绘图策略（作为函数、函数对象或 lambda）。例如，我们可以实现以下 OpenGLCircleStrategy 作为函数对象：\nOpenGLCircleStrategy.h\n1 2 3 4 5 6 7 8 9 #include \u0026lt;Circle.h\u0026gt; class OpenGLCircleStrategy { public: explicit OpenGLCircleStrategy(/* Drawing related arguments */); void operator()(Circle const\u0026amp; circle, /*...*/) const; private: /* 绘图相关的数据成员，如颜色、纹理等 */ }; 唯一需要遵循的约定是我们需要提供一个调用操作符，该操作符接受一个 Circle 和可能几个与绘图相关的参数，并且不返回任何东西（满足函数类型 void(Circle const\u0026amp;, /*…*/)）。\n假设类似的实现用于 OpenGLSquareStrategy，我们现在可以创建不同种类的形状，配置所需的绘图行为，并最终绘制它们：\nmain.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;OpenGLCircleStrategy.h\u0026gt; #include \u0026lt;OpenGLSquareStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; int main() { using Shapes = std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt;; Shapes shapes{}; // 创建一些形状，每个形状都配备了相应的 OpenGL 绘图策略 shapes.emplace_back(std::make_unique\u0026lt;Circle\u0026gt;(2.3, OpenGLCircleStrategy(/*...red...*/))); shapes.emplace_back(std::make_unique\u0026lt;Square\u0026gt;(1.2, OpenGLSquareStrategy(/*...green...*/))); shapes.emplace_back(std::make_unique\u0026lt;Circle\u0026gt;(4.1, OpenGLCircleStrategy(/*...blue...*/))); // 绘制所有形状 for (auto const\u0026amp; shape : shapes) { shape-\u0026gt;draw(); } return EXIT_SUCCESS; } main() 函数与使用经典策略实现的原始实现非常相似（参见“指南19：使用策略模式隔离操作方式”）。然而，这种非侵入式、无基类的方法进一步减少了耦合。这在解决方案的依赖关系图中变得明显（见图5-9）：我们可以以任何形式实现绘图功能（作为自由函数、函数对象或 lambda），并且不必遵守基类的要求。此外，通过 std::function，我们自动反转了依赖关系（参见“指南9：注意抽象的所有权”）。\n性能基准测试\n“我喜欢这种灵活性、自由度。这太棒了！但是性能呢？” 是的，就像一个真正的C++开发者会说的那样。当然，性能非常重要。但在展示性能结果之前，让我先提醒你我们用来获取表4-2（“指南16：使用访问者模式扩展操作”）数据的基准场景。对于基准测试，我实现了四种不同类型的形状（圆形、正方形、椭圆和矩形）。再次运行25,000次平移操作在10,000个随机创建的形状上。我使用了GCC 11.1和Clang 11.1两个编译器，并且只添加了 -O3 和 -DNDEBUG 编译标志。平台是搭载8核Intel Core i7处理器（3.8 GHz）、64 GB内存的macOS Big Sur（版本11.4）。\n有了这些信息，你就可以准备好查看性能结果了。表5-1展示了基于策略实现的绘图示例以及使用 std::function 的解决方案的性能数字。\n表5-1 不同策略实现的性能结果\n策略实现 GCC 11.1 Clang 11.1 面向对象解决方案 1.5205 s 1.1480 s 使用 std::function 2.1782 s 1.4884 s 手动实现 std::function 1.6354 s - 经典策略实现 1.4465 s 1.6372 s 为了参考，第一行显示了来自“指南15：设计以增加类型或操作”的面向对象解决方案的性能。如你所见，这个解决方案提供了最佳性能。然而，这不是意外的结果：由于策略设计模式无论实际实现如何都会引入额外的开销，因此性能预期会有所降低。\n不过，意想不到的是，std::function 实现带来了性能开销（特别是在GCC的情况下显著）。但请稍等，在你将这种方法扔进心理垃圾桶之前，请考虑第三行。它展示了使用类型擦除技术的手动实现 std::function，这项技术将在第8章解释。这个实现表现得更好，实际上与经典策略设计模式的实现一样好（或对Clang来说几乎一样好）。这一结果表明问题不在于值语义，而是 std::function 的具体实现细节。总之，从性能角度来看，基于值语义的方法并不比经典方法差，反而如前所述，它改善了许多代码的重要方面。\n分析 std::function 解决方案的不足\n总体而言，策略设计模式的 std::function 实现提供了许多好处。首先，你的代码变得更清晰易读，因为你不必处理指针及其相关的生命周期管理（例如，使用 std::unique_ptr），也不必经历通常的引用语义问题（参见“指南22：优先使用值语义而非引用语义”）。其次，你促进了松耦合。在这种情况下，std::function 起到了编译防火墙的作用，保护你免受不同策略实现的实现细节影响，同时为开发人员提供了巨大的灵活性来实现不同的策略解决方案。\n尽管有这些优点，没有一种解决方案是没有缺点的——即使是 std::function 方法也有其劣势。我已经指出，如果你依赖标准实现，可能会存在性能劣势。虽然有一些解决方案可以最小化这种影响（参见第8章），但它仍然是你在代码库中需要考虑的因素。\n还有一个设计相关的问题。std::function 只能替换单个虚函数。如果你需要抽象多个虚函数，这种情况可能出现在你想使用策略设计模式配置多个方面时，或者你需要命令设计模式中的 undo() 函数时，你将不得不使用多个 std::function 实例。这不仅会因为多个数据成员而增加类的大小，还会因为如何优雅地处理传递多个 std::function 实例的问题而带来接口负担。因此，std::function 方法最适合用于替换单一或非常少量的虚函数。不过，这并不意味着你不能对多个虚函数使用基于值的方法：如果遇到这种情况，可以考虑通过直接应用 std::function 技术到你的类型上来泛化该方法。我将在第8章解释如何做到这一点。\n尽管有这些不足之处，基于值语义的方法被证明是策略设计模式的一个绝佳选择。命令设计模式也是如此。因此，请记住这条指南作为迈向现代C++的重要步骤。\n本节总结\n考虑使用 std::function 来实现策略或命令设计模式。 注意 std::function 的性能劣势。 了解类型擦除是策略和命令设计模式中值语义方法的一般化。 第六章 适配器、观察者和CRTP设计模式 在本章中，我们将注意力转向三个必须了解的设计模式：两个GoF（Gang of Four，四人组）设计模式——适配器（Adapter）和观察者（Observer），以及奇特的递归模板模式（Curiously Recurring Template Pattern, CRTP）设计模式。\n准则24：使用适配器标准化接口\n在“准则24：使用适配器标准化接口”中，我们将讨论如何通过适配接口使不兼容的事物协同工作。为此，我将向你展示适配器设计模式及其在继承层次结构和泛型编程中的应用。你还将获得不同类型适配器的概述，包括对象适配器、类适配器和函数适配器。\n准则25：应用观察者作为抽象通知机制\n在“准则25：应用观察者作为抽象通知机制”中，我们将讨论如何观察状态变化并接收相关通知。在此背景下，我将向你介绍观察者设计模式，这是最著名且最常用的模式之一。我们将讨论经典的GoF风格观察者模式，以及如何在现代C++中实现观察者模式。\n准则26：使用CRTP引入静态类型分类\n在“准则26：使用CRTP引入静态类型分类”中，我们将关注CRTP。我将向你展示如何使用CRTP定义一组相关类型的编译时关系，以及如何正确实现CRTP基类。\n准则27：使用CRTP创建静态混合类\n在“准则27：使用CRTP创建静态混合类”中，我将继续讲述CRTP的应用，展示如何使用CRTP创建编译时混合类。我们还将看到语义继承与技术继承之间的区别：语义继承用于创建抽象，而技术继承仅作为实现细节，用于提高技术上的优雅性和便利性。\n准则24：使用适配器标准化接口 假设你已经实现了“准则3：分离接口以避免人为耦合”中的文档示例，并且因为你严格遵循接口隔离原则（ISP），你对它的运作方式相当满意：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class JSONExportable { public: // ... virtual ~JSONExportable() = default; virtual void exportToJSON(/*...*/) const = 0; // ... }; class Serializable { public: // ... virtual ~Serializable() = default; virtual void serialize(ByteStream\u0026amp; bs, /*...*/) const = 0; // ... }; class Document : public JSONExportable , public Serializable { public: // ... }; 然而，有一天你需要引入Pages文档格式。当然，它与你已有的Word文档格式相似，但不幸的是，你不熟悉Pages格式的具体细节。更糟糕的是，由于你有很多其他事情要做，没有太多时间去熟悉这种格式。\n幸运的是，你知道有一个相当合理的开源实现——OpenPages类：\n1 2 3 4 5 6 7 8 class OpenPages { public: // ... void convertToBytes(/*...*/); }; void exportToJSONFormat(OpenPages const\u0026amp; pages, /*...*/); 从好的方面来看，这个类几乎提供了你所需的一切：一个用于序列化文档内容的convertToBytes()成员函数，以及一个将Pages文档转换为JSON格式的自由函数exportToJSONFormat()。不幸的是，它不符合你的接口期望：你希望有一个serialize()成员函数而不是convertToBytes()成员函数。并且你希望有一个exportToJSON()成员函数而不是自由函数exportToJSONFormat()。最终，第三方类并没有继承自你的Document基类，这意味着你无法轻松地将其整合到现有的类层次结构中。不过，这个问题有一个解决方案：使用适配器设计模式进行无缝集成。\n使用适配器设计模式进行无缝集成\n为了使OpenPages类适应你的现有接口，你可以创建一个适配器类。适配器类将充当桥梁，使得OpenPages类能够符合你的接口要求。以下是具体的实现方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 适配器类，使OpenPages类符合Serializable和JSONExportable接口 class OpenPagesAdapter : public JSONExportable, public Serializable { private: OpenPages openPages; public: explicit OpenPagesAdapter(const OpenPages\u0026amp; op) : openPages(op) {} // 实现Serializable接口的serialize方法 void serialize(ByteStream\u0026amp; bs, /*...*/) const override { openPages.convertToBytes(/*...*/); // 将convertToBytes的结果写入ByteStream // 这里假设有一些逻辑将字节数据写入bs } // 实现JSONExportable接口的exportToJSON方法 void exportToJSON(/*...*/) const override { exportToJSONFormat(openPages, /*...*/); } }; // 使用适配器类 int main() { OpenPages op; OpenPagesAdapter adapter(op); // 现在可以像使用Document类一样使用adapter ByteStream bs; adapter.serialize(bs, /*...*/); adapter.exportToJSON(/*...*/); return 0; } 通过这种方式，你可以无缝地将OpenPages类集成到你的现有系统中，而无需修改其原始实现。适配器类起到了桥梁的作用，使得OpenPages类能够符合你的接口标准。\n适配器设计模式解析\n适配器设计模式是经典的GoF（四人组）设计模式之一。它专注于标准化接口，并帮助非侵入性地向现有的继承层次结构中添加功能。\n意图： “将一个类的接口转换为客户期望的另一个接口。适配器使得原本由于接口不兼容而无法协同工作的类能够一起工作。”\n图6-1展示了你的适配器场景的UML图：你已经有了Document基类（我们暂时忽略JSONExportable和Serializable接口），并且已经实现了几种不同类型的文档（例如，使用Word类）。这个层次结构的新成员是Pages类。\nPages类充当第三方OpenPages类的包装器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Pages : public Document { public: // ... void exportToJSON(/*...*/) const override { exportToJSONFormat(pages, /*...*/); } void serialize(ByteStream\u0026amp; bs, /*...*/) const override { pages.convertToBytes(/*...*/); } // ... private: OpenPages pages; // 对象适配器的例子 }; Pages通过将调用转发到相应的OpenPages函数来实现Document接口：对exportToJSON()的调用被转发到自由函数exportToJSONFormat()，而对serialize()的调用则被转发到成员函数convertToBytes()。\n有了Pages类，你可以轻松地将第三方实现集成到现有的层次结构中。非常容易做到这一点：你可以在不修改其任何代码的情况下进行集成。这种非侵入性的特性正是适配器设计模式的最大优势之一：任何人都可以通过添加适配器来适应一个接口以匹配另一个现有接口。\n在这种情况下，Pages类作为对OpenPages类实际实现细节的抽象。因此，适配器设计模式将接口的关注点与实现细节分离。这很好地符合单一职责原则（SRP），并与开闭原则（OCP）的意图相契合（参见“指南2：为变化设计”和“指南5：为扩展设计”）。\n某种程度上，Pages适配器作为一个间接层，从一组函数映射到另一组函数。请注意，严格来说，并不一定需要将一个函数映射到另一个函数。相反，你可以灵活地决定如何将预期的函数集映射到可用的函数集。因此，适配器并不一定代表一对一的关系，也可以支持一对多的关系。\n假设你有以下两个类：\n1 2 3 4 5 6 7 8 // 第三方库提供的类 class OpenPages { public: void convertToBytes(/*...*/); }; void exportToJSONFormat(OpenPages const\u0026amp; pages, /*...*/); 以及你已有的Document基类：\n1 2 3 4 5 6 7 class Document { public: virtual ~Document() = default; virtual void exportToJSON(/*...*/) const = 0; virtual void serialize(ByteStream\u0026amp; bs, /*...*/) const = 0; }; 为了使OpenPages类适应Document接口，你可以创建一个适配器类Pages：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Pages : public Document { private: OpenPages pages; // 对象适配器的例子 public: void exportToJSON(/*...*/) const override { exportToJSONFormat(pages, /*...*/); } void serialize(ByteStream\u0026amp; bs, /*...*/) const override { pages.convertToBytes(/*...*/); } }; 在这个例子中，Pages类通过将Document接口的方法转发给OpenPages类的方法，实现了适配器的功能。具体来说：\nexportToJSON()方法被转发到自由函数exportToJSONFormat()。 serialize()方法被转发到OpenPages类的convertToBytes()方法。 这样，Pages类就可以无缝地融入你的现有系统中，而无需修改OpenPages类的原始实现。适配器设计模式的这种灵活性使其成为解决接口不兼容问题的强大工具，特别是在需要集成第三方库或旧有系统时。\n对象适配器与类适配器\nPages类是一个所谓的对象适配器的例子。这个术语指的是你存储了被包装类型的实例。或者，如果被包装类型是某个继承层次结构的一部分，你可以存储该层次结构基类的指针。这将允许你使用对象适配器处理所有属于该层次结构的类型，从而大大提高了对象适配器的灵活性。\n相比之下，还有一种实现所谓的类适配器的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Pages : public Document , private OpenPages // 类适配器的例子 { public: // ... void exportToJSON(/*...*/) const override { exportToJSONFormat(*this, /*...*/); } void serialize(ByteStream\u0026amp; bs, /*...*/) const override { this-\u0026gt;convertToBytes(/*...*/); } // ... }; 在这种方式中，不是存储被适配类型的实例，而是通过（可能非公开地）继承它，并相应地实现预期接口。然而，正如在“指南20：优先组合而非继承”中讨论的那样，基于组合构建通常是更好的选择。通常情况下，对象适配器比类适配器更灵活，因此应优先选择对象适配器。只有在以下几种情况下，你可能会更倾向于使用类适配器：\n如果你需要覆盖一个虚函数。 如果你需要访问一个受保护的成员函数。 如果你需要适应的类型在另一个基类之前构造。 如果你需要共享一个共同的虚基类或覆盖虚基类的构造。 如果你可以从空基类优化（EBO）中获得显著优势。 否则，在大多数情况下，你应该优先选择对象适配器。\n关于命名的讨论\n“我喜欢这个设计模式——它很强大。但是，我刚想起来你建议在代码中使用设计模式的名字来传达意图。这个类不应该叫做PagesAdapter吗？” 你提出了一个很好的观点。我很高兴你记得“指南14：使用设计模式的名字来传达意图”，确实我在其中提到设计模式的名字有助于理解代码。我承认在这个例子中，我对两种命名约定都持开放态度。虽然我看到了PagesAdapter这个名字的优点，因为它立即传达了你使用了适配器设计模式，但我并不认为有必要明确说明这个类是一个适配器。对我来说，适配器在这里更像是一个实现细节：我不需要知道Pages类没有自己实现所有细节，而是使用了OpenPages类。这就是为什么我说要“考虑使用这个名字”。你应该根据具体情况决定。\n标准库中的例子\n适配器设计模式的一个有用应用是标准化不同种类容器的接口。假设我们有以下的Stack基类：\n1 2 3 4 5 6 7 8 9 10 11 12 //---- \u0026lt;Stack.h\u0026gt; ---------------- template\u0026lt;typename T\u0026gt; class Stack { public: virtual ~Stack() = default; virtual T\u0026amp; top() = 0; virtual bool empty() const = 0; virtual size_t size() const = 0; virtual void push(T const\u0026amp; value) = 0; virtual void pop() = 0; }; 这个Stack类提供了必要的接口来访问栈顶元素、检查栈是否为空、查询栈的大小、将元素压入栈以及移除栈顶元素。这个基类现在可以用于为各种数据结构实现不同的适配器，例如std::vector：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //---- \u0026lt;VectorStack.h\u0026gt; ---------------- #include \u0026lt;Stack.h\u0026gt; template\u0026lt;typename T\u0026gt; class VectorStack : public Stack\u0026lt;T\u0026gt; { public: T\u0026amp; top() override { return vec_.back(); } bool empty() const override { return vec_.empty(); } size_t size() const override { return vec_.size(); } void push(T const\u0026amp; value) override { vec_.push_back(value); } void pop() override { vec_.pop_back(); } private: std::vector\u0026lt;T\u0026gt; vec_; }; 你可能会担心：“你真的建议用抽象基类来实现栈吗？你不担心性能影响吗？每次调用成员函数时，都要付出虚拟函数调用的代价！” 不，当然我不是这么建议的。显然你是对的，我也完全同意你的看法：从C++的角度来看，这种容器显得奇怪且非常低效。为了提高效率，我们通常通过类模板来实现相同的想法。这是C++标准库采用的方法，以三种STL类的形式实现容器适配器：std::stack、std::queue和std::priority_queue：\n1 2 3 4 5 6 7 8 template\u0026lt;typename T, typename Container = std::deque\u0026lt;T\u0026gt;\u0026gt; class stack; template\u0026lt;typename T, typename Container = std::deque\u0026lt;T\u0026gt;\u0026gt; class queue; template\u0026lt;typename T, typename Container = std::vector\u0026lt;T\u0026gt;, typename Compare = std::less\u0026lt;typename Container::value_type\u0026gt;\u0026gt; class priority_queue; 这三个类模板将给定容器类型的接口适配到特定用途。例如，std::stack类模板的目的是将容器接口适配到栈操作：top()、empty()、size()、push()、emplace()、pop()和swap()。默认情况下，你可以使用三个可用的序列容器：std::vector、std::list和std::deque。对于任何其他容器类型，你可以特化std::stack类模板。\n“这感觉熟悉多了，”你说，明显松了一口气。我完全同意。我也认为标准库的方法更适合容器的目的。但比较这两种方法仍然很有趣。虽然Stack基类和std::stack类模板之间有许多技术上的差异，但这两者的用途和语义都非常相似：它们都提供了一种将任何数据结构适配到给定栈接口的能力。并且两者都作为变化点，允许你在不修改现有代码的情况下非侵入性地添加新的适配器。\n适配器设计模式与策略设计模式的比较\n“这三个STL类似乎实现了适配器的目的，但这不就是策略设计模式中配置行为的方式吗？这和std::unique_ptr及其删除器不是一样的吗？”你问道。是的，你是对的。从结构上看，策略设计模式和适配器设计模式非常相似。然而，正如在“指南11：理解设计模式的目的”中解释的那样，设计模式的结构可能相似甚至相同，但它们的意图不同。在这种情况下，容器参数不仅仅指定行为的一个方面，而是大部分或全部行为。类模板只是给定类型的封装器——它们主要适配接口。因此，适配器的主要关注点是标准化接口并将不兼容的功能集成到现有的规范集中；而另一方面，策略设计模式的主要关注点是从外部配置行为，构建并提供预期的接口。此外，对于适配器而言，不需要随时重新配置行为。\n函数适配器\n适配器设计模式的其他例子包括标准库中的自由函数begin()和end()。“你认真的吗？”你惊讶地问，“你声称自由函数是适配器设计模式的例子？这不是类的工作吗？”其实不一定。自由begin()和end()函数的目的是将任何类型的迭代器接口适配到预期的STL迭代器接口。因此，它将可用的一组函数映射到预期的一组函数，并与其他适配器具有相同的目的。主要区别在于，与基于继承（运行时多态）或模板（编译时多态）的对象适配器或类适配器不同，begin()和end()依赖于函数重载，这是C++中的第二种主要编译时多态机制。尽管如此，某种形式的抽象仍然存在。\n注意\n记住所有类型的抽象都代表一组需求，因此必须遵守里氏替换原则（LSP）。这对重载集也适用；参见“指南8：理解重载集的语义要求”。\n考虑以下函数模板：\n1 2 3 4 5 6 7 template\u0026lt;typename Range\u0026gt; void traverseRange(Range const\u0026amp; range) { for(auto\u0026amp;\u0026amp; element : range) { // ... } } 在traverseRange()函数中，我们通过基于范围的for循环遍历给定范围内包含的所有元素。遍历通过编译器使用自由begin()和end()函数获取的迭代器完成。因此，前面的for循环等价于以下形式的for循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;typename Range\u0026gt; void traverseRange(Range const\u0026amp; range) { { using std::begin; using std::end; auto first(begin(range)); auto last(end(range)); for(; first != last; ++first) { auto\u0026amp;\u0026amp; element = *first; // ... } } } 显然，基于范围的for循环更方便使用。然而，在表面之下，编译器生成的代码基于自由begin()和end()函数。注意其开头的两个using声明：目的是为给定范围类型启用参数相关查找（ADL）。ADL确保即使重载函数位于用户特定的命名空间中，也会调用“正确的”begin()和end()函数。这意味着你可以为任何类型重载begin()和end()，并将预期接口映射到不同的、特定用途的函数集。\n这种类型的函数适配器在2004年被Matthew Wilson称为“shim”。该技术的一个重要特性是完全非侵入性：可以为任何类型添加一个自由函数，甚至是第三方库提供的类型。因此，以shims或函数适配器编写的任何通用代码都能让你拥有巨大的能力，将几乎任何类型适配到预期接口。因此，你可以想象shims或函数适配器是泛型编程的核心。\n分析适配器设计模式的不足\n尽管适配器设计模式有其价值，但我应该明确指出这个设计模式有一个问题。\n考虑以下例子，我借鉴自Eric Freeman和Elisabeth Robson：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---- \u0026lt;Duck.h\u0026gt; ---------------- class Duck { public: virtual ~Duck() = default; virtual void quack() = 0; virtual void fly() = 0; }; //---- \u0026lt;MallardDuck.h\u0026gt; ---------------- #include \u0026lt;Duck.h\u0026gt; class MallardDuck : public Duck { public: void quack() override { /*...*/ } void fly() override { /*...*/ } }; 我们从抽象的Duck类开始，该类引入了两个纯虚函数quack()和fly()。确实，这是一个相当预期且自然的鸭子类接口，并且当然会引发一些期望：鸭子发出非常独特的声音并且能够很好地飞行。许多可能的鸭子类型实现了这个接口，例如MallardDuck类。现在，由于某些原因，我们也需要处理火鸡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //---- \u0026lt;Turkey.h\u0026gt; ---------------- class Turkey { public: virtual ~Turkey() = default; virtual void gobble() = 0; // 火鸡不会嘎嘎叫，而是咯咯叫！ virtual void fly() = 0; }; //---- \u0026lt;WildTurkey.h\u0026gt; ---------------- class WildTurkey : public Turkey { public: void gobble() override { /*...*/ } void fly() override { /*...*/ } }; 火鸡由抽象的Turkey类表示，当然有许多不同种类的具体火鸡实现，比如WildTurkey。为了使事情变得更糟，出于某些原因，鸭子和火鸡需要一起使用。一种可能的方法是假装火鸡是一只鸭子。毕竟，火鸡与鸭子非常相似。好吧，虽然它不会嘎嘎叫，但它会咯咯叫（典型的火鸡声音），而且它也能飞（虽然距离不长，但确实能飞）。因此，你可以使用TurkeyAdapter来适配火鸡到鸭子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //---- \u0026lt;TurkeyAdapter.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; class TurkeyAdapter : public Duck { public: explicit TurkeyAdapter(std::unique_ptr\u0026lt;Turkey\u0026gt; turkey) : turkey_{std::move(turkey)} {} void quack() override { turkey_-\u0026gt;gobble(); } void fly() override { turkey_-\u0026gt;fly(); } private: std::unique_ptr\u0026lt;Turkey\u0026gt; turkey_; // 这是一个对象适配器的例子 }; 虽然这是一个有趣的鸭子类型解释，但这个例子很好地展示了将外来事物轻松集成到现有层次结构中是多么容易。火鸡根本不是鸭子，即使我们希望它是。我认为quack()和fly()函数很可能违反了LSP。这些函数实际上并没有做我期望的事情（至少我很确定我希望听到的是嘎嘎叫而不是咯咯叫的动物，并且我希望看到像鸭子一样真正飞行的东西）。当然，这取决于具体的上下文，但不可否认的是，适配器设计模式使得组合不相干的事物变得非常容易。因此，在应用此设计模式时，非常重要的是要考虑预期的行为并检查是否违反了LSP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;MallardDuck.h\u0026gt; #include \u0026lt;WildTurkey.h\u0026gt; #include \u0026lt;TurkeyAdapter.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; using DuckChoir = std::vector\u0026lt;std::unique_ptr\u0026lt;Duck\u0026gt;\u0026gt;; void give_concert(DuckChoir const\u0026amp; duck_choir) { for(auto const\u0026amp; duck : duck_choir) { duck-\u0026gt;quack(); } } int main() { DuckChoir duck_choir{}; // 让我们雇佣世界上最好的鸭子组成合唱团 duck_choir.push_back(std::make_unique\u0026lt;MallardDuck\u0026gt;()); duck_choir.push_back(std::make_unique\u0026lt;MallardDuck\u0026gt;()); duck_choir.push_back(std::make_unique\u0026lt;MallardDuck\u0026gt;()); // 不幸的是，我们还雇了一个伪装成鸭子的火鸡 auto turkey = std::make_unique\u0026lt;WildTurkey\u0026gt;(); auto turkey_in_disguise = std::make_unique\u0026lt;TurkeyAdapter\u0026gt;(std::move(turkey)); duck_choir.push_back(std::move(turkey_in_disguise)); // 演出将是一场音乐灾难... give_concert(duck_choir); return EXIT_SUCCESS; } 本节总结\n应用Adapter设计模式的目的是调整接口，以便不兼容的部分可以一起工作。 请注意，Adapter对动态和静态多态性都很有用。 区分对象适配器、类适配器和函数适配器。 理解适配器和策略设计模式之间的区别。 在使用Adapter设计模式时，要注意LSP违规 准则25：应用观察者作为抽象通知机制 你很可能之前听说过观察者模式。“哦，是的，当然我听说过——这不就是所谓的社交媒体平台对我们所做的吗？”你问道。嗯，虽然不是我所指的具体内容，但确实，我们可以把这些平台称为观察者。而且，他们做的事情也遵循某种模式，尽管这不是一个设计模式。实际上，我指的是GoF（四人组）设计模式中最受欢迎的设计模式之一——观察者设计模式。即使你还不熟悉这个概念，你也可能在生活中有过与有用的观察者的经验。例如，你可能注意到在某些消息应用程序中，一旦你阅读了一条新消息，发送者会立即被告知。这意味着消息显示为“已读”而不是仅仅“已送达”。这项小服务本质上是由现实生活中的观察者完成的：一旦新消息的状态发生变化，发送者就会收到通知，从而有机会对状态变化做出响应。\n观察者设计模式解释 在许多软件场景中，希望在某个状态发生变化时立即获得反馈：任务队列中添加了一个新任务、配置对象中的设置被更改、结果准备好被提取等。但是同时，引入主题（被观察实体，会发生变化）与其观察者（基于状态变化而被通知的回调函数）之间的显式依赖关系是非常不可取的。相反，主题应该对潜在的多种不同类型的观察者保持不知情。原因很简单，任何直接的依赖都会使软件更难改变和扩展。这种主题与其潜在多个观察者之间的解耦正是观察者设计模式的目的。\n像所有设计模式一样，观察者设计模式识别出一个方面作为变化点（一个变化或预期会变化的方面），并以抽象的形式提取它。因此，它有助于解耦软件实体。在观察者的情况下，引入新观察者的需求——扩展一对多依赖关系——被认为是变化点。如图6-2所示，这种变化点通过观察者基类的形式实现。\n观察者类代表了所有可能的观察者实现的抽象。这些观察者被附加到由具体主题类（ConcreteSubject）表示的特定主题上。为了减少观察者与其主题之间的耦合，或者通过提供所有通用服务来简化代码重复，可以使用主题抽象来进行attach()和detach()操作。该主题还可以在其状态发生变化时通知所有附加的观察者，并触发它们相应的更新功能（update()）。\n“引入观察者基类是不是单一职责原则（SRP）的另一个例子？”你问。是的，你100%正确：提取观察者类、提取变化点正是SRP的实际应用（参见“指南2：为变化而设计”）。再次强调，SRP充当开放封闭原则（OCP）的推动者（参见“指南5：为扩展而设计”）：通过引入观察者抽象，任何人都可以在不需要修改现有代码的情况下添加新的观察者类型（例如，具体观察者ConcreteObserver）。如果你注意观察者基类的所有权，并确保观察者类位于架构的高级别，那么你也满足了依赖倒置原则（DIP）。\n经典观察者实现\n“很好，我明白了！很高兴再次看到这些设计原则的实际应用，但我希望能够看到一个具体的观察者例子。” 我理解。那么让我们来看一个具体的观察者实现。然而，在我们开始看代码之前，我应该清楚地说明以下示例的局限性。你可能已经熟悉观察者模式，因此你可能在寻找关于许多棘手实现细节的帮助和深入建议：如何处理附加和分离观察者的顺序、多次附加同一个观察者以及特别是在并发环境中使用观察者。我必须诚实地说明，我的意图并不是回答这些问题。这种讨论就像是打开潘多拉魔盒，很快会把我们带入实现细节的领域。不，尽管你可能会失望，但我的意图主要是停留在软件设计的层面上。\n像前面的设计模式一样，我们从观察者设计模式的经典实现开始。核心元素是观察者基类：\n1 2 3 4 5 6 7 //---- \u0026lt;Observer.h\u0026gt; ---------------- class Observer { public: virtual ~Observer() = default; virtual void update( /*...*/ ) = 0; }; 这个类最重要的实现细节是纯虚函数update()，当观察者被通知某个状态变化时就会调用它。有三种定义update()函数的方式，提供了合理的实现和设计灵活性。第一种方式是通过一个或多个update()函数推送更新状态：\n1 2 3 4 5 6 7 8 class Observer { public: // ... virtual void update1( /*arguments representing the updated state*/ ) = 0; virtual void update2( /*arguments representing the updated state*/ ) = 0; // ... }; 这种形式的观察者通常被称为“推观察者”。在这种形式中，观察者由主题提供所有必要的信息，因此不需要自己从主题中提取任何信息。这可以显著减少与主题的耦合，并为多个主题重用观察者类创造机会。此外，每种状态变化都有单独的重载函数也是一个选项。在前面的代码片段中有两个update()函数，每个对应一种可能的状态变化。由于总是明确知道哪个状态发生了变化，观察者不需要“搜索”任何状态变化，这证明是高效的。\n“对不起，”你说，“但这不是违反了接口隔离原则（ISP）吗？我们应该通过将update()函数分开到几个基类来分离关注点吗？” 这是一个很好的问题！显然，你在警惕人为的耦合。非常好！你是正确的：我们可以将具有多个update()函数的观察者拆分为更小的观察者类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Observer1 { public: // ... virtual void update1( /*arguments representing the updated state*/ ) = 0; // ... }; class Observer2 { public: // ... virtual void update2( /*arguments representing the updated state*/ ) = 0; // ... }; 理论上，这种方法可以帮助减少对特定主题的耦合，并更容易为不同的主题重用观察者。不同观察者可能对不同的状态变化感兴趣，因此人为地将所有可能的状态变化耦合在一起可能是违反ISP的。当然，如果能够避免很多不必要的状态变化通知，这可能会带来效率提升。\n不幸的是，特定的主题不太可能区分不同类型的观察者。首先，因为这需要主题存储不同类型的指针（对于主题来说处理起来不方便），其次，因为不同状态变化之间可能存在某种联系。在这种情况下，主题期望观察者对所有可能的状态变化都感兴趣。从这个角度来看，将多个update()函数组合到一个基类中是合理的。无论怎样，具体观察者很可能需要处理所有类型的状态变化。我知道，即使只对其中一小部分感兴趣，也必须处理多个update()函数，这可能是个麻烦。但是，仍然要确保不要无意中违反里氏替换原则（LSP），如果不遵守某些预期行为（如果有）。\n有几个潜在缺点使得推观察者并不理想。首先，观察者总是得到所有信息，无论是否需要。因此，只有在观察者大多数时候都需要这些信息时，这种推送风格才有效。否则，很多努力会浪费在不必要的通知上。其次，推送会产生对传递给观察者的参数数量和种类的依赖。对这些参数的任何更改都需要在继承观察者类中进行大量后续更改。\n一些这些缺点可以通过第二种观察者替代方案解决。可以只传递主题的引用来观察者：\n1 2 3 4 5 6 7 class Observer { public: // ... virtual void update( Subject const\u0026amp; subject ) = 0; // ... }; 由于没有向观察者传递特定信息，继承自观察者基类的类需要自行从主题中提取新信息。因此，这种形式的观察者通常被称为“拉观察者”。优点是对参数数量和种类的依赖减少。衍生观察者可以自由查询任何信息，而不仅仅是改变的状态。另一方面，这种设计会在继承自观察者的类和主题之间创建强直接依赖关系。因此，任何对主题的更改都会轻易影响观察者。此外，观察者可能需要“搜索”状态变化，如果多个细节发生了变化，这可能会证明是不必要的低效。\n如果你仅考虑单个变化状态，性能劣势可能不会对你构成限制。不过，请记住软件会发生变化：主题可能会增长，随之而来的是通知不同类型变化的需求。适应这些变化会导致大量的额外工作。从这个角度看，推观察者似乎是一个更好的选择。\n幸运的是，存在第三种替代方案，消除了之前的许多缺点，从而成为我们的首选：除了传递主题引用外，还传递一个标签以提供有关哪个属性已更改的信息：\n1 2 3 4 5 6 7 //---- \u0026lt;Observer.h\u0026gt; ---------------- class Observer { public: virtual ~Observer() = default; virtual void update( Subject const\u0026amp; subject, /*Subject-specific type*/ property ) = 0; }; 该标签可以帮助观察者决定某个状态变化是否有趣。通常表示为主题特定枚举类型，列出所有可能的状态变化。遗憾的是，这增加了观察者类对特定主题的耦合。\n“通过将观察者基类实现为类模板，是否可以移除对特定主题的依赖？”你问道。请看以下代码片段：\n1 2 3 4 5 6 7 8 //---- \u0026lt;Observer.h\u0026gt; ---------------- template\u0026lt; typename Subject, typename StateTag \u0026gt; class Observer { public: virtual ~Observer() = default; virtual void update( Subject const\u0026amp; subject, StateTag property ) = 0; }; 这是一个很好的建议。通过将观察者类定义为类模板的形式，我们可以轻松将其提升到更高的架构级别。在这种形式下，类不依赖于任何特定主题，因此可以被希望定义一对多关系的许多不同主题重复使用。然而，你不应对此改进期望过高：效果仅限于观察者类。具体主题会期望该观察者类的具体实例化，并且具体实现的观察者仍然强烈依赖于主题。\n为了更好地理解为什么会这样，让我们看一下一个可能的主题实现。在你最初的关于社交媒体的评论之后，我建议我们为人物实现一个观察者。好吧，这个例子可能在道德上有问题，但它会达到目的，所以我们就用这个例子吧。至少我们知道是谁造成的。\n以下Person类代表一个被观察的人物：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //---- \u0026lt;Person.h\u0026gt; ---------------- #include \u0026lt;Observer.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;set\u0026gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer\u0026lt;Person,StateChange\u0026gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const\u0026amp; forename() const { return forename_; } std::string const\u0026amp; surname () const { return surname_; } std::string const\u0026amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set\u0026lt;PersonObserver*\u0026gt; observers_; }; 在这个例子中，Person只是三个数据成员的聚合：forename_、surname_和address_（我知道，这是一个人非常简单的表示）。此外，一个人持有注册观察者的std::set。请注意，观察者是通过指向PersonObserver实例的指针注册的。这有两个原因：首先，这展示了模板化的观察者类的目的：Person类实例化了自己的观察者类型。其次，指针在这里非常有用，因为对象的地址是唯一的。因此，通常使用地址作为观察者的唯一标识符。\n“这不应该使用std::unique_ptr或std::shared_ptr吗？”你问。不，在这种情况下不需要。指针仅作为注册观察者的句柄；它们不应该拥有观察者。因此，任何拥有智能指针都是不合适的工具。唯一合理的选择是std::weak_ptr，它可以让你检查悬空指针。然而，std::weak_ptr不适合用作std::set的键（即使是带有自定义比较器）。虽然有一些方法仍然可以使用std::weak_ptr，但我将坚持使用原始指针。但这并不意味着我们要放弃现代C++的好处。在这种情况使用原始指针是完全有效的。这也体现在C++核心指南F.7中： 对于一般用途，取T*或T\u0026amp;参数而不是智能指针。\n每当对人的状态变化感兴趣时，都可以通过attach()成员函数注册一个观察者。当你不再希望接收通知时，可以通过detach()成员函数注销观察者。这两个函数是观察者设计模式的核心组成部分，并且是应用该设计模式的明确标志：\n1 2 3 4 5 6 7 8 9 10 bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) \u0026gt; 0U ); } 你可以根据自己的需求自由实现attach()和detach()函数。在这个例子中，我们允许一个观察者只能注册一次到std::set中。如果你尝试第二次注册同一个观察者，函数会返回false。同样，如果你尝试注销一个未注册的观察者，也会返回false。请注意，不允许多次注册是我的选择。在其他场景中，接受重复注册可能是可取甚至必要的。无论如何，主题的行为和接口在所有情况下都应该一致。\n另一个观察者设计模式的核心函数是notify()成员函数。每当发生某种状态变化时，此函数会被调用以通知所有注册的观察者：\n1 2 3 4 5 6 7 8 void Person::notify( StateChange property ) { for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-\u0026gt;update(*this,property); } } “为什么notify()函数的实现如此复杂？范围基于的for循环难道不够吗？”你问得对，我应该解释一下这里发生了什么。给出的表达式确保可以在迭代期间检测到detach()操作。例如，如果观察者在调用update()函数时决定自我分离，则可能发生这种情况。但我不能说这种实现是完美的：不幸的是，它无法应对attach()操作。而且不要开始询问并发问题！因此，这只是观察者实现细节为何如此棘手的一个例子。\nnotify()函数在所有三个设置函数中被调用。请注意，在所有三个函数中，我们总是传递不同的标签来指示哪个属性已更改。这个标签可以由继承自观察者基类的类用来确定变化的性质：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } 有了这些机制，你现在可以编写新的完全符合OCP（开闭原则）的观察者。例如，你可以决定实现一个NameObserver和一个AddressObserver：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //---- \u0026lt;NameObserver.h\u0026gt; ---------------- #include \u0026lt;Observer.h\u0026gt; #include \u0026lt;Person.h\u0026gt; class NameObserver : public Observer\u0026lt;Person,Person::StateChange\u0026gt; { public: void update( Person const\u0026amp; person, Person::StateChange property ) override; }; //---- \u0026lt;NameObserver.cpp\u0026gt; ---------------- #include \u0026lt;NameObserver.h\u0026gt; void NameObserver::update( Person const\u0026amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... 响应名字变化 } } //---- \u0026lt;AddressObserver.h\u0026gt; ---------------- #include \u0026lt;Observer.h\u0026gt; #include \u0026lt;Person.h\u0026gt; class AddressObserver : public Observer\u0026lt;Person,Person::StateChange\u0026gt; { public: void update( Person const\u0026amp; person, Person::StateChange property ) override; }; //---- \u0026lt;AddressObserver.cpp\u0026gt; ---------------- #include \u0026lt;AddressObserver.h\u0026gt; void AddressObserver::update( Person const\u0026amp; person, Person::StateChange property ) { if( property == Person::addressChanged ) { // ... 响应地址变化 } } 装备了这两个观察者后，现在无论何时人的名字或地址发生变化，你都会收到通知：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;AddressObserver.h\u0026gt; #include \u0026lt;NameObserver.h\u0026gt; #include \u0026lt;Person.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { NameObserver nameObserver; AddressObserver addressObserver; Person homer( \u0026#34;Homer\u0026#34; , \u0026#34;Simpson\u0026#34; ); Person marge( \u0026#34;Marge\u0026#34; , \u0026#34;Simpson\u0026#34; ); Person monty( \u0026#34;Montgomery\u0026#34;, \u0026#34;Burns\u0026#34; ); // 注册观察者 homer.attach( \u0026amp;nameObserver ); marge.attach( \u0026amp;addressObserver ); monty.attach( \u0026amp;addressObserver ); // 更新Homer Simpson的信息 homer.forename( \u0026#34;Homer Jay\u0026#34; ); // 添加中间名 // 更新Marge Simpson的信息 marge.address( \u0026#34;712 Red Bark Lane, Henderson, Clark County, Nevada 89011\u0026#34; ); // 更新Montgomery Burns的信息 monty.address( \u0026#34;Springfield Nuclear Power Plant\u0026#34; ); // 注销观察者 homer.detach( \u0026amp;nameObserver ); return EXIT_SUCCESS; } 在了解了这么多实现细节之后，让我们退一步看看更大的图景。图6-3显示了这个观察者示例的依赖关系图。\n由于决定以类模板的形式实现观察者类，观察者类位于我们架构的最高层次。这使你能够为多种用途重用观察者类，例如Person类。Person类声明了自己的Observer\u0026lt;Person,Person::StateChange\u0026gt;类型，并通过这种方式将自己的代码注入其自身的架构层次。具体的人观察者，如NameObserver和AddressObserver，可以在此声明的基础上构建。\n基于值语义的观察者实现\n“我理解你为什么从经典实现开始，但既然你已经强调了偏好值语义的重要性，那么在一个基于值语义的世界中，观察者会是什么样子呢？” 这是一个非常好的问题，因为这是非常合理的下一步。正如在“指南22：优先选择值语义而不是引用语义”中解释的那样，有很多好的理由避免引用语义的领域。然而，我们不会完全偏离经典的实现：为了注册和注销观察者，我们总是需要某种唯一的标识符来标识观察者，而观察者的唯一地址只是解决这个问题最简单、最方便的方法。因此，我们将继续使用指针来引用已注册的观察者。但是，std::function是一种优雅的方式来避免继承层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //---- \u0026lt;Observer.h\u0026gt; ---------------- #include \u0026lt;functional\u0026gt; template\u0026lt; typename Subject, typename StateTag \u0026gt; class Observer { public: using OnUpdate = std::function\u0026lt;void(Subject const\u0026amp;,StateTag)\u0026gt;; explicit Observer( OnUpdate onUpdate ) : onUpdate_{ std::move(onUpdate) } { // 可能响应无效/空的 std::function 实例 } // 非虚函数 update void update( Subject const\u0026amp; subject, StateTag property ) { onUpdate_( subject, property ); } private: OnUpdate onUpdate_; }; 代替将观察者类实现为基类，并要求派生类以特定方式继承并实现update()函数，我们通过组合（参见“指南20：优先选择组合而不是继承”）来分离关注点。观察者类首先提供了一个名为OnUpdate的类型别名，用于预期签名的std::function类型。通过构造函数，您传递了一个std::function实例，并将其移动到数据成员onUpdate_中。update()函数现在的工作是将调用及其参数转发给onUpdate_。\nstd::function的灵活性可以通过更新后的main()函数轻松展示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;Observer.h\u0026gt; #include \u0026lt;Person.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; void propertyChanged( Person const\u0026amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... 响应名字变化 } } int main() { using PersonObserver = Observer\u0026lt;Person,Person::StateChange\u0026gt;; PersonObserver nameObserver( propertyChanged ); PersonObserver addressObserver( [/*捕获的状态*/]( Person const\u0026amp; person, Person::StateChange property ){ if( property == Person::addressChanged ) { // ... 响应地址变化 } } ); Person homer( \u0026#34;Homer\u0026#34; , \u0026#34;Simpson\u0026#34; ); Person marge( \u0026#34;Marge\u0026#34; , \u0026#34;Simpson\u0026#34; ); Person monty( \u0026#34;Montgomery\u0026#34;, \u0026#34;Burns\u0026#34; ); // 注册观察者 homer.attach( \u0026amp;nameObserver ); marge.attach( \u0026amp;addressObserver ); monty.attach( \u0026amp;addressObserver ); // ... return EXIT_SUCCESS; } 由于选择了侵入性较低的方法，并且与std::function解耦，如何实现update()函数的选择完全取决于观察者的实现者（无状态、有状态等）。对于nameObserver，我们依赖于自由函数propertyChanged()，它本身是高度解耦的，因为它不绑定到任何类并且可能在多个场合重用。另一方面，addressObserver选择使用lambda表达式，该表达式可以捕获一些状态。无论如何，这两个观察者只需要遵循所需的std::function类型的必要签名这一约定。\n“为什么我们仍然需要观察者类？难道我们不能直接使用std::function吗？” 从功能角度来看，观察者类本身并没有添加任何东西。然而，作为值语义的真正产物，我们倾向于复制或移动std::function对象。但在这种情况下这不是所希望的：特别是如果您使用的是有状态观察者，您不希望您的观察者的副本被调用。尽管技术上可行，但传递指向std::function的指针并不常见。因此，观察者类仍可以作为std::function的适配器（参见“指南24：使用适配器标准化接口”）发挥作用。\n分析观察者设计模式的不足\n“这并不是我期望的值语义解决方案，但我仍然喜欢它！” 我很高兴您这么想。确实，值语义的优势结合观察者设计模式的优点（即事件与其相应动作的解耦以及轻松添加新种类观察者的能力）工作得非常好。不幸的是，没有完美的设计，每个设计也有其缺点。\n首先，应该明确指出，演示的std::function方法仅适用于具有单个update()函数的拉取观察者。由于std::function只能处理单一可调用对象，任何需要多个update()函数的方法都无法由单个std::function处理。因此，对于具有多个update()函数的推送观察者或潜在增长的update()函数数量，std::function通常不是最佳选择（记住，代码往往会发生变化！）。不过，可以泛化std::function的方法。如果需要，类型擦除设计模式（参见第8章）是首选。\n第二个（较小的）缺点是，如您所见，没有纯粹基于值的实现。虽然我们可以使用std::function实现update()功能以获得灵活性，但我们仍然使用原始指针来附加和分离观察者。这一点很容易解释：使用指针作为唯一标识符的优点实在太多，无法忽视。此外，对于有状态观察者，我们不想处理实体的副本。当然，这仍然需要我们检查nullptr（这需要额外的努力），并且我们必须始终支付指针代表的间接费用。我个人认为这是一个小问题，因为这种方法有许多优点。\n更大的缺点是观察者的潜在实现问题：注册和注销的顺序可能会有很大影响，特别是在允许观察者多次注册的情况下。此外，在多线程环境中，线程安全地注册和注销观察者以及事件处理是非常复杂的主题。例如，不可信的观察者在回调期间如果行为不当可能会冻结服务器，并且为任意计算实现超时非常复杂。然而，这个话题远远超出了本书的范围。\n然而，属于本书范围的是观察者过度使用的所谓危险：它可以快速且容易地导致复杂的互连网络。事实上，如果不小心，可能会意外引入无限循环的回调！因此，开发人员有时会对使用观察者感到担忧，并担心单个通知可能会由于这些互连而导致巨大的全局响应。虽然这种危险确实存在，但如果设计合理并且观察者实现正确，则任何通知序列都应该沿着有向无环图（DAG）朝着架构的低层运行。而这正是良好软件设计的美妙之处。\n总结来说，旨在提供状态变化通知的解决方案，观察者设计模式被证明是最著名和最常用的模式之一。除了潜在棘手的实现细节外，它无疑是每个开发人员工具箱中应包含的设计模式之一。应用观察者设计模式以创建主题与其观察者之间的一对多关系，并了解推送观察者与拉取观察者之间的权衡。利用基于值语义的观察者实现的优势。\n准则26：使用CRTP引入静态类型类别 C++ 真的有很多值得探索的地方。它带有许多特性、许多语法上的奇特之处以及大量的令人惊叹但难以发音（对于新手来说几乎是神秘的）的缩写词：RAII、ADL、CTAD、SFINAE、NTTP、IFNDR 和 SIOF。哦，多么有趣！其中一个神秘的缩写是 CRTP，即 Curiously Recurring Template Pattern（奇妙递归模板模式）的缩写。\n如果你因为这个名字毫无意义而感到困惑，不要担心：在 C++ 中，名字通常是随意选择的，但一旦选定就不会再更改。这个模式是由 James Coplien 在 1995 年 2 月的《C++ Report》中命名的，因为他意识到这种模式在许多不同的 C++ 代码库中反复出现。并且奇怪的是，尽管这种模式基于继承（可能作为抽象），但它并没有表现出许多其他经典设计模式通常具有的性能缺点。因此，CRTP 绝对值得一看，因为它可能会成为你设计模式工具箱中一个有价值甚至可以说是“奇妙”的补充。\nCRTP 的动机\n在 C++ 中，性能非常重要。事实上，在某些上下文中，使用虚函数的性能开销被认为是完全不可接受的。因此，在性能敏感的上下文中，例如某些计算机游戏或高频交易的部分，不会使用虚函数。同样的情况也适用于高性能计算（HPC）。在 HPC 中，任何条件或间接操作，包括虚函数，都被禁止出现在最影响性能的部分，例如计算内核的最内层循环。使用它们会带来太多的性能开销。\n为了说明这一点及其重要性，让我们考虑以下来自线性代数（LA）库的 DynamicVector 类模板示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //---- \u0026lt;DynamicVector.h\u0026gt; ---------------- #include \u0026lt;numeric\u0026gt; #include \u0026lt;iosfwd\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;vector\u0026gt; // ... template\u0026lt; typename T \u0026gt; class DynamicVector { public: using value_type = T; using iterator = typename std::vector\u0026lt;T\u0026gt;::iterator; using const_iterator = typename std::vector\u0026lt;T\u0026gt;::const_iterator; // ... 构造函数和特殊成员函数 size_t size() const; T\u0026amp; operator[]( size_t index ); T const\u0026amp; operator[]( size_t index ) const; iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; // ... 许多数值函数 private: std::vector\u0026lt;T\u0026gt; values_; // ... }; template\u0026lt; typename T \u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, DynamicVector const\u0026lt;T\u0026gt;\u0026amp; vector ) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34;; for( auto const\u0026amp; element : vector ) { os \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; element; } os \u0026lt;\u0026lt; \u0026#34; )\u0026#34;; return os; } template\u0026lt; typename T \u0026gt; auto l2norm( DynamicVector const\u0026lt;T\u0026gt;\u0026amp; vector ) { using std::begin, std::end; return std::sqrt( std::inner_product( begin(vector), end(vector) , begin(vector), T{} ) ); } // ... 更多内容 尽管名称如此，DynamicVector 并不代表容器，而是用于 LA 计算的数值向量。名称中的“动态”部分意味着它以动态方式分配其元素，在此示例中使用 std::vector。因此，它适用于大型 LA 问题（肯定是在数百万个元素的范围内）。虽然此类可能包含许多数值运算，但从接口角度来看，你可能会称之为容器：它提供了常用的嵌套类型（value_type、iterator 和 const_iterator）、查询当前元素数量的 size() 函数、通过索引访问单个元素的下标运算符（一个用于非常量向量，一个用于常量向量）、迭代元素的 begin() 和 end() 函数。除了成员函数外，它还提供了一个输出运算符和至少一个 LA 操作，用于计算向量的欧几里得范数（通常也称为 L2 范数，因为它近似于离散向量的 L2 范数）。\n然而，DynamicVector 不是唯一的向量类。在我们的 LA 库中，你还会发现以下 StaticVector 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //---- \u0026lt;StaticVector.h\u0026gt; ---------------- #include \u0026lt;array\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iosfwd\u0026gt; #include \u0026lt;iterator\u0026gt; // ... template\u0026lt; typename T, size_t Size \u0026gt; class StaticVector { public: using value_type = T; using iterator = typename std::array\u0026lt;T,Size\u0026gt;::iterator; using const_iterator = typename std::array\u0026lt;T,Size\u0026gt;::const_iterator; // ... 构造函数和特殊成员函数 size_t size() const; T\u0026amp; operator[]( size_t index ); T const\u0026amp; operator[]( size_t index ) const; iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; // ... 许多数值函数 private: std::array\u0026lt;T,Size\u0026gt; values_; // ... }; template\u0026lt; typename T, size_t Size \u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, StaticVector\u0026lt;T,Size\u0026gt; const\u0026amp; vector ) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34;; for( auto const\u0026amp; element : vector ) { os \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; element; } os \u0026lt;\u0026lt; \u0026#34; )\u0026#34;; return os; } template\u0026lt; typename T, size_t Size \u0026gt; auto l2norm( StaticVector\u0026lt;T,Size\u0026gt; const\u0026amp; vector ) { using std::begin, std::end; return std::sqrt( std::inner_product( begin(vector), end(vector) , begin(vector), T{} ) ); } // ... 更多内容 “这不是几乎与 DynamicVector 类相同吗？”你可能会问。是的，这两个类确实非常相似。StaticVector 类提供了与 DynamicVector 相同的接口，如嵌套类型 value_type、iterator 和 const_iterator、查询当前元素数量的 size() 成员函数、下标运算符、迭代元素的 begin() 和 end() 函数。它还包括一个输出运算符和一个自由的 l2norm() 函数。然而，两者之间有一个重要的性能相关的区别：正如名称中的“静态”所暗示的那样，StaticVector 不动态分配其元素。相反，它使用类内的缓冲区来存储其元素，例如使用 std::array。因此，与 DynamicVector 相比，StaticVector 的所有功能都针对少量固定数量的元素进行了优化，例如 2D 或 3D 向量。\n“好的，我理解这对性能很重要，但这仍然导致了大量的代码重复，对吧？”你再次正确。如果仔细查看两个向量类的关联输出运算符，你会发现这两个函数的实现是相同的。这是非常不理想的：如果发生任何变化，例如向量格式的变化（记住：变化是软件开发中的唯一不变，必须预期并处理；参见“指南2：为变化而设计”），那么你将不得不在多个地方进行修改，而不仅仅是一个地方。这违反了“不要重复自己”（DRY）原则：很容易忘记或错过更新某一处，从而引入不一致甚至错误。\n“但这不是可以通过稍微更通用的函数模板轻松解决的问题吗？例如，我可以想象以下适用于所有密集向量的输出运算符：”\n1 2 3 4 5 template\u0026lt; typename DenseVector \u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, DenseVector const\u0026amp; vector ) { // ... 如前所述 } 虽然这似乎是一个适当的解决方案，但我不会在拉取请求中接受此代码。该函数模板确实更通用，但我绝对不会称其为“稍微”更通用；你建议的是可以编写的最通用的输出运算符。是的，该函数模板的名称可能暗示它仅适用于密集向量（包括 DynamicVector 和 StaticVector），但实际上，该函数模板会接受任何类型：DynamicVector、StaticVector、std::vector、std::string 以及基本类型如 int 和 double。它根本无法指定任何要求或约束。因此，它违反了核心指南 T.10： 为所有模板参数指定概念。\n虽然此输出运算符适用于所有密集向量和序列容器，但对于不提供预期接口的类型，你会得到编译错误。或者更糟糕的是，你可能会微妙地违反隐式的要求和期望，从而违反 LSP（参见“指南6：遵循抽象的预期行为”）。当然，你不会有意这样做，但很可能是无意间发生的：此输出运算符是任何类型的完美匹配，并且即使你不期望也会被使用。因此，这个函数模板将成为输出运算符重载集中的一个不幸添加。我们需要的是一组全新的类型，一个新的类型类别。\n“这不是基类的作用吗？我们不能简单地定义一个 DenseVector 基类来为所有密集向量定义预期接口吗？考虑以下 DenseVector 基类的草图：”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt; typename T \u0026gt; // 元素类型 class DenseVector { public: virtual ~DenseVector() = default; virtual size_t size() const = 0; virtual T\u0026amp; operator[]( size_t index ) = 0; virtual T const\u0026amp; operator[]( size_t index ) const = 0; // ... }; template\u0026lt; typename T \u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, DenseVector\u0026lt;T\u0026gt; const\u0026amp; vector ) { // ... 如前所述 } “这应该可以工作，对吧？我只是不确定如何声明 begin() 和 end() 函数，因为我无法从不同迭代器类型（如 std::vector\u0026lt;T\u0026gt;::iterator 和 std::array\u0026lt;T\u0026gt;::iterator）中抽象出来。” 我也有类似的感觉，这个问题没有快速解决方案。但还有一个更为严重的问题：有了这个基类，我们会将所有成员函数变成虚成员函数。这包括 begin() 和 end() 函数，但最重要的是两个下标运算符。后果将是显著的：每次访问向量的一个元素时，我们现在都需要调用一个虚函数。每一次访问！因此，有了这个基类，我们就告别了高性能。\n然而，构建抽象的基本类的想法本身是好的。我们只需要以不同的方式去做。这就是我们应该仔细看看 CRTP 的地方。\nCRTP 设计模式解释\nCRTP 设计模式建立在创建抽象的基本类这一常见想法上。但是，它通过编译时关系而不是运行时关系（通过虚函数）在基类和派生类之间建立了联系。\nCRTP 设计模式通过识别一个方面作为变化点（一个变化或预期会变化的方面）并将其提取为抽象形式来帮助解耦软件实体。在这种情况下，引入新观察者的需求——扩展一对多依赖关系——被认为是变化点。如图 6-2 所示，这种变化点通过观察者基类的形式实现。\nObserver 类代表所有可能的观察者实现的抽象。这些观察者附加到由具体主题类（ConcreteSubject）表示的特定主题上。为了减少观察者与其主题之间的耦合，或者通过提供所有通用服务来简化代码重复，可以使用主题抽象来进行 attach() 和 detach() 操作。该主题还可以在其状态发生变化时通知所有附加的观察者，并触发它们相应的更新功能（update()）。\nCRTP 设计模式基于使用基类创建抽象的常见思想。但它不是通过虚函数在基类和派生类之间建立运行时关系，而是创建编译时关系。\nDenseVector 基类和 DynamicVector 派生类之间的编译时关系是通过将基类升级为类模板来创建的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---- \u0026lt;DenseVector.h\u0026gt; ---------------- template\u0026lt; typename Derived \u0026gt; struct DenseVector { // ... size_t size() const { return static_cast\u0026lt;Derived const\u0026amp;\u0026gt;(*this).size(); } }; // ... //---- \u0026lt;DynamicVector.h\u0026gt; ---------------- template\u0026lt; typename T \u0026gt; class DynamicVector : public DenseVector\u0026lt;DynamicVector\u0026lt;T\u0026gt;\u0026gt; { public: // ... size_t size() const; // ... }; CRTP 的奇妙之处在于，基类的新模板参数表示关联派生类的类型。例如，DynamicVector 等派生类需要提供自己的类型来实例化基类。\n“哇，等一下——这怎么可能？”你可能会问。确实可以。为了实例化一个模板，你不需要完整的类型定义。使用不完整类型就足够了。这种不完整类型在编译器看到 DynamicVector 类声明后即可获得。实际上，这段语法起到了前向声明的作用。因此，DynamicVector 类确实可以使用自身作为 DenseVector 基类的模板参数。\n当然，你可以根据喜好命名基类的模板参数（例如，简单地命名为 T），但正如“指南14：使用设计模式名称传达意图”中讨论的那样，使用设计模式的名称或常用名称有助于传达意图。因此，你可以将参数命名为 CRTP，这很好地传达了模式，但不幸的是只对熟悉的人有意义。其他人会对此缩写感到困惑。因此，模板参数通常称为 Derived，这完美表达了其用途并传达了意图：它代表派生类的类型。\n通过这个模板参数，基类现在知道了实际派生类型的类型。虽然它仍然代表所有密集向量的抽象和公共接口，但现在能够访问和调用派生类型中的具体实现。例如，在 size() 成员函数中发生这种情况：DenseVector 使用 static_cast 将自身转换为派生类的引用，并调用该类的 size() 函数。乍一看，这看起来像是递归函数调用（在 size() 函数内部调用 size() 函数），但实际上是在派生类中调用 size() 成员函数。\n“所以这就是你所说的编译时关系。基类代表具体派生类型和实现细节的抽象，但仍确切知道实现细节在哪里。所以我们真的不需要任何虚函数。” 正确。通过 CRTP，我们现在能够实现一个通用接口，并通过简单的 static_cast 将每个调用转发给派生类。这样做没有任何性能损失。实际上，基类函数很可能会被内联，如果 DenseVector 是唯一的或第一个基类，static_cast 甚至不会产生单条汇编指令。它只是告诉编译器将对象视为派生类型的对象。\n为了提供一个干净的 CRTP 基类，我们还需要更新一些细节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //---- \u0026lt;DenseVector.h\u0026gt; ---------------- template\u0026lt; typename Derived \u0026gt; struct DenseVector { protected: ~DenseVector() = default; public: Derived\u0026amp; derived() { return static_cast\u0026lt;Derived\u0026amp;\u0026gt;( *this ); } Derived const\u0026amp; derived() const { return static_cast\u0026lt;Derived const\u0026amp;\u0026gt;( *this ); } size_t size() const { return derived().size(); } // ... }; 因为我们想避免任何虚函数，所以我们也对虚析构函数不感兴趣。因此，我们将析构函数实现为保护部分中的非虚函数。这完全符合核心指南 C.35： 基类析构函数应该是公共且虚的，或者是受保护且非虚的。\n需要注意的是，此析构函数的定义阻止了编译器生成两个移动操作。由于 CRTP 基类通常是空的，没有什么可移动的内容，这不是问题；但仍然要时刻注意“规则5”。\n我们还应该避免在基类的每个成员函数中使用 static_cast。虽然这是正确的，但任何类型转换都应该被视为可疑行为，应尽量减少。因此，我们添加了两个 derived() 成员函数，它们执行转换并在其他成员函数中使用。这样不仅使代码更简洁、遵循 DRY 原则，而且看起来也远不那么可疑。\n有了 derived() 函数，我们现在可以定义下标运算符和 begin() 和 end() 函数：\n1 2 3 4 5 6 7 8 9 10 11 template\u0026lt; typename Derived \u0026gt; struct DenseVector { // ... decltype(auto) operator[]( size_t index ) { return derived()[index]; } decltype(auto) operator[]( size_t index ) const { return derived()[index]; } decltype(auto) begin() { return derived().begin(); } decltype(auto) begin() const { return derived().begin(); } decltype(auto) end() { return derived().end(); } decltype(auto) end() const { return derived().end(); } }; 然而，这些函数不像 size() 成员函数那样直接。特别是返回类型证明有点难以指定，因为这些类型依赖于 Derived 类的实现。“嗯，那不应该太难吧，”你说。“这就是为什么派生类型提供了几个嵌套类型，如 value_type、iterator 和 const_iterator，对吧？” 实际上，直接询问似乎是直观的做法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt; typename Derived \u0026gt; struct DenseVector { // ... using value_type = typename Derived::value_type; using iterator = typename Derived::iterator; using const_iterator = typename Derived::const_iterator; value_type\u0026amp; operator[]( size_t index ) { return derived()[index]; } value_type const\u0026amp; operator[]( size_t index ) const { return derived()[index]; } iterator begin() { return derived().begin(); } const_iterator begin() const { return derived().begin(); } iterator end() { return derived().end(); } const_iterator end() const { return derived().end(); } }; 我们查询派生类中的 value_type、iterator 和 const_iterator 类型（不要忘记 typename 关键字）并使用这些类型来指定我们的返回类型。这看起来很简单，对吧？你几乎可以肯定这并不那么简单。如果你尝试这样做，Clang 编译器会报出一条非常奇怪且令人困惑的错误消息：\n1 2 3 CRTP.cpp:29:41: error: no type named \u0026#39;value_type\u0026#39; in \u0026#39;DynamicVector\u0026lt;int\u0026gt;\u0026#39; using value_type = typename Derived::value_type; ~~~~~~~~~~~~~~~~~~^~~~~~~~~~ “没有 DynamicVector\u0026lt;int\u0026gt; 中的 value_type —— 很奇怪。” 你的第一个想法是你搞砸了。一定是拼写错误。当然！所以你回到代码中检查拼写。然而，结果是拼写没有问题。你再次检查 DynamicVector 类：那里有嵌套的 value_type 成员。而且一切都是公开的。错误信息毫无意义。你重新检查一切，再检查一遍，半小时后你得出结论：“编译器有一个 bug！”\n不，这不是编译器的 bug。无论是 Clang 还是其他编译器都没有 bug。GCC 提供了一个不同的但稍微更具启发性的错误消息：\n1 2 3 CRTP.cpp:29:10: error: invalid use of incomplete type \u0026#39;class DynamicVector\u0026lt;int\u0026gt;\u0026#39; 29 | using value_type = typename Derived::value_type; ^~~~~~~~~~ Clang 编译器是对的：在 DynamicVector 类中还没有 value_type。还没有！当你查询嵌套类型时，DynamicVector 类的定义还没有被看到，DynamicVector 仍然是一个不完整类型。这是因为编译器会在 DynamicVector 类定义之前实例化 DenseVector 基类。毕竟，从语法上看，基类是在类主体之前指定的：\n1 2 3 template\u0026lt; typename T \u0026gt; class DynamicVector : public DenseVector\u0026lt;DynamicVector\u0026lt;T\u0026gt;\u0026gt; // ... 因此，没有办法使用派生类的嵌套类型来指定 CRTP 类的返回类型。实际上，只要派生类是不完整类型，你就不能使用任何东西。“但是为什么我可以调用派生类的成员函数呢？这难道不会导致同样的问题吗？” 幸运的是，这可以工作（否则 CRTP 模式根本无法工作）。但这仅在类模板的一个特殊属性下有效：成员函数仅在实际调用时才实例化。由于实际调用通常发生在派生类定义可用之后，因此不存在缺少定义的问题。此时，派生类不再是不完整类型。\n“好的，我明白了。但我们如何指定下标运算符和 begin() 和 end() 函数的返回类型呢？” 处理这个问题最方便的方法是使用返回类型推导。这是一个使用 decltype(auto) 返回类型的绝佳机会：\n1 2 3 4 5 6 7 8 9 10 11 template\u0026lt; typename Derived \u0026gt; struct DenseVector { // ... decltype(auto) operator[]( size_t index ) { return derived()[index]; } decltype(auto) operator[]( size_t index ) const { return derived()[index]; } decltype(auto) begin() { return derived().begin(); } decltype(auto) begin() const { return derived().begin(); } decltype(auto) end() { return derived().end(); } decltype(auto) end() const { return derived().end(); } }; “仅仅使用 auto 不够吗？例如，我们可以这样定义返回类型：”\n1 2 3 4 5 6 7 8 9 10 11 template\u0026lt; typename Derived \u0026gt; struct DenseVector { // ... 注意：这种方法在这种情况下可能不够通用，而 `decltype(auto)` 总是有效的 auto\u0026amp; operator[]( size_t index ) { return derived()[index]; } auto const\u0026amp; operator[]( size_t index ) const { return derived()[index]; } auto begin() { return derived().begin(); } auto begin() const { return derived().begin(); } auto end() { return derived().end(); } auto end() const { return derived().end(); } }; 在这种情况下，这确实是足够的。然而，正如我一直强调的，代码会发生变化。最终，可能会出现另一个衍生向量类，它不存储值而是按值返回。例如，考虑一个 ZeroVector 类，它代表向量的零元素。这样的向量不会存储所有元素，因为这样做会浪费资源，而是可能实现为空类，每次访问元素时返回零值。在这种情况下，auto\u0026amp; 返回类型将是不正确的。是的，编译器（希望）会警告你这一点。但你可以通过返回与派生类相同的类型来避免整个问题。这种返回类型由 decltype(auto) 表示。\n分析 CRTP 设计模式的不足\n“哇，这个 CRTP 设计模式听起来太棒了。所以，除了这些比平常稍微复杂一点的实现细节之外，这不是解决所有虚函数性能问题的办法吗？这难道不是所有与继承相关问题的关键、圣杯吗？” 我能理解你的热情！乍一看，CRTP 确实像是解决各种继承层次结构的终极方案。不幸的是，这是一种错觉。记住：每种设计模式都有其优点，但也有缺点。CRTP 设计模式有几个相当限制性的缺点。\n第一个，也是最限制性的缺点之一是缺乏一个通用基类。为了强调其严重性，我再重复一遍：没有通用基类！实际上，每个派生类都有不同的基类。例如，DynamicVector\u0026lt;T\u0026gt; 类有 DenseVector\u0026lt;DynamicVector\u0026lt;T\u0026gt;\u0026gt; 基类。StaticVector\u0026lt;T, Size\u0026gt; 类有 DenseVector\u0026lt;StaticVector\u0026lt;T, Size\u0026gt;\u0026gt; 基类（见图 6-4）。因此，每当需要一个通用基类时，比如用于在集合中存储不同类型，CRTP 设计模式就不是一个合适的选择。\n“哦，哇，我看到这确实是一个真正的限制。但我们不能让 CRTP 基类从一个通用基类派生吗？” 你可能会争辩。不，实际上不行，因为这样做会要求我们再次引入虚函数。“好吧，我明白了。那么使用 std::variant 模拟一个通用基类呢？” 是的，这是一个选项。然而，请记住 std::variant 实际上是访问者设计模式的一种表现形式（见“指南 16：使用访问者扩展操作”）。由于 std::variant 需要知道其所有潜在替代项，这将限制你添加新类型的自由度。所以你看，即使你可能不喜欢它，CRTP 并不能替代所有的继承层次结构。\n第二个，同样可能非常限制性的缺点是，所有与 CRTP 基类接触的东西本身都变成了模板。这对于所有与该基类一起工作的函数来说尤其如此。例如，升级后的输出运算符和 l2norm() 函数：\n1 2 3 4 5 template\u0026lt; typename Derived \u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, DenseVector\u0026lt;Derived\u0026gt; const\u0026amp; vector ); template\u0026lt; typename Derived \u0026gt; auto l2norm( DenseVector\u0026lt;Derived\u0026gt; const\u0026amp; vector ); 这两个函数应该适用于所有从 DenseVector CRTP 类派生的类。当然，它们不应该依赖于派生类的具体类型。因此，这两个函数必须是函数模板：Derived 类型必须被推导出来。虽然在一个线性代数库的上下文中，这通常不是问题，因为几乎所有功能都是用模板实现的，但在其他上下文中，这可能是一个很大的缺点。将大量代码转换为模板并将定义移到头文件中，实际上牺牲了源文件的封装性。是的，这可能确实是一个严重的缺点！\n第三，CRTP 是一种侵入式设计模式。派生类必须通过继承自 CRTP 基类来明确选择加入。虽然在我们自己的代码中这可能不是问题，但你无法轻易地为外部代码添加基类。在这种情况下，你必须求助于适配器设计模式（见“指南 24：使用适配器标准化接口”）。因此，CRTP 不提供非侵入式设计模式的灵活性（例如，使用 std::variant 实现的访问者设计模式、适配器设计模式等）。\n最后但并非最不重要的一点是，CRTP 不提供运行时多态性，只提供编译时多态性。因此，只有在需要某种静态类型抽象的情况下，这种模式才有意义。如果不是这样，它也不是所有继承层次结构的替代品。\nCRTP 的未来：CRTP 与 C++20 概念的比较\n“我明白了，你是对的。CRTP 是纯粹的编译时多态性。然而，这让我思考：我们能否基于 C++20 概念而不是 CRTP 来构建？考虑以下代码。我们可以使用概念来定义一组类型的接口要求，并将函数和运算符限制为仅那些提供预期接口的类型：”\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template\u0026lt; typename T \u0026gt; concept DenseVector = requires ( T t, size_t index ) { t.size(); t[index]; { t.begin() } -\u0026gt; std::same_as\u0026lt;typename T::iterator\u0026gt;; { t.end() } -\u0026gt; std::same_as\u0026lt;typename T::iterator\u0026gt;; } \u0026amp;\u0026amp; requires ( T const t, size_t index ) { t[index]; { t.begin() } -\u0026gt; std::same_as\u0026lt;typename T::const_iterator\u0026gt;; { t.end() } -\u0026gt; std::same_as\u0026lt;typename T::const_iterator\u0026gt;; }; template\u0026lt; DenseVector VectorT \u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, VectorT const\u0026amp; vector ) { // ... 如之前一样 } 你完全正确。我同意，这是一个非常合理的替代方案。实际上，C++20 概念与 CRTP 非常相似，但提供了更简单、非侵入式的替代方法。特别是由于其非侵入性，如果你可以使用 C++20 概念并可以通过概念定义静态类型集，你应该优先选择概念而不是 CRTP。\n尽管如此，我对这个解决方案并不完全满意。虽然这种形式的输出运算符有效地将函数模板限制为仅那些提供预期接口的类型，但它并没有完全限制函数模板到我们的密集向量类型集。仍然有可能传递 std::vector 和 std::string（std::string 在 std 命名空间中已经有一个输出运算符）。因此，这个概念还不够具体。但是如果你遇到这种情况，不用担心：有一种使用标签类的解决方案：\n1 2 3 4 5 6 7 8 9 10 11 12 struct DenseVectorTag {}; template\u0026lt; typename T \u0026gt; concept DenseVector = // ... 密集向量的所有要求定义（如前） \u0026amp;\u0026amp; std::is_base_of_v\u0026lt;DenseVectorTag,T\u0026gt;; template\u0026lt; typename T \u0026gt; class DynamicVector : private DenseVectorTag { // ... }; 通过从 DenseVectorTag 类（最好是私有继承）派生，像 DynamicVector 这样的类可以标识为属于某个特定类型的集合。因此，函数和运算符模板可以有效地限制为仅接受那些明确选择加入类型集合的类型。\n不幸的是，这里有个问题：这种方法不再是非侵入式的。为了克服这一限制，我们引入了一个可定制的类型特征类来进行编译时间接调用。换句话说，我们应用单一职责原则（SRP）并将关注点分离：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct DenseVectorTag {}; template\u0026lt; typename T \u0026gt; struct IsDenseVector : public std::is_base_of\u0026lt;DenseVectorTag,T\u0026gt; {}; template\u0026lt; typename T \u0026gt; constexpr bool IsDenseVector_v = IsDenseVector\u0026lt;T\u0026gt;::value; template\u0026lt; typename T \u0026gt; concept DenseVector = // ... 密集向量的所有要求定义（如前） \u0026amp;\u0026amp; IsDenseVector_v\u0026lt;T\u0026gt;; template\u0026lt; typename T \u0026gt; class DynamicVector : private DenseVectorTag { // ... }; template\u0026lt; typename T, size_t Size \u0026gt; class StaticVector { // ... }; template\u0026lt; typename T, size_t Size \u0026gt; struct IsDenseVector\u0026lt; StaticVector\u0026lt;T,Size\u0026gt; \u0026gt; : public std::true_type {}; IsDenseVector 类模板及其对应的变量模板指示给定类型是否属于密集向量类型集。DenseVector 概念不会直接查询给定类型，而是通过 IsDenseVector 类型特征间接询问。这样，类可以选择通过继承 DenseVectorTag 或通过非侵入式地特化 IsDenseVector 类型特征来明确选择加入类型集合。在这种形式下，概念方法真正取代了经典的 CRTP 方法。\n总结来说，CRTP 是一种用于定义相关类型家族之间编译时关系的出色设计模式。最有趣的是，它解决了继承层次结构中可能遇到的所有性能问题。然而，CRTP 有一些潜在的限制性缺点，例如缺乏通用基类、模板代码的快速传播以及仅限于编译时多态性。在 C++20 中，考虑用概念替换 CRTP，因为概念提供了更简单且非侵入式的替代方案。然而，如果你无法使用 C++20 概念并且 CRTP 适用，它将对你非常有价值。\n本节总结\n应用 CRTP 设计模式为相关类型家族定义编译时抽象。 注意从 CRTP 基类到派生类的有限访问。 记住 CRTP 设计模式的限制，特别是缺乏通用基类。 尽可能优先选择 C++20 概念而非 CRTP 设计模式。 准则27：使用 CRTP 实现静态混入类 在“准则 26：使用 CRTP 引入静态类型类别”中，我向你介绍了 CRTP 设计模式。我也可能给你留下了 CRTP 已经过时的印象，被 C++20 概念的出现所取代。然而，有趣的是，事实并非如此。至少不完全是。那是因为我还没有告诉你完整的故事。CRTP 仍然可能有价值：不是作为设计模式，而是作为实现模式。让我们稍微偏离一下，进入实现模式的领域，让我来解释。\n强类型动机\n考虑以下 StrongType 类模板，它表示任何其他类型的包装器，目的是创建唯一且命名的类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //---- \u0026lt;StrongType.h\u0026gt; ---------------- #include \u0026lt;utility\u0026gt; template\u0026lt; typename T, typename Tag \u0026gt; struct StrongType { public: using value_type = T; explicit StrongType( T const\u0026amp; value ) : value_( value ) {} T\u0026amp; get() { return value_; } T const\u0026amp; get() const { return value_; } private: T value_; }; 这个类可以用于定义类型如 Meter、Kilometer 和 Surname：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---- \u0026lt;Distances.h\u0026gt; ---------------- #include \u0026lt;StrongType.h\u0026gt; template\u0026lt; typename T \u0026gt; using Meter = StrongType\u0026lt;T, struct MeterTag\u0026gt;; template\u0026lt; typename T \u0026gt; using Kilometer = StrongType\u0026lt;T, struct KilometerTag\u0026gt;; // ... //---- \u0026lt;Person.h\u0026gt; ---------------- #include \u0026lt;StrongType.h\u0026gt; using Surname = StrongType\u0026lt;std::string, struct SurnameTag\u0026gt;; // ... 使用别名模板（alias templates）为 Meter 和 Kilometer 允许你选择不同的类型（例如 long 或 double）来表示距离。尽管这些类型基于基础类型或标准库类型（如 std::string），它们代表具有语义意义的独特类型（强类型），不能在算术操作中意外地组合在一起，例如加法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Distances.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { auto const m1 = Meter\u0026lt;long\u0026gt;{ 120L }; auto const m2 = Meter\u0026lt;long\u0026gt;{ 50L }; auto const km = Kilometer\u0026lt;long\u0026gt;{ 30L }; auto const surname1 = Surname{ \u0026#34;Stroustrup\u0026#34; }; auto const surname2 = Surname{ \u0026#34;Iglberger\u0026#34; }; // ... // 正确地不会编译！ m1 + km; // 同样正确地不会编译！ surname1 + surname2; // 不幸的是这也无法编译。 m1 + m2; return EXIT_SUCCESS; } 虽然 Meter 和 Kilometer 都通过 long 表示，但不能直接将 Meter 和 Kilometer 相加。这是很好的：它不会留下任何意外引入错误的漏洞。同样也不能将两个 Surname 相加，尽管 std::string 提供了字符串拼接的加法运算符。这也是很好的：强类型有效地限制了底层类型的不期望操作。\n不幸的是，这一“特性”也阻止了两个 Meter 实例的相加。然而，这种操作是可取的：直观、自然，并且由于操作的结果仍然是 Meter 类型，因此物理上也是准确的。为了实现这一点，我们可以为 Meter 类型实现一个加法运算符。然而，显然这不会是唯一的加法运算符。我们还需要为其他强类型（如 Kilometer、Mile、Foot 等）实现类似的运算符。由于所有这些实现看起来都一样，这违反了 DRY 原则。因此，扩展 StrongType 类模板以包含加法运算符似乎是合理的：\n1 2 3 4 5 6 template\u0026lt; typename T, typename Tag \u0026gt; StrongType\u0026lt;T, Tag\u0026gt; operator+( StrongType\u0026lt;T, Tag\u0026gt; const\u0026amp; a, StrongType\u0026lt;T, Tag\u0026gt; const\u0026amp; b ) { return StrongType\u0026lt;T, Tag\u0026gt;( a.get() + b.get() ); } 由于这个加法运算符的表述方式，不可能将两个不同的 StrongType 实例（例如 Meter 和 Kilometer）相加，但它允许相同实例化的两个 StrongType 实例相加。“哦，但我看到了一个问题：虽然现在可以将两个 Meter 或两个 Kilometer 相加，但也可以将两个 Surname 相加。我们不希望那样！” 你是对的：这是不希望的。我们需要的是特定 StrongType 实例化中操作的有意添加。这就是 CRTP 发挥作用的地方。\n使用 CRTP 作为实现模式\n与其直接为 StrongType 类模板配备操作，我们通过混入类（mixin classes）提供这些操作：这些基类“注入”所需的操作。这些混入类是通过 CRTP 实现的。例如，考虑表示加法操作的 Addable 类模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //---- \u0026lt;Addable.h\u0026gt; ---------------- template\u0026lt; typename Derived \u0026gt; struct Addable { friend Derived\u0026amp; operator+=( Derived\u0026amp; lhs, Derived const\u0026amp; rhs ) { lhs.get() += rhs.get(); return lhs; } friend Derived operator+( Derived const\u0026amp; lhs, Derived const\u0026amp; rhs ) { return Derived{ lhs.get() + rhs.get() }; } }; 模板参数的名字揭示了它的用途：Addable 是一个 CRTP 基类。Addable 只提供了两个函数，作为隐藏友元实现：赋值加法运算符和加法运算符。这两个运算符都定义在指定的 Derived 类型上，并被注入到周围的命名空间中。因此，任何从这个 CRTP 基类派生的类都会“继承”两个自由加法运算符：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //---- \u0026lt;StrongType.h\u0026gt; ---------------- #include \u0026lt;stdlib\u0026gt; #include \u0026lt;utility\u0026gt; template\u0026lt; typename T, typename Tag \u0026gt; struct StrongType : private Addable\u0026lt; StrongType\u0026lt;T,Tag\u0026gt; \u0026gt; { /* ... */ }; //---- \u0026lt;Distances.h\u0026gt; ---------------- #include \u0026lt;StrongType.h\u0026gt; template\u0026lt; typename T \u0026gt; using Meter = StrongType\u0026lt;T, struct MeterTag\u0026gt;; // ... //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Distances.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { auto const m1 = Meter\u0026lt;long\u0026gt;{ 100 }; auto const m2 = Meter\u0026lt;long\u0026gt;{ 50 }; auto const m3 = m1 + m2; // 编译并得到 150 米的结果 // ... return EXIT_SUCCESS; } “我理解混入类的目的，但在这个形式下，所有 StrongType 的实例都会继承一个加法运算符，即使有些实例不需要加法操作，对吧？” 是的，确实如此。因此，我们还没有完成。我们希望的是有选择地将混入类添加到那些需要操作的 StrongType 实例中。我们的解决方案是将混入类以可选模板参数的形式提供。为此，我们将 StrongType 类模板扩展为带有变长模板模板参数包的形式：\n1 2 3 4 5 6 7 //---- \u0026lt;StrongType.h\u0026gt; ---------------- #include \u0026lt;utility\u0026gt; template\u0026lt; typename T, typename Tag, template\u0026lt;typename\u0026gt; class... Skills \u0026gt; struct StrongType : private Skills\u0026lt; StrongType\u0026lt;T,Tag,Skills...\u0026gt; \u0026gt;... { /* ... */ }; 这种扩展使我们能够为每个单独的强类型指定所需的技能。例如，考虑另外两个技能 Printable 和 Swappable：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //---- \u0026lt;Printable.h\u0026gt; ---------------- template\u0026lt; typename Derived \u0026gt; struct Printable { friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, const Derived\u0026amp; d ) { os \u0026lt;\u0026lt; d.get(); return os; } }; //---- \u0026lt;Swappable.h\u0026gt; ---------------- template\u0026lt; typename Derived \u0026gt; struct Swappable { friend void swap( Derived\u0026amp; lhs, Derived\u0026amp; rhs ) { using std::swap; // 启用 ADL swap( lhs.get(), rhs.get() ); } }; 结合 Addable 技能，我们现在可以组装具有所需技能的强类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //---- \u0026lt;Distances.h\u0026gt; ---------------- #include \u0026lt;StrongType.h\u0026gt; template\u0026lt; typename T \u0026gt; using Meter = StrongType\u0026lt;T, struct MeterTag, Addable, Printable, Swappable\u0026gt;; template\u0026lt; typename T \u0026gt; using Kilometer = StrongType\u0026lt;T, struct KilometerTag, Addable, Printable, Swappable\u0026gt;; // ... //---- \u0026lt;Person.h\u0026gt; ---------------- #include \u0026lt;StrongType.h\u0026gt; #include \u0026lt;string\u0026gt; using Surname = StrongType\u0026lt;std::string, struct SurnameTag, Printable, Swappable\u0026gt;; // ... Meter 和 Kilometer 都可以进行加法、打印和交换，而 Surname 可以打印和交换，但不能相加（即不接收 Addable 混入类，因此不从其派生）。\n“这太好了。我理解在这种情况下 CRTP 混入类的目的。但这个 CRTP 示例与之前的示例有什么不同？” 很好的问题。你问得对，实现细节非常相似。但有几个显著的区别。注意，CRTP 基类没有提供虚或保护析构函数。因此，与之前的示例相比，它不是设计为多态基类。还要注意，在这个示例中，使用 CRTP 基类作为私有基类就足够了，甚至更好。因此，在这种情况下，CRTP 基类不代表抽象，而是仅作为一个实现细节。因此，CRTP 不具备设计模式的特性，也不充当设计模式。它仍然是一个模式，但在这里只是作为一个实现模式。\nCRTP 示例的主要区别在于我们如何使用继承。对于 CRTP 设计模式，我们根据 LSP 使用继承作为抽象：基类代表派生类的要求，以及可用和预期的行为。用户代码通过指向基类的指针或引用直接访问操作，这反过来要求我们提供虚或保护析构函数。当这样实现时，CRTP 成为了软件设计的一个真正元素——一个设计模式。\n相比之下，对于 CRTP 实现模式，我们使用继承来实现技术上的优雅和便利。基类成为实现细节，不需要被调用代码知道或使用。因此，它不需要虚或保护析构函数。当这样实现时，CRTP 保持在实现细节层面，因此是一个实现模式。然而，在这种形式下，CRTP 并不与 C++20 概念竞争。相反：在这种形式下，CRTP 是无可替代的，因为它代表了一种提供静态混入功能的独特技术。因此，CRTP 今天仍然在使用，并且是每个 C++ 开发者工具箱中的宝贵补充。\n总结来说，CRTP 并没有过时，但它的价值已经改变。在 C++20 中，CRTP 被概念所取代，因此不再作为设计模式。然而，它继续作为混入类的实现模式有价值。\n本节总结\n请注意将CRTP用作设计模式和将其用作实现模式之间的区别。 要理解表示抽象的CRTP基类充当设计模式。 要了解，不表示抽象的CRTP基类充当实现模式。 第七章 桥接、原型和外部多态设计模式 在本章中，我们将专注于两个经典的 GoF（Gang of Four）设计模式：桥接设计模式和原型设计模式。此外，我们还将研究外部多态设计模式。乍一看，这种选择可能显得像是一个杰出的、几乎随机的设计模式组合。然而，我选择这些模式有两个原因：首先，根据我的经验，这三个模式在设计模式目录中是最有用的。因此，你应该对它们的意图、优点和缺点有相当好的了解。其次且同样重要的是：它们在第八章中都将发挥至关重要的作用。\n准则 28：构建桥梁以消除物理依赖\n在这一部分，我将向你介绍桥接设计模式及其最简单的形式——Pimpl 惯用法。最重要的是，我将展示如何使用桥接来通过解耦接口与实现细节来减少物理耦合。\n准则 29：注意桥接性能的增益与损失\n在这一部分，我们将明确地探讨桥接对性能的影响。我们将运行基准测试，比较没有桥接的实现、基于桥接的实现以及“部分”桥接的实现。\n准则 30：应用原型进行抽象复制操作\n在这一部分，我将向你介绍克隆的艺术。也就是说，我们将讨论复制操作，特别是抽象复制操作。为此目的，我们将采用原型设计模式。\n准则 31：使用外部多态实现非侵入式运行时多态\n在这一部分，我们将继续分离关注点的旅程，通过从类中提取函数的实现细节。为了进一步减少依赖性，我们将这种分离提升到一个新的水平：不仅提取虚拟函数的实现细节，还提取整个函数本身，这将通过外部多态设计模式来实现。\n准则 28：构建桥梁以消除物理依赖 根据词典，术语“桥”表示时间、地点或连接或过渡的方式。如果我问你“桥”这个词对你意味着什么，我相信你会有一个类似的定义。你可能会隐式地想到连接两件事物，并因此使它们更接近。例如，你可能会想到一个被河流分隔的城市。一座桥会将城市的两边连接起来，使它们更接近，并节省人们很多时间。你也可能想到电子学中的桥，它连接电路的两个独立部分。音乐中有桥，现实世界中也有很多例子，这些桥帮助我们连接事物。是的，直觉上，“桥”这个词暗示着增加接近和邻近性。因此，桥接设计模式恰恰相反：它支持你减少物理依赖，并帮助解耦，即保持需要一起工作的两个功能模块在彼此之间保持一定距离，从而不需了解太多对方的细节。\n一个激励的例子\n为了说明我的想法，考虑以下 ElectricCar 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //---- \u0026lt;ElectricEngine.h\u0026gt; ---------------- class ElectricEngine { public: void start(); void stop(); private: // ... }; //---- \u0026lt;ElectricCar.h\u0026gt; ---------------- #include \u0026lt;ElectricEngine.h\u0026gt; // ... class ElectricCar { public: ElectricCar(/* maybe some engine arguments */); void drive(); // ... private: ElectricEngine engine_; // ... 更多与汽车相关的数据成员（轮子、驱动系统等） }; //---- \u0026lt;ElectricCar.cpp\u0026gt; ---------------- #include \u0026lt;ElectricCar.h\u0026gt; ElectricCar::ElectricCar(/* maybe some engine arguments */) : engine_{/* engine arguments */} // ... 初始化其他数据成员 {} // ... 顾名思义，ElectricCar 类配备了一个 ElectricEngine。然而，尽管在现实中这样的车可能非常有吸引力，当前的实现细节却令人担忧：由于 engine_ 数据成员的存在，《ElectricCar.h》头文件需要包含《ElectricEngine.h》头文件。编译器需要看到 ElectricEngine 的类定义，因为否则它无法确定 ElectricCar 实例的大小。然而，包含《ElectricEngine.h》头文件很容易导致传递性的物理依赖：每个包含《ElectricCar.h》头文件的文件都会物理上依赖于《ElectricEngine.h》头文件。因此，每当头文件发生更改时，ElectricCar 类以及潜在的许多其他类都会受到影响。它们可能需要重新编译、重新测试，甚至在最坏的情况下重新部署……唉。\n此外，这种设计暴露了所有实现细节。“你是什么意思？类的私有部分不是用来隐藏和封装实现细节的吗？” 是的，它是私有的，但 private 标签只是一个访问标签。它不是一个可见性标签。因此，你的类定义中的所有内容（我是指所有内容）对所有能看到 ElectricCar 类定义的人都可见。这意味着你不能在不被人注意的情况下改变这个类的实现细节。特别是，如果你需要提供 ABI 稳定性，即你的类的内存表示不能改变，这可能是一个问题。\n稍微好一点的方法是只存储一个指向 ElectricEngine 的指针：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //---- \u0026lt;ElectricCar.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; // ... struct ElectricEngine; // 前向声明 class ElectricCar { public: ElectricCar(/* maybe some engine arguments */); void drive(); // ... private: std::unique_ptr\u0026lt;ElectricEngine\u0026gt; engine_; // ... 更多与汽车相关的数据成员（轮子、驱动系统等） }; //---- \u0026lt;ElectricCar.cpp\u0026gt; ---------------- #include \u0026lt;ElectricCar.h\u0026gt; #include \u0026lt;ElectricEngine.h\u0026gt; ElectricCar::ElectricCar(/* maybe some engine arguments */) : engine_{std::make_unique\u0026lt;ElectricEngine\u0026gt;(/* engine arguments */)} // ... 初始化其他数据成员 {} // ... 其他 \u0026#39;ElectricCar\u0026#39; 成员函数，使用指向 \u0026#39;ElectricEngine\u0026#39; 的指针 在这种情况下，只需要向前声明 ElectricEngine 类即可，因为编译器不需要知道类定义来确定 ElectricCar 实例的大小。\n此外，物理依赖也消失了，因为《ElectricEngine.h》头文件已经移到了源文件中。因此，从依赖关系的角度来看，这个解决方案要好得多，仍然存在的问题是实现细节的可见性，每个人仍然可以看到 ElectricCar 构建在 ElectricEngine 之上，因此每个人都仍然隐式地依赖于这些实现细节。\n因此，任何对这些细节的更改，例如升级到新的 PowerEngine，都会影响使用《ElectricCar.h》头文件的所有类。“这是不好的，对吧？” 确实如此，因为变化是可以预期的（参见“指南 2：为变化而设计”）。\n为了摆脱这种依赖并获得随时轻松更改实现细节而不被人注意的便利，我们必须引入抽象。经典的抽象形式是引入抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //---- \u0026lt;Engine.h\u0026gt; ---------------- class Engine { public: virtual ~Engine() = default; virtual void start() = 0; virtual void stop() = 0; // ... 更多与引擎相关的函数 private: // ... }; //---- \u0026lt;ElectricCar.h\u0026gt; ---------------- #include \u0026lt;Engine.h\u0026gt; #include \u0026lt;memory\u0026gt; class ElectricCar { public: void drive(); // ... private: std::unique_ptr\u0026lt;Engine\u0026gt; engine_; // ... 更多与汽车相关的数据成员（轮子、驱动系统等） }; //---- \u0026lt;ElectricEngine.h\u0026gt; ---------------- #include \u0026lt;Engine.h\u0026gt; class ElectricEngine : public Engine { public: void start() override; void stop() override; private: // ... }; //---- \u0026lt;ElectricCar.cpp\u0026gt; ---------------- #include \u0026lt;ElectricCar.h\u0026gt; #include \u0026lt;ElectricEngine.h\u0026gt; ElectricCar::ElectricCar(/* maybe some engine arguments */) : engine_{std::make_unique\u0026lt;ElectricEngine\u0026gt;(/* engine arguments */)} // ... 初始化其他数据成员 {} // ... 其他 \u0026#39;ElectricCar\u0026#39; 成员函数，主要使用 \u0026#39;Engine\u0026#39; 抽象，但也可能明确处理 \u0026#39;ElectricEngine\u0026#39; 有了 Engine 基类（），我们可以使用这种抽象实现 ElectricCar 类。没有人需要知道我们使用的实际引擎类型。也没有人需要知道我们何时升级引擎。通过这种实现，我们可以随时通过仅修改源文件轻松更改实现细节。因此，通过这种方法，我们真正最小化了对 ElectricEngine 实现的依赖。我们将这一细节的知识变成我们的秘密实现细节。通过这样做，我们构建了一座桥梁。\n桥接设计模式解释\n桥接设计模式是1994年由GoF（四人组）引入的经典设计模式之一。桥接的目的在于通过将某些实现细节封装在抽象之后来最小化物理依赖。在C++中，它充当编译防火墙，使更改变得容易：\n在这个意图的表述中，四人组讨论了“抽象”和“实现”。在我们的例子中，ElectricCar 类代表“抽象”，而 Engine 类代表“实现”（参见图7-1）。这两者都应该能够独立变化；即对其中任何一个的更改都不应影响另一个。易于更改的障碍是 ElectricCar 类与其引擎之间的物理依赖。因此，想法是提取并隔离这些依赖关系。通过以 Engine 抽象的形式隔离它们，分离关注点，并满足单一职责原则（SRP），你可以获得灵活地更改、调整或升级引擎的方式（参见“指南 2：为变化而设计”）。这种变化不再在 ElectricCar 类中可见。结果是，现在可以轻松添加新的引擎类型而不让“抽象”察觉。这符合开放封闭原则（OCP）的思想（参见“指南 5：为扩展而设计”）。\n虽然这为我们提供了轻松应用更改的能力，并实现了桥接的想法，但我们可以采取一个额外的步骤来进一步解耦和减少重复。假设我们不仅对电动汽车感兴趣，还对内燃机汽车感兴趣。因此，对于每一种我们计划实现的汽车类型，我们都希望引入相同的与引擎细节解耦方式，即相同的桥接。为了减少重复并遵循DRY原则，我们可以将桥接相关的实现细节提取到 Car 基类中。Car 基类封装了与关联 Engine 的桥接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //---- \u0026lt;Car.h\u0026gt; ---------------- #include \u0026lt;Engine.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; class Car { protected: explicit Car(std::unique_ptr\u0026lt;Engine\u0026gt; engine) : pimpl_(std::move(engine)) {} public: virtual ~Car() = default; virtual void drive() = 0; // ... 更多与汽车相关的函数 protected: Engine* getEngine() { return pimpl_.get(); } Engine const* getEngine() const { return pimpl_.get(); } private: std::unique_ptr\u0026lt;Engine\u0026gt; pimpl_; // Pointer-to-implementation (pimpl) // ... 更多与汽车相关的数据成员（轮子、驱动系统等） }; 通过添加 Car 类，“抽象”和“实现”都获得了易于扩展的机会，并且可以独立变化。尽管 Engine 基类仍然在此桥接关系中代表“实现”，但现在 Car 类扮演了“抽象”的角色。关于 Car 类的第一个值得注意的细节是受保护的构造函数（）。这个选择确保只有派生类才能指定引擎类型。构造函数接受一个指向 Engine 的 std::unique_ptr 并将其移动到其 pimpl_ 数据成员（）。这个指针数据成员是所有类型的 Car 的单一实现指针，通常称为 pimpl。这个不透明指针表示到封装的实现细节的桥接，并实质上代表了整个桥接设计模式。因此，在代码中使用名称 pimpl 来指示你的意图是一个好主意（记住“指南 14：使用设计模式的名称传达意图”）。\n注意 pimpl_ 被声明在类的私有部分，尽管派生类需要使用它。这一选择是由核心指南 C.133 动机： 避免保护的数据成员。 实际上，经验表明，保护的数据成员几乎不比公共数据成员更好。因此，为了授予访问 pimpl 的权限，Car 类提供了受保护的 getEngine() 成员函数（）。ElectricCar 类相应地进行了调整：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //---- \u0026lt;ElectricCar.h\u0026gt; ---------------- #include \u0026lt;Engine.h\u0026gt; #include \u0026lt;memory\u0026gt; class ElectricCar : public Car { public: explicit ElectricCar(/* maybe some engine arguments */); void drive() override; // ... }; //---- \u0026lt;ElectricCar.cpp\u0026gt; ---------------- #include \u0026lt;ElectricCar.h\u0026gt; #include \u0026lt;ElectricEngine.h\u0026gt; ElectricCar::ElectricCar(/* maybe some engine arguments */) : Car(std::make_unique\u0026lt;ElectricEngine\u0026gt;(/* engine arguments */)) {} // ... 而不是实现桥接本身，ElectricCar 类现在继承自 Car 基类（）。这种继承关系引入了通过指定一个 Engine 初始化 Car 基类的要求。这项任务在 ElectricCar 构造函数（）中完成。\nPimpl惯用法\n有一种更简单的桥接设计模式形式，几十年来在C和C++中被广泛成功使用。为了看一个例子，让我们考虑以下的Person类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person { public: // ... int year_of_birth() const; // ... 更多访问函数 private: std::string forename_; std::string surname_; std::string address_; std::string city_; std::string country_; std::string zip_; int year_of_birth_; // ... 可能还有更多的数据成员 }; 一个人包含了许多数据成员：名字、姓氏、完整的邮政地址、出生年份等，并且可能需要在未来添加更多数据成员，如手机号码、Twitter账号或下一个社交媒体热潮的账户信息。换句话说，可以合理地认为Person类需要随着时间扩展或更改，甚至可能会频繁更改。这可能会给该类的用户带来很多不便：每当Person发生变化时，使用Person的用户必须重新编译他们的代码。更不用说ABI稳定性了：Person实例的大小会改变！\n为了隐藏所有对Person实现细节的更改并获得ABI稳定性，你可以使用桥接设计模式。然而，在这种特定情况下，不需要提供以基类形式的抽象：只有一个并且确切的Person实现。因此，我们所做的就是引入一个名为Impl的私有嵌套类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //---- \u0026lt;Person.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; class Person { public: // ... private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; const pimpl_; }; //---- \u0026lt;Person.cpp\u0026gt; ---------------- #include \u0026lt;Person.h\u0026gt; #include \u0026lt;string\u0026gt; struct Person::Impl { std::string forename; std::string surname; std::string address; std::string city; std::string country; std::string zip; int year_of_birth; // ... 可能还有更多的数据成员 }; 嵌套的Impl类的任务是封装Person的实现细节。因此，Person类中唯一的剩余数据成员是一个指向Impl实例的std::unique_ptr。其他所有数据成员以及潜在的一些非虚拟辅助函数都被移到了Impl类中。请注意，Impl类仅在Person类中声明但未定义。相反，它在相应的源文件中定义。只有这样，所有细节及其更改（如添加或删除数据成员，更改数据成员类型等）才会对Person的用户隐藏。\n这个Person的实现使用了桥接设计模式的最简单形式：这种局部、非多态形式的桥接被称为Pimpl惯用法。它带来了桥接模式的所有解耦优势，但尽管其简单性，仍然导致了Person类实现稍微复杂一些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 //---- \u0026lt;Person.h\u0026gt; ---------------- //#include \u0026lt;memory\u0026gt; class Person { public: // ... Person(); ~Person(); Person(Person const\u0026amp; other); Person\u0026amp; operator=(Person const\u0026amp; other); Person(Person\u0026amp;\u0026amp; other); Person\u0026amp; operator=(Person\u0026amp;\u0026amp; other); int year_of_birth() const; // ... 更多访问函数 private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; const pimpl_; }; //---- \u0026lt;Person.cpp\u0026gt; ---------------- //#include \u0026lt;Person.h\u0026gt; //#include \u0026lt;string\u0026gt; struct Person::Impl { // ... }; Person::Person() : pimpl_{std::make_unique\u0026lt;Impl\u0026gt;()} {} Person::~Person() = default; Person::Person(Person const\u0026amp; other) : pimpl_{std::make_unique\u0026lt;Impl\u0026gt;(*other.pimpl_)} {} Person\u0026amp; Person::operator=(Person const\u0026amp; other) { *pimpl_ = *other.pimpl_; return *this; } Person::Person(Person\u0026amp;\u0026amp; other) : pimpl_{std::make_unique\u0026lt;Impl\u0026gt;(std::move(*other.pimpl_))} {} Person\u0026amp; Person::operator=(Person\u0026amp;\u0026amp; other) { *pimpl_ = std::move(*other.pimpl_); return *this; } int Person::year_of_birth() const { return pimpl_-\u0026gt;year_of_birth; } // ... 更多Person成员函数 Person构造函数通过std::make_unique()初始化pimpl_数据成员。当然，这涉及动态内存分配，这意味着需要清理动态内存。“所以我们使用std::unique_ptr，”你说。正确。但也许令人惊讶的是，尽管我们使用std::unique_ptr为此目的，仍然需要手动处理析构函数。\n“为什么我们必须这样做？std::unique_ptr的目的不就是我们不必处理清理吗？” 是的，但我们仍需这么做。让我解释一下：如果你不编写析构函数，编译器会为你生成一个析构函数。不幸的是，它会在\u0026lt;Person.h\u0026gt;头文件中生成析构函数。Person的析构函数将触发std::unique_ptr数据成员析构函数的实例化，这反过来又需要Impl类析构函数的定义。然而，Impl的定义不在头文件中，而是在源文件中定义。否则，它会违背桥接的目的。因此，编译器会发出关于不完整类型Impl的错误。幸运的是，你不必放弃std::unique_ptr来解决这个问题（事实上你不应该放弃）。问题相当简单：只需将Person析构函数的定义移到源文件中即可：在类定义中声明析构函数并在源文件中通过=default定义它。\n由于std::unique_ptr不能被复制，你必须实现拷贝构造函数以保持Person类的拷贝语义。同样的道理也适用于拷贝赋值运算符。请注意，此运算符假设每个Person实例都将有一个有效的pimpl_。这一假设解释了移动构造函数的实现：而不是简单地移动std::unique_ptr，它执行可能失败或抛出异常的动态内存分配与std::make_unique()。因此，它没有被声明为noexcept。这一假设还解释了为什么pimpl_数据成员被声明为const。一旦初始化，指针将不再改变，即使在移动操作中也是如此，包括移动赋值运算符。\n最后一个值得注意的细节是year_of_birth()成员函数的定义位于源文件中。尽管这个简单的getter函数是一个很好的内联候选者，定义仍需移到源文件中。原因是头文件中的Impl是一个不完全类型。这意味着在头文件中无法访问任何成员（数据和函数）。这只能在源文件中进行，或者更一般地说，当编译器知道Impl的定义时。\n桥接与策略设计模式的比较\n“我有一个问题，”你说，“我看到桥接和策略设计模式之间有很大的相似之处。我知道你说过设计模式有时结构上非常相似，唯一的区别在于它们的意图。但这两者之间的具体区别是什么？” 我理解你的问题。这两种模式之间的相似性确实有些令人困惑。然而，有一些方法可以帮助区分它们：如何初始化相应数据成员是一个强有力的指标，表明你在使用哪种模式。\n如果一个类不想知道某些实现细节，并因此提供了从外部传递这些细节的机会（例如，通过构造函数或设置函数），那么你很可能在处理策略设计模式。因为灵活配置行为（即减少逻辑依赖）是它的主要关注点，策略模式属于行为设计模式类别。例如，在以下代码片段中，Database类的构造函数就是一个明显的标志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class DatabaseEngine { public: virtual ~DatabaseEngine() = default; // ... 许多数据库特定的函数 }; class Database { public: explicit Database(std::unique_ptr\u0026lt;DatabaseEngine\u0026gt; engine); // ... 许多数据库特定的函数 private: std::unique_ptr\u0026lt;DatabaseEngine\u0026gt; engine_; }; // 数据库不了解任何实现细节，并通过其构造函数从外部请求 -\u0026gt; 策略设计模式 Database::Database(std::unique_ptr\u0026lt;DatabaseEngine\u0026gt; engine) : engine_{std::move(engine)} {} 实际的DatabaseEngine类型从外部传入，这使得它成为策略设计模式的一个很好的例子。\n另一方面，如果一个类了解实现细节，但主要想减少对这些细节的物理依赖，则你很可能在处理桥接设计模式。在这种情况下，类不会提供任何机会从外部设置指针，也就是说，指针是一个实现细节并内部设置。由于桥接设计模式主要关注实现细节的物理依赖，而不是逻辑依赖，因此桥接模式属于结构性设计模式类别。例如，考虑以下代码片段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Database { public: explicit Database(); // ... private: std::unique_ptr\u0026lt;DatabaseEngine\u0026gt; pimpl_; }; // 数据库了解所需的实现细节，但不想过于依赖它 -\u0026gt; 桥接设计模式 Database::Database() : pimpl_{std::make_unique\u0026lt;ConcreteDatabaseEngine\u0026gt;(/* 一些参数 */)} {} 再次，桥接设计模式的应用有一个明显的标志：不是接受外部的引擎，而是Database类的构造函数了解ConcreteDatabaseEngine并内部设置它。\n图7-4显示了数据库示例的桥接实现的依赖关系图。最重要的是，Database类与ConcreteDatabaseEngine类处于相同的架构级别，并且不允许其他人提供不同的实现。这表明与策略设计模式相比，桥接在逻辑上耦合到特定实现，但在物理上仅通过DatabaseEngine抽象解耦。\n分析桥接设计模式的不足\n“我完全理解为什么桥接设计模式在社区中如此受欢迎。它的解耦特性真的非常好！”你感叹道。“然而，你一直告诉我每个设计都有其优缺点。我预计会有一些性能损失？”很好，你还记得每个设计都有其缺点。当然，这包括桥接设计模式，尽管它被证明是非常有用的。是的，你的假设是正确的，确实会有一些性能开销。\n桥接设计模式带来的五种开销中的第一种源于这样一个事实：桥接引入了额外的间接层：pimpl指针使得所有对实现细节的访问都变得更加昂贵。然而，这个指针导致的性能损失有多大是一个需要单独讨论的问题（参见“指南 29：注意桥接的性能增益与损失”）。不过，这并不是性能开销的唯一来源；还有更多。取决于你是否使用抽象，你可能还需要支付虚拟函数调用的开销。此外，由于即使是访问数据成员的最简单函数也无法内联，你也需要为此支付更多的成本。当然，每当创建一个新的基于桥接实现的类实例时，你还需要为额外的动态内存分配支付成本。最后但同样重要的是，你还应该考虑到引入 pimpl 指针所带来的内存开销。所以，是的，隔离物理依赖并隐藏实现细节并不是没有代价的，而是会导致相当大的开销。\n尽管如此，这不应该是普遍抛弃桥接解决方案的理由：这总是取决于具体情况。例如，如果底层实现执行缓慢、昂贵的任务（如系统调用），那么这种开销可能根本无法测量。换句话说，是否使用桥接应该根据具体情况决定，并通过性能基准测试来支持。\n此外，你已经看到了实现细节并意识到代码复杂性有所增加。由于代码的简洁性和可读性是一种美德，这应该被视为一个缺点。的确，这仅影响类的内部实现，而不影响用户代码。但是，对于经验较少的开发人员来说，一些细节（例如需要在源文件中定义析构函数）可能会令人困惑。\n总结来说，桥接设计模式是减少物理依赖最有价值和最常用的解决方案之一。尽管如此，你应该意识到桥接引入的开销和复杂性。以下是一些具体的考虑因素：\n性能开销：\n额外的间接层（pimpl指针）使访问实现细节的成本更高。 使用抽象时，可能需要支付虚拟函数调用的开销。 简单函数无法内联，增加了成本。 创建新实例时需要进行额外的动态内存分配。 引入 pimpl 指针带来了内存开销。 代码复杂性：\n实现细节变得更为复杂，虽然这对用户代码的影响较小。 对于经验较少的开发人员来说，某些细节（如在源文件中定义析构函数）可能会造成困惑。 因此，在选择是否使用桥接设计模式时，应权衡其优点和缺点，并根据具体需求进行评估。特别是在性能敏感的应用场景中，建议通过实际的性能基准测试来验证桥接设计模式的实际效果。\n本节总结\n注意由数据成员或包括引入的物理依赖关系。 应用桥接设计模式的目的是将物理依赖与实现细节隔离开来； 建议使用pimpl数据成员进行桥接通信。 了解桥接设计模式的优点和缺点。 了解减少物理依赖（桥接）和减少逻辑依赖（策略）之间的区别。 准则 29：注意桥接的性能增益与损失 在“准则 28：构建桥梁以消除物理依赖”中，我们详细讨论了桥接设计模式。虽然我想象桥接的设计和解耦方面给你留下了积极的印象，但我必须让你意识到使用这种模式可能会引入性能损失。“是的，这让我有些担心。性能对我来说很重要，听起来桥接会带来巨大的性能开销，”你说。这是一个非常普遍的预期。由于性能至关重要，我真的应该给你一个概念，告诉你在使用桥接时需要预期多少开销。然而，我也应该展示如何明智地使用桥接来提高代码的性能。听起来难以置信？让我向你展示如何做到这一点。\n桥接的性能影响\n正如在“准则 28：构建桥梁以消除物理依赖”中讨论的那样，桥接实现的性能受到许多因素的影响：通过间接层访问、虚拟函数调用、内联、动态内存分配等。由于这些因素和可能的组合非常多，无法给出桥接会耗费多少性能的确切答案。没有捷径，也没有替代方法可以代替为自己的代码组装一些基准测试并运行它们以得出确切答案。我想展示的是，确实存在由于间接访问数据成员而带来的性能损失，但你仍然可以使用桥接来实际提高性能。\n让我们从给你一个关于基准测试的概念开始。为了形成对指针间接层成本的看法，我们将比较以下两种 Person 类的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;string\u0026gt; //---- \u0026lt;Person1.h\u0026gt; ---------------- class Person1 { public: // ... private: std::string forename_; std::string surname_; std::string address_; std::string city_; std::string country_; std::string zip_; int year_of_birth_; }; Person1 结构表示一种不基于桥接实现的类型。所有七个数据成员（六个 std::string 和一个 int）都直接属于结构本身。总共而言，并假设是一个64位机器，一个 Person1 实例的大小是152字节（Clang 11.1）或200字节（GCC 11.1）。\n另一方面，Person2 结构是通过Pimpl惯用法实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //---- \u0026lt;Person2.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; class Person2 { public: explicit Person2(/*...各种person参数...*/); ~Person2(); // ... private: struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pimpl_; }; //---- \u0026lt;Person2.cpp\u0026gt; ---------------- #include \u0026lt;Person2.h\u0026gt; #include \u0026lt;string\u0026gt; struct Person2::Impl { std::string forename; std::string surname; std::string address; std::string city; std::string country; std::string zip; int year_of_birth; }; Person2::Person2(/*...各种person参数...*/) : pimpl_{std::make_unique\u0026lt;Impl\u0026gt;(/*...各种person参数...*/)} {} Person2::~Person2() = default; 所有七个数据成员都被移到嵌套的 Impl 结构中，并且只能通过 pimpl 指针访问。虽然嵌套的 Impl 结构的总大小与 Person1 的大小相同，但 Person2 结构的大小仅为8字节（再次假设是64位机器）。\n注意：通过桥接设计，你可以减少类型的大小，有时甚至显著减少。这可以证明非常有价值，例如，如果你想将该类型作为 std::variant 的替代方案（参见“准则 17：考虑使用 std::variant 实现访问者”）。\n因此，让我概述一下基准测试：我将创建两个包含25,000个人的 std::vector，每个 Person 实现一个。这个数量的元素将确保我们在底层CPU的内部缓存之外工作（即，我们将使用总计3.2 MB的内存，Clang 11.1），或者4.2 MB（GCC 11.1）。所有这些人被赋予任意的名字和地址，以及1957年至2004年之间的出生年份（在撰写本文时，这代表了一个组织中员工合理的年龄范围）。然后我们将遍历这两个 Person 向量五千次，并每次使用 std::min_element() 确定最年长的人。结果由于基准测试的重复性而相当无趣。一百次迭代后，你会觉得无聊到不想再看。唯一重要的是看到直接访问数据成员（Person1）和间接访问数据成员（Person2）之间的性能差异。表7-1显示了不同 Person 实现的性能结果，归一化为 Person1 实现的性能。\n表7-1 不同 Person 实现的性能结果（归一化性能）\nPerson 实现 GCC 11.1 Clang 11.1 Person1（无 pimpl） 1.0 1.0 Person2（完整 Pimpl 惯用法） 1.1099 1.1312 很明显，在这个特定的基准测试中，桥接实现带来了相当显著的性能损失：对于GCC是11.0%，对于Clang是13.1%。这听起来很多！然而，不要把这些数字看得太认真：显然，结果严重依赖于实际元素的数量、实际数据成员的数量和类型、运行系统的具体配置以及基准测试中执行的实际计算。\n如果你改变其中任何一个细节，数字也会改变。因此，这些数字仅表明由于间接访问数据成员而导致有一些，甚至是更多的开销。\n使用部分桥接改进性能\n“好吧，但这是一个预期的结果，对吧？我应该从中学习什么？”你问道。我承认这个基准测试非常具体，并不能回答所有问题。然而，它确实为我们提供了一个机会，实际上可以通过桥接来提高性能。如果你仔细观察 Person1 的实现，你可能会意识到对于给定的基准测试，可达到的性能相当有限：尽管 Person1 的总大小是152字节（Clang 11.1）或200字节（GCC 11.1），但我们只使用了4字节，即单个 int，从整个数据结构中。这被证明是非常浪费和低效的：因为在基于缓存的架构中，内存总是按缓存行加载，我们从内存中加载的大部分数据实际上根本没有使用。事实上，几乎我们从内存中加载的所有数据都没有被使用：假设缓存行长度为64字节，我们只使用了大约6%的加载数据。\n因此，尽管我们根据所有人的出生年来确定最年长的人听起来像是一个计算受限的操作，但实际上我们完全受内存限制：机器根本无法足够快地提供数据，整数单元大多数时间处于空闲状态。\n这种设置为我们提供了使用桥接来提高性能的机会。假设我们可以区分经常使用的数据（如名字、姓氏和出生年份）和很少使用的数据（如邮政地址）。基于这种区分，我们现在相应地安排数据成员：所有经常使用的数据成员直接存储在 Person 类中。所有很少使用的数据成员存储在 Impl 结构中。这导致了 Person3 实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //---- \u0026lt;Person3.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; class Person3 { public: explicit Person3(/*...各种person参数...*/); ~Person3(); // ... private: std::string forename_; std::string surname_; int year_of_birth_; struct Impl; std::unique_ptr\u0026lt;Impl\u0026gt; pimpl_; }; //---- \u0026lt;Person3.cpp\u0026gt; ---------------- #include \u0026lt;Person3.h\u0026gt; struct Person3::Impl { std::string address; std::string city; std::string country; std::string zip; }; Person3::Person3(/*...各种person参数...*/) : forename_{/*...*/} , surname_{/*...*/} , year_of_birth_{/*...*/} , pimpl_{std::make_unique\u0026lt;Impl\u0026gt;(/*...address相关的参数...*/)} {} Person3::~Person3() = default; 一个 Person3 实例的总大小为64字节（Clang 11.1，两个24字节的 std::string，一个整数，一个指针，以及由于对齐要求的四个填充字节）或80字节（GCC 11.1，两个32字节的 std::string，一个整数，一个指针，以及一些填充）。因此，Person3 实例只有 Person1 实例的一半大小。这种大小上的差异是可以测量的：表7-2显示了所有 Person 实现的性能结果，包括 Person3。同样，结果归一化为 Person1 实现的性能。\n表7-2 不同 Person 实现的性能结果（归一化性能）\nPerson 实现 GCC 11.1 Clang 11.1 Person1（无 pimpl） 1.0 1.0 Person2（完整 Pimpl 惯用法） 1.1099 1.1312 Person3（部分 Pimpl 惯用法） 0.8597 0.9353 与 Person1 实现相比，Person3 的性能提高了14.0%（GCC 11.1）和6.5%（Clang 11.1）。而且，如前所述，这只是因为我们减少了 Person3 实现的大小。“哇，这是出乎意料的。我明白了，桥接不一定总是对性能有害，”你说。是的，确实如此。当然，这总是取决于具体的设置，但区分经常使用和很少使用的数据成员并通过实现“部分”桥接来减少数据结构的大小，可能会对性能产生非常积极的影响。\n“性能提升很大，这很好，但这不是违背了桥接的初衷吗？”你问道。确实，你意识到隐藏实现细节和为了性能“内联”数据成员之间存在二元对立。如常，这取决于具体情况：你需要逐案决定要优先考虑哪一方面。你也意识到在两个极端之间有一系列完整的解决方案：没有必要将所有数据成员都隐藏在桥接后面。最终，你才是找到给定问题最优解的人。\n总之，尽管桥接通常会导致一定的性能损失，但在适当的情况下，实现部分桥接可能会对性能产生非常积极的影响。然而，这只是影响性能的众多因素之一。因此，你应该始终检查桥接是否会导致性能瓶颈，或者部分桥接是否能解决性能问题。最好的验证方法是基于实际代码和尽可能多的实际数据进行有代表性的基准测试。\n本节总结\n请记住，桥接可能会对性能产生负面影响。 需要注意的是，当分离常用数据和不常用数据时，部分桥接可能对性能有正面影响。 始终通过有代表性的基准测试来确认性能瓶颈或改进；不要依赖你的直觉。 准则 30：应用原型模式进行抽象复制操作 想象一下你坐在一家高档的意大利餐厅里，正在研究菜单。哦，天哪，他们提供了这么多美味的东西；千层面听起来很棒。但他们提供的比萨选择也很棒。真是难以选择……然而，你的思绪被打断了，因为服务员端着一道看起来非常诱人的菜肴走过。不幸的是，那道菜不是为你准备的，而是为另一桌客人准备的。哦，哇，那香味……在这一刻，你知道不再需要考虑你想吃什么了：无论是什么，你都要点同样的菜。“啊，服务员，我想要他们点的那道菜。”\n同样的问题也可能出现在你的代码中。用C++术语来说，你向服务员请求的是别人盘子里菜肴的副本。复制一个对象，即创建实例的精确副本，是C++中一项基本重要的操作。如此重要以至于类默认配备了拷贝构造函数和拷贝赋值运算符——这是所谓的“特殊成员函数”中的两个。然而，在请求一份菜肴的副本时，不幸的是你并不知道具体是什么菜肴。用C++术语来说，你只有一个指向基类的指针（比如说，一个 Dish*）。不幸的是，尝试通过 Dish* 使用拷贝构造函数或拷贝赋值运算符通常不起作用。尽管如此，你仍然想要一个精确的副本。这个问题的解决方案是另一个经典的GoF设计模式：原型设计模式。\n一个关于复制动物的例子：绵羊\n作为一个例子，让我们考虑以下 Animal 基类：\n1 2 3 4 5 6 7 8 //---- \u0026lt;Animal.h\u0026gt; ---------------- class Animal { public: virtual ~Animal() = default; virtual void makeSound() const = 0; // ... 更多与动物相关的函数 }; 除了表示 Animal 应该是一个基类的虚析构函数外，类只提供了一个处理打印可爱动物声音的 makeSound() 函数。一个这样的动物示例是 Sheep 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //---- \u0026lt;Sheep.h\u0026gt; ---------------- #include \u0026lt;Animal.h\u0026gt; #include \u0026lt;string\u0026gt; class Sheep : public Animal { public: explicit Sheep(std::string name) : name_{std::move(name)} {} void makeSound() const override; // ... 更多与动物相关的函数 private: std::string name_; }; //---- \u0026lt;Sheep.cpp\u0026gt; ---------------- #include \u0026lt;Sheep.h\u0026gt; #include \u0026lt;iostream\u0026gt; void Sheep::makeSound() const { std::cout \u0026lt;\u0026lt; \u0026#34;baa\\n\u0026#34;; } 在 main() 函数中，我们现在可以创建一只绵羊并让它发出声音：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;Sheep.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory\u0026gt; int main() { // 创建唯一的 Dolly std::unique_ptr\u0026lt;Animal\u0026gt; const dolly = std::make_unique\u0026lt;Sheep\u0026gt;(\u0026#34;Dolly\u0026#34;); // 触发 Dolly 的叫声 dolly-\u0026gt;makeSound(); return EXIT_SUCCESS; } Dolly 很棒，对吧？而且非常可爱！事实上，她非常有趣，我们希望再有一个 Dolly。然而，我们只有一个指向基类的指针——一个 Animal*。我们不能通过 Sheep 的拷贝构造函数或拷贝赋值运算符来复制它，因为我们（技术上）甚至不知道我们正在处理的是一只 Sheep。它可以是任何种类的动物（例如狗、猫、绵羊等）。我们也不想只复制 Sheep 的 Animal 部分，因为这被称为切片。哦，我的天，我刚刚意识到这个例子可能特别不适合解释原型设计模式。分割动物听起来很糟糕。所以让我们迅速继续。我们在哪儿？啊，是的，我们想要一个 Dolly 的副本，但我们只有一个 Animal*。这时原型设计模式就派上用场了。\n原型设计模式解释\n原型设计模式是由四人组收集的五种创建型设计模式之一。它专注于提供一种创建某些抽象实体副本的抽象方式。\n意图：“指定要创建的对象种类，使用一个原型实例，并通过复制这个原型创建新的对象。”\n原型设计模式通常通过基类中的 virutal clone() 函数实现。考虑更新后的 Animal 基类：\n1 2 3 4 5 6 7 8 //---- \u0026lt;Animal.h\u0026gt; ---------------- class Animal { public: virtual ~Animal() = default; virtual void makeSound() const = 0; virtual std::unique_ptr\u0026lt;Animal\u0026gt; clone() const = 0; // 原型设计模式 }; 通过这个 clone() 函数，任何人都可以请求给定（原型）动物的抽象副本，而无需了解任何特定类型的动物（如 Dog、Cat 或 Sheep）。当 Animal 基类正确分配到架构的高层时，它遵循依赖倒置原则。\nclone() 函数被声明为纯虚函数，这意味着派生类必须实现它。但是，派生类不能随意实现该函数，而是应该返回自身的精确副本（任何其他结果都会违反LSP；参见“准则 6：遵守抽象的预期行为”）。这个副本通常是通过 new 动态创建并通过指向基类的指针返回的。当然，这不仅导致了一个指针，还需要显式地删除副本。由于手动清理在现代C++中被认为是不好的做法，指针以 std::unique_ptr 到 Animal 的形式返回。\nSheep 类相应地进行了更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //---- \u0026lt;Sheep.h\u0026gt; ---------------- #include \u0026lt;Animal.h\u0026gt; class Sheep : public Animal { public: explicit Sheep(std::string name) : name_{std::move(name)} {} void makeSound() const override; std::unique_ptr\u0026lt;Animal\u0026gt; clone() const override; // 原型设计模式 private: std::string name_; }; //---- \u0026lt;Sheep.cpp\u0026gt; ---------------- #include \u0026lt;Sheep.h\u0026gt; #include \u0026lt;iostream\u0026gt; void Sheep::makeSound() const { std::cout \u0026lt;\u0026lt; \u0026#34;baa\\n\u0026#34;; } std::unique_ptr\u0026lt;Animal\u0026gt; Sheep::clone() const { return std::make_unique\u0026lt;Sheep\u0026gt;(*this); // 复制构造一只绵羊 } 现在 Sheep 类必须实现 clone() 函数并返回其自身的精确副本：在其自己的 clone() 函数内部，它使用 std::make_unique() 函数及其自己的拷贝构造函数，即使 Sheep 类在未来发生变化，也总是假定会做正确的事情。这种方法有助于避免不必要的重复，从而遵循DRY原则（参见“指南 2：设计变化”）。\n请注意，Sheep 类既没有删除也没有隐藏其拷贝构造函数和拷贝赋值运算符。因此，如果你有一只绵羊，你仍然可以通过特殊成员函数复制这只绵羊。这是完全可以的：clone() 仅增加了一种创建副本的方式——一种执行虚拟复制的方式。\n准则 31：使用外部多态实现非侵入式运行时多态 在“准则 2：设计变化”中，我们看到了关注点分离设计原则的巨大优势。在“准则 19：使用策略隔离事物的执行方式”中，我们利用这种力量通过策略设计模式从一组形状中提取绘图实现细节。\n然而，尽管这显著减少了依赖关系，并且我们在“准则 23：优先使用基于值的策略和命令实现”中借助 std::function 现代化了解决方案，但仍然存在一些缺点。特别是，形状类仍然不得不处理 draw() 操作，虽然出于耦合的原因，处理实现细节是不可取的。\n此外，也是最重要的一点，策略方法在提取多个多态操作时显得有些不切实际。为了进一步减少耦合并从我们的形状中提取多态操作，我们将继续这一旅程，并将关注点分离原则提升到一个全新的、可能不熟悉的水平：我们将完全分离多态行为。为此，我们将应用外部多态设计模式。\n外部多态设计模式解释\n让我们回到绘制形状的例子和我们在“准则 23：优先使用基于值的策略和命令实现”中的最新版 Circle 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: virtual ~Shape() = default; virtual void draw(/* some arguments */) const = 0; }; //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;utility\u0026gt; class Circle : public Shape { public: using DrawStrategy = std::function\u0026lt;void(Circle const\u0026amp;, /*...*/)\u0026gt;; explicit Circle(double radius, DrawStrategy drawer) : radius_(radius), drawer_(std::move(drawer)) { /* 检查给定的半径是否有效且给定的 \u0026#39;std::function\u0026#39; 实例不为空 */ } void draw(/* some arguments */) const override { drawer_(*this, /* some arguments */); } double radius() const { return radius_; } private: double radius_; DrawStrategy drawer_; }; 通过策略设计模式，我们克服了最初对 draw() 成员函数实现细节的强耦合（）。我们也找到了一个基于 std::function 的值语义解决方案（）。然而，draw() 成员函数仍然是所有从 Shape 基类派生的类的公共接口的一部分，所有的形状都继承了实现它的义务（）。这是一个明显的缺陷：可以说，绘制功能应该是独立的，是形状的一个孤立方面，而形状本身不应该知道它们可以被绘制的事实。我们已经提取了实现细节这一事实进一步加强了这一论点。\n“那么，让我们直接提取 draw() 成员函数，对吧？”你争辩道。你是对的。不幸的是，乍一看这似乎是一件很难做到的事情。我希望你还记得“指南 15：为类型或操作的添加进行设计”，在那里我们得出结论，当你主要想添加类型时，你应该优先选择面向对象的解决方案。从这个角度来看，我们似乎被虚拟的 draw() 函数和表示所有形状可用操作集的 Shape 基类所困，即需求列表。\n不过，有一个解决方案。一个相当令人惊讶的方案：我们可以使用外部多态设计模式来提取完整的多态行为。该模式由 Chris Cleeland、Douglas C. Schmidt 和 Timothy H. Harrison 在 1996 年的一篇论文中引入。其意图是使非多态类型（没有单个虚拟函数的类型）能够以多态方式处理。\n外部多态设计模式\n意图：“允许不相关且没有虚拟方法的 C++ 类以多态方式处理。这些不相关的类可以通过使用它们的软件以统一的方式处理。”\n首先引人注目的是，不再有 Shape 基类。在外部多态设计模式中，不同种类的形状（如 Circle、Square 等）被认为是简单的、非多态类型。此外，形状不需要知道任何关于绘制的信息。设计模式不是要求形状继承自 Shape 基类，而是引入了一个独立的继承层次结构，形式上表现为 ShapeConcept 和 ShapeModel 类。这种外部层次结构通过引入所有期望的形状操作和要求来为形状引入多态行为。\n在我们的简单例子中，多态行为仅包含 draw() 函数。然而，当然，需求集合可以更大（例如 rotate()、serialize() 等）。这一组虚拟函数已被移到抽象的 ShapeConcept 类中，现在它取代了之前的 Shape 基类。主要的区别在于具体形状不需要了解 ShapeConcept，特别是不需要继承它。因此，形状完全解耦于虚拟函数集。唯一继承自 ShapeConcept 的类是 ShapeModel 类模板。这个类为特定类型的形状（如 Circle、Square 等）实例化，并作为其包装器。然而，ShapeModel 不会自己实现虚拟函数的逻辑，而是将请求委托给所需的实现。\n“哇，太棒了！我明白了：这个外部层次结构提取了整个虚拟函数集，从而提取了形状的所有多态行为。” 是的，正是如此。再次强调，这是关注点分离和单一职责原则（SRP）的一个例子。在这种情况下，完整的多态行为被识别为变化点并从形状中提取出来。而且，SRP 作为开闭原则（OCP）的推动者：有了 ShapeModel 类模板，你可以轻松地将任何新的非多态形状类型添加到 ShapeConcept 层次结构中。只要新类型满足所有所需的操作，这就可以工作。\n“我真的很印象深刻。然而，我不确定你所说的‘满足所有所需的操作’是什么意思。你能详细说明一下吗？”\n当然可以！我认为当展示具体的代码示例时，好处会变得清晰。因此，让我们用外部多态设计模式重构完整的形状绘制示例。\n具体代码示例\n首先，我们需要定义 ShapeConcept 和 ShapeModel 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //---- \u0026lt;ShapeConcept.h\u0026gt; ---------------- class ShapeConcept { public: virtual ~ShapeConcept() = default; virtual void draw(/* some arguments */) const = 0; }; //---- \u0026lt;ShapeModel.h\u0026gt; ---------------- #include \u0026lt;ShapeConcept.h\u0026gt; template\u0026lt;typename ShapeType\u0026gt; class ShapeModel : public ShapeConcept { public: explicit ShapeModel(ShapeType shape) : shape_(std::move(shape)) { } void draw(/* some arguments */) const override { // 这里调用实际的绘制逻辑 shape_.draw(/* some arguments */); } private: ShapeType shape_; }; 然后，我们修改 Circle 类，使其不继承自 Shape，并且只包含绘制逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //---- \u0026lt;Circle.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;utility\u0026gt; class Circle { public: explicit Circle(double radius) : radius_(radius) { /* 检查给定的半径是否有效 */ } void draw(/* some arguments */) const { // 绘制逻辑 std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle with radius \u0026#34; \u0026lt;\u0026lt; radius_ \u0026lt;\u0026lt; std::endl; } double radius() const { return radius_; } private: double radius_; }; 最后，在主程序中，我们可以创建 ShapeModel 的实例并使用它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;ShapeModel.h\u0026#34; #include \u0026#34;Circle.h\u0026#34; int main() { std::vector\u0026lt;std::unique_ptr\u0026lt;ShapeConcept\u0026gt;\u0026gt; shapes; // 创建一个 Circle 对象并将其包装在 ShapeModel 中 Circle circle(10.0); auto circleModel = std::make_unique\u0026lt;ShapeModel\u0026lt;Circle\u0026gt;\u0026gt;(circle); shapes.push_back(std::move(circleModel)); // 调用绘制函数 for (const auto\u0026amp; shape : shapes) { shape-\u0026gt;draw(/* some arguments */); } return 0; } 通过这种方式，我们可以将绘制逻辑与形状的具体实现解耦，并允许灵活地添加新的形状类型，而无需修改现有的代码。\n形状绘制再探讨\n让我们从 Circle 和 Square 类开始：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //---- \u0026lt;Circle.h\u0026gt; ---------------- class Circle { public: explicit Circle(double radius) : radius_(radius) { /* 检查给定的半径是否有效 */ } double radius() const { return radius_; } /* 更多获取器和与圆相关的实用函数 */ private: double radius_; /* 更多数据成员 */ }; //---- \u0026lt;Square.h\u0026gt; ---------------- class Square { public: explicit Square(double side) : side_(side) { /* 检查给定的边长是否有效 */ } double side() const { return side_; } /* 更多获取器和与正方形相关的实用函数 */ private: double side_; /* 更多数据成员 */ }; 这两个类已经被简化为基本的几何实体。它们完全是非多态的，即不再有基类且没有虚拟函数。最重要的是，这两个类完全不知道任何可能引入人工依赖的操作，如绘制、旋转、序列化等。\n相反，所有这些功能都在 ShapeConcept 基类中引入，并由 ShapeModel 类模板实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;functional\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;utility\u0026gt; class ShapeConcept { public: virtual ~ShapeConcept() = default; virtual void draw() const = 0; // ... 可能更多的多态操作 }; template\u0026lt;typename ShapeT\u0026gt; class ShapeModel : public ShapeConcept { public: using DrawStrategy = std::function\u0026lt;void(ShapeT const\u0026amp;)\u0026gt;; explicit ShapeModel(ShapeT shape, DrawStrategy drawer) : shape_{std::move(shape)}, drawer_{std::move(drawer)} { /* 检查给定的 \u0026#39;std::function\u0026#39; 不为空 */ } void draw() const override { drawer_(shape_); } // ... 可能更多的多态操作 private: ShapeT shape_; // 组合而非继承（记住“指南 20：优先使用组合而非继承”） DrawStrategy drawer_; }; ShapeConcept 类引入了一个纯虚函数 draw()（）。在我们的例子中，这个唯一的虚拟函数代表了形状的所有要求集。尽管集合很小，但 ShapeConcept 类代表了一种经典的抽象，符合里氏替换原则（LSP）（见“指南 6：遵守抽象的预期行为”）。这种抽象在 ShapeModel 类模板中实现（）。值得注意的是，ShapeModel 的实例是唯一继承自 ShapeConcept 的类；不期望其他类进入这种关系。ShapeModel 类模板将为每种所需的形状类型实例化，即 ShapeT 模板参数可以是 Circle、Square 等类型。请注意，ShapeModel 存储了相应形状的一个实例（），它作为一个包装器，通过所需的多态行为（在我们的情况下是 draw() 函数）增强特定形状类型。\n由于 ShapeModel 实现了 ShapeConcept 抽象，因此需要提供 draw() 函数的实现。然而，实现 draw() 细节的责任并不在于 ShapeModel 自身。相反，它应该将绘制请求转发到实际的实现。为此，我们可以再次使用策略设计模式和 std::function 的抽象能力（）。这一选择很好地解耦了绘制的实现细节和所有必要的绘制数据（颜色、纹理、透明度等），这些数据可以存储在可调用对象中。因此，ShapeModel 存储了一个 DrawStrategy 实例（），并在触发 draw() 函数时使用该策略（）。\n尽管如此，策略设计模式和 std::function 并不是唯一的选择。在 ShapeModel 类模板内，你可以完全灵活地按自己的方式实现绘制。换句话说，在 ShapeModel::draw() 函数中，你定义了特定形状类型的真正需求。例如，你可以选择转发到 ShapeT 形状的成员函数（不必命名为 draw()！），或者转发到形状的自由函数。只需确保不要对 ShapeModel 或 ShapeConcept 抽象施加人为的要求。无论哪种方式，用于实例化 ShapeModel 的任何类型都必须满足这些要求才能使代码编译。\n“ShapeModel 是否是对最初的 Circle 和 Square 类的一种泛化？那些也持有 std::function 实例的类？” 是的，这是一个很好的认识。实际上，可以说 ShapeModel 是初始形状类的模板版本。因此，它有助于减少引入策略行为所需的样板代码，并根据 DRY 原则改进实现（见“指南 2：设计变化”）。然而，你获得的好处更多：例如，由于 ShapeModel 已经是一个类模板，你可以轻松地从当前的运行时策略实现切换到编译时策略实现（即基于策略的设计；见“指南 19：使用策略隔离事物的执行方式”）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt; typename ShapeT, typename DrawStrategy \u0026gt; class ShapeModel : public ShapeConcept { public: explicit ShapeModel(ShapeT shape, DrawStrategy drawer) : shape_{std::move(shape)}, drawer_{std::move(drawer)} {} void draw() const override { drawer_(shape_); } private: ShapeT shape_; DrawStrategy drawer_; }; 除了基于 std::function，你还可以向 ShapeModel 类模板传递一个额外的模板参数，表示绘制策略（）。这个模板参数甚至可以有一个默认值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct DefaultDrawer { template\u0026lt; typename T \u0026gt; void operator()( T const\u0026amp; obj ) const { draw(obj); } }; template\u0026lt; typename ShapeT, typename DrawStrategy = DefaultDrawer \u0026gt; class ShapeModel : public ShapeConcept { public: explicit ShapeModel(ShapeT shape, DrawStrategy drawer = DefaultDrawer{}) // ... 如前所述 }; 与直接对 Circle 和 Square 类应用基于策略的设计相比，这种编译时方法在此上下文中只有好处而没有缺点。首先，由于减少了运行时间接调用（std::function 的预期性能劣势），你获得了性能提升。其次，你不需要通过添加模板参数来人为地扩充 Circle、Square 和所有其他形状类以配置绘制行为。你现在只需要为包装器这样做，这会增强绘制行为，并且只在一个地方完成（这再次很好地遵循了 DRY 原则）。第三，你不需要通过将常规类转换为类模板而在头文件中增加额外的代码。只有已经作为类模板的精简版 ShapeModel 需要驻留在头文件中。因此，你避免了创建额外的依赖关系。\n“哇，这个设计模式越来越好了。这真是继承和模板的强大结合！” 是的，我完全同意。这是结合运行时和编译时多态的一个范例：ShapeConcept 基类为所有可能的类型提供了抽象，而派生的 ShapeModel 类模板为特定形状代码提供了代码生成。最令人印象深刻的是，这种结合带来了巨大的优势，减少了依赖关系。\n看看图7-8，它展示了我们实现外部多态设计模式的依赖关系图。在架构的最高层次上是 ShapeConcept 和 ShapeModel 类，它们共同代表了形状的抽象。Circle 和 Square 是这种抽象的可能实现，但仍然完全独立：没有继承关系，没有组合，什么都没有。只有为特定类型的形状和特定的 DrawStrategy 实现实例化 ShapeModel 类模板时，才会将所有方面结合起来。然而，请特别注意，所有这一切都发生在我们架构的最低层：模板代码在所有依赖关系已知的地方生成，并“注入”到我们架构的正确层级。因此，我们确实拥有一个适当的架构：所有依赖关系连接都朝着更高的层级运行，并几乎自动遵循依赖倒置原则（DIP）。\n功能实现后，我们可以自由实现任何所需的绘制行为\n例如，我们可以再次使用OpenGL：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //---- \u0026lt;OpenGLDrawStrategy.h\u0026gt; ---------------- #include \u0026lt;Circle\u0026gt; #include \u0026lt;Square\u0026gt; #include /* OpenGL 图形库头文件 */ class OpenGLDrawStrategy { public: explicit OpenGLDrawStrategy(/* 与绘制相关的参数 */); void operator()(Circle const\u0026amp; circle) const; void operator()(Square const\u0026amp; square) const; private: /* 与绘制相关的数据成员，如颜色、纹理等 */ }; 由于 OpenGLDrawStrategy 不需要继承自任何基类，你可以自由地按需实现它。如果愿意，你可以将绘制圆和绘制正方形的实现合并到一个类中。这不会创建任何人为的依赖关系，类似于我们在“指南 19：使用策略隔离事物的执行方式”中所经历的，我们将这些功能合并到了基类中。\n注意\n将绘制圆和正方形结合在一个类中表示的内容与从两个策略基类继承类是相同的。在架构的这一层面上，这不会创建任何人为的依赖关系，仅是一个实现细节。唯一需要遵循的约定是为 Circle 和 Square 提供函数调用运算符（），因为这是 ShapeModel 类模板中定义的调用约定。\n在 main() 函数中，我们将所有细节组合在一起：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;OpenGLDrawStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; int main() { using Shapes = std::vector\u0026lt;std::unique_ptr\u0026lt;ShapeConcept\u0026gt;\u0026gt;; using CircleModel = ShapeModel\u0026lt;Circle, OpenGLDrawStrategy\u0026gt;; using SquareModel = ShapeModel\u0026lt;Square, OpenGLDrawStrategy\u0026gt;; Shapes shapes{}; // 创建一些形状，每个都配备了OpenGL绘制策略 shapes.emplace_back( std::make_unique\u0026lt;CircleModel\u0026gt;( Circle{2.3}, OpenGLDrawStrategy(/*...红色...*/) ) ); shapes.emplace_back( std::make_unique\u0026lt;SquareModel\u0026gt;( Square{1.2}, OpenGLDrawStrategy(/*...绿色...*/) ) ); shapes.emplace_back( std::make_unique\u0026lt;CircleModel\u0026gt;( Circle{4.1}, OpenGLDrawStrategy(/*...蓝色...*/) ) ); // 绘制所有形状 for (auto const\u0026amp; shape : shapes) { shape-\u0026gt;draw(); } return EXIT_SUCCESS; } 同样，我们首先创建一个空的形状向量（这次是 std::unique_ptr\u0026lt;ShapeConcept\u0026gt; 的向量）（），然后添加三个形状。在调用 std::make_unique() 时，我们实例化了 ShapeModel 类用于 Circle 和 Square（称为 CircleModel 和 SquareModel 以提高可读性），并传递了必要的细节（具体的形状和相应的 OpenGLDrawStrategy）。之后，我们能够以所需的方式绘制所有形状。\n总体而言，这种方法提供了许多显著的优点：\n关注点分离和从形状类型中提取多态行为：消除了对图形库等的所有依赖，创建了非常松散的耦合，并且很好地遵循了单一职责原则（SRP）。 形状类型变得更简单且非多态：可以轻松添加新的形状类型，甚至可能是第三方类型，因为你不再需要侵入式地继承自 Shape 基类或创建适配器（见“指南 24：使用适配器标准化接口”）。因此，完美地遵循了开闭原则（OCP）。 显著减少通常与继承相关的样板代码：只需在一个地方实现，这很好地遵循了DRY原则。 由于 ShapeConcept 和 ShapeModel 类属于一起并且共同形成抽象，更容易遵循依赖倒置原则（DIP）。 通过利用可用的类模板减少间接调用的数量，可以提高性能。 此外，外部多态设计模式还有一个更为令人印象深刻的优势：你可以非侵入式地为任何类型配备多态行为。真的，任何类型，甚至是像 int 这样简单的类型。为了演示这一点，让我们看一下以下代码片段，假设 ShapeModel 配备了一个默认绘制器（DefaultDrawer），该绘制器期望被包装的类型提供一个自由的 draw() 函数：\n1 2 3 4 5 6 7 8 9 10 11 int draw(int i) { // ... 绘制一个整数，例如将其打印到命令行 } int main() { auto shape = std::make_unique\u0026lt;ShapeModel\u0026lt;int\u0026gt;\u0026gt;(42); shape-\u0026gt;draw(); // 绘制整数 return EXIT_SUCCESS; } 首先，我们为 int 提供了一个自由的 draw() 函数（）。在 main() 函数中，我们现在实例化了一个 ShapeModel 用于 int。这一行会编译，因为 int 满足所有要求：它提供了一个自由的 draw() 函数。因此，在下一行我们可以“绘制”这个整数。\n“你真的希望我这样做吗？”你皱着眉头问道。不，我不建议你在实际项目中这样做。请将此视为技术演示，而不是推荐做法。但是尽管如此，这确实令人印象深刻：我们刚刚非侵入式地为一个 int 配备了多态行为。确实令人印象深刻！\n外部多态与适配器的比较\n“既然你提到适配器设计模式，我觉得它与外部多态设计模式非常相似。这两者之间有什么区别？” 很好的问题！你提出了原始论文中Cleeland、Schmidt和Harrison也讨论过的问题。是的，这两种设计模式确实非常相似，但有一个非常明显的区别：虽然适配器设计模式专注于标准化接口，并使类型或函数适应现有的接口，但外部多态设计模式创建一个新的外部层次结构，从一组相关的非多态类型中进行抽象。所以，如果你将某些东西适应现有接口，则（很可能）应用的是适配器设计模式。然而，如果你为了以多态方式处理一组现有类型而创建一个新的抽象，则（最有可能）应用的是外部多态设计模式。\n分析外部多态设计模式的不足\n“我感觉你非常喜欢外部多态设计模式，对吗？”你可能会这么想。是的，确实如此，我对这种设计模式感到非常惊讶。在我看来，这种设计模式是实现松耦合的关键，遗憾的是它并不广为人知。也许是因为许多开发者并没有完全接受关注点分离的原则，并倾向于将所有内容都放入少数几个类中。尽管我对外部多态充满热情，但我不想给人留下这种设计模式完美无缺的印象。不，正如多次提到的，每个设计都有其优点和缺点，外部多态设计模式也不例外。\n外部多态设计模式的主要不足在于它并没有真正满足简洁和简单解决方案的期望，尤其是基于值语义的解决方案。它不会减少指针的使用，不会减少手动分配的数量，也不会降低继承层次结构的数量，更不会简化用户代码。相反，由于需要显式地实例化 ShapeModel 类，用户代码会显得稍微复杂一些。然而，如果你认为这是一个严重的缺点，或者你在想“这应该以某种方式自动化”，那么我有一个好消息：在“指南 32：考虑用类型擦除替代继承层次结构”中，我们将探讨一种现代 C++ 解决方案，它可以优雅地解决这个问题。\n除此之外，我还想提醒两点需要注意的地方：\n适当的抽象：外部多态的应用并不会免除你思考适当抽象的责任。ShapeConcept 基类同样要遵循接口隔离原则（ISP）。\n例如，我们可以很容易地将外部多态应用到“指南 3：通过分离接口避免人为耦合”中的 Document 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class DocumentConcept { public: virtual ~Document() = default; virtual void exportToJSON(/*...*/) const = 0; virtual void serialize(ByteStream\u0026amp; bs, /*...*/) const = 0; }; template\u0026lt;typename DocumentT\u0026gt; class DocumentModel { public: void exportToJSON(/*...*/) const override; void serialize(ByteStream\u0026amp; bs, /*...*/) const override; private: DocumentT document_; }; DocumentConcept 类扮演了 ShapeConcept 基类的角色，而 DocumentModel 类模板则扮演了 ShapeModel 类模板的角色。然而，这个外部化的层次结构与原始层次结构存在同样的问题：对于只需要 exportToJSON() 功能的所有代码来说，它引入了对 ByteStream 的人为依赖。正确的做法是通过将接口分离为 JSON 导出和序列化这两个正交方面来分离关注点。\n语义一致性：\n外部多态，就像适配器设计模式一样，使得包装那些不符合语义预期的类型变得非常容易。类似于“指南 24：使用适配器标准化接口”中的鸭子类型示例，我们假装火鸡是一只鸭子，我们也假装 int 是一个形状。为了满足要求，我们所要做的就是提供一个自由的 draw() 函数。虽然这很简单，但可能过于简单。\n因此，请记住用于实例化 ShapeModel 类模板的类（如 Circle、Square 等）必须遵守里氏替换原则（LSP）。毕竟，ShapeModel 类只是一个包装器，并将 ShapeConcept 类定义的要求传递给具体的形状。\n因此，具体的形状负责正确实现预期的行为。任何未能完全满足这些期望的情况都可能导致（潜在的微妙）行为异常。不幸的是，由于这些要求已经被外部化，沟通预期行为变得更加困难。\n然而，在 int 示例中，可能是我们自己选择的抽象有问题。或许 ShapeConcept 基类并不能很好地代表形状的抽象。合理地说，形状不仅仅是绘制。也许我们应该将抽象命名为 Drawable，这样 LSP 就会被满足。也许不是。最终，一切都归结于抽象的选择。这让我们回到第 2 章的主题：“构建抽象的艺术”。这并不容易，但也许这些例子表明它是重要的，非常重要。这可能是软件设计的本质。\n总之，尽管外部多态设计模式可能无法满足你对简单或基于值的解决方案的期望，但它仍然是实现软件实体解耦的重要一步。从减少依赖的角度来看，这种设计模式似乎是松耦合的关键成分，并且是关注点分离力量的一个绝佳示例。\n它还给我们一个重要启示：使用这种设计模式，你可以非侵入式地为任何类型配备多态行为（例如虚拟函数），从而使任何类型都可以表现得多态，甚至是一个简单的值类型如 int。这一认识开启了一个全新的、令人兴奋的设计空间，我们将在下一章继续探索。\n本节总结\n应用外部多态设计模式的目的是支持对非多态类型的多态处理。 将外部多态性设计模式视为实现松耦合的关键。 利用外部化继承层次结构的设计灵活性。 理解外部多态和适配器之间的区别。 选择非侵入性解决方案而不是侵入性解决方案。 第八章 类型擦除设计模式 关注点分离和值语义是我在本书中多次提到的两个核心要点。\n在本章中，这两者被巧妙地结合进了一个最有趣的现代C++设计模式之一：类型擦除。\n鉴于这一模式可被视为当前最为热门的话题之一，在本章中我将为你提供一个非常全面、深入的介绍，涵盖类型擦除的所有方面。当然，这包括所有与设计相关的方面以及大量关于实现细节的具体信息。\n在 “准则32：考虑用类型擦除替代继承层次结构”中，我会向你介绍类型擦除，并让你了解为何这种设计模式是依赖性减少和值语义如此出色的结合。我还会带你走过一个基本的拥有类型的类型擦除实现过程。\n“准则33：注意类型擦除的优化潜力”是一个例外：尽管在这本书中我主要关注的是依赖性和设计方面，但在这一条指南中，我将完全专注于与性能相关的实现细节。我会展示如何应用小缓冲区优化(SBO)以及如何实现手动虚拟分派来加速你的类型擦除实现。\n在“准则34：注意拥有类型擦除包装器的设置成本”部分，我们将探讨拥有类型擦除实现的设置成本。我们会发现，值语义伴随有一个成本，有时我们可能不愿意支付这个成本。\n基于此原因，我们敢于踏入引用语义领域，实现一种非拥有的类型擦除形式。通过这些讨论，我们可以更深刻地理解类型擦除模式在现代C++编程中的重要性和实际应用价值。\n准则32：考虑用类型擦除替代继承层次结构 本书中反复提到的几条建议包括：\n最小化依赖。 分离关注点。 优先组合而非继承。 优先非侵入式解决方案。 优先值语义而非引用语义。 单独使用这些指导原则，它们对代码质量有非常积极的影响。然而，结合起来使用，这些指南证明更加有效。\n在讨论“准则31：使用外部多态实现非侵入式运行时多态性”中的外部多态设计模式时，你已经体验过这一点。\n提取多态行为被证明是非常强大的，并解锁了前所未有的松耦合水平。然而，令人失望的是，演示的外部多态实现并没有给你一种非常现代的解决问题的方式。\n该实现基于引用语义（许多指针、手动分配和手动生命周期管理），而不是遵循偏好值语义的建议。\n因此，你期待的缺失细节是基于值语义的外部多态设计模式实现。而这个解决方案通常被称为类型擦除。\n类型擦除的历史\n在详细介绍之前，让我们快速回顾一下类型擦除的历史。“得了吧”，你可能会说，“这真的有必要吗？我迫不及待地想看到它是如何工作的。”\n好吧，我保证简短说明。但确实，我认为这是讨论中必要的细节，有两个原因：首先，展示我们作为社区，除了最有经验的C++专家之外，可能忽视了这项技术太久；其次，给予这项技术发明者应有的认可。\n类型擦除设计模式常归功于最早也是最著名的介绍这一技术之一的演讲，\n在2013年的GoingNative大会上，Sean Parent做了题为《继承是邪恶的基础类》的演讲，他回顾了Photoshop开发的经验，并讨论了基于继承实现的危险性和缺点。\n他还提出了一种解决继承问题的方法，后来被称为类型擦除。\n尽管Sean的演讲可能是最早的记录之一，也因此可能是关于类型擦除最知名的资源，但在那之前这种技术已经被使用了很长时间。\n例如，类型擦除被用于Boost库中的多个地方，比如Douglas Gregor为boost::function所做的工作。\n然而，据我所知，这项技术最早是在Kevlin Henney于2000年7月至8月版的《C++ Report》上发表的一篇论文中讨论的。\n在这篇论文中，Kevlin通过一个代码示例展示了类型擦除，该示例后来演变成了我们现在所知的C++17的std::any。\n最重要的是，他是第一个优雅地结合几种设计模式来围绕一组无关的、非多态类型形成基于值语义实现的人。\n自那时以来，许多常见的类型采用了这种技术，为各种应用提供了值类型。其中一些类型甚至进入了标准库。例如，我们已经看到了代表可调用对象值抽象的std::function，以及我提到过的代表几乎任何东西的抽象容器值（因此得名）但不暴露任何功能的std::any：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;any\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; using namespace std::string_literals; int main() { std::any a; // 创建一个空的 \u0026#39;any\u0026#39; a = 1; // 存储一个\u0026#39;int\u0026#39;到 \u0026#39;any\u0026#39; a = \u0026#34;some string\u0026#34;s; // 将 \u0026#39;int\u0026#39; 替换为 \u0026#39;std::string\u0026#39; // 我们能做的只是从 \u0026#39;any\u0026#39; 中取回值 std::string s = std::any_cast\u0026lt;std::string\u0026gt;(a); return EXIT_SUCCESS; } 还有使用类型擦除存储分配删除器的std::shared_ptr：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory\u0026gt; int main() { { // 创建带有自定义删除器的\u0026#39;std::shared_ptr\u0026#39; // 注意删除器不是类型的一部分！ std::shared_ptr\u0026lt;int\u0026gt; s{new int{42}, [](int* ptr){ delete ptr; }}; } // \u0026#39;std::shared_ptr\u0026#39; 在作用域结束时销毁， // 通过自定义删除器删除\u0026#39;int\u0026#39;。 return EXIT_SUCCESS; } “看起来只需要为删除器提供第二个模板参数会更简单，就像std::unique_ptr那样。为什么std::shared_ptr不以相同方式实现呢？”\n其实，std::shared_ptr和std::unique_ptr的设计不同是有充分理由的。\nstd::unique_ptr的理念是最简单的原始指针包装，它应像原始指针一样快，并且大小也相同。\n因此，不希望将删除器与托管指针一起存储。因此，对于无状态删除器，std::unique_ptr的设计可以避免任何尺寸开销。\n然而，不幸的是，这个第二个模板参数很容易被忽略，导致人为的限制。相比之下，std::shared_ptr的设计避免了这种耦合，因为它有机会使用类型擦除实际上擦除删除器的类型，移除任何形式的可能依赖。\n类型擦除设计模式解析\n“哇，这听起来确实很有趣。这让我对学习类型擦除更加兴奋了。”\n好吧，那我们开始吧。然而，请不要期待任何魔法或革命性的新想法。\n类型擦除只不过是一个复合设计模式，意味着它是其他三种设计模式的非常聪明且优雅的组合，\n这三种设计模式分别是 外部多态（实现解耦效果和类型擦除非侵入性本质的关键成分；参见“准则31：使用外部多态实现非侵入式运行时多态性”）、\n桥接模式（创建基于值语义实现的关键；参见“准则28：构建桥梁以消除物理依赖”）以及（可选的）\n原型模式（处理结果值的复制语义所需；参见“准则30：应用原型进行抽象复制操作”）。\n这三个设计模式构成了类型擦除的核心，当然，要记住的是，存在不同的解释和实现，主要是为了适应特定上下文。结合这三个设计模式的目的是创建一个包装类型，它代表了一种松散耦合、非侵入式的抽象。\n类型擦除复合设计模式\n意图：“为一组扩展的、不相关的、可能非多态但具有相同语义行为的类型提供基于值的、非侵入式的抽象。”\n这个表述旨在尽可能简洁且必要地精确。然而，这个意图的每一个细节都带有意义。因此，详细阐述可能是有帮助的：\n基于值的： 类型擦除的意图是创建可以复制、移动，并且最重要的是易于推理的值类型。然而，这样的值类型并不具备常规值类型的同等质量；存在一些限制。特别是，类型擦除最适合于一元操作，但对于二元操作有一定的局限性。 非侵入式的： 类型擦除的意图是基于外部多态设计模式的例子创建一种外部、非侵入式的抽象。所有提供抽象所期望行为的类型都会自动得到支持，而无需对它们进行任何修改。 可扩展的、不相关的类型集合： 类型擦除牢固地基于面向对象的原则，即能够轻松添加类型。然而，这些类型不应有任何连接。它们不必通过某些基类共享共同的行为。相反，应该能够将任何合适的类型轻松添加到该类型集合中，无需任何侵入措施。 可能的非多态类型： 正如外部多态设计模式所展示的，类型不应该通过继承加入集合。它们也不必自行提供虚拟功能，而是应与其多态行为解耦。然而，包含基类或虚函数的类型并未被排除在外。 相同的语义行为： 目标不是为所有可能的类型提供抽象，而是为一组提供相同操作（包括相同的语法）并遵循预期行为（根据LSP，参见“指南6：遵守抽象的预期行为”）的类型提供语义抽象。如果可能的话，对于任何未提供预期功能的类型，应生成编译时错误。 考虑到这种意图的表述，因为模式的结构主要由外部多态设计模式的固有结构主导，最重要的区别和补充是在架构的最高层次上的Shape类。\n这个类作为外部多态引入的外部层次结构的包装器。主要是因为这个外部层次结构不会再直接使用，同时也反映了ShapeModel存储或“拥有”具体类型的事实，因此类模板名称已更改为OwningShapeModel。\n通过这种方式，类型擦除不仅提供了一种强大的工具来管理不同类型之间的复杂关系，还确保了代码的简洁性和灵活性，使其成为现代C++编程中的重要设计模式之一。\n拥有类型擦除的实现 好的，现在让我们在回顾类型擦除的结构时，来看看它的具体实现细节。\n尽管你之前已经见过所有这些成分的实际应用，但实现细节对于初学者来说并不友好，甚至可以说有些令人生畏。\n尽管我选择了我自己知道的最简单的类型擦除实现，情况依然如此，因此，我会尽量保持一切在合理的水平上，不会过多地深入到实现细节中。\n这包括，例如，我不打算挤出每一个微小的性能提升，我不会使用转发引用或避免动态内存分配，\n同时，我会优先考虑代码的可读性和清晰度。虽然这对您来说可能有些失望，但我相信这会省去我们很多麻烦。\n然而，如果您想深入了解实现细节和优化选项，我建议您参考“准则33：了解类型擦除的优化潜力”。\n我们再次从Circle和Square类开始：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //---- \u0026lt;Circle.h\u0026gt; ---------------- class Circle { public: explicit Circle(double radius) : radius_(radius) {} double radius() const { return radius_; } /* 更多获取器和圆特定的实用函数 */ private: double radius_; /* 更多数据成员 */ }; //---- \u0026lt;Square.h\u0026gt; ---------------- class Square { public: explicit Square(double side) : side_(side) {} double side() const { return side_; } /* 更多获取器和正方形特定的实用函数 */ private: double side_; /* 更多数据成员 */ }; 这两个类自从我们在讨论外部多态时遇到它们以来没有变化。\n但是，再次强调这两者是完全无关的、互不相识，并且最重要的是非多态的，意味着它们不继承任何基类或自行引入虚函数。\n我们还看到了ShapeConcept和OwningShapeModel类，后者以前称为ShapeModel：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; namespace detail { class ShapeConcept { public: virtual ~ShapeConcept() = default; virtual void draw() const = 0; virtual std::unique_ptr\u0026lt;ShapeConcept\u0026gt; clone() const = 0; }; template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; class OwningShapeModel : public ShapeConcept { public: explicit OwningShapeModel(ShapeT shape, DrawStrategy drawer) : shape_(std::move(shape)), drawer_(std::move(drawer)) {} void draw() const override { drawer_(shape_); } std::unique_ptr\u0026lt;ShapeConcept\u0026gt; clone() const override { return std::make_unique\u0026lt;OwningShapeModel\u0026gt;(*this); } private: ShapeT shape_; DrawStrategy drawer_; }; } // namespace detail 除了名称更改外，还有几个重要的不同点，例如，这两个类已被移到detail命名空间，该命名空间的名称表明，这两个类现在成为实现细节的一部分，即不再直接使用。\nShapeConcept类仍然引入纯虚函数 draw() 来表示绘制形状的要求。\n此外，ShapeConcept现在还引入了 纯虚 clone() 函数。\n\u0026ldquo;我知道这是什么，这是原型设计模式！\u0026rdquo; 是的，正确。 clone() 这个名字与原型模式密切相关，并强烈暗示了这种设计模式（但不是保证）。\n然而，尽管选择这个函数名非常合理和标准，但需要明确指出的是，clone() 和 draw() 函数名的选择是我们自己的：这些名字现在是实现细节，与我们对ShapeT类型的期望名称没有任何关系。\n我们可以同样命名为do_draw()和do_clone()，这不会对ShapeT类型产生任何影响。\n对ShapeT类型的真实要求是由 draw() 和 clone() 函数的实现定义的。\n作为外部层次结构的基类，ShapeConcept的 draw() 函数、clone() 函数和析构函数代表了所有形状的要求集。\n这意味着所有形状必须提供某种绘图行为——它们必须是可复制和可销毁的。请注意，这三个函数仅为此示例的要求选择。特别是，可复制性并不是所有类型擦除实现的一般要求。\nOwningShapeModel类再次代表了ShapeConcept类的唯一实现。如同之前，OwningShapeModel在其构造函数中接受一个具体的形状类型和绘制策略，并使用这些来初始化其两个数据成员。\n由于OwningShapeModel继承自ShapeConcept，它必须实现两个纯虚函数。draw()函数通过应用给定的绘制策略来实现，而clone()函数则被实现为返回相应OwningShapeModel的精确副本。\n注意： 如果您现在在想，“哦不， std::make_unique() 。这意味着动态内存。然后我就不能在我的代码中使用它了！”——别担心。std::make_unique() 只是实现细节，一种保持示例简单的选择。在“准则33：了解类型擦除的优化潜力”中，您将看到如何通过SBO避免动态内存。\n“目前为止，我并不怎么印象深刻。我们几乎没超过外部多态设计模式的实现。” 我完全理解您的批评。\n然而，我们距离将外部多态转变为类型擦除只差一步，即从引用语义切换到值语义。\n我们只需要一个值类型，一个围绕ShapeConcept和OwningShapeModel引入的外部层次结构的包装器，处理所有我们不想手动执行的细节：OwningShapeModel类模板的实例化、管理指针、执行分配以及处理生命周期。这个包装器以Shape类的形式给出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; Shape(ShapeT shape, DrawStrategy drawer) { using Model = detail::OwningShapeModel\u0026lt;ShapeT, DrawStrategy\u0026gt;; pimpl_ = std::make_unique\u0026lt;Model\u0026gt;(std::move(shape), std::move(drawer)); } // ... private: std::unique_ptr\u0026lt;detail::ShapeConcept\u0026gt; pimpl_; }; Shape类的第一个，也是最重要的细节是模板化的构造函数。此构造函数的第一个参数可以接受任何形状（称为ShapeT），\n第二个参数则是所需的 DrawStrategy ,为了简化相应的 detail::OwningShapeModel 类模板的实例化，使用方便的类型别名证明是有帮助的。该别名用于通过 std::make_unique() 实例化所需的模型。形状和绘制策略都传递给新模型。\n新创建的模型用于初始化Shape类的一个数据成员：pimpl_。“我也认出了这个，这是桥接模式！” 您高兴地宣布。\n是的，又对了。这是桥接设计模式的应用。在构造过程中，我们基于实际给定的ShapeT和DrawStrategy类型创建了一个具体的OwningShapeModel，但我们将其存储为指向ShapeConcept的指针。\n通过这样做，您创建了一个通往实现细节的桥梁，一个通往真实形状类型的桥梁。\n然而，在初始化 pimpl_ 之后，在构造函数完成后，Shape 不再记住实际类型。\nShape没有模板参数或任何成员函数会揭示它存储的具体类型，也没有数据成员记住给定类型。它持有的只是一个指向ShapeConcept基类的指针。因此，其实现的真实形状类型已经被擦除。因此得名设计模式：类型擦除。\n我们的Shape类缺少的唯一功能是一个真正的值类型所需的复制和移动操作。幸运的是，由于应用了std::unique_ptr，我们的工作量相当有限。由于编译器生成的析构函数和两个移动操作都会起作用，我们只需处理两个复制操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: // ... Shape(const Shape\u0026amp; other) : pimpl_(other.pimpl_-\u0026gt;clone()) {} Shape\u0026amp; operator=(const Shape\u0026amp; other) { // 复制并交换惯用法 Shape copy(other); pimpl_.swap(copy.pimpl_); return *this; } ~Shape() = default; Shape(Shape\u0026amp;\u0026amp;) = default; Shape\u0026amp; operator=(Shape\u0026amp;\u0026amp;) = default; private: friend void draw(const Shape\u0026amp; shape) { shape.pimpl_-\u0026gt;draw(); } // ... }; 复制构造函数可能是难以实现的函数之一，因为我们不知道存储在其他Shape中的具体形状类型。\n然而，通过在 ShapeConcept 基类中提供 clone() 函数，我们可以在不需要知道具体类型的情况下请求一个精确的副本。实现 复制赋值运算符最短、最无痛且最方便 的方法是基于复制并交换惯用法构建。\n此外，Shape 类提供了一个所谓的隐藏友元函数 draw() ，这个友元函数被称为隐藏友元，因为它虽然是一个自由函数，但在 Shape 类的主体内定义。\n作为友元，它被授予对私有数据成员的完全访问权限，并会被注入到包围的命名空间中。\n“你说过朋友不好？” 您问道。我承认，那是我说过的（参见“准则4：设计可测试性”）。\n然而，我也明确指出隐藏友元是可以的。在这种情况下，draw() 函数是 Shape 类不可分割的一部分，确实是真正的朋友（几乎是家庭的一员）。\n“但它应该是一个成员函数，对吧？” 您争论道。确实，那也是一个有效的替代方案。如果您更喜欢这种方式，请继续。\n在这种情况下，我的偏好是使用自由函数，因为我们的目标之一是通过提取 draw() 操作来减少依赖关系。这一目标也应在Shape实现中反映出来。然而，由于该函数需要访问 pimpl_ 数据成员，并且为了不增加 draw() 函数的重载集合，我将其实现为隐藏友元。\n就是这样，全部内容。让我们看看新的功能如何优雅地工作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { // 创建一个圆作为具体形状类型的代表 Circle circle{3.14}; // 创建一个绘制策略形式的lambda表达式 auto drawer = [](const Circle\u0026amp; c) { /*...*/ }; // 将形状和绘制策略结合在一个\u0026#39;Shape\u0026#39;抽象中 // 这个构造函数调用将实例化一个针对给定\u0026#39;Circle\u0026#39;和lambda类型的\u0026#39;detail::OwningShapeModel\u0026#39; Shape shape1(circle, drawer); // 绘制形状 draw(shape1); // 通过复制构造函数创建形状的副本 Shape shape2(shape1); // 绘制副本会产生相同的结果 draw(shape2); return EXIT_SUCCESS; } 首先，我们创建一个形状作为具体形状类型的代表，这感觉很简单，对吧？无需手动分配，也不需要处理指针。\n通过 draw() 函数，我们能够绘制这个 Shape。\n紧接着，我们创建形状的副本，这是一个真实的副本，不是一个简单的指针副本。通过 draw() 函数绘制副本会产生相同的结果。这感觉很好：您可以依赖值类型的复制操作（在这种情况下，是复制构造函数），并且不需要手动克隆。非常棒，对吧？而且绝对比手动使用外部多态要好得多。\n尽管在介绍了所有这些实现细节后，可能一开始不容易看出这一点，但如果您仔细分析实现细节的丛林，我希望您能体会到这种方法的美妙之处：您不再需要处理指针，没有手动分配，也不需要再处理继承层次结构。所有这些细节都在那里，是的，但所有证据都被很好地封装在 Shape 类中。\n尽管如此，您并没有失去解耦的好处：您仍然能够轻松添加新类型，并且具体形状类型仍然对绘制行为一无所知。它们仅通过 Shape 构造函数连接到所需的功能。\n“我在想，”您开始问，“难道我们不能让它变得更简单吗？我设想一个 main() 函数如下所示”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //---- \u0026lt;YourMain.cpp\u0026gt; ---------------- int main() { // 创建一个圆作为具体形状类型的代表 Circle circle{3.14}; // 将圆绑定到某些绘制功能 auto drawingCircle = [=]() { myCircleDrawer(circle); }; // 对带有绘制行为的圆进行类型擦除 Shape shape(drawingCircle); // 绘制形状 draw(shape); // ... return EXIT_SUCCESS; } 这是个很棒的想法。记住，您负责类型擦除包装器的所有实现细节以及如何将类型和操作实现结合起来。\n如果您更喜欢这种形式，请继续。但是请不要忘记，在我们的Shape示例中，为了简单和代码简洁，我特意仅使用了具有外部依赖性的单一功能（绘制）。\n可能会有更多的函数引入依赖关系，例如形状的序列化。在这种情况下，lambda 方法将不起作用，因为您需要多个命名函数（例如，draw() 和 serialize() ）。因此，最终取决于具体情况，取决于您的类型擦除包装器代表什么样的抽象。\n但无论您选择哪种实现方式，请确保不要引入功能之间的伪依赖或代码重复。\n换句话说，请记住“准则2：设计适应变化”！这就是我偏爱基于策略设计模式的解决方案的原因，尽管您不应将其视为唯一的解决方案。相反，您应努力充分利用类型擦除的松散耦合潜力。\n分析类型擦除设计模式的不足\n尽管类型擦除具有其美丽之处，并且从设计角度来看带来了许多好处，但我不会假装这个设计模式没有任何缺点。不，不公平的是隐瞒可能存在的劣势。\n首先，也是最明显的，对你来说可能是这个模式实现的复杂性，正如前面所述，我特意将实现细节保持在一个合理的水平上，希望这能帮助你理解其核心思想。\n我希望也给了你这样的印象：它实际上并不是那么困难——类型擦除的基本实现可以在大约30行代码内完成。然而，你可能会觉得它仍然过于复杂。\n此外，一旦你开始超越基本实现并考虑性能、异常安全性等方面时，实现细节确实会变得相当棘手，\n在这种情况下，使用第三方库（如Louis Dionne的dyno库、Eduardo Madrid的zoo库、Gašper Ažman的erasure库或Steven Watanabe的Boost Type Erasure库）\n是你的最佳和最方便的选择，而不是自己处理所有这些细节。\n在解释 类型擦除意图 时，我还提到了第二个更重要的限制：尽管我们现在处理的是可以复制和移动的值，但使用类型擦除进行二元操作并不直接。例如，对这些值进行相等比较并不容易，就像你期望从常规值中得到的一样：\n1 2 3 4 5 6 int main() { // ... if( shape1 == shape2 ) { /*...*/ } // 不编译！ return EXIT_SUCCESS; } 原因是 Shape 最终只是一个具体形状类型的抽象，只存储一个指向基类的指针。\n如果你直接使用外部多态，也会遇到完全相同的问题，因此这绝对不是 类型擦除 中的新问题，甚至你可能不会将其视为真正的缺点。\n然而，虽然相等比较不是当你处理基类指针时的预期操作，但它通常是对值的预期操作。\n比较两个类型擦除包装器\n“这不是只需在 Shapes 接口中暴露必要的功能就可以解决的问题吗？”你可能会问。“例如，我们可以简单地向形状的公共接口添加一个 area() 函数，并用它来比较两个对象”：\n1 2 3 4 bool operator==( Shape const\u0026amp; lhs, Shape const\u0026amp; rhs ) { return lhs.area() == rhs.area(); } “这很容易做到。那么我遗漏了什么？” 我同意这可能是你需要的全部：如果两个对象在某些公共属性相等时即认为它们相等，那么这个操作符将适用于你。一般而言，答案取决于具体情况。\n在这个特定的例子中，它取决于 Shape 类所代表的抽象的语义。问题是：什么时候两个 Shapes 相等？考虑以下带有 Circle 和 Square 的例子：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Square.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { Shape shape1( Circle{3.14} ); Shape shape2( Square{2.71} ); if( shape1 == shape2 ) { /*...*/ } return EXIT_SUCCESS; } 这两个Shapes何时相等？它们是否在面积相等时相等，还是只有在抽象背后的实例相等时才相等，即两者都是同一类型且具有相同的属性？这取决于情况。\n同样，我可以问，两个人在什么时候相等？他们的名字相同时相等吗？还是当他们所有的特征都相同时才相等？这取决于所需的语义。\n虽然第一个比较很容易实现，但第二个则不然。在一般情况下，我认为第二种情况更可能是所需的语义，因此我认为使用 类型擦除 进行相等比较以及更广泛的 二元操作 并不直接。\n请注意，我没有说相等比较是不可能的。\n技术上，你可以让它工作，尽管结果往往是一个相当丑陋的解决方案。\n因此，你必须承诺不会告诉任何人你是从我这里得到这个想法的。“你让我更加好奇了，”你带着顽皮的笑容说道。好吧，这就是解决方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... namespace detail { class ShapeConcept { public: // ... virtual bool isEqual( ShapeConcept const* c ) const = 0; }; template\u0026lt; typename ShapeT, typename DrawStrategy \u0026gt; class OwningShapeModel : public ShapeConcept { public: // ... bool isEqual( ShapeConcept const* c ) const override { using Model = OwningShapeModel\u0026lt;ShapeT,DrawStrategy\u0026gt;; auto const* model = dynamic_cast\u0026lt;Model const*\u0026gt;( c ); return ( model \u0026amp;\u0026amp; shape_ == model-\u0026gt;shape_ ); } private: // ... }; } // namespace detail class Shape { // ... private: friend bool operator==( Shape const\u0026amp; lhs, Shape const\u0026amp; rhs ) { return lhs.pimpl_-\u0026gt;isEqual( rhs.pimpl_.get() ); } friend bool operator!=( Shape const\u0026amp; lhs, Shape const\u0026amp; rhs ) { return !( lhs == rhs ); } // ... }; //---- \u0026lt;Circle.h\u0026gt; ---------------- class Circle { // ... }; bool operator==( Circle const\u0026amp; lhs, Circle const\u0026amp; rhs ) { return lhs.radius() == rhs.radius(); } //---- \u0026lt;Square.h\u0026gt; ---------------- class Square { // ... }; bool operator==( Square const\u0026amp; lhs, Square const\u0026amp; rhs ) { return lhs.side() == rhs.side(); } 为了使相等比较起作用，你可以使用dynamic_cast。\n然而，这种相等比较的实现有两个严重的缺点。\n首先，正如你在“准则18：注意无环访问者的性能”中看到的，dynamic_cast肯定不能算作快速操作。因此，每次比较你都需要付出相当大的运行时间成本。\n其次，在这种实现中，只有当两个 Shapes 配备了相同的 DrawStrategy 时才能成功比较。\n虽然这在一个上下文中可能是合理的，但在另一个上下文中也可能被视为不幸的限制。\n我知道的唯一解决方案是返回到std::function来存储绘制策略，但这会导致另一个性能损失。总之，根据上下文的不同，相等比较可能是可能的，但它通常既不容易也不便宜。这证明了我之前的声明，即类型擦除不支持二元操作。\n类型擦除包装器的接口分离\n“接口分离原则（ISP）呢？”你问。“在使用外部多态时，很容易在基类中分离关注点。看起来我们已经失去了这种能力，对吗？”\n这是一个很好的问题。你还记得我在 “准则31：使用外部多态实现非侵入式运行时多态性” 中的例子，其中使用了JSONExportable和Serializable基类。\n确实，使用类型擦除后，我们不能再使用隐藏的基类，只能使用抽象值类型。因此，看起来好像ISP无法实现了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Document // 类型擦除后的\u0026#39;Document\u0026#39; { public: // ... void exportToJSON(/*...*/) const; void serialize(ByteStream\u0026amp; bs, /*...*/) const; // ... }; // 尽管只需要JSON导出，但这里强制耦合到\u0026#39;ByteStream\u0026#39; void exportDocument(Document const\u0026amp; doc) { // ... doc.exportToJSON(/* 传递必要的参数 */); // ... } 然而，幸运的是，这种印象是错误的。你可以通过提供多个类型擦除抽象轻松遵守ISP：\n1 2 3 4 5 6 7 8 9 Document doc = /*...*/; // 类型擦除后的\u0026#39;Document\u0026#39; doc.exportToJSON(/* 传递必要的参数 */); doc.serialize(/* 传递必要的参数 */); JSONExportable jdoc = doc; // 类型擦除后的\u0026#39;JSONExportable\u0026#39; jdoc.exportToJSON(/* 传递必要的参数 */); Serializable sdoc = doc; // 类型擦除后的\u0026#39;Serializable\u0026#39; sdoc.serialize(/* 传递必要的参数 */); 在考虑这一点之前，请参阅“指南34：注意拥有类型擦除包装器的设置成本”。\n“除了实现复杂性和对一元操作的限制外，似乎没有其他缺点。那么，我不得不说这确实是非常棒的东西！优点明显超过了缺点。”\n当然，具体情况总是不同的，意味着在特定上下文中，这些问题可能会引起一些麻烦。但我同意，总的来说，类型擦除被证明是一个非常有价值的设计模式。从设计角度来看，你获得了强大的解耦水平，这将显著减少在更改或扩展软件时的痛苦。尽管这已经很吸引人了，但还有更多内容。我已经多次提到性能，但还没有展示任何性能数据。所以让我们来看看性能结果。\n性能基准测试\n实现类型 GCC 11.1 Clang 11.1 面向对象的解决方案 1.5205 秒 1.1480 秒 std::function 2.1782 秒 1.4884 秒 手动实现的std::function 1.6354 秒 1.4465 秒 经典策略 1.6372 秒 1.4046 秒 类型擦除 1.5298 秒 1.1561 秒 “看起来非常有趣。类型擦除似乎相当快。显然只有面向对象的解决方案稍微快一点。”\n是的，对于Clang来说，面向对象解决方案的性能稍好一些，但是只有一点点。\n然而，请记住，面向对象解决方案并没有解耦任何东西：draw()函数作为 Shape 层次结构中的虚函数实现，因此你体验到了与绘图功能的紧密耦合。虽然这可能带来很少的性能开销，但从设计角度来看，这是一个最糟糕的情况。\n考虑到这一点，类型擦除的性能数字确实令人惊叹：它的性能比任何策略实现高出6%到20%。\n因此，类型擦除不仅提供了最强的解耦，而且其性能也优于所有其他减少耦合的尝试。\n关于术语的一点说明\n总的来说，类型擦除是一种实现高效且松耦合代码的出色方法。尽管它有一些局限性和缺点，但你可能无法轻易忽视的是其实现细节的复杂性。\n因此，包括我和Eric Niebler在内的许多人认为，类型擦除应该成为一个语言特性：\n“如果我能回到过去，并且有能力改变C++，而不是添加虚函数，我会添加对类型擦除和概念的语言支持：定义一个单一类型的概念，并自动生成一个类型擦除包装器。”\n然而，要将类型擦除确立为一种真正的设计模式，还有更多的工作要做。\n我介绍了类型擦除作为一种由外部多态、桥接和原型组成的复合设计模式，它被引入作为一种基于值的技术，用于提供一组类型与其相关操作之间的强解耦。\n不幸的是，你可能会看到其他“形式”的类型擦除：随着时间的推移，“类型擦除”这个术语被误用和滥用在各种技术和概念中。\n例如，有时人们将void*称为类型擦除。偶尔，你也可能听到在继承层次结构或更具体地指向基类的上下文中提到类型擦除。\n最后，在std::variant的上下文中也可能听到类型擦除。\n特别是std::variant的例子展示了这种术语滥用是多么严重。虽然外部多态（类型擦除背后的主要设计模式）是关于使你能够添加新类型的，但访问者设计模式及其现代实现std::variant是关于添加新操作的（参见“准则15：设计以添加类型或操作为目标”）。\n从软件设计的角度来看，这两种解决方案完全正交：类型擦除真正解耦了具体的类型并擦除了类型信息，而std::variant的模板参数揭示了所有可能的选择，因此让你依赖这些类型。\n使用相同的术语来描述两者会导致在使用“类型擦除”这个词时完全没有传达任何信息，并产生这样的评论：“我建议我们使用类型擦除来解决这个问题。” “你能更具体一点吗？你想添加类型还是操作？”\n因此，这个术语不会具备设计模式应有的特质；它不会传达任何意图。因此，它将是无用的。\n为了给类型擦除在其应有的设计模式殿堂中赢得一席之地，并赋予其意义，请仅在讨论本指南中的意图时使用该术语。\n本节总结\n应用类型擦除设计模式的目的是为一组可扩展的、无关的、可能是非多态的类型提供基于值的、非侵入式的抽象，这些类型具有相同的语义行为。\n考虑类型擦除作为由外部多态、桥接和原型设计模式组成的复合设计模式。 理解类型擦除的优势，但也记住其局限性。 仅在沟通其意图时使用类型擦除这一术语，即作为一种允许轻松添加支持固定操作集的类型的设计模式。 通过这种方式，你可以确保在使用“类型擦除”这个术语时，它是有意义且清晰的，避免混淆和误解。这不仅有助于澄清设计意图，还能帮助团队成员更好地理解和应用这一强大的设计模式。\n准则33：了解类型擦除的优化潜力 本书的主要关注点是软件设计。因此，所有关于结构化软件、设计原则、管理依赖和抽象的工具，当然还有设计模式的信息都是核心内容。\n尽管如此，我已经多次提到性能非常重要，非常重要！毕竟，C++是一种以性能为中心的编程语言。\n因此，我现在做一个例外：本指南专门讨论性能。是的，我是认真的：不谈依赖关系，（几乎）没有分离关注点的例子，也没有值语义，只有性能。\n“终于有一些性能相关的知识了——太好了！”你欢呼道。然而，请注意其后果：本指南非常注重实现细节，而在C++中，提及一个细节通常需要处理另外两个细节，因此你很快就会陷入实现细节的泥潭。为了避免这种情况（并让我的出版商满意），我不会详细解释每一个实现细节或演示所有替代方案。但是，我会提供一些参考资料，帮助你深入研究。\n在“准则32：考虑用类型擦除替换继承层次结构”中，你看到了我们基本未优化的类型擦除实现的出色性能数据。然而，由于我们现在拥有一个值类型和包装类，而不仅仅是一个指针，我们获得了许多提高性能的机会。因此，我们将探讨两种改进性能的方法：小缓冲区优化（SBO）和手动虚拟调度。\n小缓冲区优化（SBO）\n让我们开始提升类型擦除实现性能的探索。当谈到性能时，通常首先想到的是优化内存分配。这是因为获取和释放动态内存可能会非常慢且不可预测。实际上，优化内存分配可以决定程序是慢还是快如闪电。\n然而，还有第二个原因需要关注内存。在“指南32：考虑用类型擦除替换继承层次结构”中，我可能无意中给你留下了我们需要动态内存来实现类型擦除的印象。确实，在我们的第一个Shape类的初始实现中，无论对象大小如何，构造函数和clone()函数总是无条件地进行动态内存分配，对于小对象和大对象都会执行std::make_unique()。这种选择不仅因为性能问题（特别是对于小对象）受到限制，还因为在某些环境中无法使用动态内存。因此，我应该向你展示你可以对内存做很多事情。实际上，你完全控制着内存管理！因为你使用的是值类型和包装器，所以你可以根据自己的需求处理内存。其中一个选项是完全依赖于类内的内存，并在对象过大时发出编译时错误。或者，你可以根据存储对象的大小在类内内存和动态内存之间切换。这两种方法都可以通过SBO实现。\n为了让你了解SBO的工作原理，让我们看一下一个从不在Shape中动态分配内存，而是只使用类内内存的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;array\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory\u0026gt; template\u0026lt;size_t Capacity = 32U, size_t Alignment = alignof(void*)\u0026gt; class Shape { public: // ... private: Concept* pimpl() { return reinterpret_cast\u0026lt;Concept*\u0026gt;(buffer_.data()); } Concept const* pimpl() const { return reinterpret_cast\u0026lt;Concept const*\u0026gt;(buffer_.data()); } alignas(Alignment) std::array\u0026lt;std::byte, Capacity\u0026gt; buffer_; }; 这个Shape类不再存储std::unique_ptr，而是拥有一组适当对齐的字节数组（）。为了给Shape的用户提供调整数组容量和对齐方式的灵活性，你可以为Shape类提供两个非类型模板参数Capacity和Alignment（）。虽然这提高了适应不同情况的灵活性，但缺点是将Shape类变成了一个类模板。结果，所有使用这个抽象的函数都可能变成函数模板。这可能是不希望的，例如，你可能需要将代码从源文件移动到头文件。然而，请记住这只是许多可能性之一。正如前面所述，你完全控制着内存管理。\n为了方便操作std::byte数组，我们添加了一对pimpl()函数（基于它们仍然实现桥接设计模式的事实，只是使用类内内存）（和）。你可能会说：“哦不，reinterpret_cast！这不是超级危险吗？” 你是正确的；一般来说，reinterpret_cast应被视为潜在危险。然而，在这种特定情况下，C++标准支持我们在这里所做的操作，说明它是完全安全的。\n如你所料，我们还需要引入一个外部继承层次结构，基于外部多态设计模式。这次我们在Shape类的私有部分实现这个层次结构。不是因为它更适合这个Shape实现，而是为了展示另一种选择：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 template\u0026lt;size_t Capacity = 32U, size_t Alignment = alignof(void*)\u0026gt; class Shape { public: // ... private: struct Concept { virtual ~Concept() = default; virtual void draw() const = 0; virtual void clone(Concept* memory) const = 0; virtual void move(Concept* memory) = 0; }; template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; struct OwningModel : public Concept { OwningModel(ShapeT shape, DrawStrategy drawer) : shape_(std::move(shape)), drawer_(std::move(drawer)) {} void draw() const override { drawer_(shape_); } void clone(Concept* memory) const override { std::construct_at(static_cast\u0026lt;OwningModel*\u0026gt;(memory), *this); // 或者： // auto* ptr = // const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;void const volatile*\u0026gt;(memory)); // ::new (ptr) OwningModel(*this); } void move(Concept* memory) override { std::construct_at(static_cast\u0026lt;OwningModel*\u0026gt;(memory), std::move(*this)); // 或者： // auto* ptr = // const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;void const volatile*\u0026gt;(memory)); // ::new (ptr) OwningModel(std::move(*this)); } ShapeT shape_; DrawStrategy drawer_; }; alignas(Alignment) std::array\u0026lt;std::byte, Capacity\u0026gt; buffer_; }; 在这个上下文中，第一个有趣的细节是clone()函数（）。因为clone()负责创建副本，它需要适应类内内存。因此，它不是通过std::make_unique()创建新模型，而是通过std::construct_at()原地创建新模型。或者，你可以使用placement new在给定的内存位置创建副本。\n“等等！这段代码有点难理解。为什么需要这么多转换？它们真的必要吗？” 我承认，这些行有点挑战性。因此，我应该详细解释一下。创建实例的传统方法是通过placement new。然而，使用new总是带有风险，即有人（无论是无意还是恶意）可能会提供一个类特定的new操作符的替代实现。为了避免任何问题并可靠地在指定地址构造对象，给定地址首先通过static_cast转换为void const volatile*，然后通过const_cast转换为void*。得到的地址传递给全局placement new操作符。确实，这不是最明显的代码。因此，建议使用C++20算法std::construct_at()：它提供了完全相同的功能，但语法更加简洁。\n然而，我们还需要另一个函数：clone()只处理复制操作。它不适用于移动操作。因此，我们将纯虚move()函数扩展到Concept中，并相应地在OwningModel类模板中实现它。\n“这真的有必要吗？我们使用的是类内内存，不能从一个Shape实例移动到另一个。这样做有什么意义？” 你正确地指出我们不能将内存从一个对象移动到另一个，但我们仍然可以移动存储在其中的形状。因此，move()函数将OwningModel从一个缓冲区移动到另一个缓冲区，而不是复制它。\nclone()和move()函数用于Shape的复制构造函数、复制赋值运算符、移动构造函数 和 移动赋值运算符中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 template\u0026lt;size_t Capacity = 32U, size_t Alignment = alignof(void*)\u0026gt; class Shape { public: // ... Shape(const Shape\u0026amp; other) { other.pimpl()-\u0026gt;clone(pimpl()); } Shape\u0026amp; operator=(const Shape\u0026amp; other) { // 复制并交换惯用法 Shape copy(other); buffer_.swap(copy.buffer_); return *this; } Shape(Shape\u0026amp;\u0026amp; other) noexcept { other.pimpl()-\u0026gt;move(pimpl()); } Shape\u0026amp; operator=(Shape\u0026amp;\u0026amp; other) noexcept { // 复制并交换惯用法 Shape copy(std::move(other)); buffer_.swap(copy.buffer_); return *this; } ~Shape() { std::destroy_at(pimpl()); // 或者：pimpl()-\u0026gt;~Concept(); } private: alignas(Alignment) std::array\u0026lt;std::byte, Capacity\u0026gt; buffer_; }; 在一对编译时检查确保所需的OwningModel适合类内缓冲区并符合对齐要求之后，通过std::construct_at()在类内缓冲区中实例化一个OwningModel。\n类型擦除实现 GCC 11.1 Clang 11.1 面向对象的解决方案 1.5205 秒 1.1480 秒 std::function 2.1782 秒 1.4884 秒 手动实现的std::function 1.6354 秒 1.4465 秒 经典策略 1.6372 秒 1.4046 秒 类型擦除 1.5298 秒 1.1561 秒 类型擦除（SBO） 1.3591 秒 1.0348 秒 “哇，这真快。这是……让我算一下……大约快20%比最快的策略实现，甚至比面向对象的解决方案更快。” 的确如此。非常令人印象深刻，对吧？尽管如此，你应该记住这些是我系统上的数字。你的数字会有所不同，几乎肯定。但即使你的数字不一样，总体结论是通过处理内存分配有很多优化性能的潜力。\n然而，尽管性能出色，我们失去了很多灵活性：只能存储小于或等于指定Capacity的OwningModel实例。更大的模型被排除在外。这让我回到可以在类内和动态内存之间切换的想法，具体取决于给定形状的大小：小形状存储在类内缓冲区中，而大形状则动态分配。你现在可以继续更新Shape的实现以使用这两种类型的内存。然而，在这一点上，最好再次强调我们最重要的设计原则之一：关注点分离。与其将所有逻辑和功能挤进Shape类中，不如更容易且更灵活地分离实现细节，并使用策略设计模式实现Shape（参见“指南19：使用策略隔离事物的执行方式”）：\n1 2 template\u0026lt;typename StoragePolicy\u0026gt; class Shape; Shape类模板被重写以接受一个StoragePolicy。通过这个策略，你可以从外部指定类应该如何获取内存。当然，这样你也能完美地遵循单一职责原则（SRP）和开闭原则（OCP）。其中一个这样的存储策略可以是DynamicStorage策略类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;utility\u0026gt; struct DynamicStorage { }; template\u0026lt;typename T, typename... Args\u0026gt; T* create(Args\u0026amp;\u0026amp;... args) const { return new T(std::forward\u0026lt;Args\u0026gt;(args)...); } template\u0026lt;typename T\u0026gt; void destroy(T* ptr) const noexcept { delete ptr; } 顾名思义，DynamicStorage会通过new等方法动态获取内存。如果你有更强的要求，可以基于std::aligned_alloc()或其他类似功能来提供具有指定对齐方式的动态内存。\n类似于DynamicStorage，你还可以提供一个InClassStorage策略：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; template\u0026lt;size_t Capacity, size_t Alignment\u0026gt; struct InClassStorage { template\u0026lt;typename T, typename... Args\u0026gt; T* create(Args\u0026amp;\u0026amp;... args) const { static_assert(sizeof(T) \u0026lt;= Capacity, \u0026#34;The given type is too large\u0026#34;); static_assert(alignof(T) \u0026lt;= Alignment, \u0026#34;The given type is misaligned\u0026#34;); T* memory = const_cast\u0026lt;T*\u0026gt;(reinterpret_cast\u0026lt;T const*\u0026gt;(buffer_.data())); return std::construct_at(memory, std::forward\u0026lt;Args\u0026gt;(args)...); // 或者： // void* const memory = static_cast\u0026lt;void*\u0026gt;(buffer_.data()); // return ::new (memory) T(std::forward\u0026lt;Args\u0026gt;(args)...); } template\u0026lt;typename T\u0026gt; void destroy(T* ptr) const noexcept { std::destroy_at(ptr); // 或者：ptr-\u0026gt;~T(); } alignas(Alignment) std::array\u0026lt;std::byte, Capacity\u0026gt; buffer_; }; 所有这些策略类都提供相同的接口：一个用于实例化类型T对象的create()函数和一个用于清理所需操作的destroy()函数。这个接口由Shape类用来触发构造和析构，例如在其模板构造函数和析构函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;typename StoragePolicy\u0026gt; class Shape { public: template\u0026lt;typename ShapeT\u0026gt; Shape(ShapeT shape) { using Model = OwningModel\u0026lt;ShapeT\u0026gt;; pimpl_ = policy_.template create\u0026lt;Model\u0026gt;(std::move(shape)); } ~Shape() { policy_.destroy(pimpl_); } // ... 其他成员函数，特别是特殊成员函数未显示 private: [[no_unique_address]] StoragePolicy policy_{}; Concept* pimpl_{}; }; 最后一个不应忽视的细节是数据成员：Shape类现在存储了一个给定StoragePolicy的实例，并且，不要惊慌，还有一个指向其Concept的原始指针。确实，没有必要再存储std::unique_ptr，因为我们手动在自己的析构函数中销毁对象。你可能还会注意到storage policy上的[[no_unique_address]]属性。这个C++20特性给你机会节省存储策略的内存。如果策略为空，编译器现在允许不为该数据成员保留任何内存。如果没有这个属性，则需要至少为policy_保留一个字节，但由于对齐限制，可能会更多字节。\n总的来说，SBO（小缓冲区优化）是一种有效且最有趣的类型擦除实现优化之一。因此，许多标准类型，如std::function和std::any，使用某种形式的SBO。不幸的是，C++标准库规范并不要求使用SBO。因此，你只能希望SBO被使用；不能依赖它。然而，由于性能如此重要，SBO扮演了如此关键的角色，已经有一些提案建议标准化inplace_function和inplace_any类型。时间会告诉我们这些是否会被纳入标准库。\n手动实现函数调度 “哇，这将被证明是有用的。我还能做些什么来提高我的类型擦除实现的性能吗？”你问道。哦，是的，你可以做更多。这里有第二个潜在的性能优化点。这次我们尝试提高虚拟函数的性能。是的，我指的是由外部继承层次结构（即外部多态设计模式）引入的虚拟函数。\n“我们应该如何优化虚拟函数的性能？这不是完全取决于编译器的事情吗？”确实，你是对的。然而，我不是在谈论调整后端、特定于编译器的实现细节，而是讨论用更高效的东西替换虚拟函数。而这确实是可能的。\n记住，虚拟函数只不过是一个存储在虚拟函数表中的函数指针。每个至少有一个虚拟函数的类型都有这样一个虚拟函数表。然而，每种类型只有一个虚拟函数表。换句话说，这个表并不存储在每个实例中。因此，为了将虚拟函数表与该类型的每个实例连接起来，类会存储一个额外的隐藏数据成员，我们通常称之为vptr，它是指向虚拟函数表的原始指针。\n当你调用一个虚拟函数时，首先通过vptr获取虚拟函数表。一旦到达那里，你可以从虚拟函数表中抓取相应的函数指针并调用它。因此，总共来说，一次虚拟函数调用涉及两次间接寻址：vptr和指向实际函数的指针。因此，粗略地说，虚拟函数调用的成本大约是非内联普通函数调用的两倍。\n这两个间接寻址为我们提供了优化的机会：实际上我们可以将间接寻址的数量减少到仅一次。为了实现这一点，我们将采用一种经常有效的优化策略：用空间换取速度。我们将通过在Shape类中存储虚拟函数指针来手动实现虚拟调度。以下代码片段已经为你提供了相当详细的思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; class Shape { public: // ... private: // ... template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; struct OwningModel { OwningModel(ShapeT value, DrawStrategy drawer) : shape_(std::move(value)) , drawer_(std::move(drawer)) {} ShapeT shape_; DrawStrategy drawer_; }; using DestroyOperation = void(void*); using DrawOperation = void(void*); using CloneOperation = void*(void*); std::unique_ptr\u0026lt;void, DestroyOperation*\u0026gt; pimpl_; DrawOperation* draw_{ nullptr }; CloneOperation* clone_{ nullptr }; }; 由于我们替换了所有虚拟函数，甚至包括虚拟析构函数，因此不再需要概念基类。因此，外部层次结构简化为仅包含OwningModel类模板，它仍然作为特定形状（ShapeT）和DrawStrategy的存储。尽管如此，它也遇到了同样的命运：所有的虚拟函数都被移除了。唯一剩下的细节是构造函数和数据成员。\n虚拟函数被手动函数指针所替代。由于函数指针的语法不太友好，我们添加了一些方便使用的函数类型别名：DestroyOperation代表以前的虚拟析构函数，DrawOperation代表以前的虚拟draw()函数，CloneOperation代表以前的虚拟clone()函数。DestroyOperation用于配置 pimpl_ 数据成员的删除器（并且，它充当了一种策略）。另外两个，DrawOperation和CloneOperation，用于两个额外的函数指针数据成员 draw_ 和 clone_ 。\n“哦不，void！这不是一种古老且超级危险的做法吗？”你惊呼。*\n好的，我承认没有解释的话看起来确实非常可疑。然而，请跟随我的思路，我保证一切都会完美且类型安全。现在使这一切工作的关键在于这些函数指针的初始化。它们在Shape类的模板构造函数中被初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; Shape(ShapeT shape, DrawStrategy drawer) : pimpl_(new OwningModel\u0026lt;ShapeT, DrawStrategy\u0026gt;(std::move(shape), std::move(drawer)), [](void* shapeBytes) { using Model = OwningModel\u0026lt;ShapeT, DrawStrategy\u0026gt;; auto* const model = static_cast\u0026lt;Model*\u0026gt;(shapeBytes); delete model; }) , draw_( [](void* shapeBytes) { using Model = OwningModel\u0026lt;ShapeT, DrawStrategy\u0026gt;; auto* const model = static_cast\u0026lt;Model*\u0026gt;(shapeBytes); (*model-\u0026gt;drawer_)(model-\u0026gt;shape_); }) , clone_( [](void* shapeBytes) -\u0026gt; void* { using Model = OwningModel\u0026lt;ShapeT, DrawStrategy\u0026gt;; auto* const model = static_cast\u0026lt;Model*\u0026gt;(shapeBytes); return new Model(*model); }) {} // ... private: // ... }; 让我们关注pimpl_数据成员。它通过指向新实例化的OwningModel的指针和一个无状态lambda表达式进行初始化。你可能记得无状态lambda隐式可转换为函数指针。我们利用这个语言特性将lambda直接传递给unique_ptr构造函数的deleter参数，强制编译器应用隐式转换为DestroyOperation*，从而将lambda函数绑定到std::unique_ptr。\n“好的，我明白了：lambda可以用来初始化函数指针。但这到底是如何工作的？它做了什么？”同样要记住的是，我们在模板构造函数内部创建了这个lambda。这意味着在此时我们知道传递的ShapeT和DrawStrategy的实际类型。因此，生成的lambda具有关于实例化并存储在pimpl_中的OwningModel类型的全部知识。最终，它会被调用时接收一个void*，即某个OwningModel的地址。但是，基于其对OwningModel实际类型的了解，它可以首先执行从void*到OwningModel\u0026lt;ShapeT, DrawStrategy\u0026gt;*的static_cast。虽然在大多数其他上下文中这种转换会显得可疑且可能是猜测，但在这种情况下它是完全类型安全的：我们可以确定OwningModel的正确类型。因此，我们可以使用得到的指针触发正确的清理行为。\ndraw_和clone_数据成员的初始化非常相似。唯一的区别是lambda执行的操作不同：它们分别执行绘制形状和创建模型副本的正确操作。\n我知道这可能需要一些时间来消化。但我们几乎完成了；唯一缺少的细节是特殊成员函数。对于析构函数和两个移动操作，我们可以再次请求编译器生成默认实现。然而，我们必须自己处理拷贝构造函数和拷贝赋值运算符：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //---- \u0026lt;Shape.h\u0026gt; ---------------- class Shape { public: // ... Shape(const Shape\u0026amp; other) : pimpl_(clone_(other.pimpl_.get()), other.pimpl_.get_deleter()) , draw_(other.draw_) , clone_(other.clone_) {} Shape\u0026amp; operator=(const Shape\u0026amp; other) { // Copy-and-Swap Idiom using std::swap; Shape copy(other); swap(pimpl_, copy.pimpl_); swap(draw_, copy.draw_); swap(clone_, copy.clone_); return *this; } ~Shape() = default; Shape(Shape\u0026amp;\u0026amp;) = default; Shape\u0026amp; operator=(Shape\u0026amp;\u0026amp;) = default; private: // ... }; 这就是我们需要做的所有工作，现在准备好测试这个实现。让我们再次更新“指南32：考虑用类型擦除替换继承层次结构”中的基准测试，并使用我们的手动虚拟调度实现运行它。我甚至将手动虚拟调度与之前讨论的小缓冲区优化（SBO）结合了起来。\n类型擦除实现 GCC 11.1 Clang 11.1 面向对象解决方案 1.5205 s 1.1480 s std::function 2.1782 s 1.4884 s 手动实现的std::function 1.6354 s 1.4465 s 经典策略 1.6372 s 1.4046 s 类型擦除 1.5298 s 1.1561 s 类型擦除（SBO） 1.3591 s 1.0348 s 类型擦除（手动虚拟调度） 1.1476 s 1.1599 s 类型擦除（SBO + 手动虚拟调度） 1.2538 s 1.2212 s 对于GCC，手动虚拟调度的性能提升是非常显著的。在我的系统上，运行时间缩短到了1.1476秒，相比未优化的基本类型擦除实现提高了约25%。然而，Clang在这方面并没有显示出任何改进。尽管这可能有些令人失望，但运行时间仍然非常出色。\n不幸的是，SBO和手动虚拟调度的组合并没有带来更好的性能。虽然GCC在纯SBO方法的基础上有小幅改进（这对于没有动态内存的环境可能很有趣），但在Clang上这种组合的效果并不如预期。\n总结来说，类型擦除实现有很多优化潜力。如果你之前对类型擦除持怀疑态度，这次的性能提升应该给你足够的动力去自行探索。虽然这是令人兴奋的，但重要的是要记住这些优化机会来自何处：只有通过分离虚拟行为的关注点并将行为封装到值类型中，我们才能获得这些优化机会。如果我们只有一个指向基类的指针，就无法实现这一点。\n本节总结\n使用SBO避免小对象昂贵的复制操作。 通过手动实现虚拟调度减少间接寻址次数。 准则34：注意拥有类型擦除包装器的设置成本 在“准则32：考虑用类型擦除替换继承层次结构”和“准则33：意识到类型擦除的优化潜力”中，我引导你通过了基本类型擦除实现的复杂实现细节。是的，这很艰难，但绝对值得努力：你现在变得更强大、更聪明，并且工具箱中多了一个高效且强解耦的设计模式。太棒了！\n然而，我们还需要回到这些细节中。我知道你在翻白眼，但还有更多内容。而且我必须承认：我撒了一点小谎。并不是告诉你错误的信息，而是有所遗漏。类型擦除还有一个你应该知道的缺点。一个很大的缺点。一个你可能完全不喜欢的缺点。唉。\n拥有类型擦除包装器的设置成本 假设Shape再次成为基类，而Circle是许多派生类之一。那么将一个Circle传递给期望Shape const\u0026amp;的函数将是简单且廉价的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cstdlib\u0026gt; class Shape { /*...*/ }; // 经典基类 class Circle : public Shape { /*...*/ }; // 派生类 void useShape(Shape const\u0026amp; shape) { shape.draw(/*...*/); } int main() { Circle circle{3.14}; // 自动且廉价地从 \u0026#39;Circle const\u0026amp;\u0026#39; 转换为 \u0026#39;Shape const\u0026amp;\u0026#39; useShape(circle); return EXIT_SUCCESS; } 尽管类型擦除Shape抽象略有不同（例如，它总是需要一个绘制策略），这种转换仍然是可能的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdlib\u0026gt; class Circle { /*...*/ }; // 非多态几何原语 class Shape { /*...*/ }; // 类型擦除包装类，如前所示 void useShape(Shape const\u0026amp; shape) { draw(shape); } int main() { Circle circle{3.14}; auto drawStrategy = [](Circle const\u0026amp; c) { /*...*/ }; // 创建一个临时的 \u0026#39;Shape\u0026#39; 对象，涉及复制操作和内存分配 useShape({circle, drawStrategy}); return EXIT_SUCCESS; } 不幸的是，这不再便宜。相反，基于我们之前的实现（包括基本实现和优化实现），调用useShape()函数会涉及几个潜在昂贵的操作：\n创建临时Shape对象：编译器使用非显式的模板化Shape构造函数创建一个临时Shape。 构造函数调用：构造函数调用会导致给定形状的复制操作（对于Circle来说不贵，但对于其他形状可能很昂贵）以及给定绘制策略的复制操作（如果策略是无状态的，基本上是免费的，但取决于存储在对象中的内容，可能会很昂贵）。 Shape构造函数内部：创建一个新的形状模型，涉及内存分配（隐藏在Shape构造函数中对std::make_unique()的调用中，肯定是昂贵的）。 临时（右值）Shape：通过常量引用传递给useShape()函数。 重要的是要指出，这不是我们Shape实现的具体问题。如果你使用std::function作为函数参数，同样的问题也会困扰你：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;functional\u0026gt; int compute(int i, int j, std::function\u0026lt;int(int, int)\u0026gt; op) { return op(i, j); } int main() { int const i = 17; int const j = 10; int const sum = compute(i, j, [offset=15](int x, int y) { return x + y + offset; }); return EXIT_SUCCESS; } 在这个例子中，给定的lambda被转换为std::function实例。这种转换会涉及复制操作，并可能涉及内存分配。这完全取决于给定可调用对象的大小以及std::function的实现。因此，std::function是一种不同于std::string_view和std::span的抽象类型。std::string_view和std::span是非拥有的抽象类型，因为它们只包含指向第一个元素的指针和大小，所以它们的复制成本很低。由于这两种类型执行浅拷贝，因此非常适合用作函数参数。另一方面，std::function是一个拥有抽象类型，执行深拷贝。因此，它并不完美适合作为函数参数。不幸的是，我们的Shape实现也是如此。\n“哦天哪，我不喜欢这个。一点也不喜欢。这太糟糕了！我要退款！”你惊呼道。我不得不同意这可能是代码库中的一个严重问题。然而，你需要理解底层问题是Shape类的所有权语义：基于其值语义背景，我们当前的Shape实现总是会创建给定形状的副本并始终拥有该副本。虽然这与“指南22：优先选择值语义而非引用语义”讨论的所有好处完全一致，但在这种情况下，它导致了相当不幸的性能损失。不过，别慌——我们可以为此提供一种解决方案：在这种上下文中，我们可以提供一个非拥有的类型擦除实现。\n简单的非拥有类型擦除实现\n一般来说，基于值语义的类型擦除实现是优美且完全符合现代C++精神的。然而，性能同样重要。有时，性能的重要性可能让你不那么关心值语义部分，而只关心类型擦除所提供的抽象。在这种情况下，你可能会选择一个非拥有的类型擦除实现，尽管这会将你带回引用语义的领域。\n好消息是，如果你只需要一个简单的类型擦除包装器，一个代表对基类引用的、非拥有的且可简单复制的包装器，那么所需的代码相当简单。特别是因为你已经在“指南33：意识到类型擦除的优化潜力”中看到了如何手动实现虚拟调度。有了这项技术，简单的非拥有的类型擦除实现只需几行代码即可完成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; class ShapeConstRef { public: template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; ShapeConstRef(ShapeT\u0026amp; shape, DrawStrategy\u0026amp; drawer) : shape_(std::addressof(shape)) , drawer_(std::addressof(drawer)) , draw_([](void const* shapeBytes, void const* drawerBytes) { auto const* shape = static_cast\u0026lt;ShapeT const*\u0026gt;(shapeBytes); auto const* drawer = static_cast\u0026lt;DrawStrategy const*\u0026gt;(drawerBytes); (*drawer)(*shape); }) {} private: friend void draw(ShapeConstRef const\u0026amp; shape) { shape.draw_(shape.shape_, shape.drawer_); } using DrawOperation = void(void const*, void const*); void const* shape_{ nullptr }; void const* drawer_{ nullptr }; DrawOperation* draw_{ nullptr }; }; 正如名字所示，ShapeConstRef类表示对常量形状类型的引用。它并没有存储给定形状的副本，而是仅以void*的形式保存指向该形状的指针。此外，它还保存一个指向关联绘制策略的void*，以及第三个数据成员——指向手动实现的虚拟draw()函数的函数指针（参见“指南33：意识到类型擦除的优化潜力”）。\nShapeConstRef通过引用非const的方式接受其两个参数：形状和绘制策略（可能带有cv限定符）。这种形式不允许将右值传递给构造函数，从而防止了与临时值相关的任何生命周期问题。不幸的是，这并不能保护你免受所有可能的左值生命周期问题的影响，但仍然提供了非常合理的保护。如果你想允许右值传递，你应该重新考虑。如果你真的愿意冒险处理临时值的生命周期问题，那么你可以简单地通过const引用接受参数。只是记住，这不是我给你的建议！\n这就是完整的非拥有的实现。它是高效的、简短的、简单的，并且如果不需要存储任何关联的数据或策略对象，还可以更短更简单。有了这个功能，你现在能够创建廉价的形状抽象。以下代码示例通过useShapeConstRef()函数展示了这一点。该函数使你能够通过简单地使用ShapeConstRef作为函数参数来绘制任何类型的形状（圆形、方形等），并使用任何可能的绘制实现。在main()函数中，我们通过具体的形状和具体的绘制策略（在这个例子中是一个lambda）调用useShapeConstRef()：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //---- \u0026lt;Main.cpp\u0026gt; ---------------- #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; void useShapeConstRef(ShapeConstRef shape) { draw(shape); } int main() { // 创建一个圆作为具体形状类型的代表 Circle circle{3.14}; // 创建一个绘制策略，形式为lambda auto drawer = [](Circle const\u0026amp; c) { /*...*/ }; // 通过\u0026#39;ShapeConstRef\u0026#39;抽象直接绘制圆 useShapeConstRef({circle, drawer}); return EXIT_SUCCESS; } 这一调用触发了期望的效果，特别之处在于没有任何内存分配或昂贵的复制操作，而只是通过一组指向给定形状和绘制策略的指针来封装多态行为。这种方式不仅高效，而且避免了许多潜在的性能瓶颈。\n更强大的非拥有类型擦除实现\n大多数情况下，简单的非拥有的类型擦除实现应该足以满足你的所有需求。\n然而，有时它可能还不够。有时候，你可能需要一种稍微不同的形状引用形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;Circle.h\u0026gt; #include \u0026lt;Shape.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; int main() { // 创建一个圆作为具体形状类型的代表 Circle circle{3.14}; // 创建一个绘制策略，形式为lambda auto drawer = [](Circle const\u0026amp; c) { /*...*/ }; // 将形状和绘制策略组合在一个\u0026#39;Shape\u0026#39;抽象中 Shape shape1(circle, drawer); // 绘制形状 draw(shape1); // 创建对形状的引用 // 已经可以工作，但形状引用将存储指向\u0026#39;shape1\u0026#39;实例的指针而不是\u0026#39;circle\u0026#39; ShapeConstRef shaperef(shape1); // 通过形状引用进行绘制，结果相同 // 这种方式有效，但涉及两次间接引用！ draw(shaperef); // 通过形状引用创建形状的深拷贝 // 使用简单非拥有的实现这是不可能的！ // 使用简单实现时，这会创建\u0026#39;shaperef\u0026#39;实例的副本。 // \u0026#39;shape2\u0026#39;本身将充当引用，并会有三次间接引用...唉。 Shape shape2(shaperef); // 绘制副本也会产生相同的结果 draw(shape2); return EXIT_SUCCESS; } 假设你有一个名为shape1的类型擦除圆形，你可能希望将这个Shape实例转换为ShapeConstRef。使用当前实现，这可以工作，但shaperef实例会持有指向shape1实例的指针，而不是指向circle的指针。因此，任何使用shaperef的操作都会导致两次间接引用（一次通过ShapeConstRef，另一次通过Shape抽象）。此外，你可能还希望将ShapeConstRef实例转换为Shape实例。在这种情况下，你可能会期望创建底层Circle的完整副本，并且生成的Shape抽象包含并表示该副本。不幸的是，使用当前实现，Shape会创建ShapeConstRef实例的副本，从而引入第三次间接引用。\n如果你需要在拥有和非拥有的类型擦除包装器之间更高效的交互，并且在将非拥有的包装器复制到拥有的包装器时需要实际的副本，我可以为你提供一个解决方案。不幸的是，它比之前的实现复杂一些，但幸运的是并不过于复杂。该解决方案基于“指南32：考虑用类型擦除替换继承层次结构”中的基本类型擦除实现，包括ShapeConcept和OwningShapeModel类，位于detail命名空间中，以及Shape类型擦除包装器。你会看到，只需进行一些添加，这些你之前都见过。\n第一个添加发生在ShapeConcept基类中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; namespace detail { class ShapeConcept { public: // ... virtual void clone(ShapeConcept* memory) const = 0; }; // ... } // namespace detail ShapeConcept类扩展了一个新的clone()函数。与返回新实例化模型副本不同，此函数传递了需要创建新模型的内存地址。\n第二个添加是一个新的模型类，即NonOwningShapeModel：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... namespace detail { // ... template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; class NonOwningShapeModel : public ShapeConcept { public: NonOwningShapeModel(ShapeT\u0026amp; shape, DrawStrategy\u0026amp; drawer) : shape_(std::addressof(shape)) , drawer_(std::addressof(drawer)) {} void draw() const override { (*drawer_)(*shape_); } std::unique_ptr\u0026lt;ShapeConcept\u0026gt; clone() const override { using Model = OwningShapeModel\u0026lt;ShapeT, DrawStrategy\u0026gt;; return std::make_unique\u0026lt;Model\u0026gt;(*shape_, *drawer_); } void clone(ShapeConcept* memory) const override { std::construct_at(static_cast\u0026lt;NonOwningShapeModel*\u0026gt;(memory), *this); // 或者： // auto* ptr = // const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;void const volatile*\u0026gt;(memory)); // ::new (ptr) NonOwningShapeModel(*this); } private: ShapeT* shape_{ nullptr }; DrawStrategy* drawer_{ nullptr }; }; // ... } // namespace detail NonOwningShapeModel非常类似于OwningShapeModel实现，但正如其名称所示，它不存储给定形状和策略的副本，而是仅存储指针。因此，这个类代表了OwningShapeModel类的引用语义版本。此外，NonOwningShapeModel需要覆盖ShapeConcept类的纯虚函数：draw()再次将绘制请求转发给给定的绘制策略，而clone()函数执行复制操作。第一个clone()函数通过创建一个新的OwningShapeModel并复制存储的形状和绘制策略来实现。第二个clone()函数通过std::construct_at()在指定地址创建一个新的NonOwningShapeModel来实现。\n增强的拥有型形状模型实现\n此外，OwningShapeModel类需要提供新的clone()函数的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... namespace detail { template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; class OwningShapeModel : public ShapeConcept { public: // ... void clone(ShapeConcept* memory) const { using Model = NonOwningShapeModel\u0026lt;ShapeT const, DrawStrategy const\u0026gt;; std::construct_at(static_cast\u0026lt;Model*\u0026gt;(memory), shape_, drawer_); // 或者： // auto* ptr = // const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;void const volatile*\u0026gt;(memory)); // ::new (ptr) Model(shape_, drawer_); } }; // ... } // namespace detail OwningShapeModel中的clone()函数实现类似于NonOwningShapeModel类的实现，通过std::construct_at()创建一个新的NonOwningShapeModel实例。\n接下来的添加是相应的包装类，它作为外部层次结构ShapeConcept和NonOwningShapeModel的包装器。这个包装器应承担与Shape类相同的责任（即，实例化NonOwningShapeModel类模板并封装所有指针处理），但仅表示对常量具体形状的引用，而不是副本。这个包装器再次以ShapeConstRef类的形式给出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //---- \u0026lt;Shape.h\u0026gt; ---------------- #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;memory\u0026gt; // ... class ShapeConstRef { public: // ... private: // 预期模型实例化的大小：sizeof(ShapeT*) + sizeof(DrawStrategy*) + sizeof(vptr) static constexpr size_t MODEL_SIZE = 3U * sizeof(void*); alignas(void*) std::array\u0026lt;std::byte, MODEL_SIZE\u0026gt; raw_; }; 正如你所见，ShapeConstRef类非常类似于Shape类，但有几个重要的区别。第一个值得注意的细节是使用了适当对齐的std::byte数组形式的raw_存储（）。这表明ShapeConstRef不进行动态分配，而是牢固地依赖于类内内存。在这种情况下，这是很容易实现的，因为我们可以预测所需的NonOwningShapeModel的大小等于三个指针的大小（假设指向虚函数表的指针vptr与其他指针具有相同的大小）。\nShapeConstRef的私有部分还包含几个成员函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... class ShapeConstRef { public: // ... private: friend void draw(ShapeConstRef const\u0026amp; shape) { shape.pimpl()-\u0026gt;draw(); } ShapeConcept* pimpl() { return reinterpret_cast\u0026lt;ShapeConcept*\u0026gt;(raw_.data()); } ShapeConcept const* pimpl() const { return reinterpret_cast\u0026lt;ShapeConcept const*\u0026gt;(raw_.data()); } // ... }; 我们还添加了一个隐藏的朋友draw()函数，并且就像在“指南33：意识到类型擦除的优化潜力”中的SBO实现一样，我们添加了一对pimpl()函数（）。这将使我们能够方便地使用类内的std::byte数组。\n第二个值得注意的细节是每个类型擦除实现的签名函数——模板构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... class ShapeConstRef { public: // 类型\u0026#39;ShapeT\u0026#39;和\u0026#39;DrawStrategy\u0026#39;可能是cv限定的；左值引用防止临时值的引用 template\u0026lt;typename ShapeT, typename DrawStrategy\u0026gt; ShapeConstRef(ShapeT\u0026amp; shape, DrawStrategy\u0026amp; drawer) { using Model = detail::NonOwningShapeModel\u0026lt;ShapeT const, DrawStrategy const\u0026gt;; static_assert(sizeof(Model) == MODEL_SIZE, \u0026#34;Invalid size detected\u0026#34;); static_assert(alignof(Model) == alignof(void*), \u0026#34;Misaligned detected\u0026#34;); std::construct_at(static_cast\u0026lt;Model*\u0026gt;(pimpl()), shape, drawer); // 或者： // auto* ptr = // const_cast\u0026lt;void*\u0026gt;(static_cast\u0026lt;void const volatile*\u0026gt;(pimpl())); // ::new (ptr) Model(shape, drawer); } // ... private: // ... }; 同样，你可以选择接受非const引用参数来防止临时值的生命周期问题（非常推荐！）。或者，接受const引用参数，这样允许传递右值，但会使你面临临时值生命周期问题的风险。在构造函数内部，我们首先为所需的模型类型使用一个方便的类型别名（），然后检查模型的实际大小和对齐方式（）。如果不符预期的MODEL_SIZE或指针对齐，我们将创建一个编译时错误。然后通过std::construct_at()在类内内存中构建新模型（）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... class ShapeConstRef { public: // ... ShapeConstRef(Shape\u0026amp; other) { other.pimpl_-\u0026gt;clone(pimpl()); } ShapeConstRef(Shape const\u0026amp; other) { other.pimpl_-\u0026gt;clone(pimpl()); } ShapeConstRef(ShapeConstRef const\u0026amp; other) { other.pimpl()-\u0026gt;clone(pimpl()); } ShapeConstRef\u0026amp; operator=(ShapeConstRef const\u0026amp; other) { // 复制并交换惯用法 ShapeConstRef copy(other); raw_.swap(copy.raw_); return *this; } ~ShapeConstRef() { std::destroy_at(pimpl()); // 或者：pimpl()-\u0026gt;~ShapeConcept(); } // 显式未声明移动操作 private: // ... }; 除了模板ShapeConstRef构造函数外，ShapeConstRef还提供了两个构造函数，以启用从Shape实例的转换。虽然这些不是严格必需的，因为我们可以为Shape创建一个NonOwningShapeModel实例，但这些构造函数直接为相应的底层形状类型创建一个NonOwningShapeModel，从而减少一次间接引用，有助于提高性能。注意，为了使这些构造函数工作，ShapeConstRef需要成为Shape类的朋友。不过不用担心，这是一个很好的友元示例：Shape和ShapeConstRef确实应该在一起工作，甚至可以在同一个头文件中提供。\n最后一个值得注意的细节是两个移动操作既没有显式声明也没有删除。由于我们明确地定义了两个复制操作，编译器既不会创建也不会删除这两个移动操作，因此它们完全消失了。这意味着这两个函数永远不会参与重载解析。而且，这与显式删除它们不同：如果它们被删除，则会参与重载解析，如果被选中，则会导致编译错误。但由于这两个函数已经消失，当你尝试移动一个ShapeConstRef时，复制操作会被使用，这些操作既便宜又高效，因为ShapeConstRef仅表示一个引用。因此，这个类故意实现了“规则三”。\n我们几乎完成了。最后的细节是在Shape类中添加另一个构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //---- \u0026lt;Shape.h\u0026gt; ---------------- // ... class Shape { public: // ... Shape(ShapeConstRef const\u0026amp; other) : pimpl_{other.pimpl()-\u0026gt;clone()} {} private: // ... }; 通过这个构造函数，Shape的一个实例会创建一个存储在传入的ShapeConstRef实例中的形状的深拷贝。如果没有这个构造函数，Shape将存储一个ShapeConstRef实例的副本，从而本身充当引用。\n第九章 装饰器设计模式 本章将专门介绍另一个经典设计模式：装饰器设计模式。\n多年来，装饰器已被证明在组合和复用不同实现方案时是最有用的设计模式之一。因此，它被广泛使用并不令人意外——甚至被应用于C++标准库功能中最令人印象深刻的重构之一。我在本章的主要目标是让您充分理解为何及何时装饰器是软件设计的绝佳选择。此外，我将向您展示装饰器现代化、更基于值语义的实现形式。\n在\u0026quot;准则35：使用装饰器分层添加定制功能\u0026quot;中，我们将深入探讨装饰器设计模式的设计维度。您将了解何时这是正确的设计选择，以及使用它能带来哪些优势。同时，您还将学习该模式与其他设计模式的区别及其潜在缺点。\n在\u0026quot;准则36：理解运行时与编译时抽象的权衡\u0026quot;中，我们将继续研究装饰器设计模式的两种实现方案。虽然这两种实现都根植于值语义领域，但第一种基于静态多态，而第二种基于动态多态。尽管两者具有相同的设计意图因而都实现了装饰器模式，但它们的对比将让您体会到设计模式实现方案在设计空间中的广阔可能性。\n准则35：使用装饰器层次化地添加定制 自从你通过提出基于策略设计模式的解决方案（还记得“指南19：使用策略隔离事物的实现方式”）解决了团队2D图形工具的设计问题后，你在公司内的设计模式专家声誉已经广为传播。\n因此，其他团队来找你寻求指导并不令人意外。有一天，公司商品管理系统中的两位开发人员来到你的办公室请求帮助。\n你的同事的设计问题\n这两个开发人员所在的团队处理许多不同的项目（见图9-1）。所有这些项目都有一个共同点：它们都有一个价格标签。\n为了说明他们的问题，他们选择了两个来自C++商品商店的例子：一个代表C++书籍的类（CppBook类）和一个C++会议门票的类（ConferenceTicket类）。\n当开发人员描述他们的设计问题时，你开始理解到他们的问题在于有多种不同的方式来修改价格。最初，他们只需要考虑税费。因此，Item基类配备了一个受保护的数据成员来表示税率：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //---- \u0026lt;Money.h\u0026gt; ---------------- class Money { /*...*/ }; Money operator*(Money money, double factor); Money operator+(Money lhs, Money rhs); //---- \u0026lt;Item.h\u0026gt; ---------------- #include \u0026lt;Money.h\u0026gt; class Item { public: virtual ~Item() = default; virtual Money price() const = 0; // ... protected: double taxRate_; }; 这种方法在一段时间内似乎运行良好，直到有一天，他们被要求还要考虑不同的折扣率。这显然需要大量的工作来重构现有的大量类，因为有许多不同的项目。\n你可以很容易地想象这是必要的，因为所有派生类都在访问受保护的数据成员。“是的，你应该总是为变化而设计……”你心里想道。\n他们承认，他们在Item基类中封装税率的方式并不理想。然而，随着这一认识而来的是理解到，当通过基类中的数据成员表示价格调整时，任何新的价格调整方式都会是一种侵入性的操作，并且总是直接影响Item类。因此，他们开始思考如何避免未来这种大规模的重构，并使添加新的调整器变得容易。“这就是正确的方向！”你心里想道。不幸的是，他们首先想到的方法是通过继承层次结构来分离不同种类的价格调整器（见图9-2）。\n他们没有将税和折扣值封装在基类内部，而是把这些调整器提取到派生类中，这些派生类执行所需的价格调整。“嗯…”你开始思考。显然你的表情已经透露出你对这个想法不太满意，所以他们很快告诉你他们已经放弃了这个想法。显然，他们自己也意识到这会导致更多的问题：这种解决方案会迅速导致类型爆炸，并且只能提供较差的功能重用。不幸的是，大量的代码会被重复，因为对于每个特定的项目，税收和折扣的代码必须被复制。最麻烦的是处理同时受税收和某种折扣影响的项目：他们既不喜欢提供两个功能的类，也不想在继承层次中引入另一层（见图9-3）。\n显然，让他们感到惊讶的是，他们无法通过直接继承在基类或派生类中处理价格调整器。然而，在你有机会对分离关注点发表任何评论之前，他们解释说他们最近听说了你的策略解决方案。这最终给了他们一个正确重构问题的想法（见图9-4）。\n通过将价格调整器提取到一个单独的层次结构中，并通过在构造时使用PriceStrategy配置Item，他们终于找到了一种非侵入性地添加新价格调整器的工作方案，这将为他们节省大量的重构工作。“好吧，这就是分离关注点和支持组合而非继承的好处。”你心里想道。然后你大声问道：“这太棒了，我真的为你高兴。现在一切都看起来很好，你们自己解决了这个问题！那你们为什么还来找我？”\n他们告诉你，你的策略解决方案是迄今为止他们能找到的最佳方法（包含感激的表情）。然而，他们承认他们并不是完全满意这种方法。从他们的角度来看，仍然有两个问题存在，当然，他们希望你能有一个解决这些问题的想法。第一个问题是每个Item实例都需要一个策略类，即使没有任何价格调整器应用。虽然他们同意可以通过某种空对象来解决这个问题，但他们觉得应该有一个更简单的解决方案：\n1 2 3 4 5 6 7 8 9 10 11 class PriceStrategy { public: virtual ~PriceStrategy() = default; virtual Money update(Money price) const = 0; // ... }; class NullPriceStrategy : public PriceStrategy { public: Money update(Money price) const override { return price; } }; 第二个问题似乎更难解决。显然，他们有兴趣结合不同的调整器（例如，折扣和税收结合成折扣与税收）。不幸的是，他们在当前实现中遇到了一些代码重复。例如，Tax类和DiscountAndTax类都包含了与税收相关的计算。虽然目前只有这两个调整器，有合理的解决方案可以应对重复问题，但他们预计在添加更多调整器和任意组合时会出现问题。因此，他们想知道是否有另一种更好的解决方案来处理不同种类的价格调整器。\n这确实是一个有趣的问题，你很高兴花时间帮助他们。他们完全正确：策略设计模式并不是解决这个问题的正确方法。尽管策略模式是去除对函数完整实现细节依赖并优雅处理不同实现的好方法，但它并不能轻松地组合和重用不同的实现。尝试这样做会迅速导致不理想的复杂策略继承层次结构。\n对他们的问题来说，似乎需要一种更类似于分层形式的策略，一种解耦不同价格调整器但也能灵活组合它们的形式。因此，成功的关键在于一致的应用分离关注点原则：任何类似DiscountAndTax类的手动编码组合都是不可取的。此外，解决方案应该是非侵入性的，以便他们能够随时实现新想法而无需修改现有代码。最后，不需要通过某些人工的空对象来处理默认情况。相反，基于组合而不是继承来构建，并以包装器的形式实现价格调整器将是更合理的选择。有了这个认识，你开始微笑。是的，有一种恰好合适的设计模式可以满足这一需求：你的两位客人需要的是装饰器设计模式的实现。\n装饰器设计模式解释\n装饰器设计模式同样源自GoF（设计模式：可复用面向对象软件的基础）一书。其主要关注点是通过组合灵活地结合不同的功能：\n装饰器设计模式\n意图：“动态地给对象附加额外的职责。装饰器提供了一种比继承更灵活的扩展功能的方式。”\n图9-5展示了给定Item问题的UML图。\n如前所述，Item基类代表所有可能项目的抽象，另一方面，派生的CppBook类作为Item不同实现的代表。\n在这个层次结构中的问题是难以向现有的price()函数添加新的调整器。\n在装饰器设计模式中，这种新“职责”的添加被识别为一个变化点，并以DecoratedItem类的形式提取出来。这个类是一个独立的、特殊的Item基类实现，表示任何给定项目增加的责任。\n一方面，DecoratedItem从Item派生，因此必须遵守Item抽象的所有预期行为（参见“指南6：遵循抽象的预期行为”）另一方面，它还包含一个Item（通过组合或聚合）。\n因此，DecoratedItem作为一个包装器围绕每个项目，可能自身也能扩展功能。正因为如此，它为层级应用调整器提供了基础。两个可能的调整器由Discounted类表示，它代表特定项目的折扣，以及Taxed类，它代表某种税收。\n通过引入DecoratedItem类并分离需要改变的部分，你遵循了单一职责原则（SRP）。通过分离这一关注点，从而允许轻松添加新的价格调整器，你也遵循了开闭原则（OCP）。由于DecoratedItem类的层级递归性质，以及获得的易于重用和组合不同调整器的能力，你也遵循了不要重复自己（DRY）原则。最后但并非最不重要的是，由于装饰器的包装器方法，不需要以空对象的形式定义任何默认行为。任何不需要调整器的Item都可以直接使用。\n图9-6说明了装饰器设计模式的依赖关系图。在这张图中，Item类位于架构的最高层。所有其他类都依赖于它，包括位于下一层的DecoratedItem类。当然，这不是必须的：如果Item和DecoratedItem在同一架构层引入也是完全可以接受的。然而，这个例子展示了总是可以在任何时候、任何地方引入一个新的装饰器而无需修改现有代码的可能性。具体的Item类型实现在架构的最低层。请注意，这些项目之间没有依赖关系：所有的项目，包括像Discounted这样的调整器，可以由任何人随时独立引入，并且由于装饰器的结构，能够灵活且任意地组合。\n装饰器设计模式的经典实现\n让我们通过给定的Item示例，来看一个完整的、GoF风格的装饰器设计模式实现：\n1 2 3 4 5 6 7 8 //---- \u0026lt;Item.h\u0026gt; ---------------- #include \u0026lt;Money.h\u0026gt; class Item { public: virtual ~Item() = default; virtual Money price() const = 0; }; Item基类代表所有可能项目的抽象。唯一的要求是由纯虚函数price()定义，该函数可用于查询给定项目的价格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //---- \u0026lt;DecoratedItem.h\u0026gt; ---------------- #include \u0026lt;Item.h\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;utility\u0026gt; class DecoratedItem : public Item { public: explicit DecoratedItem(std::unique_ptr\u0026lt;Item\u0026gt; item) : item_(std::move(item)) { if (!item_) { throw std::invalid_argument(\u0026#34;Invalid item\u0026#34;); } } protected: Item\u0026amp; item() { return *item_; } Item const\u0026amp; item() const { return *item_; } private: std::unique_ptr\u0026lt;Item\u0026gt; item_; }; DecoratedItem类从Item类派生，但也包含一个item_成员（通过构造函数指定）。这个item_是一个指向另一个Item的std::unique_ptr，并且不能为nullptr。注意，这个DecoratedItem类仍然是抽象的，因为纯虚函数price()尚未定义。DecoratedItem只提供了存储和访问Item的基本功能。\n具体项目类实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //---- \u0026lt;CppBook.h\u0026gt; ---------------- #include \u0026lt;Item.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;utility\u0026gt; class CppBook : public Item { public: CppBook(std::string title, Money price) : title_(std::move(title)), price_(price) {} std::string const\u0026amp; title() const { return title_; } Money price() const override { return price_; } private: std::string title_{}; Money price_{}; }; //---- \u0026lt;ConferenceTicket.h\u0026gt; ---------------- #include \u0026lt;Item.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;utility\u0026gt; class ConferenceTicket : public Item { public: ConferenceTicket(std::string name, Money price) : name_(std::move(name)), price_(price) {} std::string const\u0026amp; name() const { return name_; } Money price() const override { return price_; } private: std::string name_{}; Money price_{}; }; CppBook和ConferenceTicket类是具体的Item实现。虽然C++书籍由书名表示，而C++会议由会议名称表示，但最重要的是，这两个类都重写了price()函数，返回指定的价格price_。\n价格调整器类实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //---- \u0026lt;Discounted.h\u0026gt; ---------------- #include \u0026lt;DecoratedItem.h\u0026gt; class Discounted : public DecoratedItem { public: Discounted(double discount, std::unique_ptr\u0026lt;Item\u0026gt; item) : DecoratedItem(std::move(item)), factor_(1.0 - discount) { if (!std::isfinite(discount) || discount \u0026lt; 0.0 || discount \u0026gt; 1.0) { throw std::invalid_argument(\u0026#34;Invalid discount\u0026#34;); } } Money price() const override { return item().price() * factor_; } private: double factor_; }; //---- \u0026lt;Taxed.h\u0026gt; ---------------- #include \u0026lt;DecoratedItem.h\u0026gt; class Taxed : public DecoratedItem { public: Taxed(double taxRate, std::unique_ptr\u0026lt;Item\u0026gt; item) : DecoratedItem(std::move(item)), factor_(1.0 + taxRate) { if (!std::isfinite(taxRate) || taxRate \u0026lt; 0.0) { throw std::invalid_argument(\u0026#34;Invalid tax\u0026#34;); } } Money price() const override { return item().price() * factor_; } private: double factor_; }; Discounted和Taxed类实现了价格调整器。Discounted类接受一个折扣值，并计算一个折扣因子factor_，该因子在price()函数中用于修改给定项目的最终价格。同样地，Taxed类接受一个税率值，并计算一个税因子factor_，该因子也用于修改价格。\n主函数示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;ConferenceTicket.h\u0026gt; #include \u0026lt;CppBook.h\u0026gt; #include \u0026lt;Discounted.h\u0026gt; #include \u0026lt;Taxed.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory\u0026gt; int main() { // 7% tax: 19*1.07 = 20.33 std::unique_ptr\u0026lt;Item\u0026gt; item1( std::make_unique\u0026lt;Taxed\u0026gt;(0.07, std::make_unique\u0026lt;CppBook\u0026gt;(\u0026#34;Effective C++\u0026#34;, 19.0))); // 20% discount, 19% tax: (999*0.8)*1.19 = 951.05 std::unique_ptr\u0026lt;Item\u0026gt; item2( std::make_unique\u0026lt;Taxed\u0026gt;(0.19, std::make_unique\u0026lt;Discounted\u0026gt;(0.2, std::make_unique\u0026lt;ConferenceTicket\u0026gt;(\u0026#34;CppCon\u0026#34;, 999.0)))); Money const totalPrice1 = item1-\u0026gt;price(); // 结果为 20.33 Money const totalPrice2 = item2-\u0026gt;price(); // 结果为 951.05 // ... return EXIT_SUCCESS; } 在这个主函数示例中，我们创建了两个具体项目：\nC++书籍：假设这本书需要缴纳7%的税费，因此我们使用Taxed装饰器包裹它。最终的item1代表一个含税的C++书籍。 C++会议门票：假设我们获得了早期鸟票，享有20%的折扣。这个折扣通过Discounted类应用到ConferenceTicket实例上。此外，门票还需要缴纳19%的税费，这通过Taxed装饰器再次应用。最终的item2代表一个打折并含税的C++会议门票。 通过这种方式，我们可以轻松地组合不同的价格调整器，而无需修改原始项目类的代码。装饰器设计模式不仅提高了代码的灵活性，还减少了维护的工作量。这种方法使得系统可以灵活应对未来的需求变化，而不需要进行大规模的重构。\n第二个装饰器示例\n另一个展示装饰器设计模式优势的令人印象深刻的例子可以在C++17对STL分配器的重工作中找到。由于分配器的实现基于装饰器，因此可以创建任意复杂的分配器层次结构，以满足最特殊的内存需求。例如，考虑以下使用std::pmr::monotonic_buffer_resource的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory_resource\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::array\u0026lt;std::byte, 1000\u0026gt; raw; // 注意：未初始化！ std::pmr::monotonic_buffer_resource buffer{raw.data(), raw.size(), std::pmr::null_memory_resource()}; std::pmr::vector\u0026lt;std::pmr::string\u0026gt; strings{\u0026amp;buffer}; strings.emplace_back(\u0026#34;String longer than what SSO can handle\u0026#34;); strings.emplace_back(\u0026#34;Another long string that goes beyond SSO\u0026#34;); strings.emplace_back(\u0026#34;A third long string that cannot be handled by SSO\u0026#34;); // ... return EXIT_SUCCESS; } std::pmr::monotonic_buffer_resource是std::pmr命名空间中的几个可用分配器之一。在这个例子中，它被配置为每当strings向量请求内存时，只分配给定字节数组raw的块。如果内存请求无法处理（例如因为缓冲区已无内存），则通过抛出std::bad_alloc异常来处理。这种行为通过在构造时传递std::pmr::null_memory_resource来指定。\n然而，std::pmr::monotonic_buffer_resource还有许多其他可能的应用。例如，也可以基于动态内存构建，并通过new和delete重新分配额外的内存块，使用std::pmr::new_delete_resource()：\n1 2 3 4 int main() { std::pmr::monotonic_buffer_resource buffer{std::pmr::new_delete_resource()}; // ... } 这种灵活性和分层配置由装饰器设计模式实现。std::pmr::monotonic_buffer_resource派生自std::pmr::memory_resource基类，但同时也是一个包装器，围绕另一个派生自std::pmr::memory_resource的分配器。上游分配器在缓冲区耗尽内存时使用，在std::pmr::monotonic_buffer_resource的构造中指定。\n最令人印象深刻的是，你可以轻松且非侵入地自定义分配策略。例如，这可能使你能够以不同的方式处理大块内存请求和小块内存请求。只需提供自己的自定义分配器即可。考虑以下自定义分配器的草图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //---- \u0026lt;CustomAllocator.h\u0026gt; ---------------- #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;memory_resource\u0026gt; class CustomAllocator : public std::pmr::memory_resource { public: CustomAllocator(std::pmr::memory_resource* upstream) : upstream_{upstream} {} private: void* do_allocate(size_t bytes, size_t alignment) override; void do_deallocate(void* ptr, [[maybe_unused]] size_t bytes, [[maybe_unused]] size_t alignment) override; bool do_is_equal(std::pmr::memory_resource const\u0026amp; other) const noexcept override; std::pmr::memory_resource* upstream_{}; }; 为了被识别为C++17分配器，CustomAllocator类派生自std::pmr::memory_resource类，后者代表了所有C++17分配器的要求集。巧合的是，CustomAllocator也拥有一个指向std::pmr::memory_resource的指针，通过其构造函数初始化。\nC++17分配器的要求集包括虚拟函数do_allocate()、do_deallocate()和do_is_equal()。do_allocate()函数负责获取内存，可能是通过其上游分配器，而do_deallocate()函数在需要释放内存时调用。最后，do_is_equal()函数在需要检查两个分配器是否相等时调用。\n只需引入CustomAllocator而无需更改任何其他代码，特别是标准库中的代码，新的分配器类型可以轻松插入到std::pmr::monotonic_buffer_resource和std::pmr::new_delete_resource()之间，从而允许你非侵入地扩展分配行为：\n1 2 3 4 5 6 7 #include \u0026lt;CustomAllocator.h\u0026gt; int main() { CustomAllocator custom_allocator{std::pmr::new_delete_resource()}; std::pmr::monotonic_buffer_resource buffer{\u0026amp;custom_allocator}; // ... } 装饰器、适配器和策略模式的比较\n尽管装饰器和适配器这两种设计模式听起来有相似的目的，但在仔细检查后，它们非常不同且几乎不相关。适配器设计模式的意图是适应和改变给定接口以匹配预期接口。它不关心添加任何功能，只关心将一组函数映射到另一组函数。相反，装饰器设计模式保留给定接口，完全不关心改变它。相反，它提供了添加职责和扩展及自定义现有功能集的能力。\n策略设计模式与装饰器更相似。两种模式都提供了自定义功能的能力。然而，它们针对不同的应用场景，因此提供了不同的好处。策略设计模式侧重于消除对特定功能实现细节的依赖，并允许从外部定义这些细节。因此，从这个角度来看，它代表了该功能的核心——“核心”。这种形式特别适合表示不同的实现并在这之间切换。相比之下，装饰器设计模式侧重于消除可附加实现部分之间的依赖关系。由于其包装器形式，装饰器代表了功能的“皮肤”。在这种形式下，它特别适合组合不同的实现，从而增强和扩展功能，而不是替换它或在实现之间切换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class PriceStrategy { public: virtual ~PriceStrategy() = default; virtual Money update(Money price) const = 0; // ... }; class DecoratedPriceStrategy : public PriceStrategy { public: // ... private: std::unique_ptr\u0026lt;PriceStrategy\u0026gt; priceModifier_; }; class DiscountedPriceStrategy : public DecoratedPriceStrategy { public: Money update(Money price) const override; // ... }; 这种设计模式的组合在已经有一个策略实现的情况下特别有趣：虽然策略是侵入性的并要求修改类，但总是可以通过添加装饰器如DecoratedPriceStrategy类来非侵入性地扩展。当然，这取决于具体情况：是否这是正确的解决方案需要逐案决定。\n分析装饰器设计模式的不足\n尽管装饰器设计模式能够层次化地扩展和定制行为，无疑是设计模式目录中最有价值和最灵活的模式之一，但它也有一些缺点。首先，装饰器的灵活性是有代价的：给定层次结构中的每一层都会增加一层间接性。例如，在Item层次结构的对象导向实现中，这种间接性表现为每个装饰器的一个虚函数调用。因此，广泛使用装饰器可能会带来潜在的显著性能开销。这种可能的性能损失是否成为问题取决于具体上下文。你需要通过基准测试逐案决定装饰器的灵活性和结构性是否超过了性能问题。\n另一个不足是错误组合装饰器的潜在危险。例如，很容易将一个Taxed装饰器包裹在另一个Taxed装饰器周围，或者在一个已经征税的项目上应用Discounted。这两种情况虽然会让你的政府高兴，但不应该发生，因此应在设计时避免。Scott Meyers 的通用设计原则很好地表达了这一理性：\n使接口易于正确使用且难以错误使用。\n因此，装饰器的巨大灵活性是卓越的，但也可能是危险的（当然，这取决于场景）。在这种情况下，税收似乎扮演了一个特殊的角色，因此不将其作为装饰器处理而采用其他方式似乎是合理的。由于现实中的税收是一个相当复杂的话题，通过策略设计模式分离这一关注点似乎是合理的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //---- \u0026lt;TaxStrategy.h\u0026gt; ---------------- #include \u0026lt;Money.h\u0026gt; class TaxStrategy { public: virtual ~TaxStrategy() = default; virtual Money applyTax(Money price) const = 0; // ... }; //---- \u0026lt;TaxedItem.h\u0026gt; ---------------- #include \u0026lt;Money.h\u0026gt; #include \u0026lt;TaxStrategy.h\u0026gt; #include \u0026lt;memory\u0026gt; class TaxedItem { public: explicit TaxedItem(std::unique_ptr\u0026lt;Item\u0026gt; item, std::unique_ptr\u0026lt;TaxStrategy\u0026gt; taxer) : item_(std::move(item)), taxer_(std::move(taxer)) { // 检查有效的项目和税收策略 } Money netPrice() const { // 不含税的价格 return item_-\u0026gt;price(); } Money grossPrice() const { // 包含税的价格 return taxer_-\u0026gt;applyTax(item_-\u0026gt;price()); } private: std::unique_ptr\u0026lt;Item\u0026gt; item_; std::unique_ptr\u0026lt;TaxStrategy\u0026gt; taxer_; }; TaxStrategy类代表对Item应用税收的多种不同方式。这样的TaxStrategy与Item在TaxedItem类中结合。注意，TaxedItem本身并不是一个Item，因此不能通过另一个Item来装饰它。因此，它充当一种终止装饰器，只能作为最后一个装饰器应用。它也不提供price()函数，而是提供netPrice()和grossPrice()函数，以便查询包含税和原始项目的不含税价格。\n唯一可能看到的另一个问题是基于引用语义的装饰器设计模式实现：大量的指针、包括nullptr检查和悬空指针的风险、通过std::unique_ptr和std::make_unique()进行显式的生命周期管理以及许多小的手动内存分配。然而，幸运的是，你还有一个王牌可以展示如何基于值语义实现装饰器（见后续指南）。\n总结来说，装饰器设计模式是基本的设计模式之一，尽管有一些缺点，但它仍然是一个非常有价值的工具箱补充。只需确保不要过于热衷于装饰器并开始将其用于一切。毕竟，对于每种模式，都有一个合理使用和过度使用的界限。\n本节总结\n理解继承很少是答案。 应用装饰器设计模式的意图是非侵入式地、层次化地扩展和定制行为。 考虑装饰器用于组合和重用独立的行为片段。 理解装饰器、适配器和策略设计模式之间的差异。 利用装饰器的极端灵活性，但了解其不足之处。 避免无意义的装饰器，但更倾向于易于正确使用的良好设计。 ","date":"1074-01-04T12:57:17+08:00","permalink":"http://localhost:1313/p/c-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/","title":"C++ 软件设计"},{"content":"简介 设计模式是软件工程中一系列被广泛认可的解决特定问题的最佳实践。它们为常见问题提供了模板或指导方针，帮助开发者创建更加灵活、可维护和可复用的代码。C++作为一种多范式编程语言，支持面向对象和泛型编程等特性，因此非常适合实现各种设计模式。\n☆☆在C++中，绝大部分的模式 最终都是通过 指针指向一个多态对象 表达灵活性。☆☆对于C++特供版本来说，很多设计模式都是通过 继承抽象类 使用多态来实现，但是有些情况 使用函数指针会更好。例如观察者模式的最后一个例子 使用了函数指针，避免创建类。使用模板编程 concept，将运行期的开销 提前到编译期，也是一种方法。\n文中的所有代码都不是伪代码，全都可以运行。有些设计模式并不常用 甚至是过时的。\n主要的设计模式分类\n创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性。\n工厂方法、抽象工厂、生成器、原型、单例\n结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n适配器、桥接、组合、装饰、外观、享元、代理\n行为模式负责对象间的高效沟通和职责委派。\n责任链、命令、迭代器、 中介者、备忘录、观察者、 状态、策略、模板方法、访问者\n设计模式中的抽象思维\n耦合：两个模块相互依赖，修改其中一个模块，那么另外一个也要修改。模块之间相互影响的关系叫做两个模块之间存在耦合关系。\n解耦合：通过修改程序代码，切换两个模块之间的依赖关系，对任意一个模块的修改，不会影响到另外一个模块，就叫做两个模块之间解耦合。\n抽象思维强调对象的本质属性，主要应用于一些软件设计中的解耦合过程。\n软件开发中需求变化频繁的，开发人员要尝试寻找变化点，把 变化部分 和 稳定部分 分离开来，在变化的地方应用设计模式。\n对于某一项任务，有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或由于固有原因无法和任务的整体结构同时实现，(出现 一个早一个晚 的关系)， 如何在确定稳定操作的前提下，灵活应对各个子步骤的变化或晚期实现需求？即 稳定中有变化\n面向对象设计原则 代码与技巧不重要，要在这个学习的过程中 建立抽象思维模型\n封装，隐藏内部实现\n继承，复用现有代码\n多态，改写对象行为\n解决复杂性：1.分解，大问题切分成小问题，复杂问题转为多个简单问题2.抽象，使用通用的技术，忽略事物非本质的细节，处理理想的对象模型.\n变化是复用的天敌，面向对象的优势在于抵御变化.\n依赖倒置原则 (DIP)\n高层模块(稳定) 不应该依赖于 低层模块(变化)，二者应该依赖于 抽象(稳定)抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape类有Draw函数 用来画东西，画家类可以使用Shape类画出各种形状，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Shape { public: virtual void Draw() = 0; } class Sphere : public Shape { public: virtual void Draw() override { //画一个圆形.... } } class Box : public Shape { .... } class Painter { public: TArray\u0026lt;Shape*\u0026gt; Shapes; void DrawSomething() { for(auto Shape : Shapes) { Shape-\u0026gt;Draw(); } } } int main() { Shape* SphereDrawer = new Sphere(); Shape* BoxDrawer = new Box(); Painter Painter; Painter.Shapes.add(SphereDrawer,BoxDrawer); // 开始画 Painter.DrawSomething(); //.... } TArray是一个数组，一行add可以添加多个元素。我不想用std::vector 不然要写两行push_back.\n当Sphere的Draw函数需要变化时，例如 添加或者删掉一点东西，或是因为其它原因，函数需要修改，此时Painter并没有被影响到，它的代码不会发生变动，只需要关注Sphere::Draw的修改即可.\n如果要新增一个三角形Triangle，只要继承自Shape类 重写Draw函数就好了，把Triangle传给Painter，就可以调用Draw来画一个三角形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Triangle : public Shape { public: virtual void Draw() override { //画一个三角形.... } } int main() { Shape* TriangleDrawer = new Triangle(); Painter Painter; Painter.Shapes.add(TriangleDrawer); Painter.DrawSomething(); } 新增了一个Triangle类，Painter类并不知道这些，也不需要知道，它只调用抽象类的虚函数就好了。\n高层模块(稳定) 不应该依赖于 底层模块(变化)\nPainter可看做是 高层模块，应该稳定，不依赖于 低层模块，Painter没有因为Sphere的变化而变化.\n抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape作为 抽象(稳定) 层，它的Draw没有依赖于具体的实现细节，使用子类来实现Draw.\n最终隔离变化，在Painter、Shape、Sphere中，变化的部分只有Sphere一个.\n通过这个画画的例子可以理解这句话了 \u0026mdash;\u0026gt; 现代软件设计的特征是“需求的频繁变化”，设计模式的要点是 “寻找变化点，在变化点处应用设计模式”，何时何地使用设计模式，比理解设计模式结构本身更重要.\n开放封闭原则 (OCP)\n对扩展开放，对更改封闭类模块应该是可扩展的，但是不可修改.\n单一职责原则(SRP)\n一个类应该仅有一个变化的原因.变化的方向隐含着类的责任.\nLiskov替换原则(LSP)\n子类必须能够替换它的基类（IS-A)\n继承表达类型抽象。\n接口隔离原则(ISP)\n不应该强迫客户程序依赖它们不用的方法\n接口应该小而完备\n优先使用对象组合，而不是类继承\n继承通常为“白箱复用”，对象组合通常为“黑箱复用”继承在某种程度上破坏了封装性，子类父类耦合度高对象组合则只要求被组合的对象具有良好定义的接口，耦合度低.\n封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响.\n针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某个接口\n客户程序无需知道对象的具体类型，只需要知道对象所具有的接口减少系统中各部分的依赖关系.\n产业强盛的标志 — 接口标准化\n雕版印刷：雕版印刷是在一定厚度的平滑的木板上，粘贴上抄写工整的书稿，薄而近乎透明的稿纸正面和木板相贴，字就成了反体，刻工人用刻刀把版面没有字迹的部分削去，印刷的时候，在凸起的字体上涂上墨汁，然后把纸覆在它的上面，轻轻拂拭纸背，字迹就留在纸上了。\n雕版印刷一版能印几百部甚至几千部书，但是制版很慢，而且有错字不容易更正。\n活字印刷：活字印刷术是一种印刷方法，使用可以移动的木刻字、金属或胶泥字块，用来取代传统的抄写，或是无法重复使用的雕版印刷。活字印刷的方法是先制成单字的阳文反文字模，然后按照稿件把单字挑选出来，排列在字盘内，涂墨印刷，印完后再将字模拆出，留待下次排印时再次使用。\n只印二三本，活字印刷并不比雕版印刷快。如果印成百上千份，工作效率就极其可观了，不仅能够节约大量的人力物力，而且可以大大提高印刷的速度和质量。\n模板方法模式 行为型模式\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n在固定步骤确定的情况下，通过多态机制在多个子类中对每个步骤的细节进行差异化实现。\n你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n下面的代码 基类里的JN_Burn函数是稳定的，执行了一套固定的流程，但是其中的某些步骤可以变化， 可以或必须被子类重写，才能完成整个流程. 总之就是 完形填空\n说白了就是重写虚函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 //父类 class Fighter { public: Fighter(int life, int magic, int attack) :m_life(life), m_magic(magic), m_attack(attack) {} virtual ~Fighter() {} //做父类时析构函数应该为虚函数 //对主角自身会产生影响，对敌人会产生影响。 //分析：对敌人产生影响，有函数effect_enemy。对主角自身产生影响，有函数effect_self。播放技能play_effect函数。 void JN_Burn() //技能“燃烧”,模板方法 { if (canUseJN() == false) //如果不能使用该技能，则直接返回 return; effect_enemy(); //对敌人产生的影响 effect_self(); //对主角自身产生的影响 play_effect(); //播放技能“燃烧”的技能特效 } private: virtual void effect_enemy() {} //函数体为空，表示啥也不做，如果要求必须在子类中重新实现该虚函数，则可以将该函数写成纯虚函数。 virtual void effect_self() {} void play_effect() { cout \u0026lt;\u0026lt; \u0026#34;播放 \\\u0026#34;燃烧\\\u0026#34; 特效\u0026#34; \u0026lt;\u0026lt; endl; //所有主角播放的技能特效都相同，因此不用写成一个虚函数并在子类中实现技能特效的播放。 } virtual bool canUseJN() = 0; //判断是否能使用技能“燃烧”，这是个纯虚函数声明，子类中必须重新实现canUseJN。 protected: //可能被子类访问，所以用protected修饰 //角色属性 int m_life; //生命值 int m_magic; //魔法 int m_attack; //攻击力 }; class F_Warrior :public Fighter { public: F_Warrior(int life, int magic, int attack) :Fighter(life, magic, attack) {} private: //对敌人产生的影响 virtual void effect_enemy() { cout \u0026lt;\u0026lt; \u0026#34;战士主角_让所有敌人每人失去500点生命，相关逻辑代码这里略......\u0026#34; \u0026lt;\u0026lt; endl; } //对主角自身产生的影响 virtual void effect_self() { cout \u0026lt;\u0026lt; \u0026#34;战士主角_自身失去300点生命值\u0026#34; \u0026lt;\u0026lt; endl; m_life -= 300; } virtual bool canUseJN() { if (m_life \u0026lt; 300) //生命值不够300点，不能使用技能“燃烧” return false; return true; } }; //------------------------- //“法师”类，父类为Fighter class F_Mage :public Fighter { public: F_Mage(int life, int magic, int attack) :Fighter(life, magic, attack) {} private: //对敌人产生的影响 virtual void effect_enemy() { cout \u0026lt;\u0026lt; \u0026#34;法师主角_让所有敌人每人失去650点生命，相关逻辑代码这里略......\u0026#34; \u0026lt;\u0026lt; endl; } //对主角自身产生的影响 virtual void effect_self() { cout \u0026lt;\u0026lt; \u0026#34;法师主角_自身失去100点魔法值\u0026#34; \u0026lt;\u0026lt; endl; m_magic -= 100; } virtual bool canUseJN() { if (m_magic \u0026lt; 100) //魔法值不够100点，不能使用技能“燃烧” return false; return true; } }; 输出：\n1 2 3 4 5 6 战士主角_让所有敌人每人失去500点生命，相关逻辑代码这里略...... 战士主角_自身失去300点生命值 播放 \u0026#34;燃烧\u0026#34; 特效 法师主角_让所有敌人每人失去650点生命，相关逻辑代码这里略...... 法师主角_自身失去100点魔法值 播放 \u0026#34;燃烧\u0026#34; 特效 工厂模式 简单工厂模式\nif-else 完了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 抽象产品角色 class Vehicle { public: virtual void drive() const = 0; }; // 具体产品角色 class Car : public Vehicle { public: Car() { std::cout \u0026lt;\u0026lt; \u0026#34;Creating a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Bus : public Vehicle { public: Bus() { std::cout \u0026lt;\u0026lt; \u0026#34;Creating a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 工厂角色 class VehicleFactory { public: static Vehicle* createVehicle(const std::string\u0026amp; type) { if (type == \u0026#34;car\u0026#34;) { return new Car(); } else if (type == \u0026#34;bus\u0026#34;) { return new Bus(); } else { throw std::invalid_argument(\u0026#34;Unknown vehicle type\u0026#34;); } } }; int main() { Vehicle* vehicle = VehicleFactory::createVehicle(\u0026#34;car\u0026#34;); vehicle-\u0026gt;drive(); delete vehicle; return 0; } 特点\n简单工厂模式将创建逻辑集中在一个工厂类中，适合产品类较少且创建逻辑简单的场景。 缺点是扩展性较差，新增产品类时需要修改工厂类的代码。 工厂方法模式 一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; // 抽象产品角色 - Vehicle class Vehicle { public: // 纯虚函数，定义了所有具体产品的接口 virtual void drive() const = 0; // 虚析构函数，确保派生类正确释放资源 virtual ~Vehicle() = default; }; // 具体产品角色 - Car class Car : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体产品角色 - Bus class Bus : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 抽象工厂角色 - VehicleFactory class VehicleFactory { public: // 工厂方法，返回一个抽象产品类型的指针 virtual Vehicle* createVehicle() const = 0; virtual ~VehicleFactory() = default; }; // 具体工厂角色 - CarFactory class CarFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Car; // 返回具体产品对象 } }; // 具体工厂角色 - BusFactory class BusFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Bus; // 返回具体产品对象 } }; int main() { // 创建CarFactory实例 VehicleFactory* carFactory = new CarFactory; Vehicle* car = carFactory-\u0026gt;createVehicle(); car-\u0026gt;drive(); // 输出: Driving a car. // 创建BusFactory实例 VehicleFactory* busFactory = new BusFactory; Vehicle* bus = busFactory-\u0026gt;createVehicle(); bus-\u0026gt;drive(); // 输出: Driving a bus. return 0; } 先搞结论，费这么大劲在干神魔？\nmain函数里面 虽然实际上创建了car和bus两个类，但是在整个main的代码里面，没有出现car和bus的具体类只有两个抽象的Vehicle类，没有依赖到具体类，\n扩展性:\n工厂方法模式使得系统更容易扩展新的产品类型和相应的工厂类,如果需要添加一种新的交通工具（例如自行车 Bike），只需创建一个新的具体产品类 Bike 和一个新的具体工厂类 BikeFactory,现有代码不需要做任何修改。符合开闭原则（OCP），即对扩展开放，对修改封闭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Bike : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Riding a bike.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class BikeFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Bike; } }; 封装性:\n工厂方法模式通过封装对象的创建过程，将创建逻辑与使用逻辑分离，隐藏了对象创建的具体细节。\nVehicleFactory 抽象类定义了一个接口 createVehicle()，而具体的工厂类（如 CarFactory 和 BusFactory）实现了这个接口。客户端只需要调用 createVehicle() 方法即可获得一个 Vehicle 对象，无需关心具体的创建逻辑。\n遵循设计原则\n开闭原则（OCP）: 如前所述，系统可以通过添加新的产品和工厂类来扩展功能，而无需修改现有代码。 依赖倒置原则（DIP）: 客户端依赖于抽象接口（如 VehicleFactory 和 Vehicle），而不是具体的实现类。这使得系统的层次结构更加清晰，减少了模块间的依赖关系。 里氏替换原则（LSP）: 子类可以替代父类出现的地方而不影响程序的正确性。在我们的例子中，Car 和 Bus 可以替代 Vehicle 出现在任何需要 Vehicle 的地方。 new 还是 factory ?\n工厂方法模式\n优点：\n解耦：将对象的创建与使用分离，降低代码耦合度。 扩展性：新增产品类时，只需扩展工厂类，无需修改现有代码，符合开闭原则。 多态性：通过工厂方法返回基类指针或引用，支持运行时多态。 缺点：\n复杂性：增加了类的数量，代码结构更复杂。 性能开销：间接创建对象可能带来轻微性能损失。 new\n优点：\n简单直接：代码直观，易于理解。 性能：直接创建对象，无额外开销。 缺点：\n耦合度高：对象的创建与使用紧密耦合，修改时可能影响其他代码。 扩展性差：新增类时需要修改多处代码，违反开闭原则。 灵活性低：难以在运行时动态切换对象类型。 使用new创建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Product { public: virtual void use() = 0; }; class ConcreteProduct : public Product { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Product* Pro = new ConcreteProduct; // 用抽象类指针接收具体类对象 Pro-\u0026gt;use(); delete Pro; return 0; } 多态性：通过抽象类指针调用具体类的实现，实现了运行时多态。 直接依赖：main函数直接依赖具体类ConcreteProduct，需要显式地写出new ConcreteProduct。 耦合性：main函数与ConcreteProduct类耦合，如果将来需要替换为其他具体类，需要修改main函数。 使用工厂模式创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Product { public: virtual void use() = 0; }; class ConcreteProduct : public Product { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; endl; } }; class Factory { public: virtual Product* createProduct() = 0; }; class ConcreteFactory : public Factory { public: Product* createProduct() override { return new ConcreteProduct(); } }; int main() { Factory* factory = new ConcreteFactory(); // 创建具体工厂 Product* Pro = factory-\u0026gt;createProduct(); // 通过工厂创建对象 Pro-\u0026gt;use(); delete Pro; // 释放对象 delete factory; // 释放工厂 return 0; } 特点\n解耦：main函数只依赖抽象工厂和抽象产品，不依赖具体类。 扩展性：如果需要创建新的具体类，只需新增一个具体工厂和具体产品类，无需修改main函数。 灵活性：可以通过切换工厂来动态创建不同的具体对象。 区别对比\n特性 直接使用new创建对象 工厂方法模式 耦合性 main函数直接依赖具体类（ConcreteProduct） main函数只依赖抽象工厂和抽象产品，不依赖具体类 扩展性 修改具体类时需要修改main函数 新增具体类时只需扩展工厂，无需修改main函数 灵活性 无法动态切换具体类 可以通过切换工厂动态创建不同对象 代码复杂度 简单直接，代码量少 增加了工厂类，代码结构更复杂 运行时多态 支持（通过抽象类指针调用具体类方法） 支持（通过抽象类指针调用具体类方法） 总结\n如果代码规模较小，且不需要频繁扩展或修改具体类，直接使用new创建对象是更简单直接的选择。 如果需要解耦、扩展性和灵活性，工厂方法模式是更好的选择，尽管它会增加一些代码复杂性。 在示例中，虽然通过抽象类指针实现了多态，但仍然存在耦合性问题。如果未来需要替换ConcreteProduct为其他类，仍需修改main函数。而工厂方法模式可以避免这个问题。\n抽象工厂模式 一种创建型设计模式，它提供了一个接口用于创建一系列相关或依赖的对象，而无需指定它们的具体类。与工厂方法模式不同，抽象工厂模式关注的是产品族（一组相关的产品），而不是单一产品。\n假设正在开发一个跨平台的 UI 库，需要支持两种操作系统：Windows 和 macOS。每个操作系统有不同的按钮（Button）和文本框（TextBox）。需要通过抽象工厂模式来创建这些 UI 组件，确保客户端代码与具体平台解耦。\n产品抽象类 Button 和 TextBox。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 抽象产品：按钮 class Button { public: virtual void render() = 0; virtual ~Button() = default; }; // 抽象产品：文本框 class TextBox { public: virtual void render() = 0; virtual ~TextBox() = default; }; 定义具体产品类\n为每个平台实现具体的产品类。\nWindows\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Windows 按钮 class WindowsButton : public Button { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a button in Windows style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Windows 文本框 class WindowsTextBox : public TextBox { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a text box in Windows style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; mac\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // macOS 按钮 class MacOSButton : public Button { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a button in macOS style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // macOS 文本框 class MacOSTextBox : public TextBox { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a text box in macOS style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 定义抽象工厂类\n抽象工厂类定义了创建一组相关产品的方法。\n1 2 3 4 5 6 class GUIFactory { public: virtual Button* createButton() = 0; virtual TextBox* createTextBox() = 0; virtual ~GUIFactory() = default; }; Windows\n1 2 3 4 5 6 7 8 9 10 class WindowsFactory : public GUIFactory { public: Button* createButton() override { return new WindowsButton(); } TextBox* createTextBox() override { return new WindowsTextBox(); } }; mac\n1 2 3 4 5 6 7 8 9 10 class MacOSFactory : public GUIFactory { public: Button* createButton() override { return new MacOSButton(); } TextBox* createTextBox() override { return new MacOSTextBox(); } }; 客户端代码\n客户端代码通过抽象工厂创建一组相关的产品，而无需关心具体平台。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Application { private: GUIFactory* factory; Button* button; TextBox* textBox; public: Application(GUIFactory* factory) : factory(factory), button(nullptr), textBox(nullptr) {} void createUI() { button = factory-\u0026gt;createButton(); textBox = factory-\u0026gt;createTextBox(); } void renderUI() { if (button) button-\u0026gt;render(); if (textBox) textBox-\u0026gt;render(); } ~Application() { delete button; delete textBox; delete factory; } }; int main() { // 创建 Windows 风格的 UI GUIFactory* windowsFactory = new WindowsFactory(); Application windowsApp(windowsFactory); windowsApp.createUI(); windowsApp.renderUI(); // 创建 macOS 风格的 UI GUIFactory* macFactory = new MacOSFactory(); Application macApp(macFactory); macApp.createUI(); macApp.renderUI(); return 0; } 输出：\n1 2 3 4 Rendering a button in Windows style. Rendering a text box in Windows style. Rendering a button in macOS style. Rendering a text box in macOS style. 只有一个Application类，但是通过不同的工厂方法，可以填充出不同风格的Application.\n抽象产品类：\nButton 和 TextBox 是抽象基类，定义了 UI 组件的通用接口。 具体产品类：\nWindowsButton 和 WindowsTextBox 是 Windows 平台的具体实现。 MacOSButton 和 MacOSTextBox 是 macOS 平台的具体实现。 抽象工厂类：\nGUIFactory 定义了创建一组相关产品（按钮和文本框）的接口。 具体工厂类：\nWindowsFactory 和 MacOSFactory 分别实现了 Windows 和 macOS 平台的具体工厂。 客户端代码：\nApplication 类通过抽象工厂创建一组相关的 UI 组件，并调用它们的 render 方法。 客户端代码与具体平台解耦，只需切换工厂即可创建不同平台的 UI 组件。 优点\n解耦： 客户端代码只依赖抽象工厂和抽象产品，不依赖具体平台。 一致性： 确保创建的一组产品属于同一平台（如 Windows 或 macOS）。 扩展性： 新增平台时，只需添加新的具体工厂和具体产品类，无需修改现有代码。 缺点\n复杂性： 增加了类的数量，代码结构更复杂。 不易扩展新产品： 如果需要在抽象工厂中新增一个产品（如 Checkbox），需要修改所有具体工厂类。 适用场景\n需要创建一组相关或依赖的对象。 系统需要支持多个产品族（如多个平台、多个主题）。 客户端代码需要与具体产品的创建过程解耦。 原型模式 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n它允许通过复制现有对象来创建新对象，而不是通过构造函数 实例化类来创建。这种模式特别适用于创建复杂对象或当创建过程非常耗时、资源密集时。通过克隆（Clone）来创建对象，避免了直接依赖具体类。\n原型模式适用于以下场景：\n当对象的创建成本较高（例如需要复杂的初始化过程），而复制现有对象更高效时。 当系统需要动态地创建对象，且对象的类型在运行时才能确定时。 当需要避免使用new关键字直接创建对象，以减少耦合性。 假设正在开发一个图形编辑器，支持绘制多种形状（如圆形、矩形）。每种形状都是一个对象，且对象的创建成本较高（例如需要加载资源或初始化复杂状态）。可以使用原型模式，通过克隆现有对象来创建新对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 抽象原型类 class Shape { public: virtual ~Shape() = default; virtual Shape* clone() const = 0; // 克隆方法 virtual void draw() const = 0; // 绘制方法 }; class Circle : public Shape { private: int radius; public: Circle(int radius) : radius(radius) { std::cout \u0026lt;\u0026lt; \u0026#34;Circle构造 Radius:\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } // 显式定义拷贝构造函数 Circle(const Circle\u0026amp; other) : radius(other.radius) { std::cout \u0026lt;\u0026lt; \u0026#34;Circle克隆 Radius:\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } // 实现克隆方法 Shape* clone() const override { return new Circle(*this); // 使用拷贝构造函数克隆对象 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; class Rectangle : public Shape { private: int width, height; public: Rectangle(int width, int height) : width(width), height(height) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle构造 Width:\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; Height:\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } Rectangle(const Rectangle\u0026amp; other) : width(other.width), height(other.height) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle克隆 Width:\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; Height:\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } // 实现克隆方法 Shape* clone() const override { return new Rectangle(*this); // 使用拷贝构造函数克隆对象 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a rectangle with width \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; and height \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建原型对象 Shape* circlePrototype = new Circle(10); Shape* rectanglePrototype = new Rectangle(20, 30); // 克隆原型对象 Shape* circleClone = circlePrototype-\u0026gt;clone(); Shape* rectangleClone = rectanglePrototype-\u0026gt;clone(); // 使用克隆对象 circleClone-\u0026gt;draw(); rectangleClone-\u0026gt;draw(); return 0; } 优点\n高效创建对象： 当对象的创建成本较高时，通过克隆现有对象可以避免重复初始化。 动态创建对象： 可以在运行时动态地创建对象，而无需依赖具体类。 减少耦合性： 客户端代码只依赖抽象原型类，不依赖具体类。 缺点\n深拷贝问题： 如果对象包含指针或动态分配的资源，需要实现深拷贝，否则克隆对象会共享资源。 复杂性增加： 需要为每个类实现clone方法，增加了代码的复杂性。 扩展：深拷贝\n浅拷贝是指创建一个新的对象，并将原始对象中的成员变量的值复制到新对象中。如果成员变量是基本数据类型（如int, float, char等），则直接复制其值；如果成员变量是指针或引用，则仅复制指针或引用的地址，而不是所指向的对象。\n浅拷贝只复制了指针的地址，因此新对象和原对象共享同一块内存区域。如果两个对象共享同一块内存区域，在一个对象中修改这块内存的内容会影响另一个对象。此外，当其中一个对象被销毁时，可能会导致悬挂指针（dangling pointer）问题，因为另一个对象仍然持有已释放内存的指针。\n深拷贝是指创建一个新的对象，并且递归地复制所有成员变量，包括指针指向的对象。这意味着每个对象都有自己的独立副本，不会共享任何资源。\n深拷贝为每个对象分配独立的内存区域，确保每个对象都有自己的数据副本。由于每个对象都有自己的独立副本，因此在一个对象中修改数据不会影响其他对象，也不会出现悬挂指针的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ComplexShape : public Shape { private: int* data; // 动态分配的资源 public: ComplexShape(int value) { data = new int(value); } // 深拷贝构造函数 ComplexShape(const ComplexShape\u0026amp; other) { data = new int(*other.data); // 深拷贝 } // 实现克隆方法 std::unique_ptr\u0026lt;Shape\u0026gt; clone() const override { return std::make_unique\u0026lt;ComplexShape\u0026gt;(*this); // 使用深拷贝构造函数 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a complex shape with data \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } ~ComplexShape() { delete data; // 释放资源 } }; 特性 浅拷贝 深拷贝 基本数据类型 直接复制值 直接复制值 指针/引用类型 复制指针地址，共享同一块内存区域 分配新的内存区域，并复制指针指向的数据 资源管理 共享资源，可能导致悬挂指针问题 独立资源，安全可靠 性能 性能较高，只需复制指针地址 性能较低，需要分配新内存并复制数据 适用场景 对象没有复杂嵌套结构或不需要独立副本的情况 对象包含复杂嵌套结构或需要完全独立副本的情况 建造者模式 建造者模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n建造者模式适用于以下场景：\n当对象的创建过程非常复杂，包含多个步骤时。 当需要创建的对象有不同的表示，但构建过程相似时。 当希望将对象的构建过程与表示解耦时。 示例场景\n假设正在开发一个游戏，需要创建不同类型的角色（如英雄、怪物）。每个角色有多个属性（如名字、职业、武器、盔甲等），且这些属性的设置过程可能非常复杂。可以使用建造者模式来分离角色的构建过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; // 角色类（产品） class Character { public: Character() { std::cout \u0026lt;\u0026lt; \u0026#34;Character created\u0026#34; \u0026lt;\u0026lt; std::endl; } void setName(const std::string\u0026amp; name) { this-\u0026gt;name = name; } void setClass(const std::string\u0026amp; className) { this-\u0026gt;className = className; } void setWeapon(const std::string\u0026amp; weapon) { this-\u0026gt;weapon = weapon; } void setArmor(const std::string\u0026amp; armor) { this-\u0026gt;armor = armor; } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;-------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Class: \u0026#34; \u0026lt;\u0026lt; className \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Weapon: \u0026#34; \u0026lt;\u0026lt; weapon \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Armor: \u0026#34; \u0026lt;\u0026lt; armor \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;-------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::string name; std::string className; std::string weapon; std::string armor; }; // 抽象建造者 class CharacterBuilder { public: virtual ~CharacterBuilder() = default; virtual void buildName() = 0; virtual void buildClass() = 0; virtual void buildWeapon() = 0; virtual void buildArmor() = 0; virtual std::unique_ptr\u0026lt;Character\u0026gt; getResult() = 0; }; // 英雄建造者 class HeroBuilder : public CharacterBuilder { public: HeroBuilder() { character = std::make_unique\u0026lt;Character\u0026gt;(); // 使用智能指针 } void buildName() override { character-\u0026gt;setName(\u0026#34;Arthur\u0026#34;); } void buildClass() override { character-\u0026gt;setClass(\u0026#34;Knight\u0026#34;); } void buildWeapon() override { character-\u0026gt;setWeapon(\u0026#34;Sword\u0026#34;); } void buildArmor() override { character-\u0026gt;setArmor(\u0026#34;Plate Armor\u0026#34;); } std::unique_ptr\u0026lt;Character\u0026gt; getResult() override { return std::move(character); // 转移所有权 } private: std::unique_ptr\u0026lt;Character\u0026gt; character; }; // 怪物建造者 class MonsterBuilder : public CharacterBuilder { public: MonsterBuilder() { character = std::make_unique\u0026lt;Character\u0026gt;(); // 使用智能指针 } void buildName() override { character-\u0026gt;setName(\u0026#34;Goblin\u0026#34;); } void buildClass() override { character-\u0026gt;setClass(\u0026#34;Enemy\u0026#34;); } void buildWeapon() override { character-\u0026gt;setWeapon(\u0026#34;Claws\u0026#34;); } void buildArmor() override { character-\u0026gt;setArmor(\u0026#34;Leather Armor\u0026#34;); } std::unique_ptr\u0026lt;Character\u0026gt; getResult() override { return std::move(character); // 转移所有权 } private: std::unique_ptr\u0026lt;Character\u0026gt; character; }; // 指挥者 class CharacterDirector { public: void setBuilder(CharacterBuilder* builder) { this-\u0026gt;builder = builder; } std::unique_ptr\u0026lt;Character\u0026gt; construct() { builder-\u0026gt;buildName(); builder-\u0026gt;buildClass(); builder-\u0026gt;buildWeapon(); builder-\u0026gt;buildArmor(); return builder-\u0026gt;getResult(); } private: CharacterBuilder* builder; }; int main() { // 创建建造者和指挥者 HeroBuilder heroBuilder; MonsterBuilder monsterBuilder; CharacterDirector director; // 构建英雄角色 director.setBuilder(\u0026amp;heroBuilder); auto hero = director.construct(); hero-\u0026gt;display(); // 构建怪物角色 director.setBuilder(\u0026amp;monsterBuilder); auto monster = director.construct(); monster-\u0026gt;display(); return 0; } 优点\n分离构建过程与表示： 将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。 更好的控制构建过程： 指挥者类可以精确控制构建过程。 代码复用： 可以复用相同的构建过程来创建不同的产品。 缺点\n增加代码复杂性： 需要定义多个类（建造者、指挥者等），增加了代码的复杂性。 适用于复杂对象： 如果对象非常简单，使用建造者模式可能会显得过度设计。 策略模式 策略是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。\n方便应对多重switch case 或 if else，随时间推移，switch 或 if中的代码需要扩展，写的越来越多，代码很长.\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n计算税，每个国家的税不同，计算方法不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 enum TaxBase { CN_Tax; US_Tax; DE_Tax }; class SalesOrder { TexBase Tax; public: double CalcTax() { if(Tex == CN_Tex) { } else if(Tex == US_Tax) { } else if(Tex == DE_Tax) { } //..... } } 每增加一个国家的计算方法，enum TexBase就要扩充一个枚举值，CalcTax要多一套if else.如果随着时间推移，后续增加的计算方法越多，代码越来越长，极端情况下 Cache甚至放不下代码，一部分代码需要放到内存 甚至是虚拟内存(硬盘)中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class TexStrategy { public: virtual double Calc(const Context\u0026amp; context) = 0; virtual ~TexStrategy(){} } class CNTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class USTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class DETax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class SalesOrder { private: TexStrategy* Strategy; public: SalesOrder(TexStrategy* InStrategy) : Strategy(InStrategy){} ~SalesOrder() { delete Strategy; } double CalcTex() { //.... Context context; double Tex = Strategy-\u0026gt;Calc(context); //..... return Tex; } } 需要扩充计算方法时，只要继承TexStrategy 写一个新的类即可，就能完成新的税种计算.SalesOrder是不需要修改的. 对于新增的类，甚至可以使用增量编译 单独编译一个dll.\n以上代码只是说明一个大概情况，下面的代码是可运行的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Strategy { public: virtual ~Strategy() = default; virtual std::string doAlgorithm(std::string_view data) const = 0; }; class Context { private: std::unique_ptr\u0026lt;Strategy\u0026gt; strategy_; public: explicit Context(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy = {}) : strategy_(std::move(strategy)) { } void set_strategy(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy) { strategy_ = std::move(strategy); } void doSomeBusinessLogic() const { if (strategy_) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = strategy_-\u0026gt;doAlgorithm(\u0026#34;aecbd\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Strategy isn\u0026#39;t set\\n\u0026#34;; } } }; class ConcreteStrategyA : public Strategy { public: std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result), std::greater\u0026lt;\u0026gt;()); return result; } }; void clientCode() { Context context(std::make_unique\u0026lt;ConcreteStrategyA\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context.doSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context.set_strategy(std::make_unique\u0026lt;ConcreteStrategyB\u0026gt;()); context.doSomeBusinessLogic(); } int main() { clientCode(); return 0; } 输出结果\n1 2 3 4 5 6 7 Client: Strategy is set to normal sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) abcde Client: Strategy is set to reverse sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) edcba 这种设计模式 可以在运行时更改对象的算法，将算法和对象本身解耦. 对于这个例子，分辨出哪里是稳定的，哪里是变化的，算法可以通过扩展子类的方式 独立出来进行变化.\n有时候支持不使用的算法也是负担，例如 在计算税的if else版本的代码里，程序安装在America 只需要使用America部分，其它的if都是不必要的，代码在运行时 要加载到Cache、内存， 但是要使用的代码只有其中一小部分，所以其余的代码都是多余加载的。 使用策略模式可以顺便缓解这个情况.\n观察者模式 一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并自动更新。\n观察者模式的核心思想\n主题（Subject）：被观察的对象，维护一个观察者列表，并提供添加、删除和通知观察者的方法。 观察者（Observer）：接收主题通知的接口，通常包含一个 update 方法，用于接收主题的状态变化。 具体主题（Concrete Subject）：实现主题接口的具体类，负责管理状态并在状态变化时通知所有观察者。 具体观察者（Concrete Observer）：实现观察者接口的具体类，接收来自主题的通知并进行相应的处理。 按钮响应事件 当用户点击该按钮时，需要通知所有注册的监听器执行相应的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 观察者接口 class ButtonListener { public: virtual void onClick() = 0; }; // 主题类 - 按钮 class Button { private: std::vector\u0026lt;ButtonListener*\u0026gt; listeners; public: void addListener(ButtonListener* listener) { listeners.push_back(listener); } void notifyListeners() { for (auto* listener : listeners) { listener-\u0026gt;onClick(); } } void click() { std::cout \u0026lt;\u0026lt; \u0026#34;Button clicked!\u0026#34; \u0026lt;\u0026lt; std::endl; notifyListeners(); } }; // 具体观察者类 - ListenerA 和 ListenerB class ListenerA : public ButtonListener { public: void onClick() override { std::cout \u0026lt;\u0026lt; \u0026#34;Listener A: Handling button click event.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class ListenerB : public ButtonListener { public: void onClick() override { std::cout \u0026lt;\u0026lt; \u0026#34;Listener B: Handling button click event.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Button button; ListenerA listenerA; ListenerB listenerB; button.addListener(\u0026amp;listenerA); button.addListener(\u0026amp;listenerB); // 模拟点击按钮 button.click(); return 0; } 这不就是在Button类里面放一个vector，vector里面又存放了ButtonListener的基类，按下按钮时，遍历vector，逐个通知ButtonListener的onClick.\n新闻订阅服务 模拟一个新闻订阅服务，用户可以订阅不同的新闻主题。当有新的新闻更新时，所有订阅了该主题的用户都会收到通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; // 观察者接口 class NewsSubscriber { public: virtual void update(const std::string\u0026amp; news) = 0; }; // 主题类 - 新闻发布者 class NewsPublisher { private: std::unordered_map\u0026lt;std::string, std::vector\u0026lt;NewsSubscriber*\u0026gt;\u0026gt; subscribers; public: void subscribe(const std::string\u0026amp; topic, NewsSubscriber* subscriber) { subscribers[topic].push_back(subscriber); } void unsubscribe(const std::string\u0026amp; topic, NewsSubscriber* subscriber) { auto it = subscribers.find(topic); if (it != subscribers.end()) { auto\u0026amp; list = it-\u0026gt;second; list.erase(std::remove(list.begin(), list.end(), subscriber), list.end()); } } void notifySubscribers(const std::string\u0026amp; topic, const std::string\u0026amp; news) { auto it = subscribers.find(topic); if (it != subscribers.end()) { for (auto* sub : it-\u0026gt;second) { sub-\u0026gt;update(news); } } } void publishNews(const std::string\u0026amp; topic, const std::string\u0026amp; news) { std::cout \u0026lt;\u0026lt; \u0026#34;Publishing news on \u0026#34; \u0026lt;\u0026lt; topic \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; notifySubscribers(topic, news); } }; // 具体观察者类 - SubscriberA 和 SubscriberB class SubscriberA : public NewsSubscriber { public: void update(const std::string\u0026amp; news) override { std::cout \u0026lt;\u0026lt; \u0026#34;Subscriber A received news: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; } }; class SubscriberB : public NewsSubscriber { public: void update(const std::string\u0026amp; news) override { std::cout \u0026lt;\u0026lt; \u0026#34;Subscriber B received news: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; } }; int main() { NewsPublisher publisher; SubscriberA subscriberA; SubscriberB subscriberB; publisher.subscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberA); publisher.subscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberB); publisher.publishNews(\u0026#34;Technology\u0026#34;, \u0026#34;New tech breakthrough!\u0026#34;); std::cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;\u0026lt;\u0026lt;std::endl; publisher.unsubscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberA); publisher.publishNews(\u0026#34;Technology\u0026#34;, \u0026#34;New tech AA!\u0026#34;); return 0; } 输出：\n1 2 3 4 5 6 Publishing news on Technology: New tech breakthrough! Subscriber A received news: New tech breakthrough! Subscriber B received news: New tech breakthrough! Publishing news on Technology: New tech AA! Subscriber B received news: New tech AA! 状态监控 模拟一个环境监测系统，它会根据传感器的数据变化来通知多个显示组件进行更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 观察者接口 class SensorObserver { public: virtual void onUpdate(float temperature, float humidity) = 0; }; // 主题类 - 传感器 class EnvironmentSensor { private: std::vector\u0026lt;SensorObserver*\u0026gt; observers; float temperature; float humidity; public: void addObserver(SensorObserver* observer) { observers.push_back(observer); } void removeObserver(SensorObserver* observer) { observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); } void notifyObservers() { for (auto* observer : observers) { observer-\u0026gt;onUpdate(temperature, humidity); } } void setMeasurements(float temperature, float humidity) { this-\u0026gt;temperature = temperature; this-\u0026gt;humidity = humidity; notifyObservers(); } }; // 具体观察者类 - DisplayA 和 DisplayB class DisplayA : public SensorObserver { public: void onUpdate(float temperature, float humidity) override { std::cout \u0026lt;\u0026lt; \u0026#34;Display A: Temperature is \u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;F and Humidity is \u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class DisplayB : public SensorObserver { public: void onUpdate(float temperature, float humidity) override { std::cout \u0026lt;\u0026lt; \u0026#34;Display B: Current readings are Temp=\u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;F, Humidity=\u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { EnvironmentSensor sensor; DisplayA displayA; DisplayB displayB; sensor.addObserver(\u0026amp;displayA); sensor.addObserver(\u0026amp;displayB); sensor.setMeasurements(75.0f, 60.0f); // 更新传感器数据 return 0; } 输出：\n1 2 Display A: Temperature is 75F and Humidity is 60% Display B: Current readings are Temp=75F, Humidity=60% 函数指针 使用C++函数指针实现观察者模式是一种相对直接的方法，它允许你定义一个或多个回调函数来响应特定事件。下面是一个简单的示例，演示了如何使用C++函数指针实现观察者模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 定义一个Subject类，用于管理观察者的注册和通知 class Subject { public: // 注册观察者（函数指针） void registerObserver(void (*observer)(std::string)) { observers.push_back(observer); } // 通知所有注册的观察者 void notifyObservers(std::string message) { for (auto observer : observers) { observer(message); } } private: std::vector\u0026lt;void(*)(std::string)\u0026gt; observers; // 存储所有观察者函数指针 }; // 定义两个观察者函数 void observer1(std::string message) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer 1 received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } void observer2(std::string message) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer 2 received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } int main() { Subject subject; // 注册观察者 subject.registerObserver(observer1); subject.registerObserver(observer2); // 发生某个事件，通知所有观察者 subject.notifyObservers(\u0026#34;Event occurred!\u0026#34;); return 0; } 装饰模式 一种结构型设计模式，它允许动态地给对象添加功能，而无需修改其原始类。通过这种方式，可以在运行时为对象增加新的行为，同时保持代码的简洁性和灵活性。\n装饰模式的核心思想\n组件接口：定义了可以被装饰的对象的基础接口。 具体组件：实现了组件接口的基本功能。 装饰器基类：持有一个对组件接口的引用，并实现相同的接口，以确保可以像处理原始组件一样处理装饰器。 具体装饰器：扩展或修改组件的行为，通常通过在其方法中调用被装饰对象的方法，然后添加额外的功能。 角色能力增强： 在游戏中，玩家可以通过拾取道具或完成任务来获得新的能力或增强现有能力。例如，角色可以拾取一个加速道具，或者穿上一件增加防御力的盔甲。 武器升级： 玩家可以在游戏中找到不同的配件来升级他们的武器，如安装瞄准镜、消音器等。这些升级可以动态地改变武器的属性。 状态效果（Buff/Debuff）： 游戏中的角色可能会受到各种状态效果的影响，如中毒、燃烧、隐身等。这些状态效果可以在运行时动态地附加到角色上，并根据需要移除。 图形特效： 为了增强游戏的视觉效果，某些物品或技能可以给角色添加特殊的图形特效，如光环、粒子效果等。 要设计一个咖啡店系统，其中不同种类的咖啡可以通过添加调料（如糖、牛奶等）来定制。可以使用装饰模式来动态地给咖啡添加调料，而不需要创建大量的子类。\n继承实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 组件接口 - Beverage class Beverage { public: virtual ~Beverage() = default; virtual std::string getDescription() const = 0; virtual double cost() const = 0; }; // 具体组件 - Espresso class Espresso : public Beverage { public: std::string getDescription() const override { return \u0026#34;Espresso\u0026#34;; } double cost() const override { return 1.99; } }; // 装饰器基类 - CondimentDecorator class CondimentDecorator : public Beverage { protected: Beverage* beverage; public: explicit CondimentDecorator(Beverage* beverage) : beverage(beverage) {} }; // 具体装饰器 - Milk class Milk : public CondimentDecorator { public: explicit Milk(Beverage* beverage) : CondimentDecorator(beverage) {} std::string getDescription() const override { return beverage-\u0026gt;getDescription() + \u0026#34;, Milk\u0026#34;; } double cost() const override { return beverage-\u0026gt;cost() + 0.25; } }; // 具体装饰器 - Sugar class Sugar : public CondimentDecorator { public: explicit Sugar(Beverage* beverage) : CondimentDecorator(beverage) {} std::string getDescription() const override { return beverage-\u0026gt;getDescription() + \u0026#34;, Sugar\u0026#34;; } double cost() const override { return beverage-\u0026gt;cost() + 0.15; } }; int main() { // 创建基础饮料 Beverage* beverage = new Espresso(); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; // 添加装饰器 beverage = new Milk(beverage); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; beverage = new Sugar(beverage); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; // 清理资源 delete beverage; return 0; } 套娃，一层套一层，调用getDescription() 或 cost() 都是逐层调用的，\n输出：\n1 2 3 4 5 6 7 8 Description: Espresso Cost: $1.99 Description: Espresso, Milk Cost: $2.24 Description: Espresso, Milk, Sugar Cost: $2.39 初始状态\nbeverage 指向 Espresso 对象。 调用 beverage-\u0026gt;getDescription() 返回 \u0026quot;Espresso\u0026quot;。 调用 beverage-\u0026gt;cost() 返回 1.99。 1 2 beverage-\u0026gt;getDescription() -\u0026gt; Espresso::getDescription() -\u0026gt; \u0026#34;Espresso\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Espresso::cost() -\u0026gt; 1.99 第一次装饰：添加 Milk\n创建一个新的 Milk 对象，并将 Espresso 对象传递给它的构造函数。 新的 Milk 对象内部持有一个指向 Espresso 对象的指针。 调用 beverage-\u0026gt;getDescription() 实际上调用了 Milk::getDescription()，该方法会调用 beverage-\u0026gt;getDescription()（即 Espresso::getDescription()），并附加 \u0026quot;Milk\u0026quot;。 调用 beverage-\u0026gt;cost() 实际上调用了 Milk::cost()，该方法会调用 beverage-\u0026gt;cost()（即 Espresso::cost()），并加上 0.25。 此时，beverage 指向的是 Milk 对象，而 Milk 对象内部持有对 Espresso 对象的引用。\n1 2 3 4 5 6 7 beverage-\u0026gt;getDescription() -\u0026gt; Milk::getDescription() -\u0026gt; Espresso::getDescription() + \u0026#34;, Milk\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Milk::cost() -\u0026gt; Espresso::cost() + 0.25 -\u0026gt; 1.99 + 0.25 = 2.24 第二次装饰：添加 Sugar\n创建一个新的 Sugar 对象，并将 Milk 对象传递给它的构造函数。\n新的 Sugar 对象内部持有一个指向 Milk 对象的指针。\n调用 beverage-\u0026gt;getDescription() 实际上调用了 Sugar::getDescription()，该方法会调用 beverage-\u0026gt;getDescription()（即 Milk::getDescription()），并附加 \u0026quot;Sugar\u0026quot;。\n调用 beverage-\u0026gt;cost() 实际上调用了 Sugar::cost()，该方法会调用 beverage-\u0026gt;cost()（即 Milk::cost()），并加上 0.15。\n此时，beverage 指向的是 Sugar 对象，而 Sugar 对象内部持有对 Milk 对象的引用，Milk 对象内部持有对 Espresso 对象的引用。\n1 2 3 4 5 6 7 8 9 10 beverage-\u0026gt;getDescription() -\u0026gt; Sugar::getDescription() -\u0026gt; Milk::getDescription() + \u0026#34;, Sugar\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk\u0026#34; + \u0026#34;, Sugar\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk, Sugar\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Sugar::cost() -\u0026gt; Milk::cost() + 0.15 -\u0026gt; (Espresso::cost() + 0.25) + 0.15 -\u0026gt; 1.99 + 0.25 + 0.15 = 2.39 单例模式 一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例。单例模式通常用于需要控制资源（如数据库连接、配置设置、日志记录器等）的场景，以避免重复创建多个实例带来的资源浪费或不一致状态。\n使用单例模式 首先要确保 真的需要这个模式吗？\n单例模式的核心要素\n私有构造函数：防止外部通过 new 操作符创建对象。 静态方法：提供一个全局访问点来获取唯一实例。 静态成员变量：保存该类的唯一实例。 线程安全：在多线程环境下，确保实例化过程是线程安全的。 方法 说明 饿汉式 简单直接，但可能造成资源浪费。 线程安全。 懒汉式 延迟初始化，节省资源。 需要额外处理线程安全问题。 双重检查锁定 解决了懒汉式在多线程环境下的线程安全问题。 代码较为复杂。在多线程下，受内存访问重新排序影响，可能会出现致命问题，需要额外处理 使用智能指针 自动管理内存，避免手动释放资源。 使用 std::call_once 确保线程安全。 静态局部变量 最简单且线程安全，推荐指数:☆☆☆☆☆☆☆☆☆☆☆ 表格列举的方法都图一乐，真正使用的话 推荐使用线程安全的，例如：饿汉式、静态局部变量法。\n饿汉式 饿汉式是最简单的单例模式实现方式，它在类加载时就初始化实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class Logger { private: static Logger instance; // 静态成员变量，存储唯一实例 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { return instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; // 定义静态成员变量 Logger Logger::instance; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); return 0; } 优点：\n实现简单，线程安全（因为实例在类加载时就已经创建）。 缺点：\n如果实例从未被使用，仍然会占用资源。 懒汉式 懒汉式是在第一次调用 getInstance 方法时才创建实例，这样可以避免不必要的资源浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; class Logger { private: static Logger* instance; // 静态指针，指向唯一实例 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { if (instance == nullptr) { instance = new Logger(); } return *instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { delete instance; instance = nullptr; } }; // 定义静态成员变量 Logger* Logger::instance = nullptr; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); // 清理资源 Logger::destroyInstance(); return 0; } 优点：\n延迟实例化，节省资源。 缺点：\n不是线程安全的，如果在多线程环境中同时调用 getInstance，可能会创建多个实例。 双重检查锁定 为了解决懒汉式在多线程环境下的线程安全问题，可以使用双重检查锁定机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Logger { private: static Logger* instance; // 静态指针，指向唯一实例 static std::mutex mutex; // 互斥锁，保证线程安全 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { if (instance == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (instance == nullptr) { instance = new Logger(); } } return *instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); delete instance; instance = nullptr; } }; // 定义静态成员变量 Logger* Logger::instance = nullptr; std::mutex Logger::mutex; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); // 清理资源 Logger::destroyInstance(); return 0; } 优点：\n在多线程环境下保证了线程安全。 通过双重检查减少了加锁的开销。 缺点：\n代码相对复杂一些。 不安全，reorder内存访问重新排序导致双重锁定失效问题。 双重检查修复 使用atomic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Logger { private: static std::atomic\u0026lt;Logger*\u0026gt; instance; // 使用 atomic 指针管理实例 static std::mutex mutex; // 互斥锁，保证线程安全 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { Logger* tmp = instance.load(std::memory_order_relaxed); //获得原子的指针 std::atomic_thread_fence(std::memory_order_acquire); // 内存屏障，防止重排序 if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Logger(); std::atomic_thread_fence(std::memory_order_release); //释放内存屏障 instance.store(tmp, std::memory_order_relaxed); } } return *tmp; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); delete instance.load(); instance.store(nullptr, std::memory_order_relaxed); } }; // 定义静态成员变量 std::atomic\u0026lt;Logger*\u0026gt; Logger::instance(nullptr); std::mutex Logger::mutex; 进一步优化\nC++11 提供了 std::call_once 和 std::once_flag，可以确保某个函数只会被调用一次，非常适合用于实现线程安全的单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: // 获取单例实例 static Singleton* getInstance() { std::call_once(flag, []() { instance = new Singleton(); }); return instance; } // 删除拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态成员变量 static Singleton* instance; static std::once_flag flag; }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; std::once_flag Singleton::flag; int main() { // 多线程测试 auto func = []() { Singleton* instance = Singleton::getInstance(); instance-\u0026gt;doSomething(); }; std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); return 0; } 优点\n线程安全，代码简洁。 避免了双重检查锁定的复杂性。 缺点\n需要 C++11 及以上支持。 使用静态局部变量 主播主播🥰 你的单例确～实很强👍 但还是太吃操作了😇 有没有更加简单又强势的英雄推荐一下吗🧐 有的兄弟（战术停顿）有的😋 这么强势的英雄当～然是不止一个了🤓 一共有九位，都是当～前版本t～0.5的超～标英雄👉 告诉主播，你想学习哪个😤\nC++11 保证了静态局部变量的初始化是线程安全的，因此可以直接使用静态局部变量来实现单例模式。\n请务必禁用 copy 构造函数和赋值运算符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; class Singleton { public: // 获取单例实例 static Singleton\u0026amp; getInstance() { static Singleton instance; // 线程安全的静态局部变量 return instance; } // 删除拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 多线程测试 auto func = []() { Singleton\u0026amp; instance = Singleton::getInstance(); instance.doSomething(); }; std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); return 0; } 优点\n代码简洁，线程安全。 无需手动管理内存。 延迟加载，只在第一次使用时才构造。 避免静态对象在不同编译单元构造顺序的问题。 缺点\n需要 C++11 及以上支持。 静态类 在 C++ 中，单例模式 和 静态类 是两种常见的实现全局唯一实例或工具类的方式。它们各有优势和适用场景，以下是它们的详细对比：\n单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。静态类是指所有成员（包括方法和数据）都是静态的类。它通常用于工具类或全局函数集合。\n静态类示例：\n1 2 3 4 5 6 7 8 9 10 11 class StaticClass { public: // 删除构造函数和拷贝构造函数 StaticClass() = delete; StaticClass(const StaticClass\u0026amp;) = delete; // 静态方法 static void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something in StaticClass\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 特性 单例模式 静态类 实例化 延迟初始化，按需创建 无需实例化，直接调用静态方法 继承与多态 支持继承和多态 不支持继承和多态 线程安全 需要额外处理 通常是线程安全的 生命周期管理 需要手动管理 自动管理 适用场景 需要全局唯一实例的场景 工具类或全局函数集合 全局状态 引入全局状态 引入全局状态 扩展性 高（可继承、可扩展） 低（无法继承） 场景 单例模式 静态类 游戏管理器 ✔️ 适合管理全局状态 ❌ 不适合 资源管理器 ✔️ 适合按需加载资源 ❌ 不适合 音频管理器 ✔️ 适合管理全局音频 ❌ 不适合 数学工具类 ❌ 过度设计 ✔️ 适合工具函数 调试工具类 ❌ 过度设计 ✔️ 适合工具函数 输入工具类 ❌ 过度设计 ✔️ 适合工具函数 命令模式 命令模式是一种行为设计模式，它将请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。具体来说，命令模式允许你将请求发送者和请求接收者解耦，通过引入一个命令对象来封装请求调用的细节。\n发送者（调用者） 只需要知道如何调用命令对象的 execute() 方法，而不需要了解具体的实现细节。 接收者 只需要提供具体的操作方法，而不关心这些方法是如何被调用的。 命令对象 则充当了发送者和接收者之间的桥梁，封装了请求的具体执行逻辑。 说白了 就调用虚函数，完事了。假设有个Command命令基类，它有一个execute函数，只要是Command的子类 都可以接收过来，这些子类重写execute虚函数，就能做出不同的效果，调用者只要执行Command-\u0026gt;execute() 就行了。\n下面的例子创建了多个类来体现这个设计模式，但是在C++中 可以传递 Lambda函数、函数指针 什么的来调用函数。而不需要创建好几个类，就有点占地方了。\n正在开发一个遥控器应用，该应用可以控制多个家电设备（如灯、风扇等）。可以使用命令模式来实现遥控器的功能，使得遥控器与具体的设备操作解耦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // Command 接口 class Command { public: virtual ~Command() = default; virtual void execute() = 0; }; // Light 类（接收者） class Light { public: void on() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is ON\u0026#34; \u0026lt;\u0026lt; std::endl; } void off() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is OFF\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Fan 类（接收者） class Fan { public: void start() { std::cout \u0026lt;\u0026lt; \u0026#34;Fan is STARTED\u0026#34; \u0026lt;\u0026lt; std::endl; } void stop() { std::cout \u0026lt;\u0026lt; \u0026#34;Fan is STOPPED\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体命令类：打开灯 class LightOnCommand : public Command { private: Light\u0026amp; light; public: LightOnCommand(Light\u0026amp; light) : light(light) {} void execute() override { light.on(); } }; // 具体命令类：关闭灯 class LightOffCommand : public Command { private: Light\u0026amp; light; public: LightOffCommand(Light\u0026amp; light) : light(light) {} void execute() override { light.off(); } }; // 具体命令类：启动风扇 class FanStartCommand : public Command { private: Fan\u0026amp; fan; public: FanStartCommand(Fan\u0026amp; fan) : fan(fan) {} void execute() override { fan.start(); } }; // 具体命令类：停止风扇 class FanStopCommand : public Command { private: Fan\u0026amp; fan; public: FanStopCommand(Fan\u0026amp; fan) : fan(fan) {} void execute() override { fan.stop(); } }; // 调用者：遥控器 class RemoteControl { private: std::unique_ptr\u0026lt;Command\u0026gt; command; public: void setCommand(std::unique_ptr\u0026lt;Command\u0026gt; cmd) { command = std::move(cmd); } void pressButton() { if (command) { command-\u0026gt;execute(); } } }; int main() { // 创建接收者 Light light; Fan fan; // 创建命令对象 LightOnCommand lightOn(light); LightOffCommand lightOff(light); FanStartCommand fanStart(fan); FanStopCommand fanStop(fan); // 创建遥控器 RemoteControl remote; // 设置并按下按钮 remote.setCommand(std::make_unique\u0026lt;LightOnCommand\u0026gt;(lightOn)); remote.pressButton(); // 输出: Light is ON remote.setCommand(std::make_unique\u0026lt;LightOffCommand\u0026gt;(lightOff)); remote.pressButton(); // 输出: Light is OFF remote.setCommand(std::make_unique\u0026lt;FanStartCommand\u0026gt;(fanStart)); remote.pressButton(); // 输出: Fan is STARTED remote.setCommand(std::make_unique\u0026lt;FanStopCommand\u0026gt;(fanStop)); remote.pressButton(); // 输出: Fan is STOPPED return 0; } 这不就是 遥控器接收一个命令基类，调用命令基类里的execute函数，命令基类可以派生出子类，子类重写execute虚函数 执行出不同的效果，\n状态模式 一种行为设计模式，它允许对象在其内部状态改变时改变其行为。这种模式可以将状态的逻辑从对象中分离出来，使得状态转换更加清晰和易于管理。\n人的情绪可以是“开心”、“生气”或“平静”。根据他的情绪不同，他对同一件事情的反应也会不同。比如：\n当他开心时，有人跟他开玩笑他会笑得很开心。 当他生气时，同样的玩笑可能会让他愤怒地回应。 当他平静时，他可能只是微微一笑，或者完全不理会。 状态模式的核心元素\n上下文（Context）：这个人本身，他有不同的状态，并且根据当前的状态表现出不同的行为。 状态接口（State Interface）：定义了所有具体状态的公共接口，例如对玩笑的反应。 具体状态（Concrete States）：每种情绪的具体实现，如“开心”、“生气”和“平静”。 假设有一个简单的程序来模拟一个人的心情变化，并根据心情做出不同的反应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 定义状态接口 class Mood { public: virtual ~Mood() = default; virtual void reactToJoke() = 0; }; // 上下文类，持有当前状态 class Person { public: explicit Person(std::unique_ptr\u0026lt;Mood\u0026gt; mood) : currentMood_(std::move(mood)) {} void setMood(std::unique_ptr\u0026lt;Mood\u0026gt; mood) { currentMood_ = std::move(mood); } void hearJoke() { if (currentMood_) { currentMood_-\u0026gt;reactToJoke(); } } private: std::unique_ptr\u0026lt;Mood\u0026gt; currentMood_; }; // 具体状态类：开心 class HappyMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;哈哈，太好笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体状态类：生气 class AngryMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;你这是什么意思？别开玩笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体状态类：平静 class CalmMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;嗯...这有点意思。\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建一个初始状态为开心的人 auto person = std::make_unique\u0026lt;Person\u0026gt;(std::make_unique\u0026lt;HappyMood\u0026gt;()); // 听到一个笑话 person-\u0026gt;hearJoke(); // 输出: 哈哈，太好笑了！ // 切换到生气状态 person-\u0026gt;setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); person-\u0026gt;hearJoke(); // 输出: 你这是什么意思？别开玩笑了！ // 切换到平静状态 person-\u0026gt;setMood(std::make_unique\u0026lt;CalmMood\u0026gt;()); person-\u0026gt;hearJoke(); // 输出: 嗯...这有点意思。 return 0; } 清晰的行为转换：每个状态都有明确的行为，避免了大量的条件判断语句。 易于扩展：如果需要添加新的状态或修改现有状态的行为，只需添加或修改具体状态类，而不影响其他部分的代码。 更好的组织代码：将状态逻辑分离出来，使得代码更加模块化和易于维护。 状态机\n设计一个状态机来表现心情的变化，可以通过定义不同的状态和状态之间的转换规则来实现。状态机是一种模型，用于表示系统在不同状态下如何响应各种事件，并根据这些事件进行状态转换。\n设计步骤\n定义状态：首先确定有哪些可能的状态。 定义事件：确定哪些事件会触发状态的改变。 定义状态转换规则：明确每个状态下对每个事件的响应以及状态转换关系。 实现状态机：使用代码实现上述定义的状态、事件和转换规则。 状态转换规则\n开心(Happy) 听到笑话 (Joke)-\u0026gt; 更加开心（仍然保持开心状态） 受到表扬 (Praise) -\u0026gt; 更加开心（仍然保持开心状态） 受到批评 (Criticism)-\u0026gt; 生气 生气(Angry) 听到笑话 (Joke)-\u0026gt; 不理睬（仍然保持生气状态） 受到表扬 (Praise)-\u0026gt; 平静 受到批评 (Criticism)-\u0026gt; 更加生气（仍然保持生气状态） 平静(Calm) 听到笑话 (Joke)-\u0026gt; 轻微高兴（开心） 受到表扬 (Praise)-\u0026gt; 开心 受到批评 (Criticism)-\u0026gt; 生气 结合状态模式的思想，将每个状态作为一个类，并定义状态转换逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; // 定义状态接口 class Mood { public: virtual ~Mood() = default; virtual void handleEvent(const std::string\u0026amp; event) = 0; virtual std::string getStateName() const = 0; }; // 上下文类，持有当前状态 class Person { public: explicit Person(std::unique_ptr\u0026lt;Mood\u0026gt; mood) : currentMood_(std::move(mood)) {} void setMood(std::unique_ptr\u0026lt;Mood\u0026gt; mood) { currentMood_ = std::move(mood); } void handleEvent(const std::string\u0026amp; event) { if (currentMood_) { std::cout \u0026lt;\u0026lt; \u0026#34;Current mood: \u0026#34; \u0026lt;\u0026lt; currentMood_-\u0026gt;getStateName() \u0026lt;\u0026lt; std::endl; currentMood_-\u0026gt;handleEvent(event); } } private: std::unique_ptr\u0026lt;Mood\u0026gt; currentMood_; }; // 具体状态类：开心 class HappyMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;哈哈，太好笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;真不错，继续保持！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;哼，你说什么？\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); } } std::string getStateName() const override { return \u0026#34;Happy\u0026#34;; } }; // 具体状态类：生气 class AngryMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;你这是什么意思？别开玩笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;好吧，这还差不多。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;CalmMood\u0026gt;()); } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;你怎么能这么说！\u0026#34; \u0026lt;\u0026lt; std::endl; } } std::string getStateName() const override { return \u0026#34;Angry\u0026#34;; } }; // 具体状态类：平静 class CalmMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;嗯...这有点意思。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;HappyMood\u0026gt;()); } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;谢谢你的认可！\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;HappyMood\u0026gt;()); } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;我会注意的。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); } } std::string getStateName() const override { return \u0026#34;Calm\u0026#34;; } }; int main() { // 创建一个初始状态为开心的人 auto person = std::make_unique\u0026lt;Person\u0026gt;(std::make_unique\u0026lt;HappyMood\u0026gt;()); // 处理一系列事件 person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 哈哈，太好笑了！ person-\u0026gt;handleEvent(\u0026#34;ReceiveCriticism\u0026#34;); // 输出: 哼，你说什么？ Current mood: Angry person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 你这是什么意思？别开玩笑了！ person-\u0026gt;handleEvent(\u0026#34;ReceivePraise\u0026#34;); // 输出: 好吧，这还差不多。 Current mood: Calm person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 嗯...这有点意思。 Current mood: Happy person-\u0026gt;handleEvent(\u0026#34;ReceivePraise\u0026#34;); // 输出: 谢谢你的认可！ Current mood: Happy return 0; } 门面模式 一种结构型设计模式，它为复杂的子系统提供一个简化的接口。门面模式通过引入一个单一的接口类来隐藏系统的复杂性，使得外部与系统的交互更加简单和直观。\n门面模式的核心概念\n门面（Facade）：提供一个统一的接口，用于访问多个子系统的功能。客户端只需要与这个门面进行交互，而不需要直接调用各个子系统的具体实现。 子系统（Subsystem）：包含实际的功能模块或组件，通常由多个类组成，每个类负责特定的任务。 适用场景\n当需要简化一个复杂的子系统时。 当需要将子系统的实现细节与客户端代码解耦时。 当希望将一组复杂的类组织在一起，并对外提供一个简单的接口时。 当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。\n假设正在开发一个多媒体播放器，该播放器需要处理音频、视频和字幕等多个子系统。为了简化客户端代码的使用，可以使用门面模式来封装这些子系统的操作。\n子系统类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; // 音频子系统 class AudioPlayer { public: void loadAudio(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading audio: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void playAudio() { std::cout \u0026lt;\u0026lt; \u0026#34;Playing audio.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 视频子系统 class VideoPlayer { public: void loadVideo(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading video: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void playVideo() { std::cout \u0026lt;\u0026lt; \u0026#34;Playing video.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 字幕子系统 class SubtitleManager { public: void loadSubtitle(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading subtitle: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void displaySubtitle() { std::cout \u0026lt;\u0026lt; \u0026#34;Displaying subtitle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 门面类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 门面类，提供一个简化的接口来操作多媒体播放器 class MediaFacade { public: MediaFacade() : audioPlayer(new AudioPlayer()), videoPlayer(new VideoPlayer()), subtitleManager(new SubtitleManager()) {} ~MediaFacade() { delete audioPlayer; delete videoPlayer; delete subtitleManager; } void playMedia(const std::string\u0026amp; audioFile, const std::string\u0026amp; videoFile, const std::string\u0026amp; subtitleFile) { // 加载并播放音频 audioPlayer-\u0026gt;loadAudio(audioFile); audioPlayer-\u0026gt;playAudio(); // 加载并播放视频 videoPlayer-\u0026gt;loadVideo(videoFile); videoPlayer-\u0026gt;playVideo(); // 加载并显示字幕 subtitleManager-\u0026gt;loadSubtitle(subtitleFile); subtitleManager-\u0026gt;displaySubtitle(); } private: AudioPlayer* audioPlayer; VideoPlayer* videoPlayer; SubtitleManager* subtitleManager; }; 客户端代码\n1 2 3 4 5 6 7 8 9 int main() { // 创建门面对象 MediaFacade mediaFacade; // 使用门面对象来播放多媒体文件 mediaFacade.playMedia(\u0026#34;audio.mp3\u0026#34;, \u0026#34;video.mp4\u0026#34;, \u0026#34;subtitle.srt\u0026#34;); return 0; } 输出：\n1 2 3 4 5 6 Loading audio: audio.mp3 Playing audio. Loading video: video.mp4 Playing video. Loading subtitle: subtitle.srt Displaying subtitle. 门面类 MediaFacade： 提供了一个简化的接口 playMedia，该接口内部调用了各个子系统的相应方法来完成多媒体播放任务。 通过门面类，客户端代码不需要直接与各个子系统进行交互，只需要调用门面提供的接口即可。 优点\n简化客户端代码：客户端只需要与门面进行交互，无需了解子系统的内部细节。 提高灵活性：可以在不改变客户端代码的情况下修改子系统的实现。 促进松耦合：门面类与子系统之间是松耦合的，便于维护和扩展。 扩展示例\n假设需要在播放多媒体文件之前检查文件是否存在，可以在门面类中添加相应的逻辑，而无需修改子系统类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;fstream\u0026gt; class MediaFacade { public: MediaFacade() : audioPlayer(new AudioPlayer()), videoPlayer(new VideoPlayer()), subtitleManager(new SubtitleManager()) {} ~MediaFacade() { delete audioPlayer; delete videoPlayer; delete subtitleManager; } bool fileExists(const std::string\u0026amp; fileName) { std::ifstream file(fileName); return file.good(); } void playMedia(const std::string\u0026amp; audioFile, const std::string\u0026amp; videoFile, const std::string\u0026amp; subtitleFile) { if (!fileExists(audioFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Audio file not found: \u0026#34; \u0026lt;\u0026lt; audioFile \u0026lt;\u0026lt; std::endl; return; } if (!fileExists(videoFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Video file not found: \u0026#34; \u0026lt;\u0026lt; videoFile \u0026lt;\u0026lt; std::endl; return; } if (!fileExists(subtitleFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Subtitle file not found: \u0026#34; \u0026lt;\u0026lt; subtitleFile \u0026lt;\u0026lt; std::endl; return; } // 加载并播放音频 audioPlayer-\u0026gt;loadAudio(audioFile); audioPlayer-\u0026gt;playAudio(); // 加载并播放视频 videoPlayer-\u0026gt;loadVideo(videoFile); videoPlayer-\u0026gt;playVideo(); // 加载并显示字幕 subtitleManager-\u0026gt;loadSubtitle(subtitleFile); subtitleManager-\u0026gt;displaySubtitle(); } private: AudioPlayer* audioPlayer; VideoPlayer* videoPlayer; SubtitleManager* subtitleManager; }; 在这个扩展示例中，在门面类中添加了 fileExists 方法来检查文件是否存在，并在 playMedia 方法中进行了相应的检查。这样，即使子系统类没有文件检查的功能，也可以通过门面类来增强其功能，而不会影响到现有的子系统实现。\n通过这种方式，门面模式可以简化复杂的系统接口，使其更易于使用和维护。\n在扩展检查文件存在性的例子中，无论内部如何变，在外部看来是没有变化的，依然可以使用相同的方式使用\n1 2 3 4 5 6 7 8 9 int main() { // 创建门面对象 MediaFacade mediaFacade; // 使用门面对象来播放多媒体文件 mediaFacade.playMedia(\u0026#34;audio.mp3\u0026#34;, \u0026#34;video.mp4\u0026#34;, \u0026#34;subtitle.srt\u0026#34;); return 0; } 解耦—内部子系统的变化 不会影响到接口的变化.\n门面模式中组件的内部是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。\n迭代器模式 一种行为设计模式，它提供了一种方法来顺序访问一个聚合对象中的各个元素，而无需暴露其内部表示。迭代器模式将遍历集合的职责从集合本身分离出来，使得不同的遍历方式可以独立于集合实现。\n迭代器模式的核心概念\nAggregate（聚合类）：定义了创建迭代器对象的接口。 Iterator（迭代器接口）：声明了遍历集合所需的方法，如 hasNext() 和 next()。 ConcreteIterator（具体迭代器类）：实现了迭代器接口，并保持对遍历过程的跟踪。 传统迭代器模式是面向对象风格，在C++中需要使用虚函数实现，性能不好C++标准库的迭代器采用模板编程，在编译时确定\n面向对象风格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 迭代器接口 class Iterator { public: virtual ~Iterator() = default; virtual bool hasNext() const = 0; virtual std::string next() = 0; }; // 聚合类接口 class Aggregate { public: virtual ~Aggregate() = default; virtual std::unique_ptr\u0026lt;Iterator\u0026gt; createIterator() const = 0; }; // 图书类 class Book { public: explicit Book(const std::string\u0026amp; title) : title_(title) {} std::string getTitle() const { return title_; } private: std::string title_; }; // 具体聚合类：图书集合 class BookCollection : public Aggregate { public: void addBook(const std::string\u0026amp; title) { books_.emplace_back(title); } std::unique_ptr\u0026lt;Iterator\u0026gt; createIterator() const override { return std::make_unique\u0026lt;BookIterator\u0026gt;(books_); } private: std::vector\u0026lt;Book\u0026gt; books_; }; // 具体迭代器类：从前向后遍历 class BookIterator : public Iterator { public: explicit BookIterator(const std::vector\u0026lt;Book\u0026gt;\u0026amp; books) : books_(books), index_(0) {} bool hasNext() const override { return index_ \u0026lt; books_.size(); } std::string next() override { if (!hasNext()) { throw std::out_of_range(\u0026#34;No more books.\u0026#34;); } return books_[index_++].getTitle(); } private: const std::vector\u0026lt;Book\u0026gt;\u0026amp; books_; size_t index_; }; int main() { // 创建图书集合并添加一些图书 auto bookCollection = std::make_unique\u0026lt;BookCollection\u0026gt;(); bookCollection-\u0026gt;addBook(\u0026#34;C++ Primer\u0026#34;); bookCollection-\u0026gt;addBook(\u0026#34;Effective C++\u0026#34;); bookCollection-\u0026gt;addBook(\u0026#34;Design Patterns\u0026#34;); // 获取迭代器并遍历图书集合 auto iterator = bookCollection-\u0026gt;createIterator(); while (iterator-\u0026gt;hasNext()) { std::cout \u0026lt;\u0026lt; iterator-\u0026gt;next() \u0026lt;\u0026lt; std::endl; } return 0; } 组合模式 一种结构型设计模式， 可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n组合模式的核心思想是：\n定义一个统一的接口（抽象类或基类），用于表示单个对象和组合对象。 单个对象和组合对象都实现这个接口。 组合对象可以包含其他组合对象或单个对象，从而形成树形结构。 假设正在开发一个文件系统，文件系统中有两种类型的对象：\n文件（File）：单个对象，没有子对象。 文件夹（Folder）：组合对象，可以包含文件或其他文件夹。 可以使用组合模式来表示文件系统的层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 抽象组件类 class FileSystemComponent { public: virtual ~FileSystemComponent() = default; virtual void display(int depth = 0) const = 0; // 显示组件信息 }; // 叶子类：文件 class File : public FileSystemComponent { public: File(const std::string\u0026amp; name) : name(name) {} void display(int depth = 0) const override { std::cout \u0026lt;\u0026lt; std::string(depth, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; \u0026#34;File: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; } private: std::string name; }; // 组合类：文件夹 class Folder : public FileSystemComponent { public: Folder(const std::string\u0026amp; name) : name(name) {} void addComponent(FileSystemComponent* component) { components.push_back(component); } void display(int depth = 0) const override { std::cout \u0026lt;\u0026lt; std::string(depth, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Folder: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; for (const auto\u0026amp; component : components) { component-\u0026gt;display(depth + 2); // 递归显示子组件 } } private: std::string name; std::vector\u0026lt;FileSystemComponent*\u0026gt; components; }; int main() { // 创建文件 File* file1 = new File(\u0026#34;file1.txt\u0026#34;); File* file2 = new File(\u0026#34;file2.txt\u0026#34;); File* file3 = new File(\u0026#34;file3.txt\u0026#34;); // 创建文件夹 Folder* folder1 = new Folder(\u0026#34;Folder 1\u0026#34;); Folder* folder2 = new Folder(\u0026#34;Folder 2\u0026#34;); Folder* rootFolder = new Folder(\u0026#34;Root Folder\u0026#34;); // 构建树形结构 folder1-\u0026gt;addComponent(file1); folder1-\u0026gt;addComponent(file2); folder2-\u0026gt;addComponent(file3); rootFolder-\u0026gt;addComponent(folder1); rootFolder-\u0026gt;addComponent(folder2); // 显示文件系统结构 rootFolder-\u0026gt;display(); // 释放内存 delete file1; delete file2; delete file3; delete folder1; delete folder2; delete rootFolder; return 0; } 输出：\n1 2 3 4 5 6 Folder: Root Folder --Folder: Folder 1 ----File: file1.txt ----File: file2.txt --Folder: Folder 2 ----File: file3.txt 优点\n统一处理单个对象和组合对象： 客户端可以统一处理文件和文件夹，无需区分它们。 灵活性： 可以动态地添加或删除组件，构建复杂的树形结构。 可扩展性： 新增组件类型时，无需修改现有代码。 缺点\n设计复杂性： 需要定义抽象组件类、叶子类和组合类，增加了代码的复杂性。 类型检查： 在某些情况下，客户端可能需要检查组件的类型（如判断是否是文件夹），这可能会破坏组合模式的透明性。 适用场景\n表示部分-整体层次结构： 如文件系统、菜单系统、组织结构等。 统一处理单个对象和组合对象： 当客户端需要统一处理单个对象和组合对象时。 动态构建树形结构： 当需要动态地添加或删除组件时。 组合模式课后康复练习\n假设你有两个类的对象：产品和盒子。一个盒子可以包含多个产品或其他较小的盒子，这些小盒子也可以再包含产品或更小的盒子，以此类推。\n问题描述\n你需要开发一个订购系统，订单中可以包含：\n未包装的简单产品 装满产品的盒子 其他盒子（可能包含更多产品或盒子） 目标是计算每张订单的总价格。\n直接计算的问题\n直接计算所有项目的总价在现实中或许可行，但在程序中实现时会遇到以下困难：\n必须事先知道所有产品和盒子的类别。 需要了解所有盒子的嵌套层数和其他复杂细节。 这种方法非常繁琐且容易出错。 解决方案：组合模式\n组合模式通过使用通用接口来统一处理产品和盒子，并声明一个计算总价的方法。具体如下：\n定义通用接口： 声明一个计算总价的方法（例如 getPrice）。 实现叶子节点（产品）： 对于产品，该方法直接返回其价格。 实现组合节点（盒子）： 对于盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。 如果其中某个项目是另一个盒子，则当前盒子也会递归地遍历其中的所有项目，直到计算出所有内部组成部分的价格。 优点： 无需了解对象的具体类（无论是产品还是盒子）。 可以用相同的方式处理所有对象，无论它们是简单的还是复杂的结构。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 组件接口 class Component { public: virtual ~Component() = default; virtual double getPrice() const = 0; // 计算总价 }; // 产品类 class Product : public Component { public: Product(double price) : price_(price) {} double getPrice() const override { return price_; } private: double price_; }; // 盒子类 class Box : public Component { public: void add(std::unique_ptr\u0026lt;Component\u0026gt; component) { components_.push_back(std::move(component)); } double getPrice() const override { double total = 0.0; for (const auto\u0026amp; component : components_) { total += component-\u0026gt;getPrice(); } return total; } private: std::vector\u0026lt;std::unique_ptr\u0026lt;Component\u0026gt;\u0026gt; components_; }; int main() { // 创建一个盒子 auto box = std::make_unique\u0026lt;Box\u0026gt;(); // 向盒子中添加产品 box-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(10.0)); // 产品A box-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(20.0)); // 产品B // 创建另一个盒子并将其添加到第一个盒子中 auto nestedBox = std::make_unique\u0026lt;Box\u0026gt;(); nestedBox-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(5.0)); // 产品C nestedBox-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(15.0)); // 产品D box-\u0026gt;add(std::move(nestedBox)); // 计算并显示总价格 std::cout \u0026lt;\u0026lt; \u0026#34;Total Price: \u0026#34; \u0026lt;\u0026lt; box-\u0026gt;getPrice() \u0026lt;\u0026lt; std::endl; return 0; } Total Price: 50\n代理模式 一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n适用情况\n延迟初始化（Lazy Initialization）：在需要时才创建昂贵的对象。 访问控制：根据权限控制对对象的访问。 远程代理：代表远程对象进行操作，如网络请求。 虚拟代理：为复杂对象创建一个轻量级的占位符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;iostream\u0026gt; class Subject { public: virtual void Request() const = 0; }; class RealSubject : public Subject { public: void Request() const override { std::cout \u0026lt;\u0026lt; \u0026#34;RealSubject: Handling request.\\n\u0026#34;; } }; class Proxy : public Subject { private: RealSubject* real_subject_; bool CheckAccess() const { // Some real checks should go here. std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Checking access prior to firing a real request.\\n\u0026#34;; return true; } void LogAccess() const { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Logging the time of request.\\n\u0026#34;; } public: Proxy(RealSubject* real_subject) : real_subject_(new RealSubject(*real_subject)) {} ~Proxy() { delete real_subject_; } void Request() const override { if (this-\u0026gt;CheckAccess()) { this-\u0026gt;real_subject_-\u0026gt;Request(); this-\u0026gt;LogAccess(); } } }; void ClientCode(const Subject\u0026amp; subject) { // ... subject.Request(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the client code with a real subject:\\n\u0026#34;; RealSubject* real_subject = new RealSubject; ClientCode(*real_subject); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the same client code with a proxy:\\n\u0026#34;; Proxy* proxy = new Proxy(real_subject); ClientCode(*proxy); delete real_subject; delete proxy; return 0; } 间接访问：通过代理对象间接访问实际对象，可以在不修改实际对象的情况下添加额外的功能。 权限检查和日志记录：在调用实际对象的方法之前和之后，代理可以执行额外的操作，如权限检查和日志记录。 扩展性：可以在代理类中轻松添加新功能，而不需要修改实际对象的类，提高了代码的可维护性和扩展性。 适配器模式 一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n示例：手机充电适配器\n在这个示例中：\nPhone类代表的手机，它需要一个USB接口来充电。 OldCharger类代表一个旧式的充电器，它只有圆形插头输出。 UsbAdapter类是适配器，它接受圆形插头输入，并提供USB接口输出，使手机可以使用旧式充电器充电。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 目标接口：USB充电接口 class UsbCharger { public: virtual void charge() = 0; virtual ~UsbCharger() {} // 虚析构函数以确保正确释放派生类对象 }; // 具体实现：手机类，需要USB充电接口 class Phone { private: UsbCharger* charger; public: Phone(UsbCharger* c) : charger(c) {} void chargePhone() { std::cout \u0026lt;\u0026lt; \u0026#34;Connecting phone to charger...\u0026#34; \u0026lt;\u0026lt; std::endl; charger-\u0026gt;charge(); std::cout \u0026lt;\u0026lt; \u0026#34;Phone is charging.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 需要被适配的类：旧式充电器，只有圆形插头接口 class OldCharger { public: void oldCharge() { std::cout \u0026lt;\u0026lt; \u0026#34;Using old charger with round pin plug.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 适配器类：适配旧式充电器到USB充电接口 class UsbAdapter : public UsbCharger { private: OldCharger* oldCharger; public: UsbAdapter(OldCharger* oc) : oldCharger(oc) {} void charge() override { std::cout \u0026lt;\u0026lt; \u0026#34;Adapting old charger to USB...\u0026#34; \u0026lt;\u0026lt; std::endl; oldCharger-\u0026gt;oldCharge(); // 使用旧式充电器的方法 } }; // main函数演示如何使用这些类 int main() { OldCharger oldCharger; UsbAdapter usbAdapter(\u0026amp;oldCharger); Phone myPhone(\u0026amp;usbAdapter); myPhone.chargePhone(); return 0; } 输出：\n1 2 3 4 连接充电器... 适配旧式充电器为USB接口.... 使用旧式充电器（圆形插头）充电. 充电中. 即使 OldCharger 不直接兼容 Phone 所需的 USB 接口，通过 UsbAdapter，Phone 也能成功使用 OldCharger 来充电。这就是适配器模式的核心思想。\n享元模式 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n享元模式的核心思想\n内部状态：可以在多个对象之间共享的状态。 外部状态：不能在对象之间共享的状态，必须由客户端代码提供。 假设正在开发一个文本编辑器，其中每个字符都有其自己的格式（如颜色、字体大小等）。如果为每个字符都创建一个新的对象，这将消耗大量的内存。通过使用享元模式，可以共享那些具有相同格式设置的对象，从而减少内存使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; // 享元接口 class CharacterStyle { public: virtual void display(char ch) const = 0; }; // 具体享元类 class ConcreteCharacterStyle : public CharacterStyle { private: std::string color; int fontSize; public: ConcreteCharacterStyle(const std::string\u0026amp; color, int fontSize) : color(color), fontSize(fontSize) {} void display(char ch) const override { std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34;, Color: \u0026#34; \u0026lt;\u0026lt; color \u0026lt;\u0026lt; \u0026#34;, Font Size: \u0026#34; \u0026lt;\u0026lt; fontSize \u0026lt;\u0026lt; std::endl; } }; // 享元工厂 class CharacterStyleFactory { private: std::unordered_map\u0026lt;std::string, CharacterStyle*\u0026gt; styles; std::string getKey(const std::string\u0026amp; color, int fontSize) const { return color + \u0026#34;_\u0026#34; + std::to_string(fontSize); } public: CharacterStyle* getStyle(const std::string\u0026amp; color, int fontSize) { std::string key = getKey(color, fontSize); if (styles.find(key) == styles.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Creating new style for: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; styles[key] = new ConcreteCharacterStyle(color, fontSize); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Reusing existing style for: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; } return styles[key]; } ~CharacterStyleFactory() { for (auto\u0026amp; pair : styles) { delete pair.second; } } }; // 使用享元模式的客户端代码 void displayText(CharacterStyleFactory\u0026amp; factory, const std::string\u0026amp; text, const std::string\u0026amp; color, int fontSize) { for (char ch : text) { CharacterStyle* style = factory.getStyle(color, fontSize); style-\u0026gt;display(ch); } } int main() { CharacterStyleFactory factory; // 显示不同字符但相同格式的文本 displayText(factory, \u0026#34;Hello\u0026#34;, \u0026#34;Red\u0026#34;, 12); displayText(factory, \u0026#34;World\u0026#34;, \u0026#34;Red\u0026#34;, 12); // 显示不同格式的文本 displayText(factory, \u0026#34;Test\u0026#34;, \u0026#34;Blue\u0026#34;, 14); return 0; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Creating new style for: Red_12 Character: H, Color: Red, Font Size: 12 Character: e, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: o, Color: Red, Font Size: 12 Reusing existing style for: Red_12 Character: W, Color: Red, Font Size: 12 Character: o, Color: Red, Font Size: 12 Character: r, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: d, Color: Red, Font Size: 12 Creating new style for: Blue_14 Character: T, Color: Blue, Font Size: 14 Character: e, Color: Blue, Font Size: 14 Character: s, Color: Blue, Font Size: 14 Character: t, Color: Blue, Font Size: 14 CharacterStyle 类：这是享元接口，定义了所有具体享元类必须实现的方法 display()。 ConcreteCharacterStyle 类：实现了 CharacterStyle 接口的具体享元类。它包含了字符的格式信息（颜色和字体大小），并负责显示字符。 CharacterStyleFactory 类：这是一个享元工厂，用于管理和共享享元对象。它通过一个哈希表来存储已经创建的享元对象，并根据请求返回相应的享元对象。 displayText 函数：这是客户端代码，展示了如何使用享元工厂来获取和显示字符。 当第一次请求“Red_12”格式时，工厂会创建一个新的 ConcreteCharacterStyle 对象。 在后续请求相同格式（“Red_12”）时，工厂会重用之前创建的对象，而不是再次创建新的对象。 同样地，当请求不同的格式（如“Blue_14”）时，工厂会创建一个新的 ConcreteCharacterStyle 对象。 通过这种方式，享元模式有效地减少了内存使用，特别是在处理大量相似对象的情况下。\n桥接模式 一种结构型设计模式，它将抽象部分与其实现部分分离，使它们可以独立变化。这种模式通过提供一个桥梁接口来实现两个层次的抽象，使得系统更加灵活和可扩展。\n桥接模式的核心思想\n抽象部分：定义了高层控制逻辑，但不关心具体的实现细节。 实现部分：定义了底层的具体实现，但不关心如何被使用。 桥梁接口：将抽象部分与实现部分连接起来，使得两者可以独立变化。 假设要设计一个绘图应用，其中包含不同类型的形状（如圆形和矩形），并且这些形状可以在不同的渲染器上绘制（如矢量渲染器和光栅渲染器）。\n抽象部分：定义了形状的类型（如圆形、矩形）。 实现部分：定义了渲染器的具体实现（如矢量渲染器、光栅渲染器）。 桥梁接口：将形状与渲染器连接起来，使得两者可以独立变化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 实现部分：渲染器接口 class Renderer { public: virtual void renderCircle(float x, float y, float radius) const = 0; virtual ~Renderer() {} }; // 具体实现：矢量渲染器 class VectorRenderer : public Renderer { public: void renderCircle(float x, float y, float radius) const override { std::cout \u0026lt;\u0026lt; \u0026#34;VectorRenderer: Drawing Circle at (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;) with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; // 具体实现：光栅渲染器 class RasterRenderer : public Renderer { public: void renderCircle(float x, float y, float radius) const override { std::cout \u0026lt;\u0026lt; \u0026#34;RasterRenderer: Drawing Circle at (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;) with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; // 抽象部分：形状类 class Shape { protected: Renderer* renderer; public: Shape(Renderer* r) : renderer(r) {} virtual void draw() const = 0; virtual ~Shape() {} }; // 具体形状：圆形 class Circle : public Shape { private: float x, y, radius; public: Circle(float centerX, float centerY, float rad, Renderer* r) : Shape(r), x(centerX), y(centerY), radius(rad) { } void draw() const override { renderer-\u0026gt;renderCircle(x, y, radius); } }; // 客户端代码 void clientCode() { // 使用矢量渲染器绘制圆形 Renderer* vectorRenderer = new VectorRenderer(); Shape* circleWithVector = new Circle(1.0f, 2.0f, 3.0f, vectorRenderer); circleWithVector-\u0026gt;draw(); // 使用光栅渲染器绘制圆形 Renderer* rasterRenderer = new RasterRenderer(); Shape* circleWithRaster = new Circle(4.0f, 5.0f, 6.0f, rasterRenderer); circleWithRaster-\u0026gt;draw(); // 清理资源 delete circleWithVector; delete circleWithRaster; delete vectorRenderer; delete rasterRenderer; } int main() { clientCode(); return 0; } 这不就是把Renderer传给shape，让shape调用Renderer的renderCircle函数？而且Renderer类可以在运行时动态生成子类，可以把子类传给shape 从而实现shape能够调用任何Renderer子类的renderCircle函数.\n桥接模式的核心就是通过组合的方式，将抽象部分（如形状）与实现部分（如渲染器）解耦。具体来说，是通过将 Renderer 传给 Shape，使得 Shape 可以在运行时调用任何 Renderer 子类的 renderCircle 方法。这种方式不仅实现了分离关注点，还提供了极大的灵活性和可扩展性。\n桥接模式的关键点\n解耦抽象与实现：通过组合的方式，使得 Shape 和 Renderer 可以独立变化。 动态绑定：可以在运行时选择不同的 Renderer 实现，并将其传递给 Shape 对象。 灵活性：可以轻松添加新的 Shape 或 Renderer 类，而不需要修改现有代码。 备忘录模式 一种行为设计模式，它允许在不暴露对象实现细节的情况下保存和恢复对象的内部状态。这种模式通常用于需要回滚操作或撤销功能的场景中。\n备忘录模式的核心思想\n原发器（Originator）：负责创建和存储其内部状态的备忘录对象。 备忘录（Memento）：包含原发器对象的状态信息，但不允许其他对象访问这些信息，以保护封装性。 管理者（Caretaker）：负责保存备忘录对象，但不直接操作备忘录的内容。 假设正在开发一个简单的文本编辑器，用户可以输入文本并执行撤销操作。可以使用备忘录模式来保存和恢复文本编辑器的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 备忘录类 class Memento { public: std::string state; // 存储原发器的状态 // 只有原发器可以访问备忘录的私有成员 friend class TextEditor; Memento(){} Memento(const std::string\u0026amp; state) : state(state) {} std::string getState() const { return state; } }; // 原发器类 class TextEditor { private: std::string text; // 当前文本内容 public: void setText(const std::string\u0026amp; text) { this-\u0026gt;text = text; } std::string getText() const { return text; } // 创建备忘录 Memento createMemento() const { return Memento(text); } // 恢复状态 void restoreFromMemento(const Memento\u0026amp; memento) { text = memento.getState(); } }; // 管理者类 class History { public: void saveMemento(const Memento\u0026amp; memento) { this-\u0026gt;memento = memento; } Memento getMemento() const { return memento; } private: Memento memento; }; int main() { TextEditor editor; History history; // 编辑文本 editor.setText(\u0026#34;Version 1\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; // 保存状态 history.saveMemento(editor.createMemento()); // 继续编辑文本 editor.setText(\u0026#34;Version 2\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; // 恢复到之前的状态 editor.restoreFromMemento(history.getMemento()); std::cout \u0026lt;\u0026lt; \u0026#34;Restored Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 Current Text: Version 1 Current Text: Version 2 Restored Text: Version 1 代码说明\n备忘录类（Memento）： 存储原发器的内部状态（如文本内容）。 通过私有构造函数和友元类确保只有原发器可以创建和访问备忘录对象。 原发器类（TextEditor）： 负责创建备忘录对象（createMemento 方法）。 可以使用备忘录对象恢复自身状态（restoreFromMemento 方法）。 管理者类（History）： 负责保存备忘录对象（saveMemento 方法）。 不能修改备忘录对象的内容，只能获取备忘录对象（getMemento 方法）。 客户端代码： 使用原发器编辑文本并保存状态。 使用管理者保存备忘录对象。 使用备忘录对象恢复原发器的状态。 优点\n封装性： 备忘录模式在不破坏封装性的前提下保存和恢复对象的状态。 简化原发器： 将状态保存和恢复的逻辑分离到备忘录和管理者中，简化了原发器的代码。 可扩展性： 可以轻松地支持多次撤销操作（通过保存多个备忘录对象）。 缺点\n资源消耗： 如果对象的状态很大或需要保存多个状态，可能会消耗大量内存。 复杂性： 引入了备忘录和管理者类，增加了代码的复杂性。 中介模式 职责链模式 访问器模式 解析器模式 ","date":"1074-01-03T00:53:52+08:00","permalink":"http://localhost:1313/p/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"C++设计模式"},{"content":"概念与约束 简介 C++ 的 concept 是 C++20 引入的重要特性，用于约束模板参数的类型或行为，使模板编程更安全、更可读，并提供更清晰的编译错误信息。它本质上是一种编译期的类型约束机制。\n在 C++20 中，Concepts 和 requires 表达式是用于约束模板参数的强大工具。它们使得模板编程更加直观和易于理解，并且可以在编译期进行更详细的类型检查。\n为什么需要 concept？\n在传统的模板编程中，模板参数的类型约束通常是隐式的（通过代码中的操作推断），这可能导致：\n难以理解的编译错误（尤其是深层次嵌套的模板）。 无法在编译期明确检查模板参数是否满足要求。 代码可读性差，难以直观看出模板参数需要满足的条件。 concept 通过显式定义类型约束解决了这些问题。\nConcepts 语法 1 2 template\u0026lt;typename T\u0026gt; concept ConceptName = constraint_expression; ConceptName 是为这个约束起的名字。 constraint_expression 是一个布尔表达式，通常使用 requires 表达式或其他类型特征（如 std::is_integral_v\u0026lt;T\u0026gt;）来定义。 concept为true时，模版可以编译，为false不可编译。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;concepts\u0026gt; // 定义一个简单的概念，要求 T 必须是一个整数类型 template\u0026lt;typename T\u0026gt; concept Integral = std::is_integral_v\u0026lt;T\u0026gt;; // 使用该概念的模板函数 template\u0026lt;Integral T\u0026gt; void printIntegral(T value) { std::cout \u0026lt;\u0026lt; \u0026#34;Integral value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { printIntegral(42); // 正确：42 是 int 类型 // printIntegral(3.14); // 错误：3.14 不是整数类型 } Requires 表达式 requires 表达式是一种更灵活的方式来定义模板约束。它可以用于检查类型是否支持某些操作或成员函数。\n1 2 3 requires (parameter-list) { requirement-seq } // 或者 requires { requirement-seq } parameter-list 是可选的，如果需要检查某个特定类型的成员函数或操作符时可以使用。 requirement-seq 是一系列的要求，通常是表达式或类型特征。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //约束模板实参为int template \u0026lt;class T\u0026gt; requires std::is_integral_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; std::is_signed_v\u0026lt;C\u0026gt; struct X {} //编译器会断⾔ a + b 的合法性，但不会计算其最终结果。 template\u0026lt;typename T\u0026gt; concept C = requires (T a, T b) { a + b; }; //检查操作符 // 定义一个概念，要求 T 支持加法操作 template\u0026lt;typename T\u0026gt; concept Addable = requires(T a, T b) { { a + b } -\u0026gt; std::same_as\u0026lt;T\u0026gt;; // 检查 T 是否支持 + 操作且结果可转换为 T }; //检查操作符 // 定义一个概念，要求 T 支持 == 操作符 template\u0026lt;typename T\u0026gt; concept EqualityComparable = requires(T a, T b) { { a == b } -\u0026gt; std::convertible_to\u0026lt;bool\u0026gt;; }; //检查成员函数 // 定义concept：要求类型T必须实现execute() template\u0026lt;typename T\u0026gt; concept Strategy = requires(T t) { t.execute(); }; // 定义 Observer 概念的约束 template\u0026lt;typename O\u0026gt; concept Observer = requires(O o, const std::string\u0026amp; msg) { { o.update(msg) } -\u0026gt; std::same_as\u0026lt;void\u0026gt;; // 必须实现 update 方法，且返回值为void }; 用法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;concepts\u0026gt; // 定义一个概念，要求 T 支持加法操作 template\u0026lt;typename T\u0026gt; concept Addable = requires(T a, T b) { { a + b } -\u0026gt; std::same_as\u0026lt;T\u0026gt;; // 检查 T 是否支持 + 操作且结果可转换为 T }; // 使用该概念的模板函数 template\u0026lt;Addable T\u0026gt; T add(const T\u0026amp; a, const T\u0026amp; b) { return a + b; } int main() { int x = 5, y = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Integers: \u0026#34; \u0026lt;\u0026lt; add(x, y) \u0026lt;\u0026lt; std::endl; // 输出: Integers: 15 double d1 = 3.14, d2 = 2.86; std::cout \u0026lt;\u0026lt; \u0026#34;Doubles: \u0026#34; \u0026lt;\u0026lt; add(d1, d2) \u0026lt;\u0026lt; std::endl; // 输出: Doubles: 6.0 } 组合Concepts 可以组合多个 Concepts 来创建更复杂的约束条件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;concepts\u0026gt; template\u0026lt;typename T\u0026gt; concept Integral = std::is_integral_v\u0026lt;T\u0026gt;; template\u0026lt;typename T\u0026gt; concept Signed = std::is_signed_v\u0026lt;T\u0026gt;; template\u0026lt;typename T\u0026gt; concept SignedIntegral = Integral\u0026lt;T\u0026gt; \u0026amp;\u0026amp; Signed\u0026lt;T\u0026gt;; template\u0026lt;SignedIntegral T\u0026gt; void printSignedIntegral(T value) { std::cout \u0026lt;\u0026lt; \u0026#34;Signed integral value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { printSignedIntegral(-42); // 正确：-42 是 signed int 类型 // printSignedIntegral(3.14); // 错误：3.14 不是整数类型 // printSignedIntegral(static_cast\u0026lt;unsigned int\u0026gt;(42)); // 错误：unsigned int 不是 signed 类型 } 其它 基本用法\n1.定义 concept\n使用 requires 关键字或组合已有的概念来定义约束：\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; concept Integral = std::is_integral_v\u0026lt;T\u0026gt;; // 检查 T 是否为整型 template\u0026lt;typename T\u0026gt; concept Addable = requires(T a, T b) { { a + b } -\u0026gt; std::convertible_to\u0026lt;T\u0026gt;; // 检查 T 是否支持 + 操作且结果可转换为 T }; 2.使用 concept 约束模板\n在模板参数列表或函数签名中直接使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 方式1：使用 requires 子句 template\u0026lt;typename T\u0026gt; requires Integral\u0026lt;T\u0026gt; // 约束 T 必须是整型 T add(T a, T b) { return a + b; } // 方式2：简化语法（C++20） template\u0026lt;Integral T\u0026gt; T add(T a, T b) { return a + b; } // 方式3：直接约束函数参数 auto add(Integral auto a, Integral auto b) { return a + b; } 3.组合 concept\n使用逻辑运算符组合多个约束：\n1 2 3 4 5 template\u0026lt;typename T\u0026gt; concept Numeric = Integral\u0026lt;T\u0026gt; || std::floating_point\u0026lt;T\u0026gt;; // T 是整型或浮点型 template\u0026lt;Numeric T\u0026gt; T square(T x) { return x * x; } 对比传统方法（C++20 之前）\n在 C++17 及之前，通常使用 std::enable_if 或静态断言实现类似功能，但代码冗长且错误信息不友好：\n1 2 3 4 5 6 7 8 9 10 11 // 使用 enable_if template\u0026lt;typename T, typename = std::enable_if_t\u0026lt;std::is_integral_v\u0026lt;T\u0026gt;\u0026gt;\u0026gt; T add(T a, T b) { return a + b; } // 使用 static_assert template\u0026lt;typename T\u0026gt; T add(T a, T b) { static_assert(std::is_integral_v\u0026lt;T\u0026gt;, \u0026#34;T must be integral\u0026#34;); return a + b; } 举例 类型约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;class T\u0026gt; concept IntegerType = std::is_integral_v\u0026lt;T\u0026gt;; template \u0026lt;IntegerType T\u0026gt; struct X { using value_type = T; explicit X(value_type in_value) : a{in_value} {} value_type a; }; int main() { // [C7602] “X”: 未满足关联约束. //由于违反约束 IntegerType\u0026lt;float\u0026gt;， //不能将类型模板实参 float替换为约束类型模板形参 T X\u0026lt;float\u0026gt; x1(3); X\u0026lt;int\u0026gt; x2(3); cout \u0026lt;\u0026lt;format(\u0026#34;x2.a value:{} type:{} \\n\u0026#34;,x2.a,typeid(x2.a).name()); return 0; } 结构体X类 要求传入参数是int类型， X\u0026lt;float\u0026gt; 因为传入参数不是int类型 编译时报错 \u0026ldquo;未满足关联约束\u0026rdquo;.\nX\u0026lt;int\u0026gt; 传入int类型，成功编译.\n输出\n1 x2.a value:3 type:int 或直接使用 requires\n1 2 3 4 5 6 7 8 9 template \u0026lt;class T\u0026gt; requires std::is_integral_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; std::is_signed_v\u0026lt;T\u0026gt; struct X { using value_type = T; explicit X(value_type in_value) : a{in_value} {} value_type a; }; 如果不使用concept:\n使用特化实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;type_traits\u0026gt; // 主模板声明（未定义） template \u0026lt;typename T, typename Enable = void\u0026gt; struct X; // 特化版本，仅当 T 是整数类型时才启用 template \u0026lt;typename T\u0026gt; struct X\u0026lt;T, std::enable_if_t\u0026lt;std::is_integral_v\u0026lt;T\u0026gt;\u0026gt;\u0026gt; { using value_type = T; explicit X(value_type in_value) : a{in_value} {} value_type a; }; int main() { X\u0026lt;int\u0026gt; x(42); // 正常工作 // X\u0026lt;double\u0026gt; y(3.14); // 编译错误：double 不是整数类型 } 使用 static_assert 实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;type_traits\u0026gt; template \u0026lt;typename T\u0026gt; struct X { static_assert(std::is_integral_v\u0026lt;T\u0026gt;, \u0026#34;Template argument must be an integral type\u0026#34;); using value_type = T; explicit X(value_type in_value) : a{in_value} {} value_type a; }; int main() { X\u0026lt;int\u0026gt; x(42); // 正常工作 // X\u0026lt;double\u0026gt; y(3.14); // 编译错误：Template argument must be an integral type } 使用 std::enable_if：通过模板特化和 std::enable_if 实现类型约束，可以在编译时选择性地启用或禁用模板实例化。 使用 static_assert：通过 static_assert 直接在编译时检查类型是否满足条件，并在不满足时生成明确的错误消息。\n特性 Concepts std::enable_if static_assert 语法和可读性 简洁明了，意图明确 复杂，不易于理解和维护 简单，但功能有限 灵活性 支持复杂的约束条件组合 可以实现复杂的约束条件组合，但语法复杂 适用于简单的类型检查 编译器错误信息 清晰，直接指出哪个约束未满足 错误信息可能不够明确 明确，但上下文不如 Concepts 丰富 C++标准支持 C++20 及更高版本 C++11 及之后的标准 C++11 及之后的标准 适用场景 复杂的模板特化和约束条件 复杂的模板特化和约束条件，但语法复杂 简单的类型检查 函数约束 检查类型 T 是否支持加法操作 (+) 且结果可以转换为 T。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class FComplex { public: FComplex(float V) : Value(V){} float Value; FComplex operator+(const FComplex\u0026amp; other) const { return FComplex(Value + other.Value); } }; template\u0026lt;typename T\u0026gt; concept Addable = requires(T a, T b) { // 检查 T 是否支持 + 操作且结果可转换为 T { a + b } -\u0026gt; std::convertible_to\u0026lt;T\u0026gt;; }; // 只有当 T 满足 Addable 约束时，此函数才会被实例化 template\u0026lt;Addable T\u0026gt; T add(const T\u0026amp; a, const T\u0026amp; b) { return a + b; } int main() { int x = 5, y = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Integers: \u0026#34; \u0026lt;\u0026lt; add(x, y) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 输出: Integers: 15 double d1 = 3.14, d2 = 2.86; std::cout \u0026lt;\u0026lt; \u0026#34;Doubles: \u0026#34; \u0026lt;\u0026lt; add(d1, d2) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 输出: Doubles: 6.0 FComplex c1(1.5); FComplex c2(2.5); //如果FComplex不重载+运算符，报错[C2672] “add”: 未找到匹配的重载函数 add(c1,c2); } FComplex类必须重载加法操作符.\n实现策略模式 用concept约束策略类必须实现特定方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; // 定义concept：要求类型T必须实现execute() template\u0026lt;typename T\u0026gt; concept Strategy = requires(T t) { t.execute(); }; // 上下文类，使用Strategy约束类型T template\u0026lt;Strategy T\u0026gt; class Context { private: T strategy; public: Context(T strategy) : strategy(strategy) {} void run() { strategy.execute(); } }; // 具体策略类A struct StrategyA { void execute() { std::cout \u0026lt;\u0026lt; \u0026#34;StrategyA: Execute\\n\u0026#34;; } }; // 具体策略类B struct StrategyB { void execute() { std::cout \u0026lt;\u0026lt; \u0026#34;StrategyB: Execute\\n\u0026#34;; } }; int main() { StrategyA a; Context\u0026lt;StrategyA\u0026gt; ctxA(a); ctxA.run(); // 输出：StrategyA的执行 StrategyB b; Context\u0026lt;StrategyB\u0026gt; ctxB(b); ctxB.run(); // 输出：StrategyB的执行 } 输出\n1 2 StrategyA: Execute StrategyB: Execute Strategy：约束类型必须实现step1() step2() step3()。 Context类：通过模板参数接受策略类型，调用其step()。 策略类：无需继承统一接口，只需满足concept约束。 特性 传统实现（继承+虚函数） 基于concept的实现 运行时开销 虚函数调用（动态多态） 无虚函数（静态多态） 灵活性 支持运行时替换策略 编译时确定策略类型 错误信息 可能模糊的虚函数错误 明确违反concept的编译错误 代码冗余 需要定义基类和继承关系 直接实现方法，无需基类 模板方法模式 模板方法模式通过定义算法的框架，允许子类重写某些步骤。用concept约束模板参数，确保类型满足步骤方法的调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 定义concept：要求类型T必须实现step1()和step2() template\u0026lt;typename T\u0026gt; concept AlgorithmSteps = requires(T t) { t.step1(); t.step2(); }; // 算法框架类，使用AlgorithmSteps约束类型T template\u0026lt;AlgorithmSteps T\u0026gt; class Algorithm { private: T strategy; public: Algorithm(T strategy) : strategy(strategy) {} void execute() { strategy.step1(); strategy.step2(); } }; // 具体策略类A struct ConcreteStrategyA { void step1() { std::cout \u0026lt;\u0026lt; \u0026#34;StrategyA: Step 1\\n\u0026#34;; } void step2() { std::cout \u0026lt;\u0026lt; \u0026#34;StrategyA: Step 2\\n\u0026#34;; } }; // 具体策略类B struct ConcreteStrategyB { void step1() { std::cout \u0026lt;\u0026lt; \u0026#34;StrategyB: Step 1\\n\u0026#34;; } void step2() { std::cout \u0026lt;\u0026lt; \u0026#34;StrategyB: Step 2\\n\u0026#34;; } }; int main() { ConcreteStrategyA a; Algorithm\u0026lt;ConcreteStrategyA\u0026gt; algoA(a); algoA.execute(); // 输出：StrategyA的步骤 ConcreteStrategyB b; Algorithm\u0026lt;ConcreteStrategyB\u0026gt; algoB(b); algoB.execute(); // 输出：StrategyB的步骤 } 例2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 template\u0026lt;typename T\u0026gt; concept Component = requires(T t) { t.step1(); // 约束1：必须有 step1() 方法 { t.step2() } -\u0026gt; std::convertible_to\u0026lt;bool\u0026gt;; // 约束2：step2() 的返回值可转换为 bool t.step3(); // 约束3：必须有 step3() 方法 { t.step4() } -\u0026gt; std::integral; // 约束4：step4() 的返回值是整数类型 t.step5(); // 约束5：必须有 step5() 方法 }; class Library { public: static void process(Component auto\u0026amp; component) { component.step1(); if (component.step2()) { component.step3(); } if (component.step4() \u0026lt; 10) { component.step5(); } } void step1() { cout \u0026lt;\u0026lt; format(\u0026#34;Library::step1\\n\u0026#34;); } bool step2() { cout \u0026lt;\u0026lt; format(\u0026#34;Library::step2\\n\u0026#34;); return true; } void step3() { cout \u0026lt;\u0026lt; format(\u0026#34;Library::step3\\n\u0026#34;); } }; class App : public Library { public: int step4() { cout \u0026lt;\u0026lt; format(\u0026#34;App::step4\\n\u0026#34;); return 5; } void step5() { cout \u0026lt;\u0026lt; format(\u0026#34;App::step5\\n\u0026#34;); } }; //调用方法2 static void processlib(Component auto\u0026amp; component) { component.step1(); if (component.step2()) { component.step3(); } if (component.step4() \u0026lt; 10) { component.step5(); } } int main() { App app; Library::process(app); //调用方法2 processlib(app); } 输出：\n1 2 3 4 5 Library::step1 Library::step2 Library::step3 App::step4 App::step5 观察者模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // 定义 Observer 概念的约束 template\u0026lt;typename O\u0026gt; concept Observer = requires(O o, const std::string\u0026amp; msg) { { o.update(msg) } -\u0026gt; std::same_as\u0026lt;void\u0026gt;; // 必须实现 update 方法 }; // 具体 Subject 实现 template\u0026lt;Observer O\u0026gt; class ConcreteSubject { public: void addObserver(O* observer) { observers_.push_back(observer); } void removeObserver(O* observer) { observers_.remove(observer); } void notify() { for (auto* observer : observers_) { observer-\u0026gt;update(\u0026#34;Subject state changed!\u0026#34;); } } private: std::list\u0026lt;O*\u0026gt; observers_; }; // 具体 Observer 实现 class ConcreteObserver { public: void update(const std::string\u0026amp; msg) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer received: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { ConcreteSubject\u0026lt;ConcreteObserver\u0026gt; subject; ConcreteObserver obs1, obs2; subject.addObserver(\u0026amp;obs1); subject.addObserver(\u0026amp;obs2); subject.notify(); // 触发所有观察者的 update() cout \u0026lt;\u0026lt; \u0026#34;Remove obs2\\n\u0026#34;; subject.removeObserver(\u0026amp;obs2); subject.notify(); // 仅触发 obs1 的 update() return 0; } 概念定义：\nObserver 概念：要求类型必须实现 void update(const std::string\u0026amp;) 方法。 Subject 概念：要求类型必须实现观察者的增删改查操作，且关联的观察者类型需满足 Observer 概念。 实现特点：\n类型安全：通过 static_assert 确保具体类满足概念约束。 编译时检查：无效操作（如传递非 Observer 类型）会在编译期报错。 零运行时开销：概念约束在编译期展开，无额外性能损耗。 若需允许主题接受不同类型的观察者（类似传统虚函数实现），可以结合 std::function 或自定义包装器.\n","date":"1074-01-02T11:19:44+08:00","permalink":"http://localhost:1313/p/%E7%8E%B0%E4%BB%A3c-/","title":"现代C++"},{"content":"const 使用const声明函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Obj { public: void func() {cout \u0026lt;\u0026lt; \u0026#34;func\u0026#34; \u0026lt;\u0026lt; endl;} void func() const { cout \u0026lt;\u0026lt; \u0026#34;const func\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Obj NonConstObj; NonConstObj.func(); const Obj ConstObj; ConstObj.func(); return 0; } 输出:\n1 2 func const func Non-const对象 调用Non-const版本的函数const对象 调用const版本的函数.\n结合返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Obj { public: char\u0026amp; operator[](std::size_t position) { cout \u0026lt;\u0026lt; \u0026#34;Non-const Get\u0026#34; \u0026lt;\u0026lt; endl; return name[position]; } const char\u0026amp; operator[](std::size_t position) const { cout \u0026lt;\u0026lt; \u0026#34;Const Get\u0026#34; \u0026lt;\u0026lt; endl; return name[position]; } std::string name = \u0026#34;ab\u0026#34;; }; int main() { Obj NonConstObj; //调用 char\u0026amp; operator[](std::size_t position) NonConstObj[1] = \u0026#39;z\u0026#39;; cout \u0026lt;\u0026lt; NonConstObj.name \u0026lt;\u0026lt; endl; const Obj ConstObj = NonConstObj; //“ConstObj”: 不能给常量赋值 //调用 const char\u0026amp; operator[](std::size_t position) const ConstObj[1] = \u0026#39;c\u0026#39;; return 0; } ConstObj 调用const版本的[] ，函数内 string又调用了 const版本的 []，返回const_reference最终返回值是 const char\u0026amp; 所以不能给常量赋值.\n如果让 const版本的[] 返回 char\u0026amp; ，就能修改值\n1 2 3 4 5 6 7 8 char\u0026amp; operator[](std::size_t position) const { cout \u0026lt;\u0026lt; \u0026#34;Const Get\u0026#34; \u0026lt;\u0026lt; endl; return *const_cast\u0026lt;char*\u0026gt;(\u0026amp;name[position]); } //返回值是 char\u0026amp;，所以能修改值 ConstObj[1] = \u0026#39;c\u0026#39;; 只用一份operator[] , non-const 调用 const，避免代码重复.const 调用 non-const 是错误做法， non-const 可以做的事情比 const 多，const内不可以修改对象的数据，如果non-const修改了对象数据，const无法调用non-const.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Obj { public: char\u0026amp; operator[](std::size_t position) { //最终调用 const char\u0026amp; operator[](std::size_t position) const Obj \u0026amp;obj = *this; const Obj const_this = static_cast\u0026lt;const Obj\u0026amp;\u0026gt;(obj); const char\u0026amp; const_char = const_this[position]; return const_cast\u0026lt;char\u0026amp;\u0026gt;(const_char); } const char\u0026amp; operator[](std::size_t position) const { cout \u0026lt;\u0026lt; \u0026#34;Const Get\u0026#34; \u0026lt;\u0026lt; endl; return name[position]; } std::string name = \u0026#34;ab\u0026#34;; }; int main() { Obj NonConstObj; //调用 char\u0026amp; operator[](std::size_t position) NonConstObj[1] = \u0026#39;z\u0026#39;; cout \u0026lt;\u0026lt; NonConstObj.name \u0026lt;\u0026lt; endl; return 0; } 总结\nconst对象 调用 const声明的函数，例如:void func() const\n通常在 const 函数内返回一个 const对象 ，例如: const char\u0026amp; operator[](std::size_t position) const\n在这两个因素的作用下，最终获得了 const char\u0026amp; ，因此不能修改值.\nnon-const 调用 const 可避免代码重复.\nconst对象 决定了调用哪个版本的函数， 函数决定返回 const返回值，不能对 const返回值 进行修改.\npass-by-reference-to-const 在函数参数传递中，使用 pass-by-value 将触发拷贝构造，使用 const Type\u0026amp; 避免耗时的拷贝构造.\n避免不必要的拷贝：对于大型对象，使用 const type\u0026amp; 可以避免昂贵的拷贝操作。 保持数据的不可变性：使用 const 确保函数不会修改传入的参数。 支持多态：引用允许传递派生类对象给接受基类引用的函数。 兼容性和一致性：对于复杂类型，使用引用可以提高代码的一致性和可维护性。 确定对象在使用前被初始化 初始化（Initialization）：是指在对象创建时给其分配初始值的过程,这是在对象的生命周期开始之前进行的操作。使用成员初始化列表就是在对象被构造之前为成员变量设定初始值。\n赋值（Assignment）：是指将一个已经存在的对象的值替换为另一个值。这通常发生在对象已经被初始化之后，即在构造函数体内进行赋值操作。\nC++规定 对象的成员变量的初始化动作 发生在进入构造函数本体之前.初始化发生在调用构造函数之前，在构造函数本体内是赋值，而不是初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ABEntry { public: ABEntry(const std::string\u0026amp; name, const std::string\u0026amp; address, const std::list\u0026lt;PhoneNumber\u0026gt;\u0026amp; phones) : theName(name), // 初始化 theName theAddress(address), // 初始化 theAddress thePhones(phones), // 初始化 thePhones numTimesConsulted(0) // 初始化 numTimesConsulted { // 这里不再进行成员变量的赋值，避免重复操作 } private: std::string theName; std::string theAddress; std::list\u0026lt;PhoneNumber\u0026gt; thePhones; int numTimesConsulted; }; 初始化列表的本质：在内存构造阶段直接初始化\n在成员初始化列表中写 : theName(name) 时，编译器会：\n在对象内存分配完成后，直接调用 std::string 的拷贝构造函数，用 name 初始化 theName。 这个动作发生在构造函数本体代码执行之前。 构造函数本体内的操作是「赋值」\n若不在初始化列表中初始化成员变量，而是将代码移到构造函数体内：\n1 2 3 4 5 6 ABEntry(...) { // 无初始化列表 theName = name; // 这是赋值操作，不是初始化！ theAddress = address; thePhones = phones; numTimesConsulted = 0; } 此时会发生：\n成员变量先被默认初始化（例如 theName 调用 std::string 的默认构造函数，生成空字符串）。 进入构造函数本体后，再通过赋值运算符（operator=）覆盖值。 性能损失：对非基本类型（如 std::string），这相当于多了一次 默认构造 + 拷贝赋值，而初始化列表只需一次 拷贝构造。\n必须使用初始化列表的场景 某些成员变量必须在初始化列表中初始化，否则会导致编译错误：\nconst 成员：常量只能在初始化时赋值。 引用成员：引用必须绑定到初始对象。 没有默认构造函数的类成员：依赖外部参数初始化。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Example { public: Example(int\u0026amp; ref, const int c) : refMember(ref), constMember(c) // 必须用初始化列表 { // 构造函数本体内无法初始化 const/引用成员 } private: int\u0026amp; refMember; // 引用成员 const int constMember; // const 成员 }; 初始化列表的优先级 成员变量的初始化顺序与其在类中声明的顺序一致（与初始化列表中的顺序无关）。 若未在初始化列表中显式初始化成员变量： 若成员是类类型：调用其默认构造函数。 若成员是基本类型（如 int）：不保证初始化（值未定义，除非类内提供默认值）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Test { public: Test() : x(1), y(x + 1) {} // 意图：y = x + 1 = 2 // 实际初始化顺序是 y(x+1) -\u0026gt; x(1)，导致 y 的值是垃圾值 + 1 // 因为声明顺序是 y 先于 x int y; int x; }; int main() { Test d; cout \u0026lt;\u0026lt; format(\u0026#34;{} {}\u0026#34;, d.x,d.y) \u0026lt;\u0026lt; endl; return 0; } 输出结果中 y 的值是未定义的，因为 y 的初始化早于 x，此时 x 尚未被初始化为 1。\n对于基本类型（如 int），初始化列表中的 numTimesConsulted(0) 和构造函数体内的 numTimesConsulted = 0 在结果上等效，但底层行为不同：\n初始化列表：直接写入初始值（无额外操作）。 构造函数体内：先保留默认的未定义值，再覆盖为 0。 对于自定义类类型（如 std::string），差异会导致性能损耗（多调用一次默认构造函数和拷贝赋值运算符）。\n总结：为什么成员初始化列表是真正的初始化？\n时序上：初始化列表的代码在对象内存分配后立即执行，早于构造函数本体。 语义上：初始化列表直接调用成员的构造函数，而构造函数本体执行的是赋值操作。 必要性：对某些成员（如 const、引用），初始化列表是唯一合法的初始化途径。 C++默默编写的函数 编译器替我抗下了一切 😢😭\n1 2 3 4 5 6 7 8 9 10 11 12 class Empty{} //-----编译器改写-------// class Empty { public: Empty(){...} Empty(const Empty\u0026amp; rhs){...} ~Empty(){...} Empty\u0026amp; operator=(const Empty\u0026amp; rhs){...} } 上面两个类等同，\n只有这些函数被调用，编译器才会创建.\n1 2 3 4 Empty e1;//创建 默认构造函数、析构函数 Empty e2(e1); //创建 拷贝构造函数 e2 = e1; //创建 拷贝赋值运算符 编译器创建的 析构函数 不是虚函数.\n拷贝构造函数 和 拷贝赋值运算符 将来源对象的每一个 non-static 成员变量 拷贝到 目标对象.\n如果声明了一个构造函数，编译器不会再创建 默认构造函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Obj { public: int a = 3; Obj(int Value) : a(Value) {} }; int main() { Obj o1(1); Obj o2(2); cout \u0026lt;\u0026lt; format(\u0026#34;o1:{} o2:{} \\n\u0026#34;, o1.a,o2.a); o1 = o2; cout \u0026lt;\u0026lt; format(\u0026#34;o1:{} o2:{} \\n\u0026#34;, o1.a, o2.a); Obj o3(o2); //调用拷贝构造函数 cout \u0026lt;\u0026lt; format(\u0026#34;o1:{} o2:{} o3:{}\\n\u0026#34;, o1.a, o2.a,o3.a); return 0; } 输出\n1 2 3 o1:1 o2:2 o1:2 o2:2 o1:2 o2:2 o3:2 Obj 没有声明 拷贝构造函数、拷贝赋值运算符，编译器自动创建这两个函数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyInt { public: MyInt(int Value) : value(Value) {cout\u0026lt;\u0026lt;\u0026#34;MyInt\u0026#34;\u0026lt;\u0026lt;endl;} MyInt(const MyInt\u0026amp; other) : value(other.value) {cout\u0026lt;\u0026lt;\u0026#34;const MyInt\u0026amp; other\u0026#34;\u0026lt;\u0026lt;endl;} MyInt\u0026amp; operator=(const MyInt\u0026amp; other) { cout \u0026lt;\u0026lt; \u0026#34;operator=\u0026#34; \u0026lt;\u0026lt; endl; value = other.value; return *this; } int value; }; class Obj { public: MyInt a; Obj(int Value) : a(Value) {} int GetMyIntValue() { return a.value; } }; int main() { Obj o1(1); Obj o2(2); cout \u0026lt;\u0026lt; format(\u0026#34;o1:{} o2:{} \\n\u0026#34;, o1.GetMyIntValue(), o2.GetMyIntValue()); o1 = o2; cout \u0026lt;\u0026lt; format(\u0026#34;o1:{} o2:{} \\n\u0026#34;, o1.GetMyIntValue(), o2.GetMyIntValue()); Obj o3(o2); cout \u0026lt;\u0026lt; format(\u0026#34;o1:{} o2:{} o3:{}\\n\u0026#34;, o1.GetMyIntValue(), o2.GetMyIntValue(),o3.GetMyIntValue()); return 0; } 输出\n1 2 3 4 5 6 7 MyInt MyInt o1:1 o2:2 operator= o1:2 o2:2 const MyInt\u0026amp; other o1:2 o2:2 o3:2 Obj 类 拥有一个MyInt类的变量，Obj 的 拷贝赋值运算符 调用 MyInt 的 拷贝赋值运算符，Obj 的 拷贝构造函数 调用 MyInt 的 拷贝构造函数\n构造和析构过程中不应调用虚函数 先有鸡还是先有蛋？🐤🥚\n在base class构造期间，virtual 函数不是 virtual 函数.\nbase class 构造函数 的执行早于 derived class构造函数，此时 derived class的成员变量尚未初始化.\n在 derived class 对象的 base class 构造期间，对象的类型是 base class 而不是 derived class. RTTI也会把对象视为 base class 类型. dynamic_cast typeid不正确. derived class 构造函数 执行前 不会成为一个 derived class对象.\n在基类的构造函数和析构函数中调用虚函数时，虚函数不会下降到派生类。因为：\n构造顺序：先基类 -\u0026gt; 后派生类。在基类构造期间，派生类尚未初始化，此时虚函数只能调用基类的版本。 析构顺序：先派生类 -\u0026gt; 后基类。在基类析构期间，派生类已被销毁，此时虚函数也只能调用基类的版本。 这种行为可能导致逻辑错误或资源泄漏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Base { public: Base() { log(); // 意图调用派生类的 log() } virtual void log() { std::cout \u0026lt;\u0026lt; \u0026#34;Base::log()\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: void log() override { std::cout \u0026lt;\u0026lt; \u0026#34;Derived::log()\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Derived d; // 实际输出：Base::log() } 正确做法：将信息通过构造函数参数传递\n在基类构造/析构期间，虚函数无法调用派生类的实现。应通过构造函数参数直接传递信息，而非依赖运行时多态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Base { public: explicit Base(const std::string\u0026amp; info) { // 通过参数接收信息 std::cout \u0026lt;\u0026lt; \u0026#34;Base: \u0026#34; \u0026lt;\u0026lt; info \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: Derived() : Base(\u0026#34;Info from Derived\u0026#34;) {} // 将派生类信息传递给基类 }; int main() { Derived d; // 输出：Base: Info from Derived } 设计class 如何创建和销毁 初始化和赋值的区别 值传递会发生什么 成员变量的范围、类型限定 是否涉及继承，如果允许继承，需要虚析构函数 是否允许类型转换，考虑添加 explicit 需要哪些函数、操作符 哪些函数需要 =delete 函数和变量的访问权限 public、private、protected 通用类 可能定义为类模板 class tempalte ","date":"1074-01-02T00:20:51+08:00","permalink":"http://localhost:1313/p/effective-c-/","title":"Effective C++"},{"content":"简介 迭代器（Iterator）是一种用于遍历容器（如 std::vector, std::list, std::map 等）中元素的工具。它们提供了一种统一的方式来访问和操作容器中的数据，无论这些容器是如何实现的。迭代器的设计灵感来源于指针的概念，但它们提供了更抽象和灵活的操作接口。迭代器可以看作是“智能指针”，它们不仅能够指向容器中的某个位置，还能通过一系列标准操作进行移动、访问和修改容器中的元素。\nSTL 的六大组件通过 迭代器 作为粘合剂，将以下五个东西有机整合。\n数据存储（容器） 数据操作（算法） 行为策略（仿函数） 接口改造（适配器） 内存管理（分配器） 这种设计使得代码高度模块化、可复用且高效，成为C++泛型编程的典范。容器库 算法库\n容器类型 特点 时间复杂度（平均） 时间复杂度（最坏） 适用场景 std::vector 动态数组，支持随机访问 O(1) O(n) 需要频繁随机访问，且大多数操作集中在尾部 std::deque 双端队列，支持两端高效插入和删除 O(1) O(n) 需要在两端频繁插入和删除 std::list 双向链表，支持任意位置高效插入和删除 O(1) O(n) 需要频繁在任意位置插入和删除 std::forward_list 单向链表，支持高效插入和删除 O(1) O(n) 需要单向遍历和高效的插入/删除操作 std::set 有序集合，基于平衡二叉搜索树 O(log n) O(log n) 需要保持元素有序 std::multiset 有序多重集合，允许重复元素 O(log n) O(log n) 需要保持元素有序且允许重复元素 std::map 有序映射，基于平衡二叉搜索树 O(log n) O(log n) 需要保持键有序 std::multimap 有序多重映射，允许重复键 O(log n) O(log n) 需要保持键有序且允许重复键 std::unordered_set 无序集合，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multiset 无序多重集合，允许重复元素 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复元素 std::unordered_map 无序映射，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multimap 无序多重映射，允许重复键 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复键 std::stack LIFO 数据结构，基于其他容器实现 O(1) O(1) 需要栈操作 std::queue FIFO 数据结构，基于其他容器实现 O(1) O(1) 需要队列操作 std::priority_queue 优先队列，基于堆实现 O(log n) O(log n) 需要优先级管理的数据结构 设计哲学与优势\n解耦与复用： 算法与容器解耦，一个算法可作用于多种容器。 分配器与容器解耦，内存策略可灵活替换。 零开销抽象： 迭代器通过编译时多态（模板）实现，无运行时开销。 仿函数的内联优化比函数指针更高效。 扩展性： 用户可自定义容器（需提供迭代器）、算法（如支持新迭代器类型）、分配器等。 组件 作用 容器 存储和管理数据（如 vector, list, map） 算法 对数据进行操作（如 sort, find, transform） 迭代器 连接容器和算法，提供统一的元素访问接口 仿函数 封装可调用行为（如比较、运算），作为算法的策略参数 适配器 改造组件接口（如 stack 适配 deque，reverse_iterator 反向遍历） 分配器 管理容器的内存分配与释放（如自定义内存池） 联动:\n场景 参与的组件 示例 遍历容器 容器、迭代器 for (auto it = vec.begin(); ...) 排序算法 算法、迭代器、仿函数 sort(vec.begin(), vec.end(), comp) 容器适配栈 容器、适配器 stack\u0026lt;int, deque\u0026lt;int\u0026gt;\u0026gt; s 自定义内存管理 容器、分配器 vector\u0026lt;int, PoolAllocator\u0026lt;int\u0026gt;\u0026gt; 反向遍历 容器、迭代器、迭代器适配器 reverse_iterator rbegin() 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; int main() { int ia[5] = {30, 210, 12, 47, 89}; vector\u0026lt;int\u0026gt; vi(ia, ia + 5); // Container - vector //vector\u0026lt;int，allocator\u0026lt;int\u0026gt;\u0026gt; vi(ia, ia + 5); //统计小于30的元素 //Iterator - vi.begin(), vi.end() //Algorithm - count_if cout \u0026lt;\u0026lt; count_if(vi.begin(), vi.end(), [](int x) {return x \u0026lt; 30;}) \u0026lt;\u0026lt; endl; //统计大于等于30的元素 //Function Adapter - not_fn cout \u0026lt;\u0026lt; count_if(vi.begin(), vi.end(), not_fn([](int x) {return x \u0026lt; 30;})) \u0026lt;\u0026lt; endl; } 分配器 分配器（Allocator）是用于管理内存分配和释放的组件。它们主要用于标准库容器（如 std::vector, std::list, std::deque 等）中，以提供一致且高效的内存管理机制。\n主要职责：\n分配内存：为容器中的元素分配所需的内存。 释放内存：当容器不再需要某些内存时，释放这些内存。 构造和析构对象：在分配的内存上构造对象，并在需要时析构对象。 EASTL 开局 EASTL主要由容器、算法和迭代器组成。\n容器的一个例子是链表，而算法的一个例子是排序函数；迭代器则是用于遍历容器和算法的实体。\nEASTL包含相当多的容器和算法，每个都是一个非常干净、高效且经过单元测试的实现。\n我们可以自信地说，你不太可能找到更好的实现（无论是商业还是其他），因为这些实现是多年智慧和勤奋工作的结果。\nEAST 包含并扩展了标准 C++ STL 的功能，同时以各种对游戏开发有用的方式对其进行改进。\nEASTL 的大部分设计与标准 STL 相同，因为 STL 的大部分设计都经过精心设计，可用于多种用途。\nEASTL 与标准 STL 实现不同的主要方面基本上如下：\n具有简化且更灵活的自定义分配方案。 代码明显更易于阅读。 具有扩展容器和算法。 具有专为游戏开发而设计的优化。 唯一与STL不兼容的差异是内存分配的情况。\n为EASTL定义自定义分配器的方法与标准STL略有不同，尽管它们有90%的相似度。\n然而，那10%的不同之处却使得EASTL在大多数情况下比标准STL更易于使用且功能更强大。\n没有自定义分配器的容器在EASTL和标准STL之间的行为是相同的。\n某些 STL 实现（尤其是 Microsoft STL）的性能特征较差，因此不适合游戏开发。EASTL 比所有现有的 STL 实现都快。 STL 有时很难调试，因为大多数 STL 实现都使用晦涩难懂的变量名称和不寻常的数据结构。 STL 分配器有时使用起来很痛苦，因为它们有很多要求，并且一旦绑定到容器就无法修改。 STL 包含过多的功能，这些功能可能会导致代码大于预期。告诉程序员他们不应该使用该功能并不容易。 STL 是通过非常深入的函数调用实现的。这会导致在未优化构建中不可接受的性能，有时在优化构建中也是如此。 STL 不支持包含对象的对齐。 STL 容器不允许在未提供要从中复制的条目的情况下将条目插入容器。这可能效率低下。 在现有 STL 实现（如 STLPort）中找到的有用的 STL 扩展（例如 slist、hash_map shared_ptr）是不可移植的，因为它们在其他版本的 STL 中不存在，或者在 STL 版本之间不一致。 STL 缺乏游戏程序员认为有用的有用扩展（例如 intrusive_list），但在便携式 STL 环境中可以最好地优化这些扩展。 STL 的规范限制了我们有效使用它的能力。例如，STL 向量不能保证使用连续内存，因此不能安全地用作数组。 STL 强调正确性而不是性能，而有时您可以通过降低学术纯粹性来获得显着的性能提升。 STL 容器具有私有实现，不允许您以可移植的方式处理其数据，但有时这是一件重要的事情（例如节点池）。 所有现有版本的 STL 都至少在其某些容器的空版本中分配内存。这并不理想，并且会阻止优化，例如容器内存重置，在某些情况下可以大大提高性能。 STL 编译速度很慢，因为大多数现代 STL 实现都非常大。 存在一些法律问题，使我们很难自由地使用可移植的 STL 实现，例如 STLPort。 我们在 STL 的设计和实施中没有发言权，因此无法改变它以满足我们的需求。 可读性是 EASTL 比许多其他模板化库（尤其是 Microsoft STL 和 STLPort）更好的实现。\n我们尽一切努力使 EASTL 代码清晰明了。有时我们需要提供优化（特别是与 type_traits 和 iterator 类型相关）会导致代码不那么简单，但效率恰好是我们的首要任务，因此它凌驾于所有其他考虑因素之上。\n容器 原型容器：定义了所有非适配器容器都必须实现的基本功能。 适配器容器：如栈、队列等，这些容器通常基于其他基础容器构建，并且其具体实现可能会有所不同。 一致性：通过设定统一的标准，EASTL确保了不同容器之间的兼容性和易用性，减少了学习和使用成本。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 template \u0026lt;class T, class Allocator = EASTLAllocator\u0026gt; class container { public: typedef container\u0026lt;T, Allocator\u0026gt;\tthis_type; typedef T value_type; typedef T*\tpointer; typedef const T*\tconst_pointer; typedef\tT\u0026amp; reference; typedef const T\u0026amp; const_reference; typedef ptrdiff_t difference_type; typedef impl_defined size_type; typedef impl-defined iterator; typedef impl-defined const_iterator; typedef reverse_iterator\u0026lt;iterator\u0026gt; reverse_iterator; typedef reverse_iterator\u0026lt;const_iterator\u0026gt; reverse_const_iterator; typedef Allocator allocator_type; public: container(const allocator_type\u0026amp; allocator = allocator_type()); container(const this_type\u0026amp; x); this_type\u0026amp; operator=(this_type\u0026amp; x); void swap(this_type\u0026amp; x); void reset(); allocator_type\u0026amp; get_allocator(); void set_allocator(allocator_type\u0026amp; allocator); iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; bool validate() const; int validate_iterator(const_iterator i) const; protected: allocator_type mAllocator; }; template \u0026lt;class T, class Allocator\u0026gt; bool operator==(const container\u0026lt;T, Allocator\u0026gt;\u0026amp; a, const container\u0026lt;T, Allocator\u0026gt;\u0026amp; b); template \u0026lt;class T, class Allocator\u0026gt; bool operator!=(const container\u0026lt;T, Allocator\u0026gt;\u0026amp; a, const container\u0026lt;T, Allocator\u0026gt;\u0026amp; b); 分配器不交换：当两个容器通过交换操作互换内容时，它们各自的分配器不会被交换，这意味着每个容器将继续使用其原来的分配策略。 避免不必要的内存分配：EASTL的设计原则之一是尽量减少不必要的内存分配。新构造的空容器不会预先分配内存，这与某些其他容器库不同，后者可能会预先分配一个初始节点。 空容器的状态：无论是新创建的还是已经存在的空容器，都不会包含任何已构造的对象，包括所谓的“结束”节点。只有在设计确实需要并且有文档说明的情况下，才会构造用户对象。 reset函数的作用：reset函数用于快速重置容器到空状态，而无需释放容器内对象占用的内存。这对于临时使用的容器特别有用，因为它可以快速清理容器而不涉及复杂的内存管理。 显式验证机制：为了平衡性能和安全性，EASTL提供了显式的验证功能（如validate和validate_iterator），允许用户在需要时手动检查容器和迭代器的有效性，而不是每次都自动进行这种可能耗费大量资源的检查。这种方法既保证了灵活性，也确保了性能。 通过这些设计，EASTL旨在提高性能和易用性，同时为开发者提供更多的控制权和灵活性。\n分配器 STL分配器的问题：\n类级别定义：STL容器的分配器是在类级别定义的，而不是在实例级别，这使得为每个容器实例定义不同的分配器变得复杂。\n代码膨胀：由于分配器模板需要针对每种类型重新绑定，这导致了代码膨胀。\n不可访问性：容器构造后，你无法再访问其分配器，这限制了对分配器的操作和管理。\nEASTL的改进：\n单一分配器接口：EASTL采用了一个统一的分配器类接口，所有容器都使用这个接口，简化了内存分配的管理和使用。 灵活的分配器操作：EASTL容器允许用户访问、查询、命名和更改分配器，提供了更大的灵活性和控制权。 分配器在容器操作中的行为：\n交换操作：当容器A与容器B交换内容时，两个容器都会保留其原始分配器，而不是交换分配器。 赋值操作：将容器A赋值给容器B时，容器B会保留其原始分配器，而不是继承容器A的分配器。 智能交换：如果两个容器的分配器相同，EASTL会执行智能交换（更高效的方式）。如果分配器不同，则执行暴力交换（逐元素复制）。 通过这些改进，EASTL不仅解决了STL中分配器相关的一些痛点，还提高了内存管理的灵活性和效率，使开发者能够更好地控制容器的行为和性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // EASTL allocator class allocator { public: allocator(const char* pName = NULL); void* allocate(size_t n, int flags = 0); void* allocate(size_t n, size_t alignment, size_t offset, int flags = 0); void deallocate(void* p, size_t n); const char* get_name() const; void set_name(const char* pName); }; allocator* GetDefaultAllocator(); 固定大小的容器 EASTL提供了诸如fixed_list这样的固定大小容器，它们通过固定大小的连续内存池来实现。\nfixed_list具有以下特点：\n没有额外的空间开销。 不会导致内存碎片化。 分配速度非常快。 实现方式：\nEASTL通过继承自常规容器的子类来实现固定容器，这些子类将其常规容器的分配器设置为指向自身。 这种设计使得fixed_list的实现非常简洁，主要包括构造函数和分配器函数。 设计的优点：\n减少代码膨胀：由于实现简单，避免了大量的重复代码。 易于扩展：用户可以轻松地基于现有的实现进行扩展和修改。 简化实现：保持了实现的简单性和清晰度。 设计的小缺点：\n父类list中有一个指向自身的指针，占用了4个字节的空间。 如果采用不同的设计（例如策略模板参数），可以节省这4个字节，但会带来其他问题，如实现复杂化、用户扩展难度增加以及可能的代码膨胀。 为什么不采用策略设计：\n实现复杂化：策略设计会使容器的实现更加复杂。 用户扩展难度增加：复杂的实现会使用户难以扩展和修改容器。 潜在的代码膨胀：虽然可以节省每个容器实例中的4字节空间，但由于策略设计可能导致更多的代码膨胀，反而浪费了更多的内存。 通过这种方式，EASTL在简化实现和提高灵活性的同时，权衡了一些小的性能损失，确保了整体的设计简洁性和易用性。\n算法 算法设计哲学：\nEASTL算法遵循标准C++算法的设计原则，强调使用迭代器而非容器。 通过使用迭代器，算法可以处理容器的任意子范围，并且可以应用于非容器的数据结构（如C数组）。 灵活性和通用性：\n这种设计使得算法更加灵活和通用，用户可以轻松指定要操作的数据范围，而不需要局限于特定类型的容器。 例如，find算法接受两个迭代器参数，允许在任意范围内查找元素。 性能优化：\nEASTL算法不仅与商业库中的最佳STL算法一样优化，而且在很多情况下表现更好。 EASTL算法利用类型特征和迭代器类型进行优化，以生成更高效的代码。例如，对于整数数组或POD类型的数据，EASTL会在适当的情况下使用memcpy来代替逐对象复制，从而提高性能。 复杂性和实现难度：\nEASTL算法和相关支持代码使用了一些高级的C++技巧，尽管代码本身易于阅读，但实现和维护这些优化需要深厚的C++知识和经验。 开发和维护EASTL相比简单的库需要更多的努力和专业知识，但由于其带来的性能提升，这种权衡被认为是值得的。 总结来说，EASTL通过精心设计的算法和高级优化技术，在保持灵活性和通用性的同时，显著提升了性能。尽管这增加了开发和维护的复杂性，但最终的性能优势使其成为高性能应用的理想选择。\n智能指针 EASTL实现了以下智能指针类型：\nshared_ptr shared_array weak_ptr instrusive_ptr scoped_ptr scoped_array linked_ptr linked_array 除了linked_ptr和linked_array之外，其他智能指针都是来自Boost库中广为人知的智能指针。\n这些智能指针的行为与Boost中的非常相似，但有两个例外：\n分配器赋值：\nEASTL智能指针允许你为它们分配一个分配器。 这使得EASTL在内存分配和跟踪方面具有更多的控制权，因为Boost智能指针单方面使用全局operator new从全局堆中分配内存。 shared_ptr的删除机制：\nEASTL的shared_ptr通过模板参数实现删除，而不是通过动态分配的虚拟成员对象接口。 优点: EASTL避免了堆分配、避免了虚拟函数调用，并减少了模板类的泛滥。 缺点: 如果EASTL的shared_ptr容器持有void指针，则除非用户手动指定自定义删除器模板参数，否则无法调用其包含对象的析构函数。这种情况表明EASTL更高效但安全性较低。如果这个问题在未来成为一个问题，我们可以重新审视这个话题。 list::size is O(n) 链表类的设计决策\n当前设计：\nEASTL中的 list、slist 和 intrusive_list 类不缓存链表的大小。 获取链表大小的操作需要遍历整个链表并计数节点，因此是一个O(n)操作。 支持缓存大小的理由：\n符合C++标准：根据C++标准，std::list的size函数应为O(1)操作。 常见实现方式：许多C++标准库的实现都包含一个成员变量来缓存链表的大小。 性能优势：更新一个整数大小是非常快的，用户可以快速获取链表的大小。 用户期望：许多开发者期望size函数能够快速执行。 反对缓存大小的理由：\n增加内存开销：每个链表实例需要额外的4个字节来存储大小。 增加处理开销：每次插入或删除节点时，都需要更新大小变量，增加了少量的处理开销。 仅对size函数有益：缓存大小仅对size函数有效，对其他操作无明显改善。 intrusive_list的特殊性：对于intrusive_list，缓存大小可能会带来更多问题，因为它的节点管理机制不同。 最终决策与理由:\n性能优先：由于EASTL主要针对游戏开发，性能是最关键的因素。因此，EASTL选择不缓存链表的大小，以避免额外的内存和处理开销。 灵活性：如果用户确实需要快速的size函数，他们可以自行实现大小缓存。这样既保持了库的轻量化，又满足了特定需求。 basic_string不使用写时复制 ————以下内容只是介绍 写时复制 机制——与EASTL无关————\nCopy-on-Write（写时复制，简称COW） 是一种优化技术，广泛应用于操作系统、数据库和编程语言中，用于提高资源管理的效率。\n它通过延迟实际数据的复制操作，直到真正需要修改数据时才进行复制，从而节省内存和计算资源。\n工作原理\n共享数据：当一个对象或数据结构被复制时，初始阶段并不会创建一个新的副本。相反，原始对象和新对象会共享同一份数据。 检测写操作：如果任何一个对象尝试修改共享的数据（即执行写操作），系统会检测到这一操作，并为该对象创建一份独立的数据副本。 独立修改：在创建了新的副本之后，只有执行写操作的对象会使用这份新的副本，而其他对象仍然共享原始数据。 避免不必要的复制：如果多个对象只是读取数据而不进行任何修改，它们可以继续共享同一份数据，无需进行额外的复制操作。 1 2 3 4 string str1 = \u0026#34;Hello\u0026#34;; string str2 = str1; // 此时 str1 和 str2 共享同一份数据 str2[0] = \u0026#39;J\u0026#39;; // 尝试将第一个字符改为 \u0026#39;J\u0026#39; 写时复制机制会触发，系统会为 str2 创建一个新的副本，并在新副本上进行修改，而 str1 仍然指向原来的 \u0026quot;Hello\u0026quot;。\n对于STL标准库来说，std::string在C++11后不再支持COW机制.\n————以上内容只是介绍 写时复制 机制——与EASTL无关————\nCoW机制可以在某些情况下提高效率，但其带来的额外复杂性和开销使其在许多应用场景中并不适用。\n对于高性能需求的游戏开发环境，线程安全和内存管理的复杂性使得CoW字符串的实现面临诸多挑战。\n因此，EASTL选择不在主要的basic_string实现中使用CoW机制，而是考虑为特定需求提供一个独立的cow_string类，以便在不影响整体性能的情况下满足特定需求。\nCoW字符串的缺点包括：\n引用计数：字符串需要有一个引用计数，这增加了字符串的内存使用。 线程安全：在多线程环境下，原子操作和互斥锁非常昂贵，特别是在较弱的内存系统上，如游戏主机平台。 非const访问器函数：所有非const字符串访问器函数都需要进行共享检查，并且第一次这样的检查需要分离字符串。类似地，所有字符串赋值也需要进行共享检查。如果你在赋值之前访问了字符串，那么赋值不会导致共享字符串，因为字符串已经被分离。 字符串共享频率低：大多数情况下，字符串并不会被共享。在某些情况下，引用计数所需的总内存可能超过通过共享表示节省的内存。 cow_string类的考虑：EASTL正在考虑添加一个cow_string类。有些系统的字符串使用模式可能会从CoW共享中受益。这种功能最好保存在一个单独的字符串实现中，这样其他字符串使用不会受到影响。 配置 EASTL要求覆盖全局new\n1 2 3 4 5 6 7 8 9 10 void* __cdecl operator new[](size_t size, const char* name, int flags, unsigned debugFlags, const char* file, int line) { return new uint8_t[size]; } void* __cdecl operator new[](unsigned __int64 size, unsigned __int64 alignment, unsigned __int64 offset, char const* pName, int flags, unsigned int debugFlags, char const* file, int line) { return new uint8_t[size]; } 容器 Array Array\n实现了一个符合C++标准TR1的模板数组类。 这个类允许你像使用STL vector一样使用内置的C风格数组。 它不允许你改变其大小，因为它就像一个C内置数组一样。 我们的实现努力去除函数调用嵌套，因为这会使我们在调试构建中由于函数调用开销而难以进行性能分析。 注意，根据C++标准更新提案的要求，这里故意将其定义为一个具有公共数据的结构体（struct）。 使用示例 1 2 3 4 5 eastl::array\u0026lt;int, 5\u0026gt; arr{1,2,3,4,5}; for (auto value : arr) { cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 类型别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template \u0026lt;typename T, size_t N = 1\u0026gt; struct array { public: typedef array\u0026lt;T, N\u0026gt; this_type; typedef T value_type; typedef value_type\u0026amp; reference; typedef const value_type\u0026amp; const_reference; typedef value_type* iterator; typedef const value_type* const_iterator; typedef eastl::reverse_iterator\u0026lt;iterator\u0026gt; reverse_iterator; typedef eastl::reverse_iterator\u0026lt;const_iterator\u0026gt; const_reverse_iterator; typedef eastl_size_t size_type; // See config.h for the definition of eastl_size_t, which defaults to size_t. typedef ptrdiff_t difference_type; } using ArrayTest = eastl::array\u0026lt;int,5\u0026gt;; // eastl::array\u0026lt;int, 5\u0026gt; using Array_this_type = ArrayTest::this_type; //BEGIN—— 类型别名 都来自于T ——BEGIN // int using Array_value_type = ArrayTest::value_type; // int\u0026amp; using Array_reference = ArrayTest::reference; //const int\u0026amp; using Array_const_reference = ArrayTest::const_reference; // int* using Array_iterator = ArrayTest::iterator; // const int* using Array_const_iterator = ArrayTest::const_iterator; // eastl::reverse_iterator\u0026lt;int*\u0026gt; using Array_reverse_iterator = ArrayTest::reverse_iterator; // eastl::reverse_iterator\u0026lt;const int*\u0026gt; using Array_const_reverse_iterator = ArrayTest::const_reverse_iterator; //END—— 类型别名 都来自于T ——END // unsigned long long using Array_size_type = ArrayTest::size_type; // long long using Array_difference_type = ArrayTest::difference_type; 聚合初始化 1 2 3 4 5 // Note that the member data is intentionally public. // This allows for aggregate initialization of the // object (e.g. array\u0026lt;int, 5\u0026gt; a = { 0, 3, 2, 4 }; ) // do not use this member directly (use data() instead). value_type mValue[N]; 注意，成员数据有意是公开的。 这允许对对象进行聚合初始化（例如，array\u0026lt;int, 5\u0026gt; a = {0,3,2,4};） 不要直接使用这个成员（使用data（）代替）。 eastl::array 维护了一个C风格数组.\n这个eastl::array类没有显式定义构造函数，是为了保持其作为聚合类型的特性，从而允许通过聚合初始化直接初始化其公有成员数组mValue。\n源码注释里: 故意不提供构造函数、析构函数或赋值操作符。\n聚合类型的定义：C++规定，满足以下条件的类或结构体是聚合类型：\n没有用户提供的构造函数（包括默认构造函数）； 所有非静态成员都是公有的； 没有基类和虚函数。 eastl::array符合这些条件，因此它是一个聚合类型。\n支持聚合初始化：聚合类型允许通过花括号列表直接初始化成员，无需定义构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct S { int a; int b; }; S s = {1, 2}; // 直接初始化公有成员a和b //-----------------// struct my_struct { int Valueint = 1; int mValue[2]; float Valuefloat = 2 ; }; my_struct s = {.mValue= {2, 3}, .Value= 2.5}; my_struct s2 = {2,{4,5},7.2}; 1 eastl::array\u0026lt;int, 5\u0026gt; arr {1, 2, 3, 4, 5}; 聚合初始化的作用：初始化列表{1, 2, 3, 4, 5}会直接赋值给mValue数组的对应元素。 底层实现：编译器将初始化列表中的值按顺序填充到mValue的每个位置，等同于： value_type mValue[5] = {1, 2, 3, 4, 5}; 如果初始化列表元素少于N，剩余元素会默认初始化（如int类型初始化为0）；\n若多于N，编译器会报错。\n**std::array**的设计一致性：C++标准库的std::array同样没有显式构造函数，依赖聚合初始化。eastl::array遵循这一设计，确保接口兼容性和性能优化。 性能优势：避免构造函数的调用开销，编译器可直接生成高效的初始化代码。 总结:\neastl::array不定义构造函数，是为了保持聚合类型的特性，允许用户通过花括号初始化列表直接填充公有成员数组mValue。\n这种设计简化了实现，提高了效率，并与标准库的std::array行为一致。\n初始化时，编译器直接将列表值按顺序赋给mValue，无需构造函数介入。\n成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int main() { eastl::array\u0026lt;int, 5\u0026gt; arr {7,2,3,4,5}; // 输出:size:5 maxsize:5 empty:false data[0]:7 cout \u0026lt;\u0026lt; format(\u0026#34;size:{} maxsize:{} empty:{} data[0]:{} \\n\u0026#34;, arr.size(),arr.max_size(),arr.empty(),arr.data()[0]); arr.data()[0] = 120; // 输出:data[0]:120 cout \u0026lt;\u0026lt; format(\u0026#34;data[0]:{} \\n\u0026#34;,arr.data()[0]); arr[0] = 64; // 输出:data[0]:64 cout \u0026lt;\u0026lt; format(\u0026#34;data[0]:{} \\n\u0026#34;,arr[0]); arr.at(0) = 32; // 输出:data[0]:32 cout \u0026lt;\u0026lt; format(\u0026#34;data[0]:{} \\n\u0026#34;,arr.at(0)); //输出 32 2 3 4 5 for (auto i : arr) { cout \u0026lt;\u0026lt; std::format(\u0026#34;{} \u0026#34;,i); } cout \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; // 输出 front:32 back:5 cout \u0026lt;\u0026lt; format(\u0026#34;front:{} back:{} \\n\u0026#34;,arr.front(),arr.back()); } 输出结果:\nsize:5 maxsize:5 empty:false data[0]:7 data[0]:120 data[0]:64 data[0]:32 32 2 3 4 5 front:32 back:5 Vector Vector\n使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int main() { eastl::vector\u0026lt;int\u0026gt; vec; vec.push_back(127); vec.push_back(2); vec.push_back(3); vec.push_back(355); for (auto\u0026amp; i : vec) { // 输出 127 2 3 355 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; auto begin = vec.begin(); auto end = vec.end()-1; // begin:127 end:355 cout \u0026lt;\u0026lt; \u0026#34;begin:\u0026#34; \u0026lt;\u0026lt; *begin \u0026lt;\u0026lt;\u0026#34; end:\u0026#34;\u0026lt;\u0026lt;*end \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //size:4 cout\u0026lt;\u0026lt; format(\u0026#34;size:{} \\n\u0026#34;,vec.size()); //capacity:4 rbegin:355 rend:127 cout\u0026lt;\u0026lt; format(\u0026#34;capacity:{} rbegin:{} rend:{} \\n\u0026#34;,vec.capacity(),*vec.rbegin(),*(vec.rend()-1)); vec.reserve(10); //size:4 capacity:10 cout \u0026lt;\u0026lt; format(\u0026#34;size:{} capacity:{}\\n\u0026#34;,vec.size(),vec.capacity()); //begin:127 end:355 cout \u0026lt;\u0026lt; format(\u0026#34;begin:{} end:{} \\n\u0026#34;,*vec.begin(),*(vec.end()-1)); } // 输出： // 127 2 3 355 // begin:127 end:355 // size:4 // capacity:4 rbegin:355 rend:127 // size:4 capacity:10 // begin:127 end:355 size 当前元素个数 capacity 当前容量 vec容量为10，但只有3个元素，那么size = 3,capacity = 10 扩容机制 下图是stl::vector，但是算法和EASTL是一样的.可作为参考.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;T, Allocator\u0026gt;::size() const EA_NOEXCEPT { return (size_type)(mpEnd - mpBegin); } vector\u0026lt;T, Allocator\u0026gt;::capacity() const EA_NOEXCEPT { return (size_type)(internalCapacityPtr() - mpBegin); } //---------------------------// eastl::compressed_pair\u0026lt;T*, allocator_type\u0026gt; mCapacityAllocator; T*\u0026amp; internalCapacityPtr() EA_NOEXCEPT { return mCapacityAllocator.first(); } T* const\u0026amp; internalCapacityPtr() const EA_NOEXCEPT { return mCapacityAllocator.first(); } size = end - begin.\n例如:vector里面有5个元素: 1,2,3,4,5 . begin 指向1 ， end指向5的下一个位置.\nCapacity = 整个空间 - begin. 即为vector的整个空间容量.\n**internalCapacityPtr()**：返回指向当前分配的内存块的容量结束位置的指针。\nvector 创建时size=0，capacity=0\nvector 有一个元素，触发扩容，size=1,capacity=1\nvector 当后续再插入元素 空间不够时，整个空间扩容2倍.\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { eastl::vector\u0026lt;int\u0026gt; vec; cout \u0026lt;\u0026lt; format(\u0026#34;size:{} capacity:{}\\n\u0026#34;,vec.size(),vec.capacity()); for (int i = 0 ; i \u0026lt; 18 ; i++) { vec.push_back(i); cout \u0026lt;\u0026lt; format(\u0026#34;AddValue:{} size:{} capacity:{}\\n\u0026#34;,i,vec.size(),vec.capacity()); } cout \u0026lt;\u0026lt; format(\u0026#34;front:{} back:{} \\n\u0026#34;,vec.front(),vec.back()); } 输出:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 size:0 capacity:0 AddValue:0 size:1 capacity:1 AddValue:1 size:2 capacity:2 AddValue:2 size:3 capacity:4 AddValue:3 size:4 capacity:4 AddValue:4 size:5 capacity:8 AddValue:5 size:6 capacity:8 AddValue:6 size:7 capacity:8 AddValue:7 size:8 capacity:8 AddValue:8 size:9 capacity:16 AddValue:9 size:10 capacity:16 AddValue:10 size:11 capacity:16 AddValue:11 size:12 capacity:16 AddValue:12 size:13 capacity:16 AddValue:13 size:14 capacity:16 AddValue:14 size:15 capacity:16 AddValue:15 size:16 capacity:16 AddValue:16 size:17 capacity:32 AddValue:17 size:18 capacity:32 front:0 back:17 容量不够时 扩容2倍.\n插入与扩容\n1 2 3 4 5 6 7 inline void vector\u0026lt;T, Allocator\u0026gt;::push_back(const value_type\u0026amp; value) { if(mpEnd \u0026lt; internalCapacityPtr()) ::new((void*)mpEnd++) value_type(value); else DoInsertValueEnd(value); } **mpEnd**：指向当前 vector 中最后一个已使用的元素之后的位置。 **internalCapacityPtr()**：返回指向当前分配的内存块的容量结束位置的指针。 该条件检查当前 vector 是否有足够的空间来容纳新元素。\n如果 mpEnd 小于 internalCapacityPtr()，则表示当前容量足够，可以直接插入新元素。\n::new((void*)mpEnd++) value_type(value); 放置式 new 操作符，用于在指定地址上构造对象。这里使用的是 mpEnd 所指向的地址，并且在构造后将 mpEnd 向前移动一位。\nDoInsertValueEnd(value); 当前容量不足时，调用此函数处理插入操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;typename T, typename Allocator\u0026gt; template\u0026lt;typename... Args\u0026gt; void vector\u0026lt;T, Allocator\u0026gt;::DoInsertValueEnd(Args\u0026amp;\u0026amp;... args) { const size_type nPrevSize = size_type(mpEnd - mpBegin); const size_type nNewSize = GetNewCapacity(nPrevSize); pointer const pNewData = DoAllocate(nNewSize); pointer pNewEnd = eastl::uninitialized_move(mpBegin, mpEnd, pNewData); ::new((void*)pNewEnd) value_type(eastl::forward\u0026lt;Args\u0026gt;(args)...); pNewEnd++; eastl::destruct(mpBegin, mpEnd); DoFree(mpBegin, (size_type)(internalCapacityPtr() - mpBegin)); mpBegin = pNewData; mpEnd = pNewEnd; internalCapacityPtr() = pNewData + nNewSize; } template \u0026lt;typename T, typename Allocator\u0026gt; inline typename VectorBase\u0026lt;T, Allocator\u0026gt;::size_type VectorBase\u0026lt;T, Allocator\u0026gt;::GetNewCapacity(size_type currentCapacity) { // This needs to return a value of at least currentCapacity and at least 1. return (currentCapacity \u0026gt; 0) ? (2 * currentCapacity) : 1; } GetNewCapacity 如果当前容量为0，则扩容为1，其它情况下都扩容2倍.\n1. 计算当前大小与新容量\n当前大小：通过 mpEnd - mpBegin 获取当前元素数量。 新容量：调用 GetNewCapacity(nPrevSize) 确定扩容后的新容量（通常按固定策略，如翻倍）。 2. 分配新内存\n使用 DoAllocate(nNewSize) 分配大小为 nNewSize 的新内存块 pNewData。 3. 迁移旧数据\n移动构造：通过 eastl::uninitialized_move 将旧数据移动到新内存。这一步调用元素的移动构造函数，转移资源所有权。 构造新元素：在新内存末尾（pNewEnd）使用 placement new 和完美转发 Args\u0026amp;\u0026amp;... 直接构造新元素，避免额外拷贝。 4. 清理旧内存\n析构旧元素：调用 eastl::destruct 析构旧内存中的元素（移动后的源对象仍需析构，但资源已转移）。 释放旧内存：通过 DoFree 释放原内存块，需传入原指针和容量（确保内存正确释放）。 5. 更新内部指针\n**mpBegin**：指向新内存起始位置。 **mpEnd**：指向新内存的末尾（即最后一个元素的下一个位置）。 **internalCapacityPtr()**：更新为新内存的容量终点（pNewData + nNewSize）。 右值版本 调用移动构造\n1 2 3 4 5 6 7 8 template \u0026lt;typename T, typename Allocator\u0026gt; inline void vector\u0026lt;T, Allocator\u0026gt;::push_back(value_type\u0026amp;\u0026amp; value) { if (mpEnd \u0026lt; internalCapacityPtr()) ::new((void*)mpEnd++) value_type(eastl::move(value)); else DoInsertValueEnd(eastl::move(value)); } 右值引用：如果传递的是右值引用（rvalue reference），则会调用移动构造函数。 左值引用：如果传递的是左值引用（lvalue reference），则会调用拷贝构造函数。 list 该链表与 std::list 的主要区别如下：\n缺少部分不常用函数：\n这个链表没有实现 std::list 中一些不太常用的函数。任何需要的函数可以在以后添加。\n扩展函数提升性能：\n链表包含了一些扩展函数，可以提高性能。\n支持对象对齐要求：\n链表可以包含具有对齐要求的对象，而 std::list 在不进行一些繁琐且非便携的操作时无法做到这一点。\n针对目标平台的优化：\n链表包含了一些在标准库供应商提供的 STL 实现中不存在的优化。\n本地支持调试内存命名：\n链表本地支持调试内存命名。\n**size()** 函数的时间复杂度：\n默认情况下，list::size() 不是一个常数时间函数（类似于某些标准实现如 STLPort 和 SGI STL 中的 list::size），但与 Dinkumware 和 Metrowerks 中的 list 不同。可以通过设置 EASTL_LIST_SIZE_CACHE 选项来改变这一行为。\n提供可移植节点定义：\n链表提供了保证可移植的节点定义，允许用户编写自定义固定大小的节点分配器，并确保其可移植性。\n易读、调试和可视化：\n链表更容易阅读、调试和可视化。\n适应无异常处理环境：\n链表能够适应没有异常处理的环境，这在控制台或嵌入式环境中有时是必要的。\n减少深层嵌套函数调用：\n链表减少了深层嵌套函数调用，并允许用户在调试构建中启用强制内联，以减少代码膨胀。\n不保留成员变量 **size**：\n链表不保留成员变量 size。这意味着链表比 std::list 更小（取决于 std::list 的实现），并且对于大多数操作来说更快。然而，list::size 函数的速度较慢。\n**size_type** 定义为 **eastl_size_t**：\nlist::size_type 定义为 eastl_size_t 而不是 size_t，以节省内存并在 64 位系统上运行更快。\nstring string\n实现了一个 basic_string 类，类似于 C++ 标准库中的 std::basic_string。basic_string 和 std::basic_string 的主要区别如下：\n扩展函数：basic_string 包含一些扩展函数，可以提高性能。 易用性：basic_string 包含一些扩展函数，使使用更加方便，例如成员 sprintf 函数和成员 tolower/toupper 函数。 调试内存命名：basic_string 本地支持调试内存命名。 可读性和调试：basic_string 更容易阅读、调试和可视化。 内部手动扩展基本函数：如 begin()、size() 等，以改进调试性能和优化器的成功率。 无异常处理环境适应性：basic_string 能够适应没有异常处理的环境，这在控制台或嵌入式环境中有时是必要的。 减少深层嵌套函数调用：允许用户在调试构建中启用强制内联，以减少代码膨胀。 不使用字符特性（char traits）：因此，EASTL 假设字符串将包含字符而不是像小部件这样的奇特事物。至少，basic_string 假设 value_type 是一个 POD（Plain Old Data）类型。 basic_string::size_type 定义为 **eastl_size_t**：而不是 size_t，以节省内存并在 64 位系统上运行更快。 数据保证连续：basic_string 数据保证是连续的。 数据保证以零终止：c_str() 函数保证返回与 data() 相同的指针，该指针保证与 \u0026amp;string[0] 的值相同。 set_capacity() 函数：释放多余的容量。在 std::basic_string 中唯一能做到这一点的方法是通过晦涩的技巧，例如使用 basic_string\u0026lt;char\u0026gt;(x).swap(x);。 force_size() 函数：单方面移动字符串结束位置（mpEnd）到给定位置。这对于用户通过外部方式（如 C 的 strcpy 或 sprintf）写入字符串时非常有用。 **substr() 函数偏离标准：返回一个带有此 get_allocator() 复制的新字符串。 basic_string不使用写时复制\nSSO优化 空结构体，用作标记类型，帮助区分不同的构造函数重载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // CtorDoNotInitialize 存在的原因是我们可以创建一个仅分配内存但不进行初始化的构造函数， // 并且不会与其他任何构造函数声明发生冲突。 struct CtorDoNotInitialize {}; // CtorSprintf 存在的原因是我们可以创建一个接受 printf 风格参数的构造函数， // 并且不会与其他任何构造函数声明发生冲突。 struct CtorSprintf {}; // CtorConvert 存在的原因是我们可以有一个实现字符串编码转换的构造函数， // 例如在 UCS2 char16_t 和 UTF8 char8_t 之间进行转换。 struct CtorConvert {}; // 用于确定我们是否处于 SSO（Short String Optimization，短字符串优化）或堆模式的掩码 // 小端序使用最高有效位（MSB） // 检测是否使用堆存储字符串。 static EA_CONSTEXPR_OR_CONST size_type kHeapMask = ~(size_type(~size_type(0)) \u0026gt;\u0026gt; 1); // 检测是否使用短字符串优化（SSO）。 static EA_CONSTEXPR_OR_CONST size_type kSSOMask = 0x80; // 当字符串数据从分配器获取时，内存视图的结构。 struct HeapLayout { value_type* mpBegin; // 字符串的起始位置。 size_type mnSize; // 字符串的大小。当前字符串中的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 size_type mnCapacity; // 字符串的容量。字符串可以容纳的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 }; SSO优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 短字符优化 //SSO 是一种常见的优化技术，用于在小字符串的情况下避免动态内存分配。 //通常，字符串类会在对象内部预留一小块缓冲区（称为 SSO 缓冲区），用于存储短字符串。 template \u0026lt;typename CharT, size_t = sizeof(CharT)\u0026gt; struct SSOPadding { //CharT：表示字符类型（如 char, wchar_t, char16_t, char32_t 等）。 //size_t：默认为 sizeof(CharT)，用于区分不同的字符类型。 //padding数组用于填充，以确保结构体的大小与字符类型的大小对齐。 char padding[sizeof(CharT) - sizeof(char)]; }; template \u0026lt;typename CharT\u0026gt; struct SSOPadding\u0026lt;CharT, 1\u0026gt; { // 模板特化以移除填充结构，避免零长度数组警告 // 同时，这也允许我们利用空基类优化（empty-base-class optimization）。 // 适用于 CharT 的大小为 1 字节的情况（例如 char 类型）。 }; // 当字符串数据能够在本地存储（无需堆分配）时的内存视图。 struct SSOLayout { // SSO_CAPACITY 计算公式：(HeapLayout 的大小 - 1 字节) / 字符类型的大小 static EA_CONSTEXPR_OR_CONST size_type SSO_CAPACITY = (sizeof(HeapLayout) - sizeof(char)) / sizeof(value_type); // mnSize 必须对应于 HeapLayout.mnCapacity 的最后一个字节，因此我们不希望编译器在 mnSize 后插入填充（如果 sizeof(value_type) != 1）； // 同时确保两种布局具有相同的大小。 struct SSOSize : SSOPadding\u0026lt;value_type\u0026gt; { char mnRemainingSize; // 剩余大小字段 }; value_type mData[SSO_CAPACITY]; // 用于存储字符串数据的本地缓冲区。 SSOSize mRemainingSizeField; // 剩余大小字段 }; HeapLayout 结构体：描述字符串在堆上的内存布局，包含字符串的起始位置、大小和容量。\nSSOLayout 结构体：用于描述字符串在本地缓冲区中的内存布局，适用于短字符串优化（SSO）。它包含一个本地缓冲区 mData 和一个剩余大小字段 mRemainingSizeField。\nSSO_CAPACITY：计算本地缓冲区的容量，确保能够存储短字符串而不需动态内存分配。\n实际应用：通过 SSOLayout 结构体，可以有效地管理短字符串的内存布局，减少不必要的动态内存分配，提高性能和效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // This view of memory is a utility structure for easy copying of the string data. //这个内存视图是一个实用结构，便于复制字符串数据。 struct RawLayout { //大小是 sizeof(HeapLayout)，这意味着它可以容纳一个 HeapLayout 结构体的所有数据。 char mBuffer[sizeof(HeapLayout)]; }; // 当字符串数据从分配器获取时，内存视图的结构。 struct HeapLayout { value_type* mpBegin; // 字符串的起始位置。 size_type mnSize; // 字符串的大小。当前字符串中的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 size_type mnCapacity; // 字符串的容量。字符串可以容纳的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 }; 1 2 3 // 这实现了“短字符串优化”或 SSO。SSO 重用了字符串类现有的存储来保存足够短的字符串数据，从而避免了堆分配。 // 存储在字符串 SSO 缓冲区中的字符数量是可变的，并且取决于字符串字符的宽度。 // 此实现更倾向于保持一致的字符串大小，而不是增加字符串本地数据的大小以容纳一致数量的字符，尽管字符宽度不同。 Layout\n统一管理字符串存储： 使用联合体来管理不同类型的内存布局，使得字符串可以在堆上或本地缓冲区中存储，具体取决于字符串的长度。 通过 IsHeap() 和 IsSSO() 方法判断当前使用的是堆分配还是 SSO 缓冲区。 提供一致的接口： 提供了多种方法来获取和设置字符串的各种属性（如大小、容量、指针等），无论字符串是存储在堆上还是 SSO 缓冲区中，都能通过统一的接口进行操作。 支持拷贝和移动操作： 提供了拷贝构造函数、赋值运算符以及移动构造函数和赋值运算符，确保对象可以安全地进行拷贝和移动操作。 使用 Copy 和 Move 方法来处理不同情况下的数据复制和移动。 灵活的初始化和重置： 默认情况下，字符串以 SSO 模式初始化（ResetToSSO 方法）。 提供了 Swap 方法用于交换两个 Layout 对象的内容。 Layout 成员函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 构造与赋值： 构造函数：默认构造函数将字符串初始化为 SSO 模式。拷贝构造函数和移动构造函数分别用于拷贝和移动对象。 赋值运算符：提供了拷贝赋值和移动赋值运算符。 状态检查： IsHeap()：检查当前是否使用堆分配。 IsSSO()：检查当前是否使用 SSO 缓冲区。 获取指针： SSOBufferPtr()：获取 SSO 缓冲区的指针。 HeapBeginPtr()：获取堆分配字符串的起始指针。 BeginPtr()：根据当前模式返回相应的起始指针。 EndPtr()：根据当前模式返回相应的结束指针（指向字符串末尾的空字符）。 CapacityPtr()：根据当前模式返回相应的容量指针（指向缓冲区末尾）。 获取和设置大小与容量： GetSSOSize()：获取 SSO 缓冲区中的字符串大小。 GetHeapSize()：获取堆分配字符串的大小。 GetSize()：根据当前模式返回相应的字符串大小。 SetSSOSize()：设置 SSO 缓冲区中的字符串大小。 SetHeapSize()：设置堆分配字符串的大小。 SetSize()：根据当前模式设置相应的字符串大小。 SetHeapCapacity()：设置堆分配字符串的容量。 GetHeapCapacity()：获取堆分配字符串的容量。 拷贝与移动： Copy()：实现深拷贝。 Move()：实现移动操作。 Swap()：交换两个 Layout 对象的内容。 重置： ResetToSSO()：将字符串重置为 SSO 模式，并将其内容清空。 总结\nLayout 结构体：通过联合体管理不同类型的内存布局（堆分配、SSO 缓冲区和原始数据视图），实现了短字符串优化（SSO）。 主要功能：提供了一致的接口来获取和设置字符串的各种属性，支持拷贝和移动操作，并且可以根据需要在堆分配和 SSO 缓冲区之间切换。 实际应用：通过这种设计，可以有效地减少不必要的动态内存分配，提高性能和效率，同时保持代码的简洁性和可靠性。 在 Layout 结构体中，字符串可以存储在两个不同的地方：\nSSO 缓冲区（Short String Optimization Buffer）： 当字符串长度较短时，字符串数据会被存储在 SSOLayout 中的本地缓冲区 mData 中。 这种情况下，字符串不会占用额外的堆内存。 堆分配（Heap Allocation）： 当字符串长度超过 SSO 缓冲区的容量时，字符串数据会被存储在堆上，具体通过 HeapLayout 结构体中的指针 mpBegin 来指向堆上的内存块。 获取不同版本的指针\n1 2 3 4 5 6 7 8 9 10 11 12 inline value_type* BeginPtr() EA_NOEXCEPT { return IsHeap() ? HeapBeginPtr() : SSOBeginPtr(); } inline const value_type* BeginPtr() const EA_NOEXCEPT { return IsHeap() ? HeapBeginPtr() : SSOBeginPtr(); } inline value_type* HeapEndPtr() EA_NOEXCEPT { return heap.mpBegin + heap.mnSize; } inline const value_type* HeapEndPtr() const EA_NOEXCEPT { return heap.mpBegin + heap.mnSize; } string 成员函数 cppreference-string\nEASTL的很多函数都和STL中的相同.\nbasic_string 类提供了多种构造函数，以支持不同场景下的字符串初始化。\n默认构造：创建空字符串。 带分配器的构造：允许指定分配器。 部分复制构造：从现有字符串中复制部分内容。 带长度和数据的构造：使用指定长度的数据初始化字符串。 C 字符串构造：使用以空字符结尾的 C 字符串初始化。 填充构造：创建包含多个相同字符的字符串。 拷贝构造：创建现有字符串的副本。 带分配器的拷贝构造：创建现有字符串的副本，并使用指定分配器。 范围构造：使用指定范围的数据初始化字符串。 不初始化构造：创建未初始化的字符串对象。 格式化构造：使用格式化字符串初始化。 初始化列表构造：使用初始化列表初始化。 移动构造：使用右值引用移动构造。 带分配器的移动构造：使用右值引用移动构造，并使用指定分配器。 视图构造：使用字符串视图初始化。 部分视图构造：使用字符串视图中的部分内容初始化。 模板转换构造：支持不同字符类型的转换构造。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Implicit conversion operator //这个隐式转换操作符允许将 basic_string 对象隐式转换为 basic_string_view\u0026lt;T\u0026gt; 类型的对象。 operator basic_string_view\u0026lt;T\u0026gt;() const EA_NOEXCEPT; //---------------// void printview(eastl::string_view sv) { cout \u0026lt;\u0026lt; sv.data() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { eastl::string s = \u0026#34;Hello World\u0026#34;; printview(s); } void swap(this_type\u0026amp; x)\n交换两个 basic_string 对象的内容。考虑了分配器的兼容性，以确保高效地交换内容，同时避免不必要的内存分配和拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T, typename Allocator\u0026gt; void basic_string\u0026lt;T, Allocator\u0026gt;::swap(this_type\u0026amp; x) { // If allocators are equivalent... if(get_allocator() == x.get_allocator() || (internalLayout().IsSSO() \u0026amp;\u0026amp; x.internalLayout().IsSSO())) { // We leave mAllocator as-is. eastl::swap(internalLayout(), x.internalLayout()); } else // else swap the contents. { const this_type temp(*this); // Can\u0026#39;t call eastl::swap because that would *this = x; // itself call this member swap function. x = temp; } } 目的：交换两个 basic_string 对象的内容。 实现方式 如果分配器相同或两者都使用 SSO 缓冲区，则直接交换内部布局。 如果分配器不同，则通过创建临时对象的方式进行交换。 优点 当分配器兼容时，交换操作非常高效，因为它只交换一些指针和状态信息，而不涉及实际数据的拷贝。 即使分配器不兼容，也能保证正确的交换行为。 assign\n这个函数提供了一种方式来安全地将一个basic_string实例的内容复制到另一个实例中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const eastl::string\u0026amp; sv) { os \u0026lt;\u0026lt; sv.data(); return os; } int main() { eastl::string s; // assign(size_type count, CharT ch) s.assign(4, \u0026#39;=\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;====\u0026#34; eastl::string const c(\u0026#34;Exemplary\u0026#34;); // assign(const basic_string\u0026amp; str) s.assign(c); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; == \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; // \u0026#34;Exemplary == Exemplary\u0026#34; // assign(const basic_string\u0026amp; str, size_type pos, size_type count) s.assign(c, 0, c.length() - 1); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;Exemplar\u0026#34;; // assign(basic_string\u0026amp;\u0026amp; str) s.assign(eastl::string(\u0026#34;C++ by \u0026#34;) + \u0026#34;example\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C++ by example\u0026#34; // assign(const CharT* s, size_type count) s.assign(\u0026#34;C-style string\u0026#34;, 7); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style\u0026#34; // assign(const CharT* s) s.assign(\u0026#34;C-style\\0string\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style\u0026#34; char mutable_c_str[] = \u0026#34;C-style string\u0026#34;; // assign(InputIt first, InputIt last) s.assign(eastl::begin(mutable_c_str), eastl::end(mutable_c_str) - 1); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style string\u0026#34; // assign(::initializer_list\u0026lt;CharT\u0026gt; ilist) s.assign({\u0026#39;C\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;}); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style\u0026#34; } 输出\n1 2 3 4 5 6 7 8 ==== Exemplary == Exemplary Exemplar C++ by example C-style C-style C-style string C-style append\n追加多个字符或整个字符串\n使用示例\n1 2 3 4 eastl::string s = \u0026#34;hello\u0026#34;; eastl::string s2 = \u0026#34;world\u0026#34;; s.append(s2); s.append(\u0026#34;ddd\u0026#34;); 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 template \u0026lt;typename T, typename Allocator\u0026gt; basic_string\u0026lt;T, Allocator\u0026gt;\u0026amp; basic_string\u0026lt;T, Allocator\u0026gt;::append(const value_type* pBegin, const value_type* pEnd) { //如果pBegin和pEnd不同，则说明有字符需要追加。 if(pBegin != pEnd) { //当前字符串的大小 const size_type nOldSize = internalLayout().GetSize(); //要追加的字符数 const size_type n = (size_type)(pEnd - pBegin); //当前字符串的容量 const size_type nCapacity = capacity(); //追加后的新字符串大小 const size_type nNewSize = nOldSize + n; //如果新的字符串大小超过当前容量，则需要重新分配内存。 if(nNewSize \u0026gt; nCapacity) { //计算新的容量 const size_type nLength = GetNewCapacity(nCapacity, nNewSize - nCapacity); //分配新内存 pointer pNewBegin = DoAllocate(nLength + 1); //将现有字符和要追加的字符复制到新分配的内存中 pointer pNewEnd = CharStringUninitializedCopy(internalLayout().BeginPtr(), internalLayout().EndPtr(), pNewBegin); pNewEnd = CharStringUninitializedCopy(pBegin, pEnd, pNewEnd); //标记字符串的结束位置 *pNewEnd = 0; //设置新的开始指针、容量和大小，并释放旧的内存 DeallocateSelf(); internalLayout().SetHeapBeginPtr(pNewBegin); internalLayout().SetHeapCapacity(nLength); internalLayout().SetHeapSize(nNewSize); } else { //如果新字符串大小不超过当前容量，则直接在现有内存中追加字符，并更新字符串大小 pointer pNewEnd = CharStringUninitializedCopy(pBegin, pEnd, internalLayout().EndPtr()); //标记字符串的结束位置 *pNewEnd = 0; internalLayout().SetSize(nNewSize); } } return *this; } push_back\n追加单个字符\n使用示例\n1 2 eastl::string s = \u0026#34;hell\u0026#34;; s.push_back(\u0026#39;o\u0026#39;); 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template \u0026lt;typename T, typename Allocator\u0026gt; inline void basic_string\u0026lt;T, Allocator\u0026gt;::push_back(value_type c) { //调用 append(size_type n, value_type c) 方法， //其中 n 是要追加的字符数（在这里是1），c 是要追加的字符。 append((size_type)1, c); } template \u0026lt;typename T, typename Allocator\u0026gt; basic_string\u0026lt;T, Allocator\u0026gt;\u0026amp; basic_string\u0026lt;T, Allocator\u0026gt;::append(size_type n, value_type c) { //检查是否需要追加 if (n \u0026gt; 0) { const size_type nSize = internalLayout().GetSize(); const size_type nCapacity = capacity(); //如果新的大小超过当前容量，则调用 reserve 方法重新分配内存 if((nSize + n) \u0026gt; nCapacity) reserve(GetNewCapacity(nCapacity, (nSize + n) - nCapacity)); //填充新字符 pointer pNewEnd = CharStringUninitializedFillN(internalLayout().EndPtr(), n, c); //标记字符串的结束位置 *pNewEnd = 0; //更新字符串的实际大小 internalLayout().SetSize(nSize + n); } return *this; } find、replace\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { eastl::string s = \u0026#34;hellohello\u0026#34;; eastl::string s2 = \u0026#34;world\u0026#34;; s.append(s2); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; eastl_size_t first = s.find(\u0026#34;hello\u0026#34;); s.replace(first, 5, \u0026#34;HELLO\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 输出\n1 2 hellohelloworld HELLOhelloworld find\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T, typename Allocator\u0026gt; typename basic_string\u0026lt;T, Allocator\u0026gt;::size_type basic_string\u0026lt;T, Allocator\u0026gt;::find(const value_type* p, size_type position, size_type n) const { if(EASTL_LIKELY(((npos - n) \u0026gt;= position) \u0026amp;\u0026amp; (position + n) \u0026lt;= internalLayout().GetSize())) // If the range is valid... { const value_type* const pTemp = eastl::search(internalLayout().BeginPtr() + position, internalLayout().EndPtr(), p, p + n); if((pTemp != internalLayout().EndPtr()) || (n == 0)) return (size_type)(pTemp - internalLayout().BeginPtr()); } return npos; } 查找范围的有效性检查： 确保 position 和 n 的组合不会导致溢出，并且查找范围在当前字符串的有效范围内。 使用 eastl::search 进行查找： 在指定范围内查找子串，eastl::search 是一个标准算法，用于在一个范围内查找另一个范围的首次出现。 判断查找结果： 如果找到匹配的子串，计算并返回其起始位置。 如果查找空子串或未找到匹配的子串，返回 npos。 HashTable 哈希表(Hash Table)，也称为散列表，是一种数据结构，它通过哈希函数将键映射到表中的一个位置来加速查找操作。哈希表可以在平均情况下以常数时间复杂度 O(1）进行插入、删除和查找操作，这使得它们在许多应用场景中非常高效。\n哈希表的基本概念\n哈希函数：用于将键转换为数组索引的函数。理想情况下，哈希函数应均匀分布键，以避免冲突。 桶（Bucket）：哈希表中的每个位置通常称为桶，每个桶可以存储一个或多个键值对。 冲突解决方法: 链地址法（Separate Chaining）：每个桶是一个链表（或其他数据结构），用于存储具有相同哈希值的所有元素。 开放寻址法（Open Addressing）：当发生冲突时，使用某种策略找到另一个空桶来存储元素。常见的策略包括线性探测、二次探测和双重哈希。 哈希表的主要操作\n插入（Insert）：将一个新的键值对插入哈希表中。 查找（Find/Search）：根据键查找对应的值。 删除（Delete）：从哈希表中删除指定的键值对。 1 2 3 4 5 6 7 8 9 10 11 12 13 插入操作 1.使用哈希函数计算键的哈希值。 2.将哈希值映射到哈希表的一个桶。 3.如果该桶为空，则直接插入键值对；如果该桶已占用，则使用冲突解决方法处理。 查找操作 1.使用哈希函数计算键的哈希值。 2.找到对应的桶，并在桶内查找是否存在该键。 3.如果存在，则返回对应的值；否则返回未找到的结果。 删除操作 1.使用哈希函数计算键的哈希值。 2.找到对应的桶，并在桶内查找并删除该键值对。 优点\n高效查找：在理想情况下，哈希表的查找、插入和删除操作的时间复杂度均为 O(1)。 灵活性：支持多种数据类型的键值对。 可扩展性：可以通过调整桶的数量和负载因子来优化性能。 缺点\n冲突处理：尽管哈希函数设计得再好，也无法完全避免冲突。冲突处理会影响性能。 空间开销：为了减少冲突，通常需要预留更多的空间，导致空间利用率较低。 扩容问题：当哈希表接近满载时，需要进行扩容操作，这涉及重新计算所有元素的哈希值并重新分配位置，代价较高。 哈希表广泛应用于各种算法和系统中，以下是几个典型的应用场景：\n字典和集合：如 C++ STL 中的 unordered_map 和 unordered_set，Python 中的 dict 和 set。 缓存机制：如 LRU 缓存（Least Recently Used Cache）。 去重和计数：例如统计文档中单词出现的频率。 数据库索引：提高查询效率。 编译器符号表：管理变量名和函数名等符号信息。 hash_set 实现了一个 hash_set，这是一个哈希唯一项容器。查找操作的时间复杂度为 O(1)（即非常快），但容器不是排序的。\n需要注意的是，查找操作只有在哈希表分布良好（没有冲突）时才是 O(1)。\n当表变得越来越差时，查找操作的时间复杂度会接近 O(n)。\n运用set,为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是 hash table,都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable 没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有。\nset_max_load_factor\n如果你想让哈希表永远不会增加其桶的使用量，可以调用 set_max_load_factor 并传入一个非常高的值，例如 100000.f。\nfind_as\n为了支持能够在字符串哈希表中通过字符指针高效查找的功能（即不需要将字符指针转换为字符串对象），我们提供了 find_as 函数。这个函数允许你使用不同于哈希表键类型的键进行查找。\n1 2 3 4 5 6 7 // 示例 1：使用默认哈希和比较函数 hash_set\u0026lt;string\u0026gt; hashSet; auto i = hashSet.find_as(\u0026#34;hello\u0026#34;); // 使用默认哈希和比较函数 // 示例 2：显式指定哈希和比较函数（省略命名空间以简化） hash_set\u0026lt;string\u0026gt; hashSet; auto i = hashSet.find_as(\u0026#34;hello\u0026#34;, hash\u0026lt;char*\u0026gt;(), equal_to\u0026lt;\u0026gt;()); 智能指针 智能指针（Smart Pointer）是 C++ 中用于管理动态分配对象生命周期的一种工具。\n通过封装原始指针，并利用 RAII 机制自动管理内存的分配和释放，从而避免常见的内存泄漏问题。\nRAII 机制 资源获取即初始化：在对象创建时获取资源，在对象销毁时释放资源。 作用域控制：智能指针在其作用域结束时自动释放所管理的对象，确保资源不会被遗忘或泄露。 自动内存管理 自动释放：智能指针会在其生命周期结束时自动释放所管理的对象，减少手动管理内存的复杂性和出错的可能性。 防止悬挂指针：智能指针能够检测到对象是否仍然被引用，从而防止悬挂指针的问题。 引用计数 共享所有权：多个智能指针可以共享同一个对象的所有权，只有当最后一个指向该对象的智能指针被销毁时，才会释放该对象。 线程安全：某些智能指针（如 std::shared_ptr）提供了线程安全的引用计数机制。 独占所有权 单一所有权：某些智能指针（如 std::unique_ptr）确保只有一个指针拥有某个对象的所有权，防止多个指针同时管理同一对象。 unique_ptr 独占所有权：一个 std::unique_ptr 对象只能指向一个对象，不能进行拷贝操作，但可以通过移动语义转移所有权。 轻量级：相比于 std::shared_ptr，std::unique_ptr 更加轻量，因为它不涉及引用计数。 更具体地说，unique_ptr 模板类存储一个指向动态分配对象的指针。该对象在 unique_ptr 的析构函数中自动删除，或者可以通过 unique_ptr::reset 函数手动删除。\n使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Object { public: int A = 0; Object(int v) : A(v) { cout\u0026lt;\u0026lt;\u0026#34;CreateObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } ~Object() { cout\u0026lt;\u0026lt;\u0026#34;DestroyObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; int main() { { using ObjectPtr = eastl::unique_ptr\u0026lt;Object\u0026gt;; Object* obj1 = new Object(100); ObjectPtr objpt1(obj1); ObjectPtr objpt2 = eastl::make_unique\u0026lt;Object\u0026gt;(200); cout \u0026lt;\u0026lt; format(\u0026#34;objpt1: {} objpt2:{} \\n\u0026#34;, objpt1-\u0026gt;A, objpt2-\u0026gt;A); // 交换 objpt1 和 objpt2 保存的指针 objpt1.swap(objpt2); cout \u0026lt;\u0026lt;\u0026#34;----------objpt2.reset()--------------\\n\u0026#34;; //reset - delete保存的指针. //调用objpt2保存的Object对象的析构函数. //然后，objpt2保存的指针是空指针. objpt2.reset(); cout \u0026lt;\u0026lt;\u0026#34;----------Move Test--------------\\n\u0026#34;; // 把ptr1的指针交给ptr2， // ptr1指针为空，ptr2拥有原先ptr1的指针. // 也可以说 ptr2接管了ptr1的指针. ObjectPtr ptr1(new Object(400)); cout \u0026lt;\u0026lt; format(\u0026#34;ptr1: {}\\n\u0026#34;, ptr1-\u0026gt;A); ObjectPtr ptr2 = eastl::move(ptr1); cout \u0026lt;\u0026lt; \u0026#34;move ptr1 ---\u0026gt; ptr2 \\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;ptr2: {}\\n\u0026#34;, ptr2-\u0026gt;A); if (auto ptr1object = ptr1.get()) { cout \u0026lt;\u0026lt; ptr1object-\u0026gt;A \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { cout \u0026lt;\u0026lt; \u0026#34;ptr1 is null\\n\u0026#34;; } cout \u0026lt;\u0026lt;\u0026#34;----------ptr2.reset(new Object(5000))--------------\\n\u0026#34;; ptr2.reset(new Object(5000)); cout \u0026lt;\u0026lt;\u0026#34;----------Main End--------------\\n\u0026#34;; } while (true) { } } 输出:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 CreateObj 100 CreateObj 200 objpt1: 100 objpt2:200 ----------objpt2.reset()-------------- DestroyObj 100 ----------Move Test-------------- CreateObj 400 ptr1: 400 move ptr1 ---\u0026gt; ptr2 ptr2: 400 ptr1 is null ----------ptr2.reset(new Object(5000))-------------- CreateObj 5000 DestroyObj 400 ----------Main End-------------- DestroyObj 5000 DestroyObj 200 release() 取出指针\nunique_ptr返回指针，并且把自己保存的设为空.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using ObjectPtr = eastl::unique_ptr\u0026lt;Object\u0026gt;; Object* Obj1 = new Object(100); ObjectPtr ObjPtr(Obj1); cout \u0026lt;\u0026lt; format(\u0026#34;Smart ObjPtr.A = {}\\n\u0026#34;, ObjPtr-\u0026gt;A); Object* ptr = ObjPtr.release(); cout \u0026lt;\u0026lt; format(\u0026#34;ptr.A = {}\\n\u0026#34;, ptr-\u0026gt;A); if (ObjPtr.get()) { cout \u0026lt;\u0026lt; format(\u0026#34;objPtr.A = {}\\n\u0026#34;, ObjPtr-\u0026gt;A); } else { cout \u0026lt;\u0026lt; \u0026#34;ObjPtr is nullptr\\n\u0026#34;; } 输出\n1 2 3 4 CreateObj 100 Smart ObjPtr.A = 100 ptr.A = 100 ObjPtr is nullptr 析构过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //销毁已拥有的指针。 //被拥有的指针引用的对象的析构函数将被调用。 ~unique_ptr() EA_NOEXCEPT { reset(); } //删除已拥有的指针，并获取传入指针的所有权。 //如果传入的指针与拥有的指针相同，则什么也不做。 // 例如: // unique_ptr\u0026lt;int\u0026gt; ptr(new int(3)); // ptr.reset(new int(4)); // deletes int(3) // ptr.reset(NULL); // deletes int(4) void reset(pointer pValue = pointer()) EA_NOEXCEPT { if (pValue != mPair.first()) { if (auto first = eastl::exchange(mPair.first(), pValue)) get_deleter()(first); } } deleter_type\u0026amp; get_deleter() EA_NOEXCEPT { return mPair.second(); } void operator()(T* p) const EA_NOEXCEPT { static_assert(eastl::internal::is_complete_type_v\u0026lt;T\u0026gt;, \u0026#34;Attempting to call the destructor of an incomplete type\u0026#34;); delete p; } 析构时调用reset函数，并且传入空指针.\neastl::exchange(mPair.first(), pValue) 交换两个指针，\n假设 unique_ptr 保存的有效指针 unique_ptr -\u0026gt; ptr 为 指针A.\n1.把 unique_ptr 里面保存的 指针A 与 nullptr 交换，此时 unique_ptr保存的是 nullptr.\nunique_ptr -\u0026gt; ptr = nullptr\nfirst= 指针A ，\n2.get_deleter() 取出删除器.\n删除器有两种，default_delete\u0026lt;T\u0026gt; default_delete\u0026lt;T[]\u0026gt; 分别是删除普通对象 和 删除数组对象.\n3.调用 删除器 的 ()运算符重载，把 first 作为参数传递进去. 这个重载运算符将调用delete 删除 first.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename T\u0026gt; struct default_delete { EA_CONSTEXPR default_delete() EA_NOEXCEPT = default; template \u0026lt;typename U\u0026gt; // Enable if T* can be constructed with U* (i.e. U* is convertible to T*). default_delete(const default_delete\u0026lt;U\u0026gt;\u0026amp;, typename eastl::enable_if\u0026lt;is_convertible\u0026lt;U*, T*\u0026gt;::value\u0026gt;::type* = 0) EA_NOEXCEPT {} void operator()(T* p) const EA_NOEXCEPT { static_assert(eastl::internal::is_complete_type_v\u0026lt;T\u0026gt;, \u0026#34;Attempting to call the destructor of an incomplete type\u0026#34;); delete p; } }; //-------------------// template \u0026lt;typename T\u0026gt; struct default_delete\u0026lt;T[]\u0026gt; { void operator()(T* p) const EA_NOEXCEPT { delete[] p; } } shared_ptr 共享所有权：多个 std::shared_ptr 对象可以共享同一个对象的所有权，每个 std::shared_ptr 都持有对对象的引用计数。 这个类实现了 C++11 标准库中的 shared_ptr 模板。\nshared_ptr 类似于 C++ 标准库中的 unique_ptr，但不同之处在于它允许通过引用计数在多个实例之间共享指针。\nshared_ptr 对象可以安全地进行拷贝，并且可以安全地用于 C++ 标准库容器中，如 std::vector 或 std::list。\n这个类不是线程安全的，因为你不能同时从两个线程使用它的同一个实例，也不能同时使用拥有相同指针的两个独立实例。\n使用标准的多线程互斥技术来解决前者的问题，并使用 shared_ptr_mt 来解决后者的问题。\n请注意，这与 C++11 标准不一致。\n如果你使用原始指针构造一个 shared_ptr，你不能仅用那个原始指针再构造另一个 shared_ptr。相反，你需要用最初创建的 shared_ptr 来构造额外的 shared_ptr。否则会导致崩溃。 使用 shared_ptr 是线程安全的，但它指向的对象并不自动是线程安全的。多个引用同一个对象的 shared_ptr 可以被多个线程任意使用。 你可以将单个 shared_ptr 在多个线程之间以所有方式共享，除了赋值操作。以下操作不是线程安全的，需要通过互斥锁或 shared_ptr 的原子函数来保护： 1 2 3 4 5 shared_ptr\u0026lt;Foo\u0026gt; pFoo; // 线程 1: shared_ptr\u0026lt;Foo\u0026gt; pFoo2 = pFoo; // 线程 2: pFoo = make_shared\u0026lt;Foo\u0026gt;(); shared_ptr:\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; class shared_ptr { //........... protected: element_type* mpValue; ref_count_sp* mpRefCount; //......... } 两个成员变量分别是 指针 和 引用计数块.\n引用计数块以指针形式存储，原因就是它是 new创建的，本体在内存条里，可以用指针指向它.\n这样就实现了 多个 shared_ptr 类拥有同一个引用计数块. 因为它们都可以获得 引用计数块的地址，并且用指针指向它.\n引用计数 ref_count_sp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct ref_count_sp { atomic\u0026lt;int32_t\u0026gt; mRefCount; /// Reference count on the contained pointer. Starts as 1 by default. atomic\u0026lt;int32_t\u0026gt; mWeakRefCount; /// Reference count on contained pointer plus this ref_count_sp object itself. Starts as 1 by default. public: ref_count_sp(int32_t refCount = 1, int32_t weakRefCount = 1) EA_NOEXCEPT; virtual ~ref_count_sp() EA_NOEXCEPT {} int32_t use_count() const EA_NOEXCEPT; void addref() EA_NOEXCEPT; void release(); void weak_addref() EA_NOEXCEPT; void weak_release(); ref_count_sp* lock() EA_NOEXCEPT; virtual void free_value() EA_NOEXCEPT = 0; // Release the contained object. virtual void free_ref_count_sp() EA_NOEXCEPT = 0; // Release this instance. #if EASTL_RTTI_ENABLED virtual void* get_deleter(const std::type_info\u0026amp; type) const EA_NOEXCEPT = 0; #else virtual void* get_deleter() const EA_NOEXCEPT = 0; #endif }; ref_count_sp 拥有两个原子变量\n强引用计数 (mRefCount)：跟踪有多少个 shared_ptr 实例指向同一个对象。 弱引用计数 (mWeakRefCount)：跟踪有多少个 weak_ptr 实例指向同一个对象。 release() 方法用于减少强引用计数，并在引用计数降为零时释放对象。\n1 2 3 4 5 6 7 8 9 10 11 inline void ref_count_sp::release() { EASTL_ASSERT((mRefCount.load(memory_order_relaxed) \u0026gt; 0)); if(mRefCount.fetch_sub(1, memory_order_release) == 1) { atomic_thread_fence(memory_order_acquire); free_value();//释放对象 } weak_release(); } fetch_sub：原子操作，减少引用计数并返回旧值。 free_value()：虚函数，在引用计数降为零时调用，实际执行的是派生类中的实现。 派生类 ref_count_sp_t 实现了具体的删除逻辑:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template \u0026lt;typename T, typename Allocator, typename Deleter\u0026gt; class ref_count_sp_t : public ref_count_sp { public: typedef ref_count_sp_t\u0026lt;T, Allocator, Deleter\u0026gt; this_type; typedef T value_type; typedef Allocator allocator_type; typedef Deleter deleter_type; value_type mValue; // This is expected to be a pointer. deleter_type mDeleter; allocator_type mAllocator; ref_count_sp_t(value_type value, deleter_type deleter, allocator_type allocator) : ref_count_sp(), mValue(value), mDeleter(eastl::move(deleter)), mAllocator(eastl::move(allocator)) {} void free_value() EA_NOEXCEPT override { mDeleter(mValue); mValue = nullptr; } void free_ref_count_sp() EA_NOEXCEPT override { allocator_type allocator; allocator.destroy(this); allocator.deallocate(this, 1); } }; free_value()：重写了基类的虚函数，使用 mDeleter 删除对象。 free_ref_count_sp()：重写了基类的虚函数，释放 ref_count_sp_t 对象本身。 shared_ptr 类封装了上述引用计数管理机制，并提供了用户接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; class shared_ptr { public: typedef shared_ptr\u0026lt;T\u0026gt; this_type; typedef T element_type; typedef typename shared_ptr_traits\u0026lt;T\u0026gt;::reference_type reference_type; // This defines what a reference to a T is. It\u0026#39;s always simply T\u0026amp;, except for the case where T is void, whereby the reference is also just void. typedef EASTLAllocatorType default_allocator_type; typedef default_delete\u0026lt;T\u0026gt; default_deleter_type; typedef weak_ptr\u0026lt;T\u0026gt; weak_type; protected: element_type* mpValue; ref_count_sp* mpRefCount; /// Base pointer to Reference count for owned pointer and the owned pointer. } 析构过程 1 2 3 4 5 6 7 ~shared_ptr() { if (mpRefCount) { mpRefCount-\u0026gt;release(); } } 析构时调用 mpRefCount-\u0026gt;release() 判断引用计数是否为0:\n1 2 3 4 5 6 7 8 9 10 11 inline void ref_count_sp::release() { EASTL_ASSERT((mRefCount.load(memory_order_relaxed) \u0026gt; 0)); if(mRefCount.fetch_sub(1, memory_order_release) == 1) { atomic_thread_fence(memory_order_acquire); free_value(); } weak_release(); } 如果为0，调用 free_value() , free_value()调用删除器的 ()运算符重载\n最终删除对象指针.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void free_value() EA_NOEXCEPT { mDeleter(mValue); mValue = nullptr; } //----------// deleter_type mDeleter; //mDeleter 实际上就是default_delete template \u0026lt;typename T\u0026gt; struct default_delete { #if defined(EA_COMPILER_GNUC) \u0026amp;\u0026amp; (EA_COMPILER_VERSION \u0026lt;= 4006) // GCC prior to 4.7 has a bug with noexcept here. EA_CONSTEXPR default_delete() = default; #else EA_CONSTEXPR default_delete() EA_NOEXCEPT = default; #endif template \u0026lt;typename U\u0026gt; // Enable if T* can be constructed with U* (i.e. U* is convertible to T*). default_delete(const default_delete\u0026lt;U\u0026gt;\u0026amp;, typename eastl::enable_if\u0026lt;is_convertible\u0026lt;U*, T*\u0026gt;::value\u0026gt;::type* = 0) EA_NOEXCEPT {} void operator()(T* p) const EA_NOEXCEPT { static_assert(eastl::internal::is_complete_type_v\u0026lt;T\u0026gt;, \u0026#34;Attempting to call the destructor of an incomplete type\u0026#34;); delete p; } }; 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Object { public: int A = 0; Object(int v) : A(v) { cout\u0026lt;\u0026lt;\u0026#34;CreateObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } ~Object() { cout\u0026lt;\u0026lt;\u0026#34;DestroyObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; int main() { { using ObjectPtr = eastl::shared_ptr\u0026lt;Object\u0026gt;; Object* Object1 = new Object(1); ObjectPtr ptr1(Object1); //仍然可以通过原始指针访问 Object1 //cout \u0026lt;\u0026lt; format(\u0026#34;Object1 value: {}\\n\u0026#34;, Object1-\u0026gt;A); //---------------------------------------------------// cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} value:{} \\n\u0026#34;, ptr1.use_count(),ptr1-\u0026gt;A); //ptr1 count: 1 value:1 ObjectPtr ptr2(ptr1); ptr2-\u0026gt;A = 5; cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} value:{} \\n\u0026#34;, ptr1.use_count(),ptr1-\u0026gt;A); //ptr1 count: 2 value:5 cout \u0026lt;\u0026lt; format(\u0026#34;ptr2 count: {} value:{} \\n\u0026#34;, ptr1.use_count(),ptr2-\u0026gt;A); //ptr2 count: 2 value:5 { ObjectPtr ptr3(ptr2); cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} ptr2 count: {} \\n\u0026#34;, ptr1.use_count(),ptr2.use_count()); //ptr1 count: 3 ptr2 count: 3 ObjectPtr ptr4(ptr3); cout \u0026lt;\u0026lt; format(\u0026#34;ptr3 count: {} ptr4 count: {} \\n\u0026#34;, ptr3.use_count(),ptr4.use_count()); //ptr3 count: 4 ptr4 count: 4 ObjectPtr ptr5(ptr4); ObjectPtr ptr6(ptr5); cout \u0026lt;\u0026lt; format(\u0026#34;ptr5 count: {} ptr6 count: {} \\n\u0026#34;, ptr5.use_count(),ptr6.use_count()); //ptr5 count: 6 ptr6 count: 6 } cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} \\n\u0026#34;, ptr1.use_count()); //ptr1 count: 2 cout \u0026lt;\u0026lt;\u0026#34;---------- End --------------\\n\u0026#34;; } //DestroyObj 5 while(true){} } 输出\n1 2 3 4 5 6 7 8 9 10 CreateObj 1 ptr1 count: 1 value:1 ptr1 count: 2 value:5 ptr2 count: 2 value:5 ptr1 count: 3 ptr2 count: 3 ptr3 count: 4 ptr4 count: 4 ptr5 count: 6 ptr6 count: 6 ptr1 count: 2 ---------- End -------------- DestroyObj 5 safe_ptr safe_ptr 是一种自动且轻量的解决方案，用于解决悬空指针问题。\n类描述\n这个类是 weak_ptr 的一种替代方案，其主要优点是不需要分配额外的内存，但代价是稍微慢一些，并且不是线程安全的。\n在正常使用情况下，safe_ptr\u0026lt;T\u0026gt; 的行为与 T* 完全相同。当 safe_ptr 引用的原始指针被删除时，所有指向该原始指针的 SafePtrs 都会被设置为 NULL。\n工作原理\n这一机制通过让原始对象继承自 safe_object 类来实现。safe_object 类维护一个指向它的 SafePtrs 的链表。当一个 safe_object 被销毁时 会遍历其链表，将每个 SafePtr 的对象引用设置为 NULL。\n这种开销很小——只需在所指向的对象大小中增加一个指针，并且 safePtr 的大小等于一个原始指针加上一个链表指针。\n线程安全性\n这个类不是线程安全的。特别是，操作引用同一个底层对象的 safe_ptr 对象不能从多个线程安全地进行。然而，不相关的 safe_ptr 对象可以在多个线程中安全使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class RandomLifetimeObject : public eastl::safe_object { public: int A = 0; RandomLifetimeObject(int value) : A(value){} void Print() { cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; int main() { { Object* Object1 = new Object(1); eastl::safe_ptr\u0026lt;RandomLifetimeObject\u0026gt; pSafePtr(new RandomLifetimeObject(50)); pSafePtr-\u0026gt;Print(); eastl::safe_ptr\u0026lt;RandomLifetimeObject\u0026gt; pSafePtrCopy = pSafePtr; pSafePtrCopy-\u0026gt;Print(); pSafePtr-\u0026gt;Print(); delete pSafePtr; // 此时，pSafePtrCopy 评估为 NULL。 //get()返回false if (pSafePtrCopy.get()) { pSafePtrCopy-\u0026gt;Print(); } else { cout \u0026lt;\u0026lt; \u0026#34;pSafePtrCopy is null\\n\u0026#34;; } } while (true) { } } ","date":"1074-01-01T20:11:46+08:00","permalink":"http://localhost:1313/p/eastl/","title":"EASTL"},{"content":"模板专题\n构造 赋值 析构 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { String s1(); String s2(\u0026#34;Hello\u0026#34;); // 拷贝构造 String s3(s1); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; // 拷贝赋值 s3 = s2; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; } 不写这些函数，编译器自动写.\n构造 析构 String类，手动定义 构造、赋值、析构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 String::String(const char* cstr = 0) { if(cstr) { // 字符长度+1 的+1 是结尾符号\u0026#39;\\0\u0026#39; m_data = new char[strlen(cstr)+1]; strcpy(m_data,cstr); } else { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } } String::~String() { //清理动态分配的数组内存[] delete[] m_data; } { String s1(); String s2(\u0026#34;hello\u0026#34;); String* p = new String(\u0026#34;hello\u0026#34;); delete p; } // 离开作用域，s1 s2自动释放 析构，p要delete. 拷贝构造 b=a 浅拷贝， b的data指向a的data的区域，导致b原本的\u0026quot;World\\0\u0026quot;内存泄露， 当a的data修改后，b跟着受影响.\n深拷贝，空间创建出以后 把内容拷贝过去.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 String::String(const String\u0026amp; str) { m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); } { String s1(\u0026#34;hello\u0026#34;); 下面两行意思相同 String s2(s1); //String s2 = s1; 忽略上面一行，s2是新创建出的对象，调用构造函数 } 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）.按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。\n深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）\n拷贝赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String\u0026amp; String::operator=(const String\u0026amp; str) { // 必写 检测自我赋值 if(this == \u0026amp;str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); return *this; } { String s1(\u0026#34;hello\u0026#34;); String s2(s1); s2 = s1; } 检测自我赋值，避免delete自杀\n流重载要写到类外\n1 2 3 4 5 6 7 8 9 10 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const string\u0026amp; str) { os \u0026lt;\u0026lt; str.get_c_str(); return os; } { String s1(\u0026#34;hello\u0026#34;); cout \u0026lt;\u0026lt; s1; } stack 栈 heap堆 stack是存在于某作用域的一块内存空间。调用函数时 函数本身会形成一个stack用来存放它接收的参数 和 返回地址在函数本体内声明的任何变量，其所使用的内存块都取自stack.heap 或 system heap ,是操作系统提供的一块 global内存空间，程序可动态分配从其中获得区块. new出来的东西必须手动delete\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Complex{...}; { Complex c1(1,2); Complex* p = new Complex(3); static Complex c3(1,2); //释放p，否则p离开作用域后就死亡了，会对内存失去控制，导致内存泄露，无法把内存还给系统 delete p; } //c1占用的空间来自stack. //Complex(3)是临时对象，占用的空间是以new自heap动态分配来的，并由p指向. //c1是stack object，生命在作用域结束的时候结束， //在作用域内的object 又称为 auto object，因为会被自动清理. //c3是static object,生命在作用域结束后仍然存在，直到整个程序结束. 1 2 3 4 5 6 7 8 9 10 class Complex{...}; Complex c4(1,2) int main() { } //C4是global object,生命在整个程序结束才结束。其作用域是 整个系统. new : 先分配内存，再调用构造 。 new内部调用malloc(n)\n1 2 3 4 5 6 Complex* pc = new Complex(1,2); //编译器转化为: void* mem = operator new( sizeof(Complex) ); pc = static_cast\u0026lt;Complex*\u0026gt;(mem); pc-\u0026gt;Complex::Complex(1,2); //实际是Complex::Complex(pc,1,2); delete:先调用析构， 再释放内存\n1 2 3 4 5 6 String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 1 2 3 4 5 6 7 8 9 10 class Complex { double A; double B; } class String { char* m_data; } VC内存 Complex、String被 new 出来之后的内存\n调试模式下的Complex的头尾都有 00000041 这一串数据，称为 cookie，这一个东西在delete时要用到. 末尾的1 表示内存以及分配出去，4表示其大小64，绿色块用来把内存大小从52填充为64Release模式下的Complex头尾有00000011,1表示大小为16. 当Complex被回收后，这一串数值会变成00000010，末尾的0表示已经被回收的内存.00000000 和 00000001 分别是0和16，只差一位，但十进制上差的是16，由于对象的内存大小必须是16的倍数，所以16以及16以下的数据 都是没有用到的，可以拿来做内存 分配出去 与 回收 的状态标记.\nnew Array的内存:\n8x3 ，一个Complex有2个double，2个double是8.32+4是debug的块, 4x2是头尾的51h， 4是用一个整数记录有3个Complex.String里面只有一个指针，所以图中有一个箭头去表示这个指针指向一个地方.\nArray 的new 与 delete delete要看内存头尾的cookie，cookie 记录了一整块的大小，如 图中的两个21h，delete根据它们可以把内存删掉. 此时 delete 和 delete[]不会造成内存泄露，使用delete[] 编译器才知道要删除的是数组，数组里有3个String，调用3次析构，再回收整块内存.不写delete[] 会造成内存泄露，如图中右边的红色 ?! 块 是String里面指针指向的地方. 这里会发生内存泄露.\n1 2 3 4 5 6 7 8 9 10 11 class String { char* m_data; } String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 如果new的是Complex，里面只有double 没有指针， 即便是用 delete 也可以.\n用了array new 就必须搭配 delete[] 才可万无一失.\n阶段A 复习String.\nString使用char*指针，动态分配大小. 不使用数组 如果用数组，数组大小不确定 太大太小都不好.\nString里面有指针，要关注3个重要函数: 拷贝构造、拷贝赋值、析构.\n在这里不会修改来源端的数据，函数参数用const\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class String { public: // C - Style String(const char* cstr = 0); // 拷贝构造 String(const String\u0026amp; str); // 拷贝赋值 String\u0026amp; operator=(const String\u0026amp; str); //析构 ~String(); char* get_c_str() const {return m_data;} private: char* m_data; } static、cout 所有Account实例共用一份m_rate数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Account { public: static double m_rate; static void set_rate(const double\u0026amp; x){m_rate = x;} }; // 定义初始值 double Account::m_rate = 8.0; int main() { // 调用static函数的两个方式 Account::set_rate(5.0); Account a; a.set_rate(7.0); } Singleton ， 把构造函数放在private\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); static A a; } A::GetInstance.setup(); 有人调用GetInstance时，A才会出现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); } A\u0026amp; A::GetInstance() { static A a; return a; } Cout为了打印出一些不同类型的数据 ， 做了一堆重载\n复合、继承、委托 复合 Adapter适配器设计模式\ndeque的功能很强，拿过来改造一下，只开放部分函数 成为queue.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template\u0026lt;class T\u0026gt; class queue { ... protected: deque\u0026lt;T\u0026gt; c; public: // 使用c的操作函数完成. bool empty() const {return c.empty();} size_type size() const {return c.size();} reference front() {return c.front();} reference back() {return c.back();} // void push(const value_type\u0026amp; x) {c.push_back(x);} void pop() {c.pop_front();} }; 构造由内而外，析构由外而内.\n构造： queue的构造函数首先调用deque的默认构造函数，然后才执行自己析构： queue的析构函数首先执行自己，然后才次调用deque的析构函数.\n委托 用指针指向实现功能的那个类，指针可以指向不同的实现类，右边的变动不影响左边.编译防火墙：左边不用再编译，要编译的是右边.\n继承 1 2 3 4 5 6 7 8 9 10 11 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; } template\u0026lt;typename _Tp\u0026gt; struct _List_node : public _List_node_base { _Tp _M_Data } 构造由内而外，析构由外而内\n子类的构造函数首先调用父类的默认构造函数，然后才执行自己析构首先执行自己，然后才调用父类的析构函数.\n继承搭配虚函数才是更强的.\nnon-virtual：不希望子类重新定义(override)virtual:希望子类重新定义，并且它已有默认定义pure virtual:希望子类一定要重新定义，它没有默认定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Shape { public: // pure virtual virtual void draw() const = 0; // impure virtual virtual void error(const std::string\u0026amp; msg); // non - virtual int objectID()const; } class Rectangle : public Shape { ... } const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Obj { public: int A = 0; }; int main() { Obj obj; Obj objB; Obj* objptr = \u0026amp;obj; cout \u0026lt;\u0026lt; objptr-\u0026gt;A \u0026lt;\u0026lt; endl; objptr-\u0026gt;A = 1; cout \u0026lt;\u0026lt; objptr-\u0026gt;A \u0026lt;\u0026lt; endl; const Obj* objptr2 = \u0026amp;obj; //由于正在通过常量对象访问“A”，因此无法对其进行修改 objptr2-\u0026gt;A = 2;// 错误 objptr2 = \u0026amp;objB; Obj* const objptr3 = \u0026amp;obj; objptr3-\u0026gt;A = 3; //“objptr3”: 不能给常量赋值 objptr3 = \u0026amp;objB;// 错误 return 0; } 转换函数 分母默认为1，Fraction(3) 就是3/1 = 3；只需要一个参数够了，one-argument\nnon-explicit-one-argument\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); // 调用operator double将f转换为0.6 double d=4+f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; Fraction重载了+号，但是f+4时 4是int，不是Fraction类型，调用non-explicit ctor将4转换为Fraction(4,1)，然后调用operator+\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; //[Error] operator double() 可以把Fraction转为double， Fraction(int num,int den=1) 可以把4转为Fraction\n此时有两条路线可以走，编译器报错.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: explicit Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; 构造加上explicit，防止隐式转换，不可以把3变成3/1了，不能把3变成Fraction类型，\nf+4 , 4不会变成Fraction，而operator+(const Fraction\u0026amp; f) 要的参数是Fraction类型，所以4转不到Fraction,会转换失败.\nC++11 变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\nrange-based for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for(int i : {2,3,5,7,9,13,17,19}) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } vector\u0026lt;double\u0026gt; vec; // pass by value for(auto elem: vec) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt;endl; } // pass by reference for(auto\u0026amp; elem:vec) { elem *=3 ; } auto lambda 1 2 3 4 5 6 7 8 9 10 11 12 auto i = 42; double f(); auto d = f(); vector\u0026lt;string\u0026gt; v; ... auto pos = v.begin(); auto I = [](int x) -\u0026gt; bool { ...; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; } //call: []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }(); // print \u0026#34;hello lambda\u0026#34; auto I = []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }; I(); // print \u0026#34;hello lambda\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 [...](...)-\u0026gt;returnType{...} ()参数 {}函数体 [=] 外部变量值传递 [\u0026amp;] 外部变量引用传递 int id = 0; //mutable []里的东西是可变的，不写 就不能++id auto f = [id]()mutable{ std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } { id = 42; f(); f(); f(); std::cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; } //输出 id:0; id:1; id:2; 42 //内部的id变了，外部的还是42. // class Functor { private: int id;//copy of outside id public: void operator() { std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } }; Functor f; Uniform Initialization 1 2 3 4 int values[] {1,2,3}; vector\u0026lt;int\u0026gt; v{2,3,5,7}; vector\u0026lt;string\u0026gt; cities{\u0026#34;New York\u0026#34;,\u0026#34;Berlin\u0026#34;}; complex\u0026lt;double\u0026gt; c{4.0,3.0}; 编译器在幕后做出一个 initializer_list 进行构造.\ninitializer_list 1 2 3 4 int i;\ti拥有未定义值 int j{}; j = 0 int* p; p未定义值 int* q{}; q = nullptr 1 2 3 4 5 6 7 8 void print(std::initializer_list\u0026lt;int\u0026gt; vals) { for(auto p=vals.bee();p!=vals.end;++p) { std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } print({12,3,5,7,11,13,17}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } P(initializer_list\u0026lt;int\u0026gt; initlist) { cout \u0026lt;\u0026lt; \u0026#34;P(initializer_list\u0026lt;int\u0026gt;) ,values =\u0026#34;; for(auto i : initlist) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\u0026#39;; } cout \u0026lt;\u0026lt; endl; } } P p(77,5); //P(int,int) a=77,b=5 P q{77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 P r{77,5,42}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 42 P s={77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 1 2 3 4 5 6 7 8 9 10 11 12 13 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } } P p(77,5); P q{77,5}; P r{77,5,42}; P s={77,5}; 没有initializer_list构造时，编译器会把{}里面的一包内容拆解出来，q{77,5} 和 s={77,5} 有两个数，符合P(int,int)r里面有3个数，不符合P(int,int)，失败.\ninitializer_list背后是个array，编译器能够调用initializer_list的私有构造函数.编译器看到 {} 时就制造一个initializer_list，\n=default , =delete 如果自行定义了一个构造函数，那么编译器就不会再给你一个默认构造函数。如果强制加上 = default，就可以重新获得并使用默认构造函数。 =delete告诉编译器不要定义它。必须出现在声明式。适用于任何成员函数。也适用于构造函数，但后果自负。\n1 2 3 4 5 6 7 8 9 10 11 12 class Zoo { public: Zoo(int i1,inti2) : d1(i1),d2(i2){} Zoo(const Zoo\u0026amp;) = delete; Zoo(Zoo\u0026amp;\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;\u0026amp;)=delete; virtual ~Zoo(){} private: int d1,d2; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A { public: // A user-defined // parameterized constructor A(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is a parameterized constructor\u0026#34;; } // Using the default specifier to instruct // the compiler to create the default // implementation of the constructor. A() = default; }; int main() { // executes using defaulted constructor A a; // uses parameterized constructor A x(1); return 0; } 在上述情况下，我们不必指定构造函数 A() 的主体，因为通过附加说明符 \u0026lsquo;=default\u0026rsquo;，编译器将创建此函数的默认实现。\n默认函数需要是特殊成员函数（默认构造函数、复制构造函数、析构函数等），或者没有默认参数。例如，以下代码说明非特殊成员函数不能为默认值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class B { public: // Error, func is not a special member function. int func() = default; // Error, constructor B(int, int) is not // a special member function. B(int, int) = default; // Error, constructor B(int=0) // has a default argument. B(int = 0) = default; }; // driver program int main() { return 0; } 禁用复制构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class A { public: A(int x): m(x) { } // Delete the copy constructor A(const A\u0026amp;) = delete; // Delete the copy assignment operator A\u0026amp; operator=(const A\u0026amp;) = delete; int m; }; int main() { A a1(1), a2(2), a3(3); // Error, the usage of the copy // assignment operator is disabled a1 = a2; // Error, the usage of the // copy constructor is disabled a3 = A(a2); return 0; } 禁用不需要的参数转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class A { public: A(int) {} // Declare the conversion constructor as a // deleted function. Without this step, // even though A(double) isn\u0026#39;t defined, // the A(int) would accept any double value // for it\u0026#39;s argumentand convert it to an int A(double) = delete; }; int main() { A A1(1); // Error, conversion from // double to class A is disabled. A A2(100.1); return 0; } 删除特殊成员函数提供了一种更清晰的方法来防止编译器生成我们不需要的特殊成员函数。\n删除普通成员函数或非成员函数可以防止有问题的类型提升导致意外调用函数(如“禁用不需要的参数转换”示例所示)。\nAlias Template 别名: 李白 字太白\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; using Vec = std::vector\u0026lt;T,MyAlloc\u0026lt;T\u0026gt;\u0026gt;; Vec\u0026lt;int\u0026gt; coll; std::vector\u0026lt;int,MyAlloc\u0026lt;int\u0026gt;\u0026gt; coll; //TODO::模板内容很多，不止这些\n右值与移动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //解决非必要的拷贝，右边是右值时，左边可以偷右边的资源 //而不需要执行allocation重新分配内存 //Lvalue:可以出现在operator=左侧者 //Rvalue:只能出现在operator=右侧者 //临时对象一定被当作右值 //————————————————————————————————————————————————————————————// int a = 9; int b = 4; a=b; //ok b=a;\t//ok a=a+b;\t//ok //a+b是右值 a+b=42 //Error , lvalue required as left operand of assignment //————————————————————————————————————————————————————————————// string s1(\u0026#34;hello\u0026#34;); string s2(\u0026#34;world\u0026#34;); s1 + s2 = s2; //通过编译 cout \u0026lt;\u0026lt; \u0026#34;s1:\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;s2:\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt;endl; string() = \u0026#34;world\u0026#34;; //对临时对象赋值？ //————————————————————————————————————————————————————————————// 1 2 3 4 5 int foo(){return 5;} int x = foo(); //ok int* p = \u0026amp;foo(); //Error，不能对右值取地址 foo() = 7\t//Error 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyString { private: char* _data; public: //copy ctor MyString(const MyString\u0026amp; str):initialization_list{...} //move ctor MyString(MyString\u0026amp;\u0026amp; str) noexcept : initialization_list{...} } //---------------- M c1(c); M c2(std::move(c1));//要确保后续不再使用c1. 完美转发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 template\u0026lt;typename T1,typename T2\u0026gt; void functionA(T1\u0026amp;\u0026amp;t1,T2\u0026amp;\u0026amp;t2) { functionB(std::forward\u0026lt;T1\u0026gt;(t1),std::forward\u0026lt;T2\u0026gt;(t2)); } //-------------------------------------// void _init_data(const char* s) { _data = new char[_len+1]; memcpy(_data,s,_len); _data[_len] = \u0026#39;\\0\u0026#39;; } // copy constructor MyString(const MyString\u0026amp; str) :_len(str.len) { _init_data(str._data); } // move constructor MyString(MyString\u0026amp;\u0026amp; str) noexcept :_data(str._data),_len(str._len) { str._len = 0; str._data=null; } //----------------------------------------------// //copy assignment MyString\u0026amp; operator=(const MyString\u0026amp; str) { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str.len; _init_data(str.data); // Copy } else { } return *this; } //move assignment MyString\u0026amp; operator=(MyString\u0026amp;\u0026amp; str) noexcept { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str._len; //Move _data = str.data; //Move str._len = 0; //重要 str._data = null; //重要 } } //----------------------------------------------// virtual ~MyString() { if(_data) { delete _data; } } 模板 函数模板 模板函数Max，不管是什么样的类型 都可以调用这个模板，模板函数在使用时实例化，只有使用 Max(float,float) 时 才会生成对于float的Max函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; template \u0026lt;typename T\u0026gt; T Max(const T\u0026amp; T1, const T\u0026amp; T2) { return T1 \u0026gt; T2 ? T1 : T2; } class VNumber { public: float A; float B; std::string Name; VNumber(float InA , float InB,std::string InName) : A(InA),B(InB),Name(InName) {} bool operator\u0026lt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026lt; (Ohter.A + Ohter.B); } bool operator\u0026gt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026gt; (Ohter.A + Ohter.B); } }; int main() { int A = Max(2,3); double B = Max(2.2,3.3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;float Max - A:{} B:{} \\n\u0026#34;,A,B); //float Max - A:3 B:3.3 VNumber V1(1,2,\u0026#34;V1\u0026#34;); VNumber V2(3,5,\u0026#34;V2\u0026#34;); auto MaxVNumber = Max(V1,V2); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber.Name,MaxVNumber.A,MaxVNumber.B); // MaxName:V2 A:3 B:5 VNumber V3(10,5,\u0026#34;V3\u0026#34;); auto MaxVNumber2 = Max(V2,V3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber2.Name,MaxVNumber2.A,MaxVNumber2.B); // MaxName:V3 A:10 B:5 } 自动推导返回值 C++14引入自动推导:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format; template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { return tv1 + tv2; } int main() { int a = 5; int b = 3; int c = Add(a, b); float d = 5.5f; float e = 3.3f; float f = Add(d, e); auto AplusD = Add(a, d); cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2}\u0026#34;, a, b, c) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2}\u0026#34;, d, e, f) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2} Type:{3}\u0026#34;, a, d, AplusD, typeid(AplusD).name()) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; 输出：\n1 2 3 5 + 3 = 8 5.5 + 3.3 = 8.8 5 + 5.5 = 10.5 Type:float 如果在C++11中使用自动推导，需要使用尾置返回类型（trailing return type）：\n1 2 3 4 5 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 函数重载 当调用 Add 函数时，编译器会优先选择最匹配的重载函数。\n如果没有匹配的重载函数，则调用模板函数。\n如果重载函数和模板函数同时存在，编译器会优先选择重载函数（如果匹配）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { return tv1 + tv2; } // 2. 重载函数：处理两个整数相加 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用整数相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } // 3. 重载函数：处理两个字符串相加 string Add(const string\u0026amp; str1, const string\u0026amp; str2) { cout \u0026lt;\u0026lt; \u0026#34;调用字符串相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return str1 + str2; } // 4. 重载函数：处理一个整数和一个字符串相加 string Add(int a, const string\u0026amp; str) { cout \u0026lt;\u0026lt; \u0026#34;调用整数和字符串相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return std::to_string(a) + str; } int main() { // 调用模板函数 cout \u0026lt;\u0026lt; Add(1.5, 2.3) \u0026lt;\u0026lt;endl; // 调用模板函数，返回 double 类型 // 调用整数相加的重载函数 cout \u0026lt;\u0026lt; Add(10, 20) \u0026lt;\u0026lt; endl; // 调用整数相加的重载函数 // 调用字符串相加的重载函数 cout \u0026lt;\u0026lt; Add(string(\u0026#34;Hello\u0026#34;), string(\u0026#34;World!\u0026#34;)) \u0026lt;\u0026lt; endl; // 调用字符串相加的重载函数 // 调用整数和字符串相加的重载函数 cout \u0026lt;\u0026lt; Add(42, string(\u0026#34; is the answer\u0026#34;)) \u0026lt;\u0026lt; endl; // 调用整数和字符串相加的重载函数 }; 1 2 3 4 5 6 7 8 调用模板函数 3.8 调用整数相加的重载函数 30 调用字符串相加的重载函数 HelloWorld! 调用整数和字符串相加的重载函数 42 is the answer 特化 Specialization 特化是指为模板的某些特定类型或条件提供特殊的实现\n针对Object类 ，调用Add时 只会把它们内部的Name变量加起来.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format,std::string; template\u0026lt;typename T\u0026gt; void Add(T\u0026amp; T1, T\u0026amp; T2) { T1 += T2; } struct Object { Object(string InName) : Name(InName){} string Name; }; template\u0026lt;\u0026gt; void Add\u0026lt;Object\u0026gt;(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } int main() { int A = 5; int B = 6; Add(A,B); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,A,B); //A:11 B:6 Object Obj1(\u0026#34;Manba\u0026#34;); Object Obj2(\u0026#34;Out\u0026#34;); Add(Obj1,Obj2); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,Obj1.Name,Obj2.Name); //A:ManbaOut B:Out } 这个例子里的第二个Add 手动指定了两个参数的类型，而且模板函数也只有这两个参数，也就是把所有参数类型全部手动指定了，这就是全特化.\n以下两种写法都可以，有时候还是写明模板实参比较好，即第一种写法，在尖括号里指明特化类型.\n1 2 3 4 5 6 template\u0026lt;\u0026gt; void Add\u0026lt;Object\u0026gt;(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } 1 2 3 4 5 6 template\u0026lt;\u0026gt; void Add(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } 全特化是指为模板的所有模板参数指定具体的类型或值，从而为这些特定类型提供一个完全独立的实现。\n偏特化是指为模板的部分模板参数指定具体的类型或条件，而不是全部参数。偏特化允许对模板参数进行部分约束，从而为某些特定情况提供特殊实现。\n实际上 函数模板只有全特化，没有偏特化，模板类有全特化和偏特化.\n模板类特化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename T\u0026gt; void VarType(T T1) {} template \u0026lt;\u0026gt; void VarType\u0026lt;int\u0026gt;(int) { cout \u0026lt;\u0026lt; \u0026#34;VarType is int\\n\u0026#34;; } template \u0026lt;\u0026gt; void VarType\u0026lt;float\u0026gt;(float) { cout \u0026lt;\u0026lt; \u0026#34;VarType is float\\n\u0026#34;; } 函数重载与特化 （1）普通函数重载优先 普通函数重载的优先级最高。如果调用时的实参与某个普通函数重载完全匹配，编译器会直接选择该函数，而不会考虑模板函数或模板特化版本。\n（2）模板全特化版本次之 如果没有匹配的普通函数重载，编译器会检查是否存在模板全特化版本。如果调用时的实参与某个模板全特化版本完全匹配，编译器会选择该特化版本。\n（3）模板函数最后 如果既没有匹配的普通函数重载，也没有匹配的模板全特化版本，编译器会选择最匹配的模板函数，并实例化该模板。\n函数模板重载 普通函数重载：这是指在同一作用域内定义多个具有相同名称但参数列表不同的函数。\n1 2 3 4 5 // 普通函数重载 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用整数相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } 函数模板重载：这是指在同一作用域内定义多个具有相同名称但模板参数或参数列表不同的函数模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 通用函数模板 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { cout \u0026lt;\u0026lt; \u0026#34;调用模板函数: T, U\u0026#34; \u0026lt;\u0026lt; endl; return tv1 + tv2; } // 特定参数类型的函数模板重载 template\u0026lt;typename T\u0026gt; auto Add(float T1, T\u0026amp; T2) { cout \u0026lt;\u0026lt; \u0026#34;调用第二个Add\u0026#34; \u0026lt;\u0026lt; endl; return T1 + T2; } 缺省参数 缺省值\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T\u0026gt; auto Sub(T tv1, T tv2 = 1) { cout \u0026lt;\u0026lt; \u0026#34;调用模板函数: T\u0026#34; \u0026lt;\u0026lt; endl; return tv1 - tv2; } int main() { int A = 10; auto c = Sub(A); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 调用模板函数: T 9 缺省类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T = int,typename T2\u0026gt; auto Add(T2 tv2) { T tv1 = 1; return tv1 + tv2; } int main() { int A = 10; auto c = Add(A); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 运行结果 C = 11\n非类型模板参数 非类型模板参数是具体的值或对象，它们可以在编译时确定，并且可以用于控制模板的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T,typename U,auto V = 100\u0026gt; auto Add(T a,T b) { return a + b + V; } int main() { int A = 10; int B = 20; auto c = Add\u0026lt;int,int\u0026gt;(A,B); //C = A + B + 100 //C = 130 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; auto d = Add\u0026lt;int,int,2.2\u0026gt;(A,B); // d = A + B + 2.2 // d = 32.2 cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 运行结果 c=130，d=32.2\n非类型模板参数要在编译期确定，不能使用变量，除非是const、constexpr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int V1 = 100; constexpr int V2 = 100; int V3 = 100; template\u0026lt;typename T,typename U,auto V = 100\u0026gt; auto Add(T a,T b) { return a + b + V; } int main() { int a = 10; int b = 20; auto c = Add\u0026lt;int,int,V1\u0026gt;(a,b); auto d = Add\u0026lt;int,int,V2\u0026gt;(a,b); auto e = Add\u0026lt;int,int,V3\u0026gt;(a,b); return 0; } 其中 e的V3是变量，编译时报错\n1 2 表达式的计算结果不是常数 非常量参数或对非常量符号的引用导致了故障 如果在代码中 没有使用到非类型模板参数，可以不写参数名，但在调用时 还是要用尖括号指明类型的，以下的写法是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T, int value\u0026gt; auto Add2() { return 100; } template \u0026lt;typename , int \u0026gt; auto Add2() { return 100; } //调用时指明尖括号 Add2\u0026lt;int,5\u0026gt;(); 可变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\n折叠表达式极大地简化了可变参数模板的操作，使得编写递归模板函数来处理参数包变得不再必要，从而让代码更加简洁和易读\n折叠表达式主要用于对可变数量的模板参数进行操作，常见的应用场景包括：\n对所有参数应用一个二元运算符：例如求和、求积等。 构建复杂的类型列表或值列表：例如生成类型列表或初始化列表。 简化递归模板函数：通过折叠表达式可以避免手动编写递归模板函数来处理参数包。 求和 求积：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 使用折叠表达式计算参数包中所有整数的和 template\u0026lt;typename... Args\u0026gt; auto sum(Args... args) { return (args + ...); // 左折叠 } template\u0026lt;typename... Args\u0026gt; auto product(Args... args) { return (args * ...); // 左折叠 } template\u0026lt;typename... Args\u0026gt; std::string concat(Args... args) { return (... + std::string(args)); // 右折叠 } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Sum: \u0026#34; \u0026lt;\u0026lt; sum(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出: 15 std::cout \u0026lt;\u0026lt; \u0026#34;Product: \u0026#34; \u0026lt;\u0026lt; product(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出: 120 // 输出: Hello World! cout \u0026lt;\u0026lt; \u0026#34;Concatenated:\u0026#34; \u0026lt;\u0026lt; concat(\u0026#34;Hello\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 左折叠 vs 右折叠\n左：参数从左侧开始计算 (((\u0026ldquo;Hello\u0026rdquo; + \u0026quot; \u0026ldquo;) + \u0026ldquo;World\u0026rdquo;) + \u0026ldquo;!\u0026rdquo;)右：参数从右侧开始计算 ((\u0026ldquo;Hello\u0026rdquo; + (\u0026rdquo; \u0026quot; + (\u0026ldquo;World\u0026rdquo; + \u0026ldquo;!\u0026rdquo;))))\n对于字符串连接操作 +，左折叠和右折叠的结果也是相同的，因为字符串连接也是结合律的。\n对于具有结合律的运算符（如 +, *），左折叠和右折叠的结果是相同的。但对于没有结合律的运算符（如 -, /），左折叠和右折叠的结果可能会不同。因此，在选择左折叠还是右折叠时，需要根据具体情况和运算符的特性进行选择。\n一元左折(unary left fold) 格式:(\u0026hellip; 运算符 一包参数) 计算方式:(((参数1 运算符 参数2) 运算符 参数3)\u0026hellip;.运算符 参数N)\n一元右折(unary right fold) 格式: (一包参数 运算符 \u0026hellip;) 计算方式:(参数1 运算符 ( \u0026hellip; (参数N-1 运算符 参数N)))\n二元左折(binary left fold) 格式:(init 运算符 \u0026hellip; 运算符 一包参数) 计算方式:(((init 运算符 参数1) 运算符 参数2) \u0026hellip; 运算符 参数N) init表示 一个初始的东西，它可能是一个值，也可能是个其他东西。\n二元右折(binary right fold) 格式:(一包参数 运算符 \u0026hellip; 运算符 init) 计算方式:(参数1 运算符 (\u0026hellip;（参数N 运算符 init )))\n多态 模板中的多态，并不需要用到父类以及继承的概念，子类也不需要虚函数(压根就不存在父类指针指向子类对象或者父类引用绑定子类对象这种概念)\n1 编译期间内，编译器会实例化出eatTmpl\u0026lt;A\u0026gt;和eatTmpl\u0026lt;B\u0026gt;这两个函数。 总结： 传统多态：也叫动态多态（运行时多态），因为要访问虚函数表指针，所以对执行期间的性能多少会有一些影响。 模板多态：也叫静态多态，编译期间就确定了具体调用谁，就不存在执行期间的性能问题 只要支持相同的语法，就允许不同类型的对象以同样的方式被操纵——都有eat成员函数，那么就允许调用该成员函数，因为这是在编译期间完成的多态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class A { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;A!\u0026#34; \u0026lt;\u0026lt; endl; } }; class B { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;B!\u0026#34; \u0026lt;\u0026lt; endl; } }; //函数模板 template\u0026lt;typename T\u0026gt; void eatTmpl(T\u0026amp; obj) { obj.eat(); } int main() { A ObjA; B ObjB; eatTmpl(ObjA); eatTmpl(ObjB); return 0; } 类模板 类模板可以做数据结构的容器什么的. 比如在一个模板类里面搞一个数组，在使用时 可以定义数组存放什么样的类型， 或者 搞个链表，放一串int / float / string 等等类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template\u0026lt;typename T\u0026gt; class SimpleContainer { public: SimpleContainer(T InContent) : Content(InContent){} T GetContent() { return Content; } void SetContent(T InContent) { Content = InContent; } private: T Content; }; int main() { SimpleContainer SC(5); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} ,type:{} \\n\u0026#34;,SC.GetContent(),typeid(SC.GetContent()).name()); //SC Content:5 ,type:int SC.SetContent(10); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} , Is String? : {}\\n\u0026#34;, SC.GetContent(), std::is_same\u0026lt;decltype(SC.GetContent()),string\u0026gt;::value); //SC Content:10 , Is String? : false SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); cout\u0026lt;\u0026lt;format(\u0026#34;SC1 Content:{}, Is String? : {} \\n\u0026#34;, SC1.GetContent(), std::is_same\u0026lt;decltype(SC1.GetContent()),string\u0026gt;::value); //SC1 Content:Manba out, Is String? : true } C++17 模板参数自动推导，下面两种写法是一样的\n1 2 SimpleContainer SC(string(\u0026#34;Fuck\u0026#34;)); SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); 推断指引 在 C++17 之前，如果你有一个模板类，比如 std::pair，你在实例化时必须显式指定模板参数：\n1 2 3 4 std::pair\u0026lt;int, double\u0026gt; p(42, 3.14); // 必须显式指定 \u0026lt;int, double\u0026gt; //C++17 引入了 类模板参数推导 std::pair p(42, 3.14); // 编译器自动推导为 std::pair\u0026lt;int, double\u0026gt; 但有些情况下，编译器无法根据构造函数参数正确推导模板参数，这时就需要 deduction guide 来明确推导规则。\nDeduction guide 的主要作用是在 不显式指定模板参数 的情况下，帮助编译器推导模板参数\n1 2 template \u0026lt;模板参数列表\u0026gt; 类名(构造函数参数列表) -\u0026gt; 推导出的模板参数; 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; class Box { public: T value; Box(T v) : value(v) { cout\u0026lt;\u0026lt;format(\u0026#34;Box created with value {}\\n\u0026#34;,value); } }; int main() { Box b(\u0026#34;hello\u0026#34;); return 0; } 当Box b构建完成，它的value是const char*类型，\n使用推断指引 指定value的类型，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename T\u0026gt; class Box { public: T value; Box(T v) : value(v) { cout\u0026lt;\u0026lt;format(\u0026#34;Box created with value {}\\n\u0026#34;,value); } }; // Deduction guide for const char* Box(const char*)-\u0026gt;Box\u0026lt;std::string\u0026gt;; int main() { Box b(\u0026#34;hello\u0026#34;); return 0; } 添加了推断指引后，value为string类型\n例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename T\u0026gt; class Wrapper { public: T value; Wrapper(int v) : value(v) { cout \u0026lt;\u0026lt; format(\u0026#34;Wrapper({}) created\\n\u0026#34;, value); } // 构造函数参数是 int，但 T 可能是其他类型 }; // Deduction guide for Wrapper Wrapper(int)-\u0026gt;Wrapper\u0026lt;int\u0026gt;; int main() { Wrapper w(42); return 0; } 如果不添加推导指引，编译器会报错，\n1 2 3 error C2641: 无法推导“Wrapper”的模板参数 error C2783: “Wrapper\u0026lt;T\u0026gt; Wrapper(int)”: 无法推导“T”的 模板 参数 error C2784: “Wrapper\u0026lt;T\u0026gt; Wrapper(Wrapper\u0026lt;T\u0026gt;)”: 无法从“int”推导出“Wrapper\u0026lt;T\u0026gt;”的 模板 参数 当不添加推导指引时，可以手动使用尖括号指定T的类型，不需要依赖 类模板参数推导（CTAD） 或 deduction guide。\n1 Wrapper\u0026lt;int\u0026gt; w(42); 例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename T\u0026gt; struct B { T m_b; T m_b2; }; template\u0026lt;typename T\u0026gt; B(T) -\u0026gt; B\u0026lt;T\u0026gt;; template\u0026lt;typename T\u0026gt; B(T, T) -\u0026gt; B\u0026lt;T\u0026gt;; int main() { B\u0026lt;int\u0026gt; bobj1; //需要明确指定模板参数类型 B\u0026lt;int\u0026gt; bobj2{ 15 }; //可以用初始化列表的方式来定义对象bobj2,成员变量m_b=15。 B bobj3{ 15 }; //无法推导B的模板参数 B bobj4{ 15,20 }; return 0; } 在C++17版本，不添加推断指引，编译错误.\nC++20版本，即使不写推断指引，也能自动推导，编译成功.\n模板类特化 全特化 说人话就是 模板里的参数被手动指定了，例如指定为 int和double\n偏特化 模板里的参数 只指定了一个为int，另一个还是T\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 主模板 template \u0026lt;typename T, typename U\u0026gt; class MyClass { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;主模板\u0026#34; \u0026lt;\u0026lt; endl; } }; // 全特化：T = int, U = double template \u0026lt;\u0026gt; class MyClass\u0026lt;int, double\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;全特化版本：T = int, U = double\u0026#34; \u0026lt;\u0026lt; endl; } }; // 偏特化：T = int, U 任意 template \u0026lt;typename U\u0026gt; class MyClass\u0026lt;int, U\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化版本：T = int, U 任意\u0026#34; \u0026lt;\u0026lt; endl; } }; // 偏特化：T 任意, U = double template \u0026lt;typename T\u0026gt; class MyClass\u0026lt;T, double\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化版本：U = double, T 任意\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void TemA() { MyClass\u0026lt;char, char\u0026gt; obj1; obj1.print(); // 调用主模板 MyClass\u0026lt;int, double\u0026gt; obj2; obj2.print(); // 调用全特化版本 return 0; } void TemB() { MyClass\u0026lt;char, char\u0026gt; obj1; obj1.print(); // 调用主模板 MyClass\u0026lt;int, char\u0026gt; obj2; obj2.print(); // 调用偏特化版本：T = int, U 任意 MyClass\u0026lt;char, double\u0026gt; obj3; obj3.print(); // 调用偏特化版本：U = double, T 任意 return 0; } 函数定义也可以写在类外\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 主模板 template \u0026lt;typename T, typename U\u0026gt; class MyClass { public: void print(); }; template \u0026lt;typename T, typename U\u0026gt; void MyClass\u0026lt;T,U\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;主模板\u0026#34; \u0026lt;\u0026lt; endl; } // 全特化：T = float, U = double template \u0026lt;\u0026gt; class MyClass\u0026lt;float, double\u0026gt; { public: void print(); }; void MyClass\u0026lt;float,double\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;全特化 float, double\u0026#34; \u0026lt;\u0026lt; endl; } // 偏特化：T = int, U 任意 template \u0026lt;typename U\u0026gt; class MyClass\u0026lt;int, U\u0026gt; { public: void print(); }; template \u0026lt;typename U\u0026gt; void MyClass\u0026lt;int, U\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化：T = int, U 任意\u0026#34; \u0026lt;\u0026lt; endl; } int main() { MyClass\u0026lt;float, float\u0026gt; Mclass; Mclass.print(); MyClass\u0026lt;float,double\u0026gt; Mclass2; Mclass2.print(); MyClass\u0026lt;int,int\u0026gt; Mclass1; Mclass1.print(); return 0; } 输出：\n1 2 3 主模板 全特化 float, double 偏特化：T = int, U 任意 成员函数模板 类模板中的成员函数，只有源程序代码中出现调用这些成员函数的代码时，这些成员函数才会出现在一个实例化了的类模板中。\n类模板中的成员函数模板，只有源程序代码中出现调用这些成员函数模板的代码时，这些成员函数模板的具体实例才会出现在一个实例化了的类模板中。\n目前编译器并不支持虚成员函数模板，因为虚函数表vtbl的大小是固定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u0026lt;typename T1\u0026gt; class A { public: template \u0026lt;typename T2\u0026gt; A(T2 v1, T2 v2); //构造函数模板，引入了自己的模板参数T2，与类A的模板参数T1没有关系 template \u0026lt;typename T3\u0026gt; void myft(T3 tmpt) //普通成员函数模板 { cout \u0026lt;\u0026lt; tmpt \u0026lt;\u0026lt; endl; } }; template \u0026lt;typename T1\u0026gt; template \u0026lt;typename T2\u0026gt; A\u0026lt;T1\u0026gt;::A(T2 v1, T2 v2) { cout \u0026lt;\u0026lt; \u0026#34;A::A(T2,T2)执行了!\u0026#34; \u0026lt;\u0026lt; endl; } int main() { A\u0026lt;int\u0026gt; A1(1,2); A1.myft(3); return 0; } 继承关系 CRTP\nCRTP（Curiously Recurring Template Pattern，奇特递归模板模式）是一种C++编程技术，通过使用模板和继承来实现静态多态性。与传统的运行时多态（通过虚函数实现）不同，CRTP可以在编译时进行优化，从而提高性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename Derived\u0026gt; class Base { public: void interface() { // 调用派生类的实现 static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); } }; class Derived : public Base\u0026lt;Derived\u0026gt; { public: void implementation() { // 实现细节 } }; CRTP实现策略模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 策略接口 template \u0026lt;typename Derived\u0026gt; class Strategy { public: void execute() { static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;doExecute(); } }; // 具体策略A class ConcreteStrategyA : public Strategy\u0026lt;ConcreteStrategyA\u0026gt; { public: void doExecute() { std::cout \u0026lt;\u0026lt; \u0026#34;Executing strategy A\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体策略B class ConcreteStrategyB : public Strategy\u0026lt;ConcreteStrategyB\u0026gt; { public: void doExecute() { std::cout \u0026lt;\u0026lt; \u0026#34;Executing strategy B\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { ConcreteStrategyA strategyA; ConcreteStrategyB strategyB; strategyA.execute(); // 输出: Executing strategy A strategyB.execute(); // 输出: Executing strategy B return 0; } 这里的关键点在于派生类Derived在定义时将自己作为模板参数传递给了基类Base。这样做的好处是可以让基类访问到派生类的成员，同时保持一定的抽象层次和代码复用。\n实现机制\n静态绑定：由于所有操作都在编译期确定，因此避免了虚函数调用带来的间接性和开销。CRTP允许基类调用派生类的方法或访问其数据成员，而不需要通过虚函数表（vtable）。 类型识别：在CRTP中，基类通过模板参数知道它是为哪个具体的派生类实例化的。这使得基类可以根据不同的派生类提供不同的行为，而这些行为在编译期就已经确定。 接口扩展与策略模式：除了实现静态多态外，CRTP还常用于接口扩展和策略模式的实现。例如，可以为一个类添加额外的功能而不修改其原始定义。 C++23\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Base { void name(this auto\u0026amp;\u0026amp; self) { self.impl(); } }; struct D1 : Base { void impl() { cout\u0026lt;\u0026lt;\u0026#34;D1::impl() \\n\u0026#34;; } }; struct D2 : Base { void impl() { cout\u0026lt;\u0026lt;\u0026#34;D2::impl() \\n\u0026#34;; } }; int main() { D1 d1; d1.name(); D2 d2; d2.name(); } 混入\n通过模板混入技巧，我们可以在不修改基类的情况下，动态地为类添加新的功能。这种方式比继承更加灵活，因为它允许我们在编译时选择性地组合功能，而不需要创建复杂的继承层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 基类 class Base { public: void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Base is doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 混入类：添加日志功能 template \u0026lt;typename T\u0026gt; class LoggingMixin : public T { public: void doSomethingWithLog() { std::cout \u0026lt;\u0026lt; \u0026#34;Logging: Before doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; T::doSomething(); // 调用基类的功能 std::cout \u0026lt;\u0026lt; \u0026#34;Logging: After doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 使用混入类扩展 Base 的功能 LoggingMixin\u0026lt;Base\u0026gt; obj; // 调用扩展后的功能 obj.doSomethingWithLog(); return 0; } 结果\n1 2 3 Logging: Before doing something. Base is doing something. Logging: After doing something. 基类 Base：这是一个普通的类，有一个 doSomething 方法。\n混入类 LoggingMixin：这是一个模板类，继承自模板参数 T。它添加了一个新的方法 doSomethingWithLog，在调用基类的 doSomething 方法前后添加了日志输出。\n使用混入类：在 main 函数中，我们通过 LoggingMixin\u0026lt;Base\u0026gt; 创建了一个对象 obj。这个对象既拥有 Base 的功能，又拥有 LoggingMixin 添加的日志功能。\nMixin 模式非常适合以下场景：\n功能扩展：当你需要为现有类添加新功能而不修改其源代码时。 模块化设计：通过将不同功能分离到不同的 Mixin 类中，使代码更加模块化和易于维护。 代码复用：Mixin 类可以被多个不同的类复用，减少了重复代码。 灵活性：通过多重继承或模板组合，可以在不修改原始类的情况下灵活地组合多种功能。 然而，需要注意的是，过多的多重继承可能会导致复杂的继承层次结构，增加代码理解和维护的难度。因此，在使用 Mixin 时应权衡其优点和潜在的复杂性。结合 CRTP（Curiously Recurring Template Pattern）等技术，可以进一步增强 Mixin 的功能和控制力。\n变量模板 C++14，允许定义模板化的常量或变量。通过变量模板，可以在编译时生成不同类型的常量或变量实例，并且可以简化代码，提高可读性和维护性。\n例1：使用变量模板表示某个类型的最小值\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; constexpr T min_value = std::numeric_limits\u0026lt;T\u0026gt;::min(); template\u0026lt;typename T\u0026gt; constexpr T max_value = std::numeric_limits\u0026lt;T\u0026gt;::max(); cout \u0026lt;\u0026lt; \u0026#34;Min value for unsigned short: \u0026#34; \u0026lt;\u0026lt; min_value\u0026lt;unsigned short\u0026gt; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Max value for unsigned short: \u0026#34; \u0026lt;\u0026lt; max_value\u0026lt;unsigned short\u0026gt; \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt;format(\u0026#34;Min value for unsigned short: {}\\nMax value for unsigned short: {}\\n\u0026#34;, min_value\u0026lt;unsigned short\u0026gt;, max_value\u0026lt;unsigned short\u0026gt;); 例2：数字常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;typename T\u0026gt; constexpr T pi = T(3.1415926535897932385L); // 定义一个函数模板，计算圆的面积 template\u0026lt;typename T\u0026gt; T circle_area(T radius) { return pi\u0026lt;T\u0026gt; * radius * radius; } cout \u0026lt;\u0026lt; \u0026#34;Pi (double): \u0026#34; \u0026lt;\u0026lt; pi\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Pi (float): \u0026#34; \u0026lt;\u0026lt; pi\u0026lt;float\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Area of a circle with radius 5 (double): \u0026#34; \u0026lt;\u0026lt; circle_area(5.0) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Area of a circle with radius 5 (float): \u0026#34; \u0026lt;\u0026lt; circle_area(5.0f) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 例3：类型特性\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; constexpr bool is_integer = std::is_integral_v\u0026lt;T\u0026gt;; cout \u0026lt;\u0026lt; \u0026#34;Is int an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;int\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Is double an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Is char an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;char\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;typename T\u0026gt; T Value{}; int main() { Value\u0026lt;int\u0026gt; = 10; cout \u0026lt;\u0026lt; format(\u0026#34;Value = {}\\n\u0026#34;, Value\u0026lt;int\u0026gt;); Value\u0026lt;string\u0026gt; = \u0026#34;Hello\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;Value = {}\\n\u0026#34;, Value\u0026lt;string\u0026gt;); cout \u0026lt;\u0026lt; format(\u0026#34;Value\u0026lt;int\u0026gt; = {} Value\u0026lt;string\u0026gt; = {}\\n\u0026#34;, Value\u0026lt;int\u0026gt;, Value\u0026lt;string\u0026gt;); return 0; } 进阶 模板模板参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 template\u0026lt;typename T,template\u0026lt;typename\u0026gt; typename Vec = std::vector\u0026gt; class Obj { public: Vec\u0026lt;T\u0026gt; vec; Obj() { cout \u0026lt;\u0026lt; format(\u0026#34;{}\u0026#34;,typeid(T).name()) \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; ++i) { vec.push_back(i); } } void print() { for (auto i : vec) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt; endl; } }; int main() { Obj\u0026lt;int\u0026gt; Ob; Ob.print(); return 0; } //输出： //int //0 1 2 3 4 5 6 7 8 9 使用模板模板参数 打印各种不同容器的元素\n1 2 3 4 5 6 7 8 9 template \u0026lt;template \u0026lt;typename, typename\u0026gt; class Container, typename T, typename Allocator\u0026gt; void printContainer(const Container\u0026lt;T, Allocator\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 打印vector 以及 模板实例化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::vector\u0026lt;int\u0026gt; vec = { 1, 2, 3, 4 }; printContainer(vec); // 模板实例化的代码 //template \u0026lt;typename, typename\u0026gt; class Container, typename T, typename Allocator // Container = std::vector // T = int // Allocator = Allocator\u0026lt;int\u0026gt; void printContainer(const std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt;\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 打印list 以及 模板实例化\n1 2 3 4 5 6 7 8 9 10 11 std::list\u0026lt;double\u0026gt; lst = { 1.1, 2.2, 3.3 }; printContainer(lst); //模板实例化 void printContainer(const std::list\u0026lt;double, std::allocator\u0026lt;double\u0026gt;\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 模板参数推导： 编译器根据传入的容器类型（如 std::vector\u0026lt;int\u0026gt; 或 std::list\u0026lt;double\u0026gt;）推导出模板参数 Container、T 和 Allocator。 默认模板参数： std::vector 和 std::list 的第二个模板参数（分配器）是默认的 std::allocator\u0026lt;T\u0026gt;，因此不需要显式指定。 万能引用 万能引用（Universal Reference） 是 C++11 引入的一个概念，通常与 \u0026amp;\u0026amp; 和模板结合使用。它允许函数模板接受任意类型的参数（左值或右值），并根据传入的参数类型自动推导出正确的引用类型。万能引用的典型应用是实现完美转发（Perfect Forwarding）。\n右值与移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 函数模板，使用万能引用 template \u0026lt;typename T\u0026gt; void print(T\u0026amp;\u0026amp; value) { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { int x = 10; const std::string str = \u0026#34;Hello\u0026#34;; // 传递左值 print(x); // T 推导为 int\u0026amp; print(str); // T 推导为 const std::string\u0026amp; // 传递右值 print(42); // T 推导为 int print(std::string(\u0026#34;World\u0026#34;)); // T 推导为 std::string return 0; } 万能引用的语法： T\u0026amp;\u0026amp; 是万能引用的语法形式。 当 T 是一个模板参数时，T\u0026amp;\u0026amp; 可以根据传入的参数类型推导出左值引用或右值引用。 类型推导： 如果传入的是一个左值（如 x 或 str），T 会被推导为左值引用类型（如 int\u0026amp; 或 const std::string\u0026amp;）。 如果传入的是一个右值（如 42 或 std::string(\u0026quot;World\u0026quot;)），T 会被推导为值类型（如 int 或 std::string）。 输出结果： 无论传入左值还是右值，print 函数都能正确处理并输出。 完美转发\n将参数以原始类型（左值或右值）传递给另一个函数。以下是一个完美转发的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void process(int\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing lvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } void process(int\u0026amp;\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing rvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } // 转发函数模板 template \u0026lt;typename T\u0026gt; void forwarder(T\u0026amp;\u0026amp; arg) { process(std::forward\u0026lt;T\u0026gt;(arg)); // 使用 std::forward 完美转发 } int main() { int x = 10; // 传递左值 forwarder(x); // 调用 process(int\u0026amp;) // 传递右值 forwarder(20); // 调用 process(int\u0026amp;\u0026amp;) return 0; } std::forward： std::forward\u0026lt;T\u0026gt;(arg) 用于保持参数的原始类型（左值或右值）。 如果 arg 是一个左值，std::forward 会将其转发为左值。 如果 arg 是一个右值，std::forward 会将其转发为右值。 完美转发的作用： 通过万能引用和 std::forward，forwarder 函数可以将参数以原始类型传递给 process 函数，确保调用正确的重载版本。 输出：\n1 2 Processing lvalue: 10 Processing rvalue: 20 总结\n万能引用（T\u0026amp;\u0026amp;）允许函数模板接受任意类型的参数（左值或右值）。 通过 std::forward，可以实现完美转发，保留参数的原始类型。 万能引用是 C++11 中实现通用代码和高效资源管理的重要工具。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Person 类 class Person { public: // 构造函数，接受 std::string 参数 explicit Person(const string\u0026amp; name) : name_(name) { cout \u0026lt;\u0026lt; \u0026#34;Person 左值创建：: \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } explicit Person(string\u0026amp;\u0026amp; name) : name_(std::move(name)) { cout \u0026lt;\u0026lt; \u0026#34;Person 右值创建：: \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } void greet() const { cout \u0026lt;\u0026lt; \u0026#34;Hello, my name is \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } private: string name_; }; using PersonPtr = std::unique_ptr\u0026lt;Person\u0026gt;; // 工厂函数模板，使用完美转发 template \u0026lt;typename T\u0026gt; PersonPtr createPerson(T\u0026amp;\u0026amp; name) { return std::make_unique\u0026lt;Person\u0026gt;(std::forward\u0026lt;T\u0026gt;(name)); } int main() { std::string lvalueName = \u0026#34;Alice\u0026#34;; // 使用左值创建 Person auto person1 = createPerson(lvalueName); // 调用 Person(const std::string\u0026amp;) // 使用右值创建 Person auto person2 = createPerson(\u0026#34;Bob\u0026#34;); // 调用 Person(std::string\u0026amp;\u0026amp;) // 使用右值（移动语义）创建 Person auto person3 = createPerson(std::move(lvalueName)); // 调用 Person(std::string\u0026amp;\u0026amp;) // 检查 lvalueName 是否被移动， 左值移动后 这个字符串应该为空 std::cout \u0026lt;\u0026lt; \u0026#34;lvalueName after move: \u0026#34; \u0026lt;\u0026lt; lvalueName \u0026lt;\u0026lt; endl; return 0; } 移动语义是一种优化技术，允许我们将资源（如动态内存、文件句柄等）从一个对象“转移”到另一个对象，而不是进行昂贵的拷贝操作。对于 std::string 来说，移动操作会将字符串的内部指针（指向字符数据的指针）从源对象转移到目标对象，同时将源对象置于有效但未定义的状态（通常是空字符串）。std::move 将 lvalueName 转换为右值，从而触发移动语义。移动后，lvalueName 的内容被转移到 Person 对象的构造函数中，而 lvalueName 本身会变为空字符串。如果输出是空值，说明 lvalueName 的内容已经被成功移动。\nSFINAE SFINAE C++模板编程中的一个重要概念，它的核心思想是：在模板推导过程中，如果某个替换失败了，编译器不会报错，而是简单地忽略这个候选，继续尝试其他可行的模板。SFINAE 通常用于在编译时根据类型特性选择不同的函数重载或模板特化。\nenable_if\nstd::enable_if 是C++模板编程中的一个工具，主要用于基于某些条件启用或禁用模板的实例化。它通常用来实现SFINAE原则，允许编译器根据表达式的有效性来选择不同的函数重载或类模板特化。\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; struct enable_if {}; // no member \u0026#34;type\u0026#34; when !_Test template \u0026lt;class _Ty\u0026gt; struct enable_if\u0026lt;true, _Ty\u0026gt; { // type is _Ty for _Test using type = _Ty; }; 当 _Test 为 true 时，std::enable_if\u0026lt;_Test,_Ty\u0026gt;::type 存在，并等于 T 类型。 当 _Test 为 false 时，std::enable_if\u0026lt;_Test,_Ty\u0026gt;::type 不存在，这会导致试图使用它的代码无法编译。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std::enable_if\u0026lt;true\u0026gt;::type; //可用作类型，其type是void类型. //等同于 using std::enable_if\u0026lt;true,void\u0026gt;::type = void std::enable_if\u0026lt;true\u0026gt;::type func() { cout \u0026lt;\u0026lt; \u0026#34;func\\n\u0026#34;; } //std::enable_if\u0026lt;true\u0026gt;::type func() // 二者相等 //void func() std::enable_if\u0026lt;false\u0026gt;::type; //类 \u0026#34;std::enable_if\u0026lt;false, void\u0026gt;\u0026#34; 没有成员 \u0026#34;type\u0026#34; 测试第一个模板参数bool _Test\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename T\u0026gt; enable_if\u0026lt;(sizeof(T)\u0026gt;2)\u0026gt;::type Func() { } int main() { Func\u0026lt;int\u0026gt;(); Func\u0026lt;char\u0026gt;(); return 0; } 第一个Func，int大于2，enable_if为true，true的特化版本有type成员，可以编译，函数匹配成功第二个Func，char小于2，enable_if为false，它没有type成员，忽略这个模板函数，寻找其它合适的函数，但没有合适的其它模板函数，函数匹配失败 所以报错\n1 2 error C2672: “Func”: 未找到匹配的重载函数 type Func(void)”的显式 模板 参数无效 enable_if_t简化版本，不用写::type\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; using enable_if_t = typename enable_if\u0026lt;_Test, _Ty\u0026gt;::type; template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;(sizeof(T)\u0026gt;2)\u0026gt; Func() { } 以上是第一个bool参数的实现，还有第二个参数_Ty\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; struct enable_if {}; // no member \u0026#34;type\u0026#34; when !_Test template \u0026lt;class _Ty\u0026gt; struct enable_if\u0026lt;true, _Ty\u0026gt; { // type is _Ty for _Test using type = _Ty; }; _Ty默认是void，也就是上面例子中void func 中的 void 的来历，\n1 2 3 4 5 6 7 8 9 10 11 12 enable_if_t\u0026lt;(sizeof(int) \u0026gt; 2),int\u0026gt; D = 3; //等同于using std::enable_if\u0026lt;true,int\u0026gt; = int int D = 3; template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;(sizeof(T)\u0026gt;2),T\u0026gt; Func() { } Func\u0026lt;int\u0026gt;(); //函数为: int Func\u0026lt;int\u0026gt;(); 例1:\n考虑需要根据类型的属性定义不同版本的函数。比如，你可能想要一个只适用于整数类型的加法函数和一个适用于浮点类型的加法函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 仅当 T 是整数类型时此函数才有效 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, T\u0026gt;::type add(T a, T b) { cout\u0026lt;\u0026lt; \u0026#34;Add integer \\n\u0026#34;; return a + b; } // 仅当 T 是浮点类型时此函数才有效 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_floating_point\u0026lt;T\u0026gt;::value, T\u0026gt;::type add(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;Add float \\n\u0026#34;; return a + b; } int main() { add(3,2); add(3.0,2.0); return 0; } 输出\n1 2 Add integer Add float 简化写法 使用enable_if_t\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 仅当 T 是整数类型时此函数才有效 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, T\u0026gt; add(T a, T b) { cout\u0026lt;\u0026lt; \u0026#34;Add integer \\n\u0026#34;; return a + b; } // 仅当 T 是浮点类型时此函数才有效 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_floating_point\u0026lt;T\u0026gt;::value, T\u0026gt; add(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;Add float \\n\u0026#34;; return a + b; } 标准库 std::declval std::declval 是 C++ 标准库中的一个工具，通常用于在编译时生成某个类型的假想值，以便在不实际创建对象的情况下进行类型推导或表达式求值。它主要用于模板元编程和 SFINAE场景中。主要作用是在编译时模拟一个类型的对象，从而可以在不实际构造对象的情况下推导表达式的类型或检查表达式的合法性。std::declval 通常与 decltype 一起使用，用于推导表达式的类型。\n1 2 template \u0026lt;class T\u0026gt; typename std::add_rvalue_reference\u0026lt;T\u0026gt;::type declval() noexcept; 它声明了一个返回类型为 T 的右值引用的函数，但这个函数不应该被调用。其目的仅在于帮助编译器推导类型。 从 C++14 开始，可以使用 std::declval\u0026lt;T\u0026gt;() 更简洁地表示相同的意思，其中 std::declval_t\u0026lt;T\u0026gt; 直接给出了 T 类型的右值引用。 add_rvalue_reference：是C++标准库中的类模板，他的能力是给进来一个类型，他能够返回该类型的右值引用类型。比如： a)给进来一个int类型,返回的就是int \u0026amp;\u0026amp; b)给进来一个int \u0026amp;类型，返回的还是int \u0026amp;类型。这里用到了引用折叠。 c)给进来一个int \u0026amp;\u0026amp;类型，返回的还是int \u0026amp;\u0026amp;类型。这里依旧用到了引用折叠知识。\n示例：基本用法\n假设我们有一个类 MyClass，它有一个成员函数 int foo()。我们想要在不实际创建 MyClass 对象的情况下，推导 foo() 函数的返回类型。\n1 2 int a = 10; decltype(a) b = a; // b 的类型是 int，因为 a 的类型是 int declval + decltype:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyClass { public: MyClass() {cout \u0026lt;\u0026lt; \u0026#34;MyClass constructor called\u0026#34; \u0026lt;\u0026lt; endl;} int foo() { return 42; } }; int main() { // 使用 std::declval 来模拟一个 MyClass 对象，并推导 foo() 的返回类型 using FooReturnType = decltype(std::declval\u0026lt;MyClass\u0026gt;().foo()); // 检查推导的类型是否是 int static_assert(std::is_same\u0026lt;FooReturnType, int\u0026gt;::value, \u0026#34;Foo return type should be int\u0026#34;); return 0; } 在这个过程中MyClass的构造函数不会被调用\nstd::true_type std::true_type 和 std::false_type 是 C++ 标准库中的类型，分别表示编译时的布尔值 true 和 false。它们是类型特征（type traits）的基础，通常用于模板元编程和编译时逻辑判断。\nstd::true_type 和 std::false_type 是类型别名，分别表示 true 和 false 的编译时常量。\n它们的主要作用是在编译时进行逻辑判断，例如通过模板特化或 SFINAE来实现条件编译或类型检查。\nstd::true_type 和 std::false_type 通常与 std::is_same、std::enable_if 等类型特征一起使用。\n它们可以通过 value 成员访问其布尔值（true 或 false）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 _EXPORT_STD using true_type = bool_constant\u0026lt;true\u0026gt;; _EXPORT_STD using false_type = bool_constant\u0026lt;false\u0026gt;; //true_type 拥有成员value //true_type 和 false_type 都继承自bool_constant template \u0026lt;bool _Val\u0026gt; using bool_constant = integral_constant\u0026lt;bool, _Val\u0026gt;; //bool_constant继承自integral_constant template \u0026lt;class _Ty, _Ty _Val\u0026gt; struct integral_constant { static constexpr _Ty value = _Val; using value_type = _Ty; using type = integral_constant; constexpr operator value_type() const noexcept { return value; } _NODISCARD constexpr value_type operator()() const noexcept { return value; } }; 示例1：模板特化\n假设我们有一个模板函数，它需要根据类型是否为指针来决定如何处理该类型的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 模板函数的基础版本，处理非指针类型 template\u0026lt;typename T\u0026gt; void processData(T data, std::false_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing non-pointer data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } // 模板函数的特化版本，处理指针类型 template\u0026lt;typename T\u0026gt; void processData(T* data, std::true_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing pointer data: \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } int main() { int a = 42; int* b = \u0026amp;a; // 对于非指针类型，使用 std::false_type processData(a, std::is_pointer\u0026lt;decltype(a)\u0026gt;{}); // 对于指针类型，使用 std::true_type processData(b, std::is_pointer\u0026lt;decltype(b)\u0026gt;{}); return 0; } processData 函数有两个重载版本：一个用于处理非指针类型，另一个用于处理指针类型。 std::is_pointer\u0026lt;T\u0026gt;::type 返回 std::true_type 或 std::false_type，取决于 T 是否是指针类型。 在 main 函数中，通过 std::is_pointer\u0026lt;decltype(a)\u0026gt; 和 std::is_pointer\u0026lt;decltype(b)\u0026gt; 来区分 a 和 b 的类型，并选择合适的 processData 版本。 1 2 3 //输出结果 Processing non-pointer data: 42 Processing pointer data: 42 示例 2：自定义类型特征\n以下示例展示了如何自定义一个类型特征，用于检查类型是否为指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 主模板：默认情况下，T 不是指针 template \u0026lt;typename T\u0026gt; struct IsPointer : std::false_type {}; // 特化模板：如果 T 是指针，继承 std::true_type template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; : std::true_type {}; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Is int* a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int*\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) std::cout \u0026lt;\u0026lt; \u0026#34;Is int a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) return 0; } 示例 3: SFINAE 中的应用\n假设我们需要一个函数模板，仅当类型 T 是整数类型时才有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 仅对整数类型有效的函数模板 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, void\u0026gt; printIfIntegral(T value, std::true_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Integer value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 如果类型不是整数，则不会实例化此函数 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;!std::is_integral\u0026lt;T\u0026gt;::value, void\u0026gt; printIfIntegral(T value, std::false_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Non-integer value\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { int a = 10; double b = 3.14; printIfIntegral(a, std::is_integral\u0026lt;decltype(a)\u0026gt;{}); printIfIntegral(b, std::is_integral\u0026lt;decltype(b)\u0026gt;{}); return 0; } printIfIntegral 函数有两个模板版本，分别针对整数类型和非整数类型。 std::enable_if 结合 std::is_integral 来控制哪个版本会被实例化。 通过传递 std::is_integral\u0026lt;decltype(a)\u0026gt;{} 或 std::is_integral\u0026lt;decltype(b)\u0026gt;{} 来选择合适的函数版本。 输出\n1 2 Integer value: 10 Non-integer value 总结\nstd::true_type 和 std::false_type 提供了一种简洁的方式来进行编译时的条件判断，特别适用于模板元编程中的类型选择和函数重载。通过结合其他类型特征工具（如 std::is_integral），可以在编译期实现复杂的行为控制和优化。\nstd::function C++11 引入的一个通用函数包装器，用于存储、复制和调用任何可调用对象（如函数、Lambda 表达式、函数对象等）。它提供了一种类型安全的方式来处理各种可调用对象，使得代码更加灵活和通用。\n统一接口：std::function 可以包装任何可调用对象，提供一个统一的接口来调用它们。 类型安全：通过模板参数指定函数签名，确保调用时参数和返回值的类型正确。 灵活性：可以在运行时动态地绑定不同的可调用对象。 1 std::function\u0026lt;返回类型(函数参数....)\u0026gt; 示例 1：包装普通函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int add(int a, int b) { return a + b; } int main() { // 包装一个普通函数 std::function\u0026lt;int(int, int)\u0026gt; func = add; // 调用包装的函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(2, 3) \u0026lt;\u0026lt; std::endl; // 输出 5 return 0; } std::function\u0026lt;int(int, int)\u0026gt; 定义了一个函数包装器，可以存储任何接受两个 int 参数并返回 int 的可调用对象。 func(2, 3) 调用包装的函数。 示例 2：包装 Lambda 表达式\nLambda 表达式也是可调用对象，可以直接存储在 std::function 中。\n1 2 3 4 5 6 7 8 9 // 包装一个 Lambda 表达式 std::function\u0026lt;int(int, int)\u0026gt; func = [](int a, int b) { return a * b; }; // 调用包装的 Lambda 表达式 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(2, 3) \u0026lt;\u0026lt; std::endl; // 输出 6 示例 3: 包装成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyClass { public: int add(int a, int b) { return a + b; } }; int main() { MyClass obj; // 包装一个成员函数 std::function\u0026lt;int(MyClass\u0026amp;, int, int)\u0026gt; func = \u0026amp;MyClass::add; // 调用包装的成员函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(obj, 2, 3) \u0026lt;\u0026lt; std::endl; // 输出 5 return 0; } \u0026amp;MyClass::add 是成员函数的指针。 std::function\u0026lt;int(MyClass\u0026amp;, int, int)\u0026gt; 的第一个参数是对象实例（MyClass\u0026amp;），后面是成员函数的参数。 示例4：作为回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 模拟一个异步任务，完成后调用回调函数 void asyncTask(std::function\u0026lt;void(int)\u0026gt; callback) { int result = 42; // 模拟任务结果 callback(result); // 调用回调函数 } int main() { // 定义一个回调函数 std::function\u0026lt;void(int)\u0026gt; callback = [](int result) { std::cout \u0026lt;\u0026lt; \u0026#34;Task completed with result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; }; // 执行异步任务 asyncTask(callback); // 输出 \u0026#34;Task completed with result: 42\u0026#34; return 0; } asyncTask 接受一个 std::function\u0026lt;void(int)\u0026gt; 类型的回调函数。 在任务完成后，调用回调函数并传递结果。 std::remove_all_extents 是C++ 标准库中的一个类型特征（type trait），用于移除数组类型的所有维度，最终得到数组元素的类型。它的主要作用是简化对多维数组类型的处理。\n移除数组类型的所有维度：如果传入的类型是多维数组（例如 int[3][4]），它会递归地移除所有维度，最终得到数组元素的类型（例如 int）。 简化类型处理：在处理数组类型时，可以直接获取其底层元素类型，而不需要手动解析数组的维度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;typename T\u0026gt; struct remove_all_extents { using type = T; }; template \u0026lt;typename T\u0026gt; struct remove_all_extents\u0026lt;T[]\u0026gt; { using type = typename remove_all_extents\u0026lt;T\u0026gt;::type; }; template \u0026lt;typename T, std::size_t N\u0026gt; struct remove_all_extents\u0026lt;T[N]\u0026gt; { using type = typename remove_all_extents\u0026lt;T\u0026gt;::type; }; 主模板：如果 T 不是数组类型，则直接返回 T。 特化模板：如果 T 是数组类型（如 T[] 或 T[N]），则递归地移除维度，直到得到非数组类型。 示例 1：移除一维数组的维度\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; // 包含 std::remove_all_extents int main() { using ArrayType = int[10]; using ElementType = std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;ArrayType: \u0026#34; \u0026lt;\u0026lt; typeid(ArrayType).name() \u0026lt;\u0026lt; std::endl; // 输出 int [10] std::cout \u0026lt;\u0026lt; \u0026#34;ElementType: \u0026#34; \u0026lt;\u0026lt; typeid(ElementType).name() \u0026lt;\u0026lt; std::endl; // 输出 int return 0; } ArrayType 是 int[10]，表示一个包含 10 个 int 元素的数组。 std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type 移除数组维度，得到 int。 如果传入的类型不是数组类型，std::remove_all_extents 会直接返回该类型。 示例2：结合 std::is_same 进行类型检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { using ArrayType = double[10][20]; using ElementType = std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type; // 检查 ElementType 是否是 double if (std::is_same\u0026lt;ElementType, double\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;ElementType is double!\u0026#34; \u0026lt;\u0026lt; std::endl; // 输出 \u0026#34;ElementType is double!\u0026#34; } else { std::cout \u0026lt;\u0026lt; \u0026#34;ElementType is not double!\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 萃取 类型萃取：从复杂类型（如指针、引用、数组等）中提取基础类型。 参数包萃取：从可变参数模板中提取特定参数。 主要用途\n类型萃取：用于获取类型的基本信息，例如去除引用、指针、cv限定符（const和volatile），或者从数组类型中提取元素类型。 参数包萃取：用于处理可变参数模板，从中提取特定参数进行操作。 类型别名 示例：为不同类型定义不同的求和结果类型\n假设我们需要实现一个通用的求和功能，但不同的类型在求和时可能需要不同的结果类型。例如：\n对于 char 类型，求和结果应该是 int，因为 char 的范围较小，直接相加可能导致溢出。 对于 int 类型，求和结果可以是 int 本身。 对于 double 类型，求和结果可以是 double 本身。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 主模板：默认情况下，求和类型为 T 本身 template \u0026lt;typename T\u0026gt; struct SumTraits { using sumT = T; // 默认求和类型为 T }; // 特化模板：针对 char 类型，求和类型为 int template \u0026lt;\u0026gt; struct SumTraits\u0026lt;char\u0026gt; { using sumT = int; // char 的求和类型为 int }; // 特化模板：针对 int 类型，求和类型为 int template \u0026lt;\u0026gt; struct SumTraits\u0026lt;int\u0026gt; { using sumT = int; // int 的求和类型为 int }; // 特化模板：针对 double 类型，求和类型为 double template \u0026lt;\u0026gt; struct SumTraits\u0026lt;double\u0026gt; { using sumT = double; // double 的求和类型为 double }; //--------------------------------// // 通用的求和函数 template \u0026lt;typename T\u0026gt; typename SumTraits\u0026lt;T\u0026gt;::sumT sum(T a, T b) { return a + b; } int main() { // 测试 char 类型 char c1 = 100, c2 = 100; auto resultChar = sum(c1, c2); cout \u0026lt;\u0026lt; \u0026#34;char sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultChar).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;char sum result: \u0026#34; \u0026lt;\u0026lt; resultChar \u0026lt;\u0026lt; endl; // 输出 200 // 测试 int 类型 int i1 = 100, i2 = 200; auto resultInt = sum(i1, i2); cout \u0026lt;\u0026lt; \u0026#34;int sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultInt).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;int sum result: \u0026#34; \u0026lt;\u0026lt; resultInt \u0026lt;\u0026lt; endl; // 输出 300 // 测试 double 类型 double d1 = 100.5, d2 = 200.5; auto resultDouble = sum(d1, d2); cout \u0026lt;\u0026lt; \u0026#34;double sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultDouble).name() \u0026lt;\u0026lt; endl; // 输出 double cout \u0026lt;\u0026lt; \u0026#34;double sum result: \u0026#34; \u0026lt;\u0026lt; resultDouble \u0026lt;\u0026lt; endl; // 输出 301.0 return 0; } 分析：\n1 2 3 4 5 // 测试 char 类型 char c1 = 100, c2 = 100; auto resultChar = sum(c1, c2); cout \u0026lt;\u0026lt; \u0026#34;char sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultChar).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;char sum result: \u0026#34; \u0026lt;\u0026lt; resultChar \u0026lt;\u0026lt; endl; // 输出 200 sum的返回类型是 SumTraits\u0026lt;T\u0026gt;::sumT, 根据特化模板，sum(char,char)的返回类型 即sumT ，将被推断为int，因此 针对char相加的情况， sum函数的返回类型是int, 所以变量resultChar的类型是int后面的两行cout，一个输出相加结果的类型名称，一个输出相加结果的值.\n总结\n类型别名（using）：通过 using 可以为类型定义别名，使代码更具可读性和灵活性。 模板特化：通过特化模板，可以为不同的类型定义不同的别名。 适用场景：当需要根据类型定制行为时（如返回值类型、参数类型等），可以使用 using 和模板特化。 优势：这种方式使代码更具通用性和可扩展性，能够轻松支持新的类型。 通过这个例子，我们可以看到 using 和模板特化的强大之处：它们能够根据类型的不同，自动选择合适的行为，从而实现高度灵活和可复用的代码。\n萃取元素类型-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 主模板：默认情况下，尝试通过 value_type 萃取元素类型 template \u0026lt;typename T\u0026gt; struct ElementType { using type = typename T::value_type; // 假设 T 有 value_type 成员 }; int main() { // 测试 std::vector using Vector = std::vector\u0026lt;int\u0026gt;; using VectorElement = ElementType\u0026lt;Vector\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;Element type of std::vector\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; typeid(VectorElement).name() \u0026lt;\u0026lt; std::endl; // 输出 int // 测试 std::list using List = std::list\u0026lt;double\u0026gt;; using ListElement = ElementType\u0026lt;List\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;Element type of std::list\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; typeid(ListElement).name() \u0026lt;\u0026lt; std::endl; // 输出 double return 0; } 萃取元素类型-2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template \u0026lt;typename T\u0026gt; struct GetEleType; //特化版本 template \u0026lt;typename T\u0026gt; struct GetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct GetEleType\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt; { using type = T; }; template \u0026lt;typename T, std::size_t Size\u0026gt; //这个特化版本增加了一个模板参数 struct GetEleType\u0026lt;T[Size]\u0026gt; //萃取出数组元素个数 { using type = T; static const std::size_t size = Size; }; int main() { using vectordouble = GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;vector\u0026lt;double\u0026gt;的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(vectordouble).name() \u0026lt;\u0026lt; endl; using listint = GetEleType\u0026lt;std::list\u0026lt;int\u0026gt; \u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;list\u0026lt;int\u0026gt;的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(listint).name() \u0026lt;\u0026lt; endl; using float45 = GetEleType\u0026lt; float[45] \u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;float[45]的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(float45).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float[45]的数组元素数量为：\u0026#34; \u0026lt;\u0026lt; GetEleType\u0026lt; float[45] \u0026gt;::size \u0026lt;\u0026lt; endl; return 0; } 模板参数匹配机制：第一个例子 using vectordouble = GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type;，看上去好像并没有把double传给GetEleType，double只是被传给了vector，但是它能够匹配到正确的GetEleType特化版本，\n实际上这是由 C++ 的 模板特化机制 和 模板参数推导规则 决定的，\nGetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; 的特化版本中有两个 T，分别是：\n模板参数 typename T：这是模板的通用参数，表示任意类型。 特化类型 std::vector\u0026lt;T\u0026gt;：这是特化版本的具体类型，表示 std::vector 的模板参数。 这两个 T 是同一个类型，因为它们是通过模板参数推导确定的。\n使用 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; 时，编译器会按照以下顺序确定 T 的具体类型：\n匹配特化版本： 编译器看到 std::vector\u0026lt;double\u0026gt;，发现它是一个 std::vector\u0026lt;T\u0026gt; 类型。 因此，编译器会尝试匹配特化版本 GetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;。 推导模板参数： 编译器将 std::vector\u0026lt;double\u0026gt; 与 std::vector\u0026lt;T\u0026gt; 进行比较。 由于 std::vector\u0026lt;double\u0026gt; 是 std::vector\u0026lt;T\u0026gt; 的一个实例化版本，编译器可以推导出 T = double。 实例化特化版本： 编译器将 T 替换为 double，实例化出 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;。 在特化版本中，using type = T; 被替换为 using type = double;。 提取类型： 通过 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type，你可以得到 double 类型。 类型萃取 简单的示例：实现一个类型萃取工具 IsPointer，用于判断一个类型是否为指针类型。\n定义主模板：默认情况下，类型不是指针类型，value 为 false。 特化模板：针对指针类型（T*），特化模板并将 value 设为 true。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; // 用于对比标准库的实现 // 主模板：默认情况下，类型不是指针 template \u0026lt;typename T\u0026gt; struct IsPointer { static constexpr bool value = false; }; // 特化模板：针对指针类型 T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; { static constexpr bool value = true; }; int main() { // 测试 int std::cout \u0026lt;\u0026lt; \u0026#34;Is int a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) // 测试 int* std::cout \u0026lt;\u0026lt; \u0026#34;Is int* a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int*\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) // 测试 int** std::cout \u0026lt;\u0026lt; \u0026#34;Is int** a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int**\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) // 测试 std::string std::cout \u0026lt;\u0026lt; \u0026#34;Is std::string a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) return 0; } 如果需要支持更多类型（如 const 指针、volatile 指针等），可以进一步扩展特化模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 特化模板：针对 const 指针类型 const T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;const T*\u0026gt; { static constexpr bool value = true; }; // 特化模板：针对 volatile 指针类型 volatile T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;volatile T*\u0026gt; { static constexpr bool value = true; }; // 特化模板：针对 const volatile 指针类型 const volatile T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;const volatile T*\u0026gt; { static constexpr bool value = true; }; C++ 标准库中已经提供了类似的类型萃取工具 std::is_pointer，其实现原理与上述代码类似。\n引用类型的移除和增加 引用类型的移除\n应用场景：\n在编写模板函数时，我们可能需要处理传入参数的原始类型，而不关心它是否是引用类型。 在完美转发中，我们需要移除参数的引用类型，以便正确地转发参数。 在实现自定义容器时，我们可能需要确保存储的元素类型是非引用类型。RemoveReference 可以帮助我们移除引用，确保类型安全。 有时需要将某个类型转换为它的非引用版本，例如在某些模板元编程场景中。 可能需要从复杂的类型推导出基础类型，去除所有修饰符（如引用、指针、cv限定符等）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u0026lt;class T1, class T2\u0026gt; void print_is_same() { cout \u0026lt;\u0026lt; \u0026#34;T1类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T1类型和T2类型是否相等：\u0026#34; \u0026lt;\u0026lt; std::is_same\u0026lt;T1, T2\u0026gt;::value \u0026lt;\u0026lt; endl; } int main() { std::remove_reference_t\u0026lt;int\u0026gt; a; std::remove_reference_t\u0026lt;int\u0026amp;\u0026gt; b; std::remove_reference_t\u0026lt;int\u0026amp;\u0026amp;\u0026gt; c; print_is_same\u0026lt;decltype(a), decltype(b)\u0026gt;(); print_is_same\u0026lt;decltype(a), decltype(c)\u0026gt;(); return 0; } 手动实现RemoveReferrce\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //泛化版本 template \u0026lt;typename T\u0026gt; struct RemoveReference { using type = T; }; //特化版本 template \u0026lt;typename T\u0026gt; struct RemoveReference\u0026lt;T\u0026amp;\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct RemoveReference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { using type = T; }; //别名模板 template \u0026lt;typename T\u0026gt; using RemoveReference_t = typename RemoveReference\u0026lt;T\u0026gt;::type; int main() { int\u0026amp;\u0026amp; A = 12; RemoveReference_t\u0026lt;decltype(A)\u0026gt; RemoveA = 125; int B = 64; int\u0026amp; RefB = B; RemoveReference_t\u0026lt;decltype(RefB)\u0026gt; RemoveRefB = 500; cout\u0026lt;\u0026lt;format(\u0026#34;{} {} {} {} {}\u0026#34;,A, RemoveA,B,RefB,RemoveRefB) \u0026lt;\u0026lt; endl; return 0; } 运行结果：\n变量 值 类型 A 12 int \u0026amp;\u0026amp; RemoveA 125 int B 64 int RefB 64 int \u0026amp; RemoveRefB 500 int 引用类型的增加：根据给定的类型来创建一个左值或者右值引用 std::add_lvalue_reference：给进来一个类型，返回该类型对应的左值引用类型 std::add_rvalue_reference：给进来一个类型，返回该类型对应的右值引用类型 std::is_lvalue_reference和std::is_rvalue_reference类模板：判断某个类型是否是左值引用类型或者右值引用类型。\n应用场景：\n确保函数参数是左值引用：使用 std::add_lvalue_reference 确保返回类型是左值引用。 实现移动语义：使用 std::add_rvalue_reference 实现移动构造函数或移动赋值操作符。 完美转发：在模板函数中使用完美转发时，可能需要将类型转换为右值引用以保留其值类别。 模板元编程中的类型转换：与其他类型特征结合使用，根据条件动态地添加或移除引用限定符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { int a = 15; //using std::add_lvalue_reference\u0026lt;int\u0026gt;::type = int\u0026amp; std::add_lvalue_reference\u0026lt;decltype(a)\u0026gt;::type b = a; //b的类型为int \u0026amp; //using std::add_rvalue_reference\u0026lt;int\u0026gt;::type = int\u0026amp;\u0026amp; std::add_rvalue_reference\u0026lt;decltype(a)\u0026gt;::type c = 16; //c的类型为int \u0026amp;\u0026amp; using btype = std::add_lvalue_reference_t\u0026lt;int\u0026gt;; //_t是个别名模板 cout \u0026lt;\u0026lt; std::is_same\u0026lt;int\u0026amp;, btype\u0026gt;() \u0026lt;\u0026lt; endl; //1 using ctype = std::add_rvalue_reference_t\u0026lt;int\u0026gt;; cout \u0026lt;\u0026lt; std::is_lvalue_reference\u0026lt;btype\u0026gt;::value \u0026lt;\u0026lt; endl; //1 cout \u0026lt;\u0026lt; std::is_rvalue_reference\u0026lt;ctype\u0026gt;::value \u0026lt;\u0026lt; endl; //1 //cc1类型为int\u0026amp;，这里涉及到引用折叠，\u0026amp;和\u0026amp;\u0026amp; 折叠后得到 \u0026amp;, 后面专门解释一下 std::add_rvalue_reference_t\u0026lt;int\u0026amp;\u0026gt; cc1 = a; //cc2的类型为int \u0026amp;\u0026amp;，这里涉及到引用折叠，\u0026amp;\u0026amp;和\u0026amp;\u0026amp;折叠得到\u0026amp;\u0026amp;。 std::add_rvalue_reference_t\u0026lt;int\u0026amp;\u0026amp;\u0026gt; cc2 = 16; return 0; } 手动实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T\u0026gt; struct AddLValueReference { using type = T\u0026amp;; //int \u0026amp;\u0026amp; \u0026amp; ，引用折叠：有左值 引用，结果必然为左值 引用，所以type = int \u0026amp; }; template\u0026lt;typename T\u0026gt; using AddLValueReference_t = typename AddLValueReference\u0026lt;T\u0026gt;::type; //实际上可以直接简化为using AddLValueReference_t = T\u0026amp;;，这样就不用定义AddLValueReference了。 template\u0026lt;typename T\u0026gt; struct AddRValueReference { using type = T\u0026amp;\u0026amp;; }; template\u0026lt;typename T\u0026gt; using AddRValueReference_t = typename AddRValueReference\u0026lt;T\u0026gt;::type; //实际上可以直接简化为using AddRValueReference_t = T\u0026amp;\u0026amp;;，这样就不用定义AddRValueReference了。 移除const 去除类型的 const 限定符，返回一个非 const 版本的类型。\n1 2 3 const int x = 10; //using std:remove_const\u0026lt;const int\u0026gt;::type = int std::remove_const\u0026lt;decltype(x)\u0026gt;::type D = 10; 手动实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //泛化版本 template \u0026lt;typename T\u0026gt; struct RemoveConst { using type = T; }; //特化版本 template \u0026lt;typename T\u0026gt; struct RemoveConst\u0026lt;const T\u0026gt; { using type = T; }; //根据需要增加其他特化版本.... template \u0026lt;typename T\u0026gt; using RemoveConst_t = typename RemoveConst\u0026lt;T\u0026gt;::type; std::decay 退化 std::decay 是 C++ 标准库中的一个类型特征（type trait），位于 \u0026lt;type_traits\u0026gt; 头文件中。\n用于将给定的类型转换为适合存储在数组或传递给函数的形式\n移除引用：将 T\u0026amp; 或 T\u0026amp;\u0026amp; 转换为 T。 移除 const 和 volatile 限定符：将 const T 或 volatile T 转换为 T。 数组到指针的转换：将数组类型（如 int[10]）转换为指针类型（如 int*）。 函数到指针的转换：将函数类型（如 int(int)）转换为函数指针类型（如 int(*)(int)）。 示例：打印参数类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template \u0026lt;typename T\u0026gt; void printType(T\u0026amp;\u0026amp; value) { using DecayedType = typename std::decay\u0026lt;T\u0026gt;::type; // 使用 std::decay 转换为值类型 std::cout \u0026lt;\u0026lt; \u0026#34;Decayed type of value: \u0026#34; \u0026lt;\u0026lt; typeid(DecayedType).name() \u0026lt;\u0026lt; std::endl; } int main() { int x = 42; const int\u0026amp; y = x; int\u0026amp;\u0026amp; z = 100; printType(x); // 输出 int printType(y); // 输出 int printType(z); // 输出 int printType(200); // 输出 int return 0; } 输出\n1 2 3 4 Decayed type of value: int Decayed type of value: int Decayed type of value: int Decayed type of value: int 示例：数组和函数的类型转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename T\u0026gt; void printDecayedType() { using DecayedType = typename std::decay\u0026lt;T\u0026gt;::type; // 使用 std::decay 转换为值类型 std::cout \u0026lt;\u0026lt; \u0026#34;Decayed type: \u0026#34; \u0026lt;\u0026lt; typeid(DecayedType).name() \u0026lt;\u0026lt; std::endl; } int main() { // 数组类型 printDecayedType\u0026lt;int[10]\u0026gt;(); // 输出 int* // 函数类型 printDecayedType\u0026lt;int(int)\u0026gt;(); // 输出 int (*)(int) return 0; } 输出 Decayed type: int* Decayed type: int (*)(int) 示例：实现通用的类型比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;typename T1, typename T2\u0026gt; void compareTypes() { using DecayedT1 = typename std::decay\u0026lt;T1\u0026gt;::type; // 使用 std::decay 转换为值类型 using DecayedT2 = typename std::decay\u0026lt;T2\u0026gt;::type; // 使用 std::decay 转换为值类型 if (std::is_same\u0026lt;DecayedT1, DecayedT2\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;Types are the same after decay.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Types are different after decay.\u0026#34; \u0026lt;\u0026lt; std::endl; } } int main() { compareTypes\u0026lt;int, const int\u0026amp;\u0026gt;(); // 输出 Types are the same after decay. compareTypes\u0026lt;int[10], int*\u0026gt;(); // 输出 Types are the same after decay. compareTypes\u0026lt;int(int), int(*)(int)\u0026gt;(); // 输出 Types are the same after decay. return 0; } 输出 Types are the same after decay. Types are the same after decay. Types are the same after decay. 值萃取 给进来一个类型，萃取出一个值.\nIsVoid\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; struct voidvaluetraits { static const bool value = false; }; template \u0026lt;\u0026gt; struct voidvaluetraits\u0026lt;void\u0026gt; { static const bool value = true; }; int main() { cout \u0026lt;\u0026lt; \u0026#34;int是void类型吗？\u0026#34; \u0026lt;\u0026lt; voidvaluetraits\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; \u0026#34;void是void类型吗？\u0026#34; \u0026lt;\u0026lt; voidvaluetraits\u0026lt;void\u0026gt;::value \u0026lt;\u0026lt; endl; //1 return 0; } IsSame\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //泛化版本 template\u0026lt;typename T1, typename T2\u0026gt; struct IsSameType { static const bool value = false; }; //特化版本 template\u0026lt;typename T1\u0026gt; struct IsSameType\u0026lt;T1, T1\u0026gt; { static const bool value = true; }; //变量模板 template\u0026lt;typename T1, typename T2\u0026gt; const bool IsSame_v = IsSameType\u0026lt;T1, T2\u0026gt;::value; int main() { cout \u0026lt;\u0026lt; IsSameType\u0026lt;int, const int\u0026gt;::value \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; IsSameType\u0026lt;int, int\u0026gt;::value \u0026lt;\u0026lt; endl; //1 cout \u0026lt;\u0026lt; IsSame_v\u0026lt;int, const int\u0026gt; \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; IsSame_v\u0026lt;int, int\u0026gt; \u0026lt;\u0026lt; endl; //1 return 0; } 因为std::true_type和std::false_type里面有value，所以也可以这样写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //泛化版本 template\u0026lt;typename T1, typename T2\u0026gt; struct IsSameType : std::false_type {\t}; //特化版本 template\u0026lt;typename T1\u0026gt; struct IsSameType\u0026lt;T1, T1\u0026gt;:std::true_type {\t}; //变量模板 template\u0026lt;typename T1, typename T2\u0026gt; const bool IsSame_v = IsSameType\u0026lt;T1, T2\u0026gt;::value; 元编程 将各种计算从运行期提前至编译期，往往会采用递归手段。\n泛型编程：“通用”，程序员不需要关心具体类型元编程：突出一种程序设计技巧达到常规编程难以达到的效果。前面章节：std::remove_all_extents类模板的实现。\n元函数 数值元函数\n1 2 3 4 5 6 7 8 9 10 11 constexpr int Add(int Value,int Value2) { return Value + Value2; } int main() { constexpr int V = Add(3,2); static_assert(V == 5, \u0026#34;std error\u0026#34;); //静态断言,编译期间断言 return 0; } V = 3+2，确实等于5， 如果把 V==5 改成其它值 断言就会失败.\n编译期计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //计算n的阶乘的泛化版本 template \u0026lt;int N\u0026gt; struct Factorial { static constexpr unsigned int value = N * Factorial\u0026lt;N - 1\u0026gt;::value; }; //计算n的阶乘的特化版本，用于做递归调用的出口 template \u0026lt;\u0026gt; struct Factorial\u0026lt;1\u0026gt; { static constexpr unsigned int value = 1; }; int main() { auto A = Factorial\u0026lt;5\u0026gt;::value; cout\u0026lt;\u0026lt;A\u0026lt;\u0026lt;endl; return 0; } 基本模板： template \u0026lt;unsigned int N\u0026gt; 这个模板类有一个静态成员变量 value，其值是 N * Factorial\u0026lt;N - 1\u0026gt;::value。这表示通过递归调用自身来计算阶乘。 特化模板： template \u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; 这是递归的终止条件。当 N 为0时，阶乘的值应该是1。因此，我们特化了这个模板，并将 value 设置为1。 主函数： 在 main 函数中，我们使用 Factorial\u0026lt;5\u0026gt;::value 来获取5的阶乘，并将其打印出来。 循环求值\n1 2 3 4 5 6 7 8 9 constexpr int Factorial(int n_v) { int result = 1; for (int i = 1; i \u0026lt;= n_v; ++i) { result *= i; } return result; } 类型元函数\nremove_all_extents类模板所实现的元编程就是靠递归模板实例化来驱动的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; struct AddPoint //类型元函数 { using type = T*; }; //using AddPoint\u0026lt;int\u0026gt;::type = int * //a是 int* 类型 AddPoint\u0026lt;int\u0026gt;::type a; 或写为 template \u0026lt;typename T\u0026gt; using AddPoint = T*; //using AddPoint\u0026lt;int\u0026gt; =int * AddPoint\u0026lt;int\u0026gt; a; 混合元编程 混合元编程指的是 结合 编译期元编程 和 运行期编程 的技术。通过这种方式，可以利用编译期计算的优势来优化程序性能，并且在运行时根据具体需求动态地执行某些操作。\n编译期元编程：使用模板、constexpr 等机制在编译期进行计算和类型推导，以生成高效的代码。 运行期编程：在程序运行期间进行的常规计算和逻辑处理。 应用场景：\n优化计算：将一些可以在编译期完成的计算提前完成，减少运行时的开销。 类型安全：利用编译期检查确保类型安全，同时在运行时进行灵活的操作。 生成代码：根据编译期信息生成特定的代码片段或数据结构，提高灵活性和效率。 点积计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //泛化版本 template \u0026lt;typename T, int U\u0026gt;//T：元素类型，U：数组大小 struct DotProduct { static T result(const T* a, const T* b) { return (*a) * (*b) + DotProduct\u0026lt;T, U - 1\u0026gt;::result(a + 1, b + 1); } }; //特化版本，用于做递归调用的出口 template \u0026lt;typename T\u0026gt; struct DotProduct\u0026lt;T, 0\u0026gt; { static T result(const T* a, const T* b) { return T{}; } }; int a[] = { 1,2,3 }; int b[] = { 4,5,6 }; int result = DotProduct\u0026lt;int, 3\u0026gt;::result(a, b); 内存模型 类对象的占用空间 普通函数 1 2 3 4 class A { public: }; sizeof(A) 的结果是 1。 原因是：C++ 标准规定，一个类的实例至少占用 1 个字节，即使它是空的（没有非静态成员变量）。这是为了确保每个实例都有唯一的地址。 1 2 3 4 class A { public: void func() {}; }; void func() 是否占用类的大小？\n不占用。成员函数（包括 void func()）不占用类的实例的大小。 成员函数是类的共享代码，存储在代码段（代码区）中，而不是每个实例中。 函数代码存储在哪里？\n成员函数的代码存储在程序的 代码段（Code Segment） 中。 代码段是内存中的一个区域，用于存储程序的执行代码（包括类的成员函数）。 所有实例共享同一份成员函数的代码。 不同实例调用 func() 时，函数地址是否相同？\n相同。对于 a1.func() 和 a2.func()，调用的函数地址是相同的。 成员函数是类的共享代码，所有实例调用的是同一份代码。 编译器在调用成员函数时，会隐式地传递一个指向当前实例的指针（即 this 指针），以区分不同实例的数据成员。 深入理解\n成员函数的调用机制\n当你调用 a1.func() 时，编译器实际上会将调用转换为类似以下的形式：\n1 func(\u0026amp;a1); // 隐式传递 this 指针 this 指针指向当前实例（a1 或 a2），这样函数可以访问当前实例的成员变量。 函数代码本身是共享的，只有 this 指针不同。 如果类中有成员变量\n如果类中有成员变量，sizeof(A) 就是这些成员变量的总大小（考虑内存对齐）。例如：\n1 2 3 4 5 class A { public: void func() {}; int x; }; sizeof(A) 将是 sizeof(int)，通常是 4（取决于平台）。 总结\nsizeof(A) 是 1，因为空的类至少占用 1 个字节。 成员函数 void func() 不占用类的大小，函数代码存储在代码段中。 不同实例调用 func() 时，函数地址相同，因为成员函数是共享的。 成员函数通过隐式传递 this 指针来区分不同实例的数据成员。 虚函数 1 2 3 4 5 6 7 class A { public: virtual void FuncA() {}; virtual void FuncB() {}; virtual void FuncC() {}; }; sizeof(A) = 8\n虚函数表（vtable） 当一个类包含虚函数时，编译器会为该类生成一个虚函数表（vtable），并且每个对象会有一个指向这个虚函数表的指针 (通常称为虚指针或 vptr), 虚指针通常位于对象的起始位置。每个类有一个唯一的vtable，而不是每个对象都有一个vtable。这个虚指针是存储在对象中的唯一额外数据成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Obj { public: virtual void Parent_MustOverrideFunc1() = 0; virtual void ParentFunc2() {} }; class A : public Obj { public: virtual void Parent_MustOverrideFunc1() override {} virtual void Subfunc1() {} }; 子类没有重写虚函数，虚函数指针 指向父类的虚函数.\n子类重写虚函数，虚函数指针 指向子类的虚函数.\n虚函数表调用私有函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; class A { public: int ca = 3; virtual void FuncA() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncA\u0026#34; \u0026lt;\u0026lt; std::endl; } private: virtual void FuncB() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncB\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void FuncC() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncC\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void FuncD() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncD\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void FuncE(int F) { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncE \u0026#34; \u0026lt;\u0026lt; F \u0026lt;\u0026lt; std::endl; } int cd = 4; }; class B : public A { public: int a = 3; virtual void FuncA() override { std::cout \u0026lt;\u0026lt; \u0026#34;B::FuncA\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 宏定义获取虚函数表指针 #define GET_VTABLE(obj) (*reinterpret_cast\u0026lt;void***\u0026gt;(obj)) int main() { B* a = new B(); // 获取虚函数表指针 void** vtable = GET_VTABLE(a); // 打印虚函数表指针地址 std::cout \u0026lt;\u0026lt; \u0026#34;VTable pointer: \u0026#34; \u0026lt;\u0026lt; vtable \u0026lt;\u0026lt; std::endl; // FuncB using FuncBPtr = void(*)(A*); FuncBPtr funcB = reinterpret_cast\u0026lt;FuncBPtr\u0026gt;(vtable[1]); // FuncE using FuncEPtr = void(*)(A*, int); FuncEPtr funcE = reinterpret_cast\u0026lt;FuncEPtr\u0026gt;(vtable[4]); funcB(a); funcE(a,3); delete a; return 0; } ","date":"1073-01-13T14:39:23+08:00","permalink":"http://localhost:1313/p/%E6%88%90%E4%B8%BA%E5%96%9C%E5%8A%A0%E5%8A%A0%E9%AB%98%E6%89%8B/","title":"成为喜加加高手"}]