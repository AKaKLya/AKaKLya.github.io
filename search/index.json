[{"content":"蘸豆 爽！ 生命值 = 当前生命值 - 即将到来的伤害.\nAttributeSet Class\n1 2 3 UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } } 受击反馈 1 2 3 4 5 6 7 8 9 10 11 12 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); const bool bFatal = NewHealth \u0026lt;= 0.f; //是否为致命伤害？ } } 这是上文的伤害血量计算. 如果不是致命伤害，就播放 受击动画.\n被打也是一种技能. 受到伤害后 触发GA. 被打的GA要在角色生成时 就要GiveAbility. 作为天生技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } } } 受击 → 触发GA → 应用GE，添加Effect.HitReact标签 → 播放受击动画 → 动画结束 → 移除GE添加的标签 → 结束技能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void AAuraEnemy::BeginPlay() { Super::BeginPlay(); InitAbilityActorInfo(); GetCharacterMovement()-\u0026gt;MaxWalkSpeed = BaseWalkSpeed; UAuraAbilitySystemLibrary::GiveStartupAbilities(this,AbilitySystemComponent); if (UAuraUserWidget* AuraUserWidget = Cast\u0026lt;UAuraUserWidget\u0026gt;(HealthBar-\u0026gt;GetUserWidgetObject())) { AuraUserWidget-\u0026gt;SetWidgetController(this); } if (UAuraAttributeSet* AuraAS = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet)) { AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAS-\u0026gt;GetMaxHealthAttribute()).AddLambda( [this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); OnHealthChanged.Broadcast(AuraAS-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAS-\u0026gt;GetMaxHealth()); } } void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 1 2 3 4 5 6 7 8 9 FGameplayTag HitTag = FAuraGameplayTags::Get().Effect_HitReact; AbilitySystemComponent-\u0026gt;RegisterGameplayTagEvent(HitTag,EGameplayTagEventType::NewOrRemoved).AddUObject(this,\u0026amp;ThisClass::HitReactTagChanged); void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount) { bHitReactiong = NewCount \u0026gt; 0 ; GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bHitReactiong ? 0 : BaseWalkSpeed; } 如果Effect_HitReact标签数量大于0，移动速度设置为0，否则就是正常移动速度.\n1 2 3 4 5 6 7 8 9 10 11 12 13 UENUM(BlueprintType) namespace EGameplayTagEventType { /** Rather a tag was added or removed, used in callbacks */ enum Type : int { /** Event only happens when tag is new or completely removed */ NewOrRemoved, /** Event happens any time tag \u0026#34;count\u0026#34; changes */ AnyCountChange }; } 死亡？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 if(Data.EvaluatedData.Attribute == GetIncomingDamageAttribute()) { const float LocalIncomingDamage = GetIncomingDamage(); SetIncomingDamage(0.f); if(LocalIncomingDamage \u0026gt; 0.f) { const float NewHealth = GetHealth() - LocalIncomingDamage; SetHealth(FMath::Clamp(NewHealth, 0.f, GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Damage - Changed Health on %s, Health:%f , Damage:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth(),LocalIncomingDamage); const bool bFatal = NewHealth \u0026lt;= 0.f; //血量小于等于0时，角色将会死亡 if (bFatal) { ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(Props.TargetAvatarActor); if (CombatInterface) { CombatInterface-\u0026gt;Die(); } } else { FGameplayTagContainer TagContainer; TagContainer.AddTag(FAuraGameplayTags::Get().Effect_HitReact); Props.TargetASC-\u0026gt;TryActivateAbilitiesByTag(TagContainer); //根据tag标签激活技能 } // 显示伤害数字 ShowFloatingText(Props,LocalIncomingDamage); } } 血量小于0，就调用Die，怎么写？ 随便.\n加了一个 显示伤害数字 的功能， 调用到了 玩家控制器 的函数 ， 把 伤害值 和 受击Actor 的位置 传过去了\n1 2 3 4 5 6 7 8 9 10 11 void UAuraAttributeSet::ShowFloatingText(const FEffectProperites\u0026amp; Props, float Damage) { if (Props.SourceCharacter != Props.TargetCharacter) { AAuraPlayerController* PC = Cast\u0026lt;AAuraPlayerController\u0026gt;(UGameplayStatics::GetPlayerController(this, 0)); if (PC) { PC-\u0026gt;ShowDamageNumber(Damage,Props.TargetCharacter); } } } 玩家控制器 创建一个 DamageText 组件. 根据 传入的位置 设置组件的位置， 把伤害值 传给组件内部.\n1 2 3 4 5 6 7 8 9 10 11 void AAuraPlayerController::ShowDamageNumber_Implementation(float DamageAmount,ACharacter* TargetCharacter) { if (IsValid(TargetCharacter) \u0026amp;\u0026amp; DamageTextComponentClass) { UDamageTextComponent* DamageText = NewObject\u0026lt;UDamageTextComponent\u0026gt;(TargetCharacter,DamageTextComponentClass); DamageText-\u0026gt;RegisterComponent(); DamageText-\u0026gt;AttachToComponent(TargetCharacter-\u0026gt;GetRootComponent(),FAttachmentTransformRules::KeepRelativeTransform); DamageText-\u0026gt;DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform); DamageText-\u0026gt;SetDamageText(DamageAmount); } } SetDamageText是个蓝图实现的函数\n1 2 3 4 5 6 7 8 9 UCLASS() class AURA_API UDamageTextComponent : public UWidgetComponent { GENERATED_BODY() public: UFUNCTION(BlueprintImplementableEvent,BlueprintCallable) void SetDamageText(float Damage); }; UMG在构造函数里 播放这个K出来的数字动画，完事.\n计算伤害 头晕 不想写\nGameplayEffectContext 谁设置了这些Context？\n1 2 UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); ↓\n1 2 3 4 5 6 7 8 9 10 11 12 FGameplayEffectContextHandle UAbilitySystemComponent::MakeEffectContext() const { FGameplayEffectContextHandle Context = FGameplayEffectContextHandle(UAbilitySystemGlobals::Get().AllocGameplayEffectContext()); // By default use the owner and avatar as the instigator and causer if (ensureMsgf(AbilityActorInfo.IsValid(), TEXT(\u0026#34;Unable to make effect context because AbilityActorInfo is not valid.\u0026#34;))) { Context.AddInstigator(AbilityActorInfo-\u0026gt;OwnerActor.Get(), AbilityActorInfo-\u0026gt;AvatarActor.Get()); } return Context; } ↓\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { if (IsValid()) { Data-\u0026gt;AddInstigator(InInstigator, InEffectCauser); } } void FGameplayEffectContext::AddInstigator(class AActor *InInstigator, class AActor *InEffectCauser) { Instigator = InInstigator; bReplicateInstigator = CanActorReferenceBeReplicated(InInstigator); SetEffectCauser(InEffectCauser); InstigatorAbilitySystemComponent = NULL; // Cache off the AbilitySystemComponent. InstigatorAbilitySystemComponent = UAbilitySystemGlobals::GetAbilitySystemComponentFromActor(Instigator.Get()); } MakeEffectContext最终调用到了AddInstigator，设置Instigator、EffectCauser、InstigatorASC\n以及 MakeEffectContext 调用的构造函数，初始化了一些变量.\n1 2 3 4 5 6 7 8 9 FGameplayEffectContext() : AbilityLevel(1) , WorldOrigin(ForceInitToZero) , bHasWorldOrigin(false) , bReplicateSourceObject(false) , bReplicateInstigator(false) , bReplicateEffectCauser(false) { } 其它属性还没有设置，剩下的属性应该怎么用？\n以火球技能为例，void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); Context.SetAbility(this); Context.AddSourceObject(Projectile); FHitResult HitResult; HitResult.Location = TargetLocation; Context.AddHitResult(HitResult); TArray\u0026lt;TWeakObjectPtr\u0026lt;AActor\u0026gt;\u0026gt; Actors; Actors.Add(Projectile); Context.AddActors(Actors); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); Custom 扩展Context\n","date":"2025-01-16T17:07:49+08:00","permalink":"https://akaklya.github.io/p/gas-a-%E6%88%98%E6%96%97/","title":"GAS A - 战斗"},{"content":"TODO:属性菜单 没写，太他妈长了，以后再填.\nUI获取GE的GameplayTag消息 应用GE时，获得GE的AssetTag，并且根据这个Tag 做点事情，\n例如：捡到血瓶时，如果GE里面有 Message.xx.xx 的Tag，就通知UI显示“捡到一个血瓶” 之类的文字.\n整体框架:\nOverlayWidgetController.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void UAuraAbilitySystemComponent::AbilityInfoSet() { OnGameplayEffectAppliedDelegateToSelf.AddUObject(this,\u0026amp;UAuraAbilitySystemComponent::ClientEffectApplied); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;EffectAssetTags.AddLambda( [this](const FGameplayTagContainer\u0026amp; AssetTags) { for (const FGameplayTag\u0026amp; Tag : AssetTags) { auto MessageTag = FGameplayTag::RequestGameplayTag(FName(\u0026#34;Message\u0026#34;)); if (Tag.MatchesTag(MessageTag)) { FUIWidgetRow* Row = GetDataTableRowByTag\u0026lt;FUIWidgetRow\u0026gt;(MessageWidgetDataTable,Tag); MessageWidgetRowDelegate.Broadcast(*Row); } } } ); } WidgetController绑定ASC的生命值等属性变化后，再追加一个委托的订阅，ASC在GE应用时 能获得GE的AssetTag，这里只筛选Message的Tag，把它广播出来，WidgetController就能收到ASC应用的GE的标签.\n1 2 3 4 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Messages\u0026#34;) FMessageWidgetRowSignature MessageWidgetRowDelegate; WidgetController里面再来一个委托，让UMG在蓝图里面订阅，把接收到的GE标签广播出去，让UMG订阅接收.\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 USTRUCT() struct FUIWidgetRow : public FTableRowBase { GENERATED_BODY() UPROPERTY(EditAnywhere,BlueprintReadOnly) FGameplayTag AssetTag = FGameplayTag(); UPROPERTY(EditAnywhere,BlueprintReadOnly) FText Message = FText(); UPROPERTY(EditAnywhere,BlueprintReadOnly) TSubclassOf\u0026lt;class UAuraUserWidget\u0026gt; MessageWidget; UPROPERTY(EditAnywhere,BlueprintReadOnly) UTexture2D* Image = nullptr; }; //-------------------------------------// template\u0026lt;typename T\u0026gt; T* GetDataTableRowByTag(UDataTable* DataTable,const FGameplayTag\u0026amp; Tag); template \u0026lt;typename T\u0026gt; T* UOverlayWidgetController::GetDataTableRowByTag(UDataTable* DataTable, const FGameplayTag\u0026amp; Tag) { return DataTable-\u0026gt;FindRow\u0026lt;T\u0026gt;(Tag.GetTagName(),TEXT(\u0026#34;\u0026#34;)); } //---------------------------------------// 查表，通过Tag获得Message，并广播给蓝图\nMMC 根据等级设置血量\n角色基类AAuraCharacterBase添加一个ICombatInterface接口，Enemy和AAuraCharacter都重写一下GetPlayerLeve函数.Enemy的Level就在Enemy类里面，玩家的Level在PlayerState里面，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 UINTERFACE(MinimalAPI,BlueprintType) class UCombatInterface : public UInterface { GENERATED_BODY() }; /** * */ class AURA_API ICombatInterface { GENERATED_BODY() // Add interface functions to this class. This is the class that will be inherited to implement this interface. public: virtual int32 GetPlayerLeve(); }; //---------------------------// class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface,public ICombatInterface //--------------------------// 1 2 3 4 5 6 7 8 9 10 11 12 int32 AAuraEnemy::GetPlayerLeve() { return Level; } int32 AAuraCharacter::GetPlayerLeve() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState) return AuraPlayerState-\u0026gt;GetPlayerLeve(); } MMC 自定义计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 UCLASS() class AURA_API UMMC_MaxHealth : public UGameplayModMagnitudeCalculation { GENERATED_BODY() public: UMMC_MaxHealth(); virtual float CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const override; private: FGameplayEffectAttributeCaptureDefinition VigorDef; }; UMMC_MaxHealth::UMMC_MaxHealth() { VigorDef.AttributeToCapture = UAuraAttributeSet::GetVigorAttribute(); VigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target; VigorDef.bSnapshot = false; RelevantAttributesToCapture.Add(VigorDef); } float UMMC_MaxHealth::CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec\u0026amp; Spec) const { const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags(); const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags(); FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = SourceTags; EvaluateParameters.TargetTags = TargetTags; float Vigor = 0 ; GetCapturedAttributeMagnitude(VigorDef,Spec,EvaluateParameters,Vigor); Vigor = FMath::Max\u0026lt;float\u0026gt;(Vigor,0.0f); ICombatInterface* Interface = Cast\u0026lt;ICombatInterface\u0026gt;(Spec.GetContext().GetSourceObject()); const int32 PlayerLevel = Interface-\u0026gt;GetPlayerLeve(); return 80 + 2.5 * Vigor + 10.0 * PlayerLevel; } GameplayAbility 1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA里的StartupInputTag是用来绑定输入的，参见后文的 “绑定EnhancedInput“\nASC类里的AddCharacterAbility函数，根据角色类传过来的技能Array赋予技能从StartupAbility里面创建FGameplayAbilitySpec，并且用StartupInputTag作为动态Tag，传入Spec.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 1 2 3 4 5 6 7 /*GameplayAbilitySpec* * An activatable ability spec, hosted on the ability system component. This defines both what the ability is (what class, what level, input binding etc) * and also holds runtime state that must be kept outside of the ability being instanced/activated. */ * 可激活的能力规范，托管在能力系统组件上。这既定义了能力是什么（什么类别、什么级别、输入绑定等） * 也保存了必须保留在实例化/激活的能力之外的运行时状态。 角色基类里用一个TArray保存初始技能，基类AddCharacterAbility函数赋予技能.在玩家类的PossessedBy函数里调用AddCharacterAbility.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 UPROPERTY(EditAnywhere,Category=\u0026#34;Ability\u0026#34;) TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt; StartupAbility; void AAuraCharacterBase::AddCharacterAbility() { UAuraAbilitySystemComponent* AuraASC = CastChecked\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent); if (!HasAuthority()) return; AuraASC-\u0026gt;AddCharacterAbility(StartupAbility); } void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); AddCharacterAbility(); } GATag Activation Owned Tags 当技能激活时，将设置的Tag应用给技能所有者，在结束时删除。如果将AbilitySystemGlobals里面的配置ReplicateActivationOwnedTags开启，Tag还将会被复制。 Activation Required Tags 当技能激活者拥有设置的所有的Tag时，此技能才能够被激活。 Activation Blocked Tags 当技能激活者有一项设置的Tag，技能就无法被激活 Source Required Tags 当技能所有者拥有设置的所有的Tag时，此技能才能够被激活 Source Blocked Tags 当技能所有者有一项设置的Tag，技能就无法被激活 Target Required Tags 当技能目标者拥有设置的所有的Tag时，此技能才能够被激活 Target Blocked Tags 当技能目标者有一项设置的Tag，技能就无法被激活 绑定EnhancedInput 增强输入\n绑定GameplayTag和InputAction 这是一个用来关联 GameplayTag 和 InputAction的资产 UAuraInputConfig\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 USTRUCT(BlueprintType) struct FAuraInputAction { GENERATED_BODY() UPROPERTY(EditDefaultsOnly) class UInputAction* InputAction = nullptr; UPROPERTY(EditDefaultsOnly) FGameplayTag InputTag = FGameplayTag(); }; UCLASS() class AURA_API UAuraInputConfig : public UDataAsset { GENERATED_BODY() public: const UInputAction* FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag,bool bLogNotFound = false); UPROPERTY(EditDefaultsOnly,BlueprintReadOnly) TArray\u0026lt;FAuraInputAction\u0026gt; AbilityInputActions; }; //------------------------------------// const UInputAction* UAuraInputConfig::FindAbilityInputActionForTag(const FGameplayTag\u0026amp; InputTag, bool bLogNotFound) { for (const auto\u0026amp; Action : AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag == InputTag) { return Action.InputAction; } } if (bLogNotFound) { UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Can Not Found AbilityInputAction for InputTag [%s] on InputConfig [%s]\u0026#34;), *InputTag.ToString(),*GetNameSafe(this)); } return nullptr; } 创建增强输入组件，继承自UEnhancedInputComponent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 UCLASS() class AURA_API UAuraInputComponent : public UEnhancedInputComponent { GENERATED_BODY() public: template\u0026lt;class UserClass,typename PressedFuncType,typename ReleasedFuncType,typename HeldFuncType\u0026gt; void BindAbilityActions(const UAuraInputConfig* InputConfig,UserClass* Object, PressedFuncType PressedFunc,ReleasedFuncType ReleasedFunc,HeldFuncType HeldFunc); }; template \u0026lt;class UserClass, typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\u0026gt; void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) { check(InputConfig); for (const auto\u0026amp; Action : InputConfig-\u0026gt;AbilityInputActions) { if (Action.InputAction \u0026amp;\u0026amp; Action.InputTag.IsValid()) { if (PressedFunc) { BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); } if (ReleasedFunc) { BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); } if (HeldFunc) { BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); } } } } typename PressedFuncType, typename ReleasedFuncType, typename HeldFuncType\n这3个参数 传入函数时，编译器会自动推导其类型可以把 \u0026amp;AAuraPlayerController::AbilityInputTagPressed 这样的参数传入进去.\n在玩家控制器里调用这个BindAbilityActions函数， 来绑定GameplayTag和InputAction.\n准备3个输入函数，分别是 Pressed、Released、Held 状态下的输入， 按下、释放、按住.\n并且这3个函数可以接收传来的FGameplayTag InputTag，因为上面的增强输入在绑定时，就可以把参数传到函数里.\n1 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction的最后两个参数 - PressedFunc函数被调用时，会把Action.InputTag传给这个函数. 所以可以使用AbilityInputTagPressed(FGameplayTag InputTag) 这样的函数 去接收传来的InputTag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { } 使用准备好的UAuraInputConfig资产 绑定输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //AuraPlayerController.h\tUPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) TObjectPtr\u0026lt;UAuraInputConfig\u0026gt; InputConfig; void AAuraPlayerController::SetupInputComponent() { Super::SetupInputComponent(); UAuraInputComponent* AuraInputComponent = CastChecked\u0026lt;UAuraInputComponent\u0026gt;(InputComponent); AuraInputComponent-\u0026gt;BindAction(MoveAction,ETriggerEvent::Triggered,this,\u0026amp;AAuraPlayerController::Move); AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); } 注意执行输入的参数顺序Press,Released,Held\n1 2 3 4 5 void UAuraInputComponent::BindAbilityActions(const UAuraInputConfig* InputConfig, UserClass* Object, PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc) AuraInputComponent-\u0026gt;BindAbilityActions(InputConfig,this, \u0026amp;ThisClass::AbilityInputTagPressed,\u0026amp;ThisClass::AbilityInputTagReleased,\u0026amp;ThisClass::AbilityInputTagHeld); 现在就把 GameplayTag 和 玩家控制器 里面的函数绑定上了，\n总结 回顾整个流程，\n1.首先创建了一个资产UAuraInputConfig，这个资产定义了 GameplayTag 和 InputAction 绑定关系，2.在 玩家控制器 里面，指定了UAuraInputConfig，再调用 增强输入 的函数，使用这个资产进行 GameplayTag和InputAction的绑定.3.增强输入 利用InputAction绑定一个要执行的函数，按下按键时 执行哪一个函数.4.绑定完了函数 还不够， 按下按键时执行函数 并且函数还要接收到对应的那个 GameplayTag.\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Completed,Object,ReleasedFunc,Action.InputTag); BindAction(Action.InputAction,ETriggerEvent::Triggered,Object,HeldFunc,Action.InputTag); 第4个条件 就是用这个BindAction绑定起来的，当按下按键时、松开按键时、持续按住按键时、都会把 Action.InputTag 传给对应的 响应函数.\n这样就实现了 按下按键时，还能获得对应按键的GameplayTag.\n1 2 3 4 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { GEngine-\u0026gt;AddOnScreenDebugMessage(1,3.f,FColor::Red,*InputTag.ToString); } 这个函数就能接收到 GameplayTag 的值.\n1 2 3 4 5 6 7 8 template\u0026lt;class UserClass, typename... VarTypes\u0026gt;\t\\ FEnhancedInputActionEventBinding\u0026amp; BindAction(const UInputAction* Action, ETriggerEvent TriggerEvent, UserClass* Object, typename HANDLER_SIG::template TMethodPtr\u0026lt; UserClass, VarTypes... \u0026gt; Func, VarTypes... Vars) \\ {\t\\ TUniquePtr\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt; AB = MakeUnique\u0026lt;FEnhancedInputActionEventDelegateBinding\u0026lt;HANDLER_SIG\u0026gt;\u0026gt;(Action, TriggerEvent);\t\\ AB-\u0026gt;Delegate.BindDelegate\u0026lt;UserClass\u0026gt;(Object, Func, Vars...);\t\\ AB-\u0026gt;Delegate.SetShouldFireWithEditorScriptGuard(bShouldFireDelegatesInEditor);\t\\ return *EnhancedActionEventBindings.Add_GetRef(MoveTemp(AB));\t\\ } 这是增强输入里使用的变参模板，应该是可以让按下按键时 触发的那个响应函数 接收任意数量的参数. 随便接.例如:\n1 2 3 BindAction(Action.InputAction,ETriggerEvent::Started,Object,PressedFunc, Action.InputTag,floatA,floatB,floatC,floatD); void Pressed(FGameplayTag InputTag,float a,float b,float c,float d); 激活技能 前面的 GameplayAbility 片段，在GA里面定义了一个变量StartupInputTag\n1 2 UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; 并且在ASC里面GiveAbility时，把这个StartupInputTag传给 GameplayAbilitySpec 作为动态Tag.\n1 2 3 4 5 6 7 8 9 10 11 12 void UAuraAbilitySystemComponent::AddCharacterAbility(const TArray\u0026lt;TSubclassOf\u0026lt;UGameplayAbility\u0026gt;\u0026gt;\u0026amp; StartupAbility) { for (auto AbilityClass : StartupAbility) { FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(AbilityClass, 1.0f); if (auto AuraAbility = Cast\u0026lt;UAuraGameplayAbility\u0026gt;(AbilitySpec.Ability)) { AbilitySpec.GetDynamicSpecSourceTags().AddTag(AuraAbility-\u0026gt;StartupInputTag); GiveAbility(AbilitySpec); } } } 现在 就使用这个Tag条件 作为 按键输入 和 激活技能 之间的桥梁.\n在ASC里创建下面两个函数，接收一个GameplayTag，按下按键时 就调用这两个函数，激活技能.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void UAuraAbilitySystemComponent::AbilityInputHeld(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputPressed(AbilitySpec); if (!AbilitySpec.IsActive()) { TryActivateAbility(AbilitySpec.Handle); } } } } void UAuraAbilitySystemComponent::AbilityInputReleased(const FGameplayTag\u0026amp; InputTag) { if (!InputTag.IsValid()) return; TArray\u0026lt;FGameplayAbilitySpec\u0026gt; Abilities = GetActivatableAbilities(); for (auto\u0026amp; AbilitySpec : Abilities) { if (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag)) { AbilitySpecInputReleased(AbilitySpec); } } } 玩家控制器 绑定了GameplayTag 和 按键响应的函数， 在按键响应的函数里能够接收到 那个按键对应的GameplayTag， 现在要做的是: 这个接收到的 GameplayTag 只要和某个 GA 的GameplayTag 匹配成功，就激活那个GA.\n按键响应的函数 在玩家控制器里，激活技能需要角色身上的ASC，AbilitySystemComponent玩家控制器 能够获得角色，从角色身上获得ASC， 好了 这就是思路.\n玩家控制器里面用一个指针存放 ASC，如果ASC有效 就使用存储的ASC，如果无效 则重新获得角色以及ASC.\n1 2 UPROPERTY() TObjectPtr\u0026lt;UAuraAbilitySystemComponent\u0026gt; AuraAbilitySystemComponent; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag) { } void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputReleased(InputTag); } void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag) { if (GetASC() == nullptr) return ; GetASC()-\u0026gt;AbilityInputHeld(InputTag); } UAuraAbilitySystemComponent* AAuraPlayerController::GetASC() { if (AuraAbilitySystemComponent == nullptr) { AuraAbilitySystemComponent =Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetPawn\u0026lt;APawn\u0026gt;())); } return AuraAbilitySystemComponent; } 投射物 从人物手上发射一个火球，撞到敌人造成伤害\n前面在 GameplayAbility 这一片段创建了自定义的GA，\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; 一个GA，一个火球Actor.GA播放角色发射火球的动作蒙太奇，GA等待GameplayEvent， 当Event触发时 才发射火球，动画蒙太奇在执行到指定帧时，通过动画通知触发Event，让GA发射火球GA在生成火球Actor时，把GE传给Actor，Actor撞到敌人，对敌人应用GE 造成伤害，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void UAuraProjectileSpell::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) { Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData); } void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) { AActor* AvartarActor = GetAvatarActorFromActorInfo(); bool bIsServer = AvartarActor-\u0026gt;HasAuthority(); if (!bIsServer) return; ICombatInterface* CombatInterface = Cast\u0026lt;ICombatInterface\u0026gt;(AvartarActor); if (CombatInterface) { const FVector SockLocation = CombatInterface-\u0026gt;GetCombatSocketLocation(); FRotator Rotation = (TargetLocation - SockLocation).Rotation(); Rotation.Pitch = 0 ; AActor* OwningActor = GetOwningActorFromActorInfo(); FTransform SpawnTransform; SpawnTransform.SetLocation(SockLocation); SpawnTransform.SetRotation(Rotation.Quaternion()); AAuraProjectile* Projectile = GetWorld()-\u0026gt;SpawnActorDeferred\u0026lt;AAuraProjectile\u0026gt;( ProjectileClass, SpawnTransform, OwningActor, Cast\u0026lt;APawn\u0026gt;(OwningActor), ESpawnActorCollisionHandlingMethod::AlwaysSpawn); UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo()); FGameplayEffectContextHandle Context = SourceASC-\u0026gt;MakeEffectContext(); FGameplayEffectSpecHandle SpeceHandle = SourceASC-\u0026gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(), Context); FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get(); const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel()); UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpeceHandle,GameplayTags.Damage,ScaledDamage); Projectile-\u0026gt;DamaeEffectSpecHandle = SpeceHandle; Projectile-\u0026gt;FinishSpawning(SpawnTransform); } } SetByCaller - AssignTagSetByCallerMagnitude\nSetByCaller，在GA里设置伤害，GE里配置Tag，GA通过Tag把数值传给GE.\n1 2 3 4 5 6 7 8 9 10 11 12 UCLASS() class AURA_API UAuraGameplayAbility : public UGameplayAbility { GENERATED_BODY() public: UPROPERTY(EditDefaultsOnly,Category=\u0026#34;Input\u0026#34;) FGameplayTag StartupInputTag; UPROPERTY(EditDefaultsOnly,BlueprintReadOnly,Category=\u0026#34;Damage\u0026#34;) FScalableFloat Damage; }; GA能获得AvatarActor，这就是角色，但不直接Cast到玩家角色，而是使用一个接口去做，没有硬绑定为某个具体角色类.接口的GetCombatSocketLocation函数，只是一个获取骨骼插槽位置的，返回一个Vector. 有起始位置和目标位置 就能设置火球Actor的朝向，让火球对准过去.\n1 void UAuraProjectileSpell::SpawnProjectile(const FVector\u0026amp; TargetLocation) TargetLocation是在蓝图里设置的\n1 2 3 4 5 FVector AAuraCharacterBase::GetCombatSocketLocation() { check(Weapon); return Weapon-\u0026gt;GetSocketLocation(WeaponTipSocketName); } AuraProjectile.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 UCLASS() class AURA_API AAuraProjectile : public AActor { GENERATED_BODY() public:\tAAuraProjectile(); UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;UProjectileMovementComponent\u0026gt; ProjectileMovement; UPROPERTY(BlueprintReadWrite,meta = (ExposeOnSpawn = true)) FGameplayEffectSpecHandle DamaeEffectSpecHandle; protected: virtual void BeginPlay() override; UFUNCTION() void OnSphereOverlap( UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult \u0026amp; SweepResult); private: UPROPERTY(EditAnywhere) float LifeSpan = 10; UPROPERTY(VisibleAnywhere) TObjectPtr\u0026lt;USphereComponent\u0026gt; Sphere; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UNiagaraSystem\u0026gt; ImpactEffect; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; ImpactSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;USoundBase\u0026gt; LoopingSound; UPROPERTY(EditAnywhere) TObjectPtr\u0026lt;UAudioComponent\u0026gt; LoopingSoundComponent; }; AuraProjectile.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 AAuraProjectile::AAuraProjectile() { PrimaryActorTick.bCanEverTick = false; bReplicates =true; Sphere = CreateDefaultSubobject\u0026lt;USphereComponent\u0026gt;(\u0026#34;Sphere\u0026#34;); SetRootComponent(Sphere); Sphere-\u0026gt;SetCollisionObjectType(ECC_Projectile); Sphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); Sphere-\u0026gt;SetCollisionResponseToAllChannels(ECR_Ignore); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldDynamic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_WorldStatic,ECR_Overlap); Sphere-\u0026gt;SetCollisionResponseToChannel(ECC_Pawn,ECR_Overlap); ProjectileMovement = CreateDefaultSubobject\u0026lt;UProjectileMovementComponent\u0026gt;(\u0026#34;ProjectileMovement\u0026#34;); ProjectileMovement-\u0026gt;InitialSpeed = 550; ProjectileMovement-\u0026gt;MaxSpeed = 550; ProjectileMovement-\u0026gt;ProjectileGravityScale = 0; } void AAuraProjectile::BeginPlay() { Super::BeginPlay(); SetLifeSpan(LifeSpan); Sphere-\u0026gt;OnComponentBeginOverlap.AddDynamic(this,\u0026amp;ThisClass::OnSphereOverlap); LoopingSoundComponent = UGameplayStatics::SpawnSoundAttached(LoopingSound,GetRootComponent()); } void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult\u0026amp; SweepResult) { UGameplayStatics::PlaySoundAtLocation(this,ImpactSound,GetActorLocation()); UNiagaraFunctionLibrary::SpawnSystemAtLocation(this,ImpactEffect,GetActorLocation()); LoopingSoundComponent-\u0026gt;Stop(); if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor)) { TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*DamaeEffectSpecHandle.Data.Get()); } Destroy(); } AbilityTask 技能任务（C++类\u0026quot;UAbilityTask\u0026quot;）是更常规的技能任务类的特殊形式，旨在使用游戏性技能。使用游戏性技能系统的游戏通常包括各种自定义技能任务，这些任务实施其独特的游戏功能。它们在游戏性技能执行过程中执行异步工作，并且能够通过调用委托（Delegate） （在本地C++代码中）或移经一个或多个输出执行引脚（在蓝图中）来影响执行流。这使技能能够跨多个帧执行，并可在同一帧内执行多个不同的函数。大部分技能任务都有一个即时触发的执行引脚，使蓝图能够在任务开始后继续执行。此外，通常还有一些特定于任务的引脚，它们会在延迟后或在可能发生或不发生的某个事件之后触发。\n技能任务可以通过调用\u0026quot;EndTask\u0026quot;函数自行终止，或者等待运行它的游戏性技能结束，此时它会自动终止。这可以防止幻影技能任务运行，有效地泄漏CPU周期和内存。例如，某个技能任务可能播放一个施法动画，而另一个任务则在玩家的瞄准点处放置一个靶向标线。如果玩家点击确认输入来施放该法术，或者等待动画结束而未确认该法术，游戏性技能就会结束。虽然它们可以在任何时候自动终止，但是技能任务保证最晚在主要技能结束时终止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMouseTargetDataSignature,const FVector\u0026amp;,Data); UCLASS() class AURA_API UTargetDataUnderMouse : public UAbilityTask { GENERATED_BODY() public: UFUNCTION(BlueprintCallable,Category=\u0026#34;Ability|Tasks\u0026#34;,meta = (DisplayName = \u0026#34;TargetDataUnderMouse\u0026#34;,HidePin=\u0026#34;OwningAbility\u0026#34;,DefaultToSelf = \u0026#34;OwningAbility\u0026#34;,BlueprintInternalUseOnly)) static UTargetDataUnderMouse* CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility); UPROPERTY(BlueprintAssignable) FMouseTargetDataSignature ValidData; private: virtual void Activate() override; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 UTargetDataUnderMouse* UTargetDataUnderMouse::CreateTargetDataUnderMouse(UGameplayAbility* OwningAbility) { UTargetDataUnderMouse* Myobj = NewAbilityTask\u0026lt;UTargetDataUnderMouse\u0026gt;(OwningAbility); return Myobj; } void UTargetDataUnderMouse::Activate() { APlayerController* PC = Ability-\u0026gt;GetCurrentActorInfo()-\u0026gt;PlayerController.Get(); FHitResult HitResult; PC-\u0026gt;GetHitResultUnderCursor(ECC_Visibility,false,HitResult); ValidData.Broadcast(HitResult.Location); } 蓝图调用UTargetDataUnderMouse的static函数 创建UTargetDataUnderMouse，创建之后调用Activate函数.\nBlueprintAssignable\n写在AbilityTask.h里的说明: 点击查看大图UnrealEngine/Engine/Plugins/Runtime/GameplayAbilities/Source/GameplayAbilities/Public/Abilities/Tasks\nGithub上的AbilityTask.h\nGameplayEvent 等待指定的游戏标记事件触发。默认情况下，这将查看此功能的所有者。可以设置 OptionalExternalTarget 以使其查看另一个参与者的标记以进行更改 只要 OnlyTriggerOnce = false，它就会继续监听 如果 OnlyMatchExact = false，它将触发嵌套标记 WaitGameplayEvent与ASC有关. 或许 ASC就是连接Send和Wait之间的桥梁. 所以在动画通知里要GetOwnerActor 给Owner发Event.\nSendGameplayEventToActor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload) { if (::IsValid(Actor)) { UAbilitySystemComponent* AbilitySystemComponent = GetAbilitySystemComponent(Actor); if (AbilitySystemComponent != nullptr \u0026amp;\u0026amp; IsValidChecked(AbilitySystemComponent)) { using namespace UE::AbilitySystem::Private; if (EnumHasAnyFlags(static_cast\u0026lt;EAllowPredictiveGEFlags\u0026gt;(CVarAllowPredictiveGEFlagsValue), EAllowPredictiveGEFlags::AllowGameplayEventToApplyGE)) { FScopedPredictionWindow NewScopedWindow(AbilitySystemComponent, true); AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } else { AbilitySystemComponent-\u0026gt;HandleGameplayEvent(EventTag, \u0026amp;Payload); } } else { ABILITY_LOG(Error, TEXT(\u0026#34;UAbilitySystemBlueprintLibrary::SendGameplayEventToActor: Invalid ability system component retrieved from Actor %s. EventTag was %s\u0026#34;), *Actor-\u0026gt;GetName(), *EventTag.ToString()); } } } 在HandleGameplayEvent里面 引用到一个AbilitySystemComponent里面的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int32 UAbilitySystemComponent::HandleGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload) { int32 TriggeredCount = 0; FGameplayTag CurrentTag = EventTag; ABILITYLIST_SCOPE_LOCK(); // 省略 if (FGameplayEventMulticastDelegate* Delegate = GenericGameplayEventCallbacks.Find(EventTag)) { // Make a copy before broadcasting to prevent memory stomping FGameplayEventMulticastDelegate DelegateCopy = *Delegate; DelegateCopy.Broadcast(Payload); } // 省略 return TriggeredCount; } AbilityTask_WaitGameplayEvent\n这里面就用到了上面提到的变量 GenericGameplayEventCallbacks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void UAbilityTask_WaitGameplayEvent::Activate() { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC) { if (OnlyMatchExact) { MyHandle = ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).AddUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventCallback); } else { MyHandle = ASC-\u0026gt;AddGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), FGameplayEventTagMulticastDelegate::FDelegate::CreateUObject(this, \u0026amp;UAbilityTask_WaitGameplayEvent::GameplayEventContainerCallback)); }\t} Super::Activate(); } void UAbilityTask_WaitGameplayEvent::OnDestroy(bool AbilityEnding) { UAbilitySystemComponent* ASC = GetTargetASC(); if (ASC \u0026amp;\u0026amp; MyHandle.IsValid()) { if (OnlyMatchExact) { ASC-\u0026gt;GenericGameplayEventCallbacks.FindOrAdd(Tag).Remove(MyHandle); } else { ASC-\u0026gt;RemoveGameplayEventTagContainerDelegate(FGameplayTagContainer(Tag), MyHandle); } } Super::OnDestroy(AbilityEnding); } 大胆猜想，GamepalyEvent就是ASC运作的WaitGameplayEvent 把要监听的GameplayTag发给ASC，当SendGameplayEvent给ASC发送Tag时，如果监听的和接收到的Tag一样，ASC就会激活触发GameplayTagEvent，\n使用数据表初始化敌人属性 不想写了，看别人写的吧\n","date":"2025-01-11T12:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-gega%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/","title":"GAS A - GE、GA、输入绑定"},{"content":"官方文档\nGit文档\nGameplayEffect 函数名称 用途 PreAttributeChange / PreAttributeBaseChange 这些函数在即将修改属性之前调用。函数旨在实施关于属性值的规则，例如，\u0026ldquo;生命值必须介于0和最大生命值\u0026quot;之间，并且不得对属性更改触发游戏内响应。 PreGameplayEffectExecute 在即将修改属性值之前，此函数可以拒绝或更改拟定修改。 PostGameplayEffectExecute 在修改属性值后，此函数可立即对更改做出响应。这通常包括限制属性的最终值或触发对新值的游戏内响应，例如当\u0026quot;生命值\u0026quot;属性降至零时死亡。 Gameplay效果组件 说明 UChanceToApplyGameplayEffectComponent 应用Gameplay效果的概率。 UBlockAbilityTagsGameplayEffectComponent 根据所有者Gameplay效果目标Actor的Gameplay标签，进行Gameplay技能激活阻止处理。 UAssetTagsGameplayEffectComponent Gameplay效果资产拥有的标签。这些标签 不会 转移到Actor。 UAdditionalEffectsGameplayEffectComponent 添加尝试在特定条件下激活（或任何条件下都不激活）的其他Gameplay效果。 UTargetTagsGameplayEffectComponent 将标签授予Gameplay效果的目标（有时指所有者）。 UTargetTagRequirementsGameplayEffectComponent 指定如果此GE须应用或继续执行，目标（Gameplay效果的拥有者）必须具备的标签要求。 URemoveOtherGameplayEffectComponent 基于某些条件移除其他Gameplay效果。 UCustomCanApplyGameplayEffectComponent 处理CustomApplicationRequirement函数的配置，以查看是否应该应用此Gameplay效果。 UImmunityGameplayEffectComponent 免疫会阻止其他GameplayEffectSpecs的应用。 新版本的GE效果组件\nAbilities Gameplay Effect component 这个组件主要是在GameplayEffect激活时，可以向目标添加的GameplayAbility\nAddtional Effects Gameplay Effect Component 当此效果添加时或完成时，需要额外添加的效果。 On Appliaciton Gameplay Effects 在添加此效果时，额外添加的效果 On Complete Always 当此效果完成时，不管正常结束还是不正常结束时，添加的效果 On Complete Normal 当此效果正常结束时，添加的额外的效果 On Complete Prematurely 当此效果提前结束时，添加的额外的效果\nGameplay效果组件 说明 Asset Tags Gameplay Effect Component 在添加此GE时，需要额外处理的标签（添加 和 删除），这个标签将放置在GE上面，只是作为一个GE的标记 Block Ability Tags Gameplay Component 添加或删除能够阻挡技能的Tags的组件，这些Tags会在GE运行时添加到Actor身上，用于阻挡其它拥有此Tag的GE或者GA的激活。 Chance to Apply Gameplay Effect Component 当前GE应用到Actor身上的几率，0为百分之0几率，1为百分之百几率 Custom Can Apply Gameplay Effect Component 自定义能够应用GE的组件，可以自定义条件来设置应用是否成功。 Immunity Gameplay Effect Component 配置角色免疫其它GE的条件 Remove Other Gameplay Effect Component 配置移除其它的GE，满足设置的标签或者资源满足条件的GE都会被移除掉。 Target Tag Requirements Gameplay Effect Component 根据目标的Tag设置当前的GE的状态Appliaction 为GE添加到目标身上时Tag的状态Ongoing 为GE激活时Tag的状态Removal 为GE被删除时Tag的状态 Target Tags Gameplay Effect Component 添加此GE后，对Actor身上带有的Tag进行操作（添加或删除），这个会随着GE的添加修改，在GE失效时移除。非Instant使用。 GameplayEffectSpec GameplayEffectSpec(GESpec)可以看作是GameplayEffect的实例, 它保存了一个其所代表的GameplayEffect类引用, 创建时的等级和创建者, 它在应用之前可以在运行时(Runtime)自由的创建和修改, 不像GameplayEffect应该由设计师在运行前创建. 当应用GameplayEffect时, GameplayEffectSpec会自GameplayEffect创建并且会实际应用到目标(Target).\nGameplayEffectSpec是由UAbilitySystemComponent::MakeOutgoingSpec()(BlueprintCallable)自GameplayEffect创建的. GameplayEffectSpec不必立即应用. 通常是将GameplayEffectSpec传递给创建自Ability的投掷物, 该投掷物可以应用到它之后击中的目标. 当GameplayEffectSpec成功应用后, 就会返回一个名为FActiveGameplayEffect的新结构体.\nGameplayEffectSpec的重要内容:\n创建该GameplayEffectSpec的GameplayEffect类. 该GameplayEffectSpec的等级. 通常和创建GameplayEffectSpec的Ability的等级一样, 但是可以是不同的. GameplayEffectSpec的持续时间. 默认是GameplayEffect的持续时间, 但是可以是不同的. 对于周期性Effect中GameplayEffectSpec的周期, 默认是GameplayEffect的周期, 但是可以是不同的. 该GameplayEffectSpec的当前堆栈数. 堆栈限制取决于GameplayEffect. GameplayEffectContextHandle表明该GameplayEffectSpec由谁创建. Attribute在GameplayEffectSpec创建时由Snapshot捕获. 除了GameplayEffect授予的GameplayTags, GameplayEffectSpec还会授予目标(Target)DynamicGrantedTags. 除了GameplayEffect拥有的AssetTags, GameplayEffectSpec还会拥有DynamicAssetTags. SetByCaller TMaps. 1 2 3 4 5 6 7 8 9 10 11 12 void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); } Stack堆栈 GameplayEffect默认会应用新的GameplayEffectSpec实例, 而不明确或不关心之前已经应用过的尚且存在的GameplayEffectSpec实例. GameplayEffect可以设置到堆栈中, 新的GameplayEffectSpec实例不会添加到堆栈中, 而是修改当前已经存在的GameplayEffectSpec堆栈数. 堆栈只适用于持续(Duration)和无限(Infinite)GameplayEffect.\nSource就是AbilitySystemComponent\n堆栈类型 描述 Aggregate by Source 目标(Target)上的每个源(Source)ASC都有一个单独的堆栈实例, 每个源(Source)可以应用堆栈中的X个GameplayEffect. Aggregate by Target 目标(Target)上只有一个堆栈实例而不管源(Source)如何, 每个源(Source)都可以在共享堆栈限制(Shared Stack Limit)内应用堆栈. By Source ，每个Source对象拥有一个计数，计数达到限制时 不能再对Target应用GE.Source1的Stack达到2后，再次应用会失效. 这时再起一个Source2对象 就可以应用GE，因为它的Stack没有达到限制\nBy Target，只要Target的Stack达到限制，不管有多少个Source 都不能对Target应用GE.\n详细解释\n————————————————\nInfinite GE的添加、移除 当GameplayEffectSpec成功应用后, 就会返回一个FActiveGameplayEffectHandle.\n在应用GESpec后，把TargetASC和GEHandle加入到Map里这是针对区域效果的操作，如果有2个玩家进入伤害区域，在他们离开区域时 要通过 \u0026lt;离开的Acotr\u0026gt; 这个条件去Map寻找他对应的GEHandle，从而根据GEHandle移除他身上的GE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TMap\u0026lt;FActiveGameplayEffectHandle,UAbilitySystemComponent*\u0026gt; ActiveEffectHandls; void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf\u0026lt;UGameplayEffect\u0026gt; GameplayEffectClass) { UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (TargetASC == nullptr) {return;} check(GameplayEffectClass); FGameplayEffectContextHandle GameplayEffectContext = TargetASC-\u0026gt;MakeEffectContext(); GameplayEffectContext.AddSourceObject(this); FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-\u0026gt;MakeOutgoingSpec(GameplayEffectClass, ActorLevel, GameplayEffectContext); FActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-\u0026gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); const bool bIsInfinite = EffectSpecHandle.Data.Get()-\u0026gt;Def.Get()-\u0026gt;DurationPolicy == EGameplayEffectDurationType::Infinite; if (bIsInfinite \u0026amp;\u0026amp; InfiniteEffectRemovePolicy == EEffectRemovePolicy::RemoveOnEndOverlap) { ActiveEffectHandls.Add(ActiveEffectHandle,TargetASC); } } 移除通过Actor的ASC查找Map里对应的GEHandle，使用Handle移除Actor的ASC上面的GE后，还要在Map里移除这一对元素.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void AAuraEffectActor::RemoveGE(AActor* TargetActor) { UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor); if (!IsValid(ASC)) return; // TArray\u0026lt;FActiveGameplayEffectHandle\u0026gt; HandlesToRemove; for (TTuple\u0026lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*\u0026gt; HandlePair : ActiveEffectHandls) { if (HandlePair.Value == ASC) { ASC-\u0026gt;RemoveActiveGameplayEffect(HandlePair.Key,1); HandlesToRemove.Add(HandlePair.Key); } } for (FActiveGameplayEffectHandle\u0026amp; Handle : HandlesToRemove) { ActiveEffectHandls.FindAndRemoveChecked(Handle); } // /*使用迭代器遍历 TMap for (auto It = ActiveEffectHandls.CreateIterator(); It; ++It) { if (It-\u0026gt;Value == ASC) { // 删除 ActiveGameplayEffect ASC-\u0026gt;RemoveActiveGameplayEffect(It-\u0026gt;Key); // 删除 TMap 中的元素 It.RemoveCurrent(); } }*/ } 数值的限制 与 响应 生命值等属性在应用GE后 可能会变成负数，或者超出最大生命值，\nPreAttributeChange PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue)是AttributeSet中的主要函数之一, 其在修改发生前响应Attribute的CurrentValue变化, 其是通过引用参数NewValue限制(Clamp)CurrentValue即将进行的修改的理想位置.\n例如像样例项目那样限制移动速度Modifier:\n1 2 3 4 5 if (Attribute == GetMoveSpeedAttribute()) { // Cannot slow less than 150 units/s and cannot boost more than 1000 units/s NewValue = FMath::Clamp\u0026lt;float\u0026gt;(NewValue, 150, 1000); } GetMoveSpeedAttribute()函数是由我们在AttributeSet.h中添加的宏块创建的(定义Attribute).\nPreAttributeChange()可以被Attribute的任何修改触发, 无论是使用Attribute的setter(由AttributeSet.h中的宏块定义(定义Attribute))还是使用GameplayEffect.\nNote: 在这里做的任何限制都不会永久性地修改ASC中的Modifier, 只会修改查询Modifier的返回值, 这意味着像GameplayEffectExecutionCalculations和ModifierMagnitudeCalculations这种自所有Modifier重新计算CurrentValue的函数需要再次执行限制(Clamp)操作.\nNote: Epic对于PreAttributeChange()的注释说明不要将该函数用于游戏逻辑事件, 而主要在其中做限制操作. 对于修改Attribute的游戏逻辑事件的建议位置是UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)(响应Attribute变化).\n限制生命值示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PreAttributeChange(const FGameplayAttribute\u0026amp; Attribute, float\u0026amp; NewValue) { Super::PreAttributeChange(Attribute, NewValue); if (Attribute == GetHealthAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxHealth()); } if (Attribute == GetManaAttribute()) { NewValue = FMath::Clamp(NewValue,0.0f,GetMaxMana()); } } ·当前值的变化 - 在变化发生之前 ·由属性的变化触发 - 属性访问器 - GameplayEffects ·不会永久更改修饰符，只会更改查询修饰符返回的值 ·后续操作会重新计算所有修饰符的当前值 - 我们需要再次限制\nPostGameplayEffectExecute PostGameplayEffectExecute(const FGameplayEffectModCallbackData \u0026amp; Data)仅在即刻(Instant)GameplayEffect对Attribute的BaseValue修改之后触发, 当GameplayEffect对其修改时, 这就是一个处理更多Attribute操作的有效位置.\n例如, 在样例项目中, 我们在这里从生命值Attribute中减去了最终的伤害值Meta Attribute, 如果有护盾值Attribute的话, 我们也会在减除生命值之前从护盾值中减除伤害值. 样例项目也在这里应用了被击打反应动画, 显示浮动的伤害数值和为击杀者分配经验值和赏金. 通过设计, 伤害值Meta Attribute总是会传递给即刻(Instant)GameplayEffect而不是Attribute Setter.\n其他只会由即刻(Instant)GameplayEffect修改BaseValue的Attribute, 像魔法值和耐力值, 也可以在这里被限制为其相应的最大值Attribute.\nNote: 当PostGameplayEffectExecute()被调用时, 对Attribute的修改已经发生, 但是还没有被同步回客户端, 因此在这里限制值不会造成对客户端的二次同步, 客户端只会接收到限制后的值.\n限制生命值:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); } if (Data.EvaluatedData.Attribute == GetManaAttribute()) { SetMana(FMath::Clamp(GetMana(),0.f,GetMaxMana())); } } PreAttributeChange 和 PostGameplayEffectExecute 一起使用，这样才是真正的限制住了\nFGameplayEffectModCallbackData PostGameplayEffectExecute的参数FGameplayEffectModCallbackData\u0026amp; Data，它包含了很多信息，\n下面这个 FEffectProperites 结构体里的信息 都能从Data里面获得.Source开头 指的是 “属性的改变是谁打过来的”，Target开头 指的是“受害者”例如: 泽拉斯Q了一下诺手， 这个Q的伤害是泽拉斯造成的，Source是泽拉斯.诺手接收到Q的伤害之后，要在PostGameplayEffectExecute里面一通计算 响应伤害，Target是诺手.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 USTRUCT() struct FEffectProperites { GENERATED_BODY() FEffectProperites(){}; FGameplayEffectContextHandle EffectContextHandle; UPROPERTY() UAbilitySystemComponent* SourceASC = nullptr; UPROPERTY() AActor* SourceAvatarActor = nullptr; UPROPERTY() AController* SourceController = nullptr; UPROPERTY() ACharacter* SourceCharacter = nullptr; //////////////////////////////////////////// UPROPERTY() UAbilitySystemComponent* TargetASC = nullptr; UPROPERTY() AActor* TargetAvatarActor = nullptr; UPROPERTY() AController* TargetController = nullptr; UPROPERTY() ACharacter* TargetCharacter = nullptr; }; FGameplayEffectModCallbackData\u0026amp; Data的使用方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void UAuraAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData\u0026amp; Data) { Super::PostGameplayEffectExecute(Data); FEffectProperites Props; SetEffectProperties(Data,Props); } void UAuraAttributeSet::SetEffectProperties(const struct FGameplayEffectModCallbackData\u0026amp; Data,FEffectProperites\u0026amp; Props) { Props.EffectContextHandle = Data.EffectSpec.GetContext(); Props.SourceASC = Props.EffectContextHandle.GetOriginalInstigatorAbilitySystemComponent(); if (IsValid(Props.SourceASC) \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.SourceAvatarActor = Props.SourceASC-\u0026gt;GetAvatarActor(); Props.SourceController = Props.SourceASC-\u0026gt;AbilityActorInfo-\u0026gt;PlayerController.Get(); if (Props.SourceController == nullptr \u0026amp;\u0026amp; Props.SourceAvatarActor!=nullptr) { if (APawn* Pawn = Cast\u0026lt;APawn\u0026gt;(Props.SourceAvatarActor)) { Props.SourceController = Pawn-\u0026gt;GetController(); } } if (Props.SourceController) { Props.SourceCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.SourceController-\u0026gt;GetPawn()); } } if (Data.Target.AbilityActorInfo.IsValid() \u0026amp;\u0026amp; Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.IsValid()) { Props.TargetAvatarActor = Data.Target.AbilityActorInfo-\u0026gt;AvatarActor.Get(); Props.TargetController = Data.Target.AbilityActorInfo-\u0026gt;PlayerController.Get(); Props.TargetCharacter = Cast\u0026lt;ACharacter\u0026gt;(Props.TargetAvatarActor); Props.TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Props.TargetAvatarActor); } } 使用Prop:\n1 2 3 4 5 6 if (Data.EvaluatedData.Attribute == GetHealthAttribute()) { SetHealth(FMath::Clamp(GetHealth(),0.f,GetMaxHealth())); UE_LOG(LogTemp,Warning,TEXT(\u0026#34;Changed Health on %s, Health:%f\u0026#34;),*Props.TargetAvatarActor-\u0026gt;GetName(),GetHealth()); } 诺手接收到伤害后，打印诺手的名字和血量，所以需要TargetAvatarActor来获得名字.\n","date":"2025-01-11T11:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-gameplayeffect/","title":"GAS A - GameplayEffect"},{"content":"MVC 插播一条：UE5中 有一套MVVM插件 可以与UMG联动。创建MVVM对象，在这个对象里面创建一些变量什么的，当变量改变时 它自己就会发出广播通知\nhttps://www.bilibili.com/video/BV1Dj411N735/\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/umg-viewmodel\n下面开始视频教程的内容：\n将应用程序分为三个核心组件：模型（Model）、视图（View）和控制器（Controller），以实现关注点分离。\n在这个系列课程中，使用这个架构来更新UMG， 玩家属性发生变化\u0026mdash;\u0026gt;通知Controller\u0026mdash;\u0026gt;Controller发出消息广播，UMG订阅Controller的消息广播，这样就把 玩家和UMG 联系起来了.\n直观上看的话，也就是 玩家大喊一声“该更新了”，具体去更新谁，玩家并不关心。\n在整个过程中，只关注一个中介者—Controller，需要更新自己数据的UMG界面 自己去订阅消息通知，变化事件发生时，Controller发出通知消息， UMG自己去查看是 生命值变化了，还是魔法值变化了，去做它自己该做的事情。\n套用MVC模式，View = UMG，Model = 玩家属性，Controller就是这两个之间的中间件. Controller可以是一个UObject. (这里的Controller不是引擎中的 AI控制器 / 玩家控制器，只是一个U类对象)\n这是最终要实现的结构，UMG内部需要Controller的指针，用来订阅Controller的消息，\nUMG和Controller都集中在HUD里面，HUD同时创建UMG、Controller，并且当场就把Controller与UMG 关联起来。 GameMode管理HUD，GameMode会自动创建HUD. 而HUD内部管理UMG、Controller，HUD对外公开一个函数，用来接收玩家相关的信息 以及 创建UMG、Controller\n1 InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) 这个函数接收4个参数 用来获得玩家信息，只需要一个合适的时机调用这个HUD的函数，一切就能关联起来。\n对于人类玩家角色来说，GAS相关组件都放在PlayerState里面，当角色死亡时 死的只是Actor 不是PlaeyrState，所以这些组件不会丢失角色的属性信息，角色复活时 就得重新获得PlayerState里面的GAS组件信息。复活 就可以视为是初始化了，游戏刚开始时，角色也算是“复活”，即调用 PossessedBy 函数，在PossessedBy 函数里面获得GAS信息的同时，就通知UI去更新信息。\n这就是InitOverlay调用的时机，即在 PossessedBy 里面调用. PossessedBy 拿到 PC、PS、ASC、AS 之后 传给HUD::InitOverlay，让HUD拿着这些信息去构造Controller\n有了这些指导思想，接下来的内容就容易看懂了.\n整这么一大堆，其实就是 本来UMG能直接GetPlayerCharacter，Cast到AuraCharacter，角色身上的所有东西都能获取，GetPlayerState ，Cast到AuraPlayerState也能获取GAS组件。这已经可以运行了，只是多了一个中间件，原本是 角色\u0026mdash;\u0026gt;UMG，一站直达的， 现在需要 角色\u0026ndash;\u0026gt;中间件\u0026mdash;\u0026gt;UMG于是乎，就要想办法把这一串逻辑 重新打通，就仅此而已.\nController \u0026amp; Widget 粗糙的结构图，WidgetController只是个继承自UObject的类，需要4个变量，PC、PS、ASC、AS，UserWidget 也就是UMG的父类， 有WidgetController的Getter、Setter，在代码里面调用SetWidgetController()，SetWidgetController内部又调用WidgetControllerSet()，这是用来调用蓝图事件的，绑定的事件在UMG的蓝图里做，这样就打通了C++和蓝图的通信.\n创建UMG 后面只是在蓝图里创建了几个UMG，这是结构图， WBP_Overlay是主界面，里面有小UI，WBP_HealthGlobe等等.\nHUD 在哪里创建主UI？Controller存放到哪里？又如何初始化？\nHUD的目的是 告知玩家当前游戏状态，即分数、生命值、游戏剩余时间等。\n这个课程把Controller放到了HUD里，UMG也由HUD来创建。\n1 2 3 4 5 6 7 AuraHUD UPROPERTY() TObjectPtr\u0026lt;UAuraUserWidget\u0026gt; OverlayWidget; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UAuraUserWidget\u0026gt; OverlayWidgetClass; 这是常用的操作，在蓝图里指定OverlayWidgetClass 选择使用哪一个蓝图，在C++中使用这个class创建对象.\n把BP_AuraHUD放到GameMode里面，用于创建BP_AuraHUD\nWidget Controller HUD能创建出UMG了，还剩下Controller没有初始化，AuraWidgetController里面还有4个变量需要初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState; TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; ———————————————————————————————————————————————————————————————————— USTRUCT(BlueprintType) struct FWidgetControllerParams { GENERATED_BODY() FWidgetControllerParams(){}; FWidgetControllerParams(APlayerController* PC,APlayerState* PS,UAbilitySystemComponent* ASC,UAttributeSet* AS) : PlayerController(PC),PlayerState(PS),AbilitySystemComponent(ASC),AttributeSet(AS) {}; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;APlayerState\u0026gt; PlayerState = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent = nullptr; UPROPERTY(EditAnywhere,BlueprintReadWrite) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet = nullptr; }; void UAuraWidgetController::SetWidgetControllerParams(const FWidgetControllerParams\u0026amp; WCParams) { PlayerController = WCParams.PlayerController; PlayerState = WCParams.PlayerState; AbilitySystemComponent = WCParams.AbilitySystemComponent; AttributeSet = WCParams.AttributeSet; } 看着比较长，实际上只是定义一个结构体，函数接收这个结构体来初始化这些变量， 思考题：为什么要用结构体？ WidgetController里面的变量初始化完了，那么WidgetController本体在哪里初始化？\n创建OverlayWidgetController ，它继承自 UAuraWidgetController，用来更新主UI.\n在AuraHUD里添加两个变量，前面的UMG在HUD里初始化了，WidgetController也在HUD初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY() TObjectPtr\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetController; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;UOverlayWidgetController\u0026gt; OverlayWidgetControllerClass; UOverlayWidgetController* AAuraHUD::GetOverlayWidgetController(const FWidgetControllerParams\u0026amp; WCParams) { if (OverlayWidgetController == nullptr) { OverlayWidgetController = NewObject\u0026lt;UOverlayWidgetController\u0026gt;(this,OverlayWidgetControllerClass); OverlayWidgetController-\u0026gt;SetWidgetControllerParams(WCParams); OverlayWidgetController-\u0026gt;BindCallbacksToDependencies(); return OverlayWidgetController; } return OverlayWidgetController; } GetOverlayWidgetController() 如果OverlayWidgetController没有值 则创建并返回，有值 直接返回。\n初始化函数有了，调用时机呢？\n1 2 3 4 5 这个函数是后文 消息广播 定义的函数，在Controller初始化时 广播一次属性值 总不能是空血条开局吧 WidgetController-\u0026gt;BroadcastInitialValues(); 这也是后文的函数，用来订阅 属性更改通知 的委托 BindCallbacksToDependencies() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AAuraHUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS) { checkf(OverlayWidgetClass,TEXT(\u0026#34;OverlayWidgetClass uninitialized,fill out BP_AurhHUD\u0026#34;)); checkf(OverlayWidgetControllerClass,TEXT(\u0026#34;OverlayWidgetControllerClass uninitialized,fill out BP_AurhHUD\u0026#34;)); OverlayWidget = CreateWidget\u0026lt;UAuraUserWidget\u0026gt;(GetWorld(), OverlayWidgetClass); const FWidgetControllerParams WidgetControllerParams(PC,PS,ASC,AS); UOverlayWidgetController* WidgetController = GetOverlayWidgetController(WidgetControllerParams); OverlayWidget-\u0026gt;SetWidgetController(WidgetController); WidgetController-\u0026gt;BroadcastInitialValues(); OverlayWidget-\u0026gt;AddToViewport(); } InitOverlay AAuraHUD::InitOverlay 是HUD公开出去的函数，是一切故事发生的入口.\n至此，HUD把UMG和WidgetController收集了起来. 在HUD中通过 InitOverlay() 创建UMG、WidgetController，并且在创建现场就把UMG和WidgetController关联起来.\n1 OverlayWidget-\u0026gt;SetWidgetController(WidgetController); 只要调用对外公开的 InitOverlay() 函数，所有东西都能链接起来，那么 在哪里调用才合适？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); Cast\u0026lt;UAuraAbilitySystemComponent\u0026gt;(AbilitySystemComponent)-\u0026gt;AbilityInfoSet(); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); if (AAuraPlayerController* AuraPlayerController = Cast\u0026lt;AAuraPlayerController\u0026gt;(GetController())) { if (AAuraHUD* AuraHud = Cast\u0026lt;AAuraHUD\u0026gt;(AuraPlayerController-\u0026gt;GetHUD())) { AuraHud-\u0026gt;InitOverlay(AuraPlayerController,AuraPlayerState,AbilitySystemComponent,AttributeSet); } } } 最终如图所示，完成整个流程。\nCharacter::PossessedBy是入口，在这里获得 玩家控制器、玩家状态、技能组件、属性Set.初始化角色自己的GAS组件 的同时 ，传给HUD 让HUD也用用，HUD在创建Controller时，把 玩家控制器、玩家状态、技能组件、属性集 传给Controller，HUD在创建UMG时，把Controller 传给UMG.\n消息广播 GAS对外公开有委托事件，当属性变化时 这个委托就会广播，Controller订阅GAS的广播 就可以在属性变化时 获得属性的最新值。\n当Controller被HUD初始化时，就要广播一次 用来初始化UMG里的内容，总不能开局血条是空的吧。\nUAuraWidgetController追加空函数，在OverlayWidgetController进行override.\n1 2 3 UFUNCTION(BlueprintCallable) virtual void BroadcastInitialValues(){}; virtual void BindCallbacksToDependencies(){}; 还要在OverlayWidgetController里面定义委托 和 委托变量\nOverlayWidgetController.h\n1 2 3 4 5 6 7 8 9 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnAttributeChangedSignature, float, NewValue); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMessageWidgetRowSignature,FUIWidgetRow,Row); —————————————————————————————————————————————————————————————————————————— UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnHealthChanged; UPROPERTY(BlueprintAssignable,Category=\u0026#34;GAS|Attributes\u0026#34;) FOnAttributeChangedSignature OnMaxHealthChanged; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void UOverlayWidgetController::BroadcastInitialValues() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); OnHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetHealth()); OnMaxHealthChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxHealth()); OnManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMana()); OnMaxManaChanged.Broadcast(AuraAttributeSet-\u0026gt;GetMaxMana()); } void UOverlayWidgetController::BindCallbacksToDependencies() { const UAuraAttributeSet* AuraAttributeSet = Cast\u0026lt;UAuraAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxHealthChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnManaChanged.Broadcast(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(AuraAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this](const FOnAttributeChangeData\u0026amp; Data) { OnMaxManaChanged.Broadcast(Data.NewValue); }); } MVVM GAS B系列使用MVVM框架更新UMG.\n(有一个漏掉的操作 → 没有手动调用一次广播，开局血条是空的，)\nELMVVMPlayer.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 UCLASS(BlueprintType) class ELEMENTAL_III_API UELMVVMPlayer : public UMVVMViewModelBase { GENERATED_BODY() public: UFUNCTION(BlueprintCallable) void SetMvvmParams(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); protected: UPROPERTY() TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Health; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxHealth; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float Mana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) float MaxMana; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter=GetIsBattleMode,Setter=SetIsBattleMode) bool bIsBattleMode = false; UPROPERTY(BlueprintReadWrite, FieldNotify,Getter,Setter) int32 KillNumber; void SetHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Health,Value);} float GetHealth() const {return Health;}; void SetMaxHealth(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxHealth,Value);} float GetMaxHealth() const {return MaxHealth;}; void SetMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(Mana,Value);} float GetMana() const {return Mana;}; void SetMaxMana(const float Value) {UE_MVVM_SET_PROPERTY_VALUE(MaxMana,Value);} float GetMaxMana() const {return MaxMana;}; void SetIsBattleMode(const bool Value) {UE_MVVM_SET_PROPERTY_VALUE(bIsBattleMode,Value);} bool GetIsBattleMode() const {return bIsBattleMode;}; void SetKillNumber(const int32 Value) {UE_MVVM_SET_PROPERTY_VALUE(KillNumber,Value);} int32 GetKillNumber() const {return KillNumber;}; }; ELMVVMPlayer.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // AELCharacterBase::InitAbilityInfo ---\u0026gt; AELHUD::InitMVVM ---\u0026gt; ThisClass::SetMvvmParams void UELMVVMPlayer::SetMvvmParams(APlayerController* PC, UAbilitySystemComponent* ASC, UAttributeSet* AS) { PlayerController = PC; AbilitySystemComponent = ASC; AttributeSet = AS; AELPlayerController* ELPlayerController = Cast\u0026lt;AELPlayerController\u0026gt;(PlayerController); ELPlayerController-\u0026gt;OnBattleModeChange.AddLambda( [this](bool InBattleMode) { SetIsBattleMode(InBattleMode); }); const UELAttributeSet* ELAttributeSet = Cast\u0026lt;UELAttributeSet\u0026gt;(AttributeSet); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxHealthAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxHealth(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetMaxManaAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetMaxMana(Data.NewValue); }); AbilitySystemComponent-\u0026gt;GetGameplayAttributeValueChangeDelegate(ELAttributeSet-\u0026gt;GetKillNumberAttribute()) .AddLambda([this]( const FOnAttributeChangeData\u0026amp; Data) { SetKillNumber(Data.NewValue); }); } ELHUD.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 UCLASS() class ELEMENTAL_III_API AELHUD : public AHUD { GENERATED_BODY() public: void InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS); UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;APlayerController\u0026gt; PlayerController; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;ACharacter\u0026gt; Character; UPROPERTY(BlueprintReadOnly) TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; UPROPERTY(BlueprintReadWrite, EditDefaultsOnly) FMVVMViewModelContext MVVMContext; UPROPERTY(BlueprintReadOnly) class UELMVVMPlayer* MVVMPlayer; }; ELHUD.cpp\n在这里创建MvvmPlayer并且添加到Mvvm全局子系统里. UMG里根据Context从全局获取MvvmPlayer.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void AELHUD::InitMvvm(APlayerController* PC,UAbilitySystemComponent* ASC,UAttributeSet* AS) { AbilitySystemComponent = ASC; PlayerController = PC; Character = Cast\u0026lt;ACharacter\u0026gt;(PlayerController-\u0026gt;GetPawn()); AttributeSet = AS; MVVMPlayer = NewObject\u0026lt;UELMVVMPlayer\u0026gt;(PC); UGameInstance* GameInstance = UGameplayStatics::GetGameInstance(this); UMVVMGameSubsystem* MvvmGameSubsystem = GameInstance-\u0026gt;GetSubsystem\u0026lt;UMVVMGameSubsystem\u0026gt;(); MvvmGameSubsystem-\u0026gt;GetViewModelCollection()-\u0026gt;AddViewModelInstance(MVVMContext,MVVMPlayer); MVVMPlayer-\u0026gt;SetMvvmParams(PC,ASC,AS); } CharacterBase\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AELCharacterBase::InitAbilityInfo() { AHUD* HUD = Cast\u0026lt;AELPlayerController\u0026gt;(GetController())-\u0026gt;GetHUD(); if (AELHUD* ELHud = Cast\u0026lt;AELHUD\u0026gt;(HUD)) { ELHud-\u0026gt;InitMvvm(Cast\u0026lt;AELPlayerController\u0026gt;(GetController()),AbilitySystemComponent,AttributeSet); } } void AELCharacterBase::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); InitAbilityInfo(); } 调用顺序: AELCharacterBase::PossessedBy\u0026mdash;\u0026gt;AELCharacterBase::InitAbilityInfo \u0026mdash;\u0026gt; AELHUD::InitMVVM \u0026mdash;\u0026gt; UELMVVMPlayer::SetMvvmParams\n","date":"2025-01-11T11:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-ui-mvc-or-mvvm/","title":"GAS A - UI - MVC or MVVM"},{"content":"起手式 网页图片模糊 点击图片预览高清大图\nhttps://dev.epicgames.com/documentation/zh-cn/unreal-engine/gameplay-ability-system-for-unreal-engine↑首先看一遍官方文档↑\nGAS学习资料:https://github.com/BillEliot/GASDocumentation_Chinese\n官方的ActionRPG项目，\nGAS A系列是由 \u0026lt; Gameplay Ability System - Top Down RPG\u0026gt; 这一套教程来的,简单的细枝末节不记录https://www.bilibili.com/video/BV1JD421E7yC\n与GameplayAbilitySystem交互的Actor须拥有 GameplayAbilitySystemComponent。此组件将激活技能、存储属性、更新效果，和处理Actor间的交互。\n角色类拥有UAbilitySystemComponent 和 UAttributeSet 两个组件，AttributeSet保存角色的属性值，例如:生命值、魔法值、生命回复、攻击力、法术强度，而这些属性由GameplayEffect来修改，不应手动修改.尽管AttributeSet提供了Setter方法，也不该手动调用它去做一些事情.\nGameplayAbility执行技能任务，被动、Q、W、E、R、D、F都可以是GameplayAbility.技能(GameplayAbility) 可以配置CD、Cost，也就是冷却时长，耗费多少蓝量. CD和Cost都由GamePlayEffect定义. CD、Cost的信息都可以在GA的蓝图面板中配置，选择对应的GE蓝图即可.\n技能执行流程 先描述最感兴趣的一集吧，开局就写难懂的东西 只会让脑子开局就过载，作文首先要引起读者的兴趣。 这把先开\u0026lt;泽拉斯\u0026gt;奥兄弟们，最会空技能的一个英雄。\n冷却时间 泽拉斯的Q技能一级有9秒CD，释放技能时 如果在冷却中 就不让释放，这个流程如何使用GAS来执行？GE可以选择 \u0026lt;立即生效 | 持续一段时间 | 无限时间\u0026gt; 三个策略。假设这个技能是GA_Q，它拥有标签TAG_Q，那么就让GE_Q_CD使用 \u0026lt;持续一段时间\u0026gt; 这个策略，并且让GE_Q_CD去阻挡TAG_Q，等到GE的持续时间结束才会取消阻挡。 这样就实现了技能的冷却。执行流程为:GA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;不在CD中\u0026mdash;\u0026gt;执行技能\u0026mdash;\u0026gt;技能结束，开始CDGA_Q被触发\u0026mdash;\u0026gt;检测CD\u0026mdash;\u0026gt;正在CD中\u0026mdash;\u0026gt;技能结束\n技能耗费 泽拉斯的Q技能需要耗费80蓝量，这就要求Attribute里面拥有\u0026lt;魔法值\u0026gt;这个属性，在GA_Q执行时扣除相应的魔法值，如果蓝量不够 就不能执行技能.GE_Q_Cost 使用 \u0026lt;立即生效\u0026gt; 策略，(瞪眼观察法可知 另外两个策略一看就不对)Q需要耗费80蓝量，GE_Q_Cost就得让 \u0026lt;魔法值\u0026gt; 减80，魔法值够减的话 那么就能执行技能. 不够减 就不执行.\n执行流程与 冷却时间 相似.\n技能伤害 有了上面使用GE去做CD 耗蓝，那么伤害如何去做？ 直接减掉目标的血量值？NO ，Attribute中定义 \u0026lt;即将到来的伤害\u0026gt;， 如果伤害值是50， 那么就使用GE 让敌人的 \u0026lt;即将到来的伤害\u0026gt; +50。 在Attribute中去执行减掉生命值的操作.\n这把开一局\u0026lt;爆破鬼才\u0026gt;，假如我发射一个火球，那么在火球滑行的途中，它撞到了地面 触发爆炸伤害. 这里就得范围检测Enemy，并且获得它们身上的 AbilitySystemComponent 并且对这个组件应用GE，造成伤害\n技能蓝图 被动技能 生命回复、法力回复 这些都是自动运行的， 每秒回复1点生命值 回复1点魔法值， 可以用GE做一个 无限时间 的效果，持续一段时间 | 无限时间 ， 这两个策略都可以设置触发周期，比如每1秒触发一次，每0.5秒触发一次 等等。\n自动回复就使用 无限时间 ，每秒触发一次，每次触发添加1点生命值，1点魔法值。就叫它 GE_Regeneration ，在BeginPlay时 对AbilitySystemComponent应用这个GE即可。那死亡时 不想要自动回复了怎么办？ GE可以被Apply，也可以被Remove，死亡时只要移除这个GE就行了,这是手动移除的案例.\nBuff也可以用一个GE完成，例如 增加50攻击力，并且持续90秒，那么就使用一个 持续一段时间的GE，让攻击力+50，时间结束后 GE自动取消. 这是自动移除的案例.手动移除方法：\nGameplayAbilitySystem 初始化技能组件 ASC附加的Actor被引用作为该ASC的OwnerActor, 该ASC的物理代表Actor被称为AvatarActor. OwnerActor和AvatarActor可以是同一个 Actor, 比如MOBA游戏中的一个简单AI小兵; 它们也可以是不同的Actor, 比如MOBA游戏中玩家控制的英雄, 其中OwnerActor是PlayerState, AvatarActor是英雄的Character类. 绝大多数Actor的ASC都附加在其自身, 如果你的Actor会重生并且重生时需要持久化Attribute或GameplayEffect(比如MOBA中的英雄), 那么ASC理想的位置就是PlayerState.\nGAS要求添加 AbilitySystemComponent (ASC) 和 AttributeSet (AS)，那么往角色身上添加 是否可行？\n如果角色可以被摧毁、可以死亡，当CharacterActor死亡时 在它身上挂载的 ASC、AS 全都没有了，一起跟着销毁再次复活时 技能信息会丢失。 这就要求把ASC、AS放到一个可靠的地方，在这个教程里 放到了PlayerState里面。\n问题:如何放？ 还要把玩家角色与PlayerState里的ASC、AS连接起来，这样在场景里才能通过玩家角色获得玩家的ASC、AS，如何连接？ ACharacter -\u0026gt; AuraCharacterBase -\u0026gt;Enemy / AuraCharacter , AuraCharacter 是玩家角色\n【Enemy 和 AuraCharacter 都继承自AuraCharacterBase 】\n在AuraCharacterBase 和 PlayerStae 中定义GAS的两个组件的指针，但是实体在Enemy 和 PlayerState 中创建.因为玩家角色的GAS组件要放在PlayerState里，而敌人AI就放在它自己的角色类里面.\n下面的内容就是解决上面的两个问题:如何放 如何连接。定义组件指针、初始化组件、连接 玩家角色 与 PlayerState 的组件.(玩家角色 被玩家控制器 控制后，就要获得PlayerState里面的ASC、AS组件)思路不清晰 可以看小节结尾的流程图.\n1 2 3 4 5 UPROPERTY() TObjectPtr\u0026lt;UAbilitySystemComponent\u0026gt; AbilitySystemComponent; UPROPERTY() TObjectPtr\u0026lt;UAttributeSet\u0026gt; AttributeSet; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 AAuraEnemy::AAuraEnemy() { GetMesh()-\u0026gt;SetCollisionResponseToChannel(ECC_Visibility,ECR_Block); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); HealthBar = CreateDefaultSubobject\u0026lt;UWidgetComponent\u0026gt;(\u0026#34;HealthBar\u0026#34;); HealthBar-\u0026gt;SetupAttachment(GetRootComponent()); } AAuraPlayerState::AAuraPlayerState() { //NetUpdateFrequency = 100.f; SetNetUpdateFrequency(100.f); AbilitySystemComponent = CreateDefaultSubobject\u0026lt;UAuraAbilitySystemComponent\u0026gt;(\u0026#34;AbilitySystemComponent\u0026#34;); AbilitySystemComponent-\u0026gt;SetIsReplicated(true); AbilitySystemComponent-\u0026gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed); AttributeSet = CreateDefaultSubobject\u0026lt;UAuraAttributeSet\u0026gt;(\u0026#34;AttributeSet\u0026#34;); } 完了还要在AuraCharacterBase继承一个接口，用来获得ASC，因为要与ASC通信，不管是哪个类，只要调用这个接口就能得到它的ASC组件.\n1 2 3 4 5 6 7 8 9 10 class AURA_API AAuraCharacterBase : public ACharacter,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraCharacterBase::GetAbilitySystemComponent() const { return AbilitySystemComponent; } 现在Enemy的组件注册完了，玩家角色的还没有结束，它的组件都在PlayerState里面，还要再手动从PS里获取组件.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AURA_API AAuraPlayerState : public APlayerState,public IAbilitySystemInterface { virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override; UAttributeSet* GetAttributeSet()const {return AttributeSet;}; } UAbilitySystemComponent* AAuraPlayerState::GetAbilitySystemComponent() const { return AbilitySystemComponent; } —————————————————————————————————————————————————————————————————————————————————————— void AAuraCharacter::PossessedBy(AController* NewController) { Super::PossessedBy(NewController); // Initi Ability Actor info For the Server; InitAbilityActorInfo(); } void AAuraCharacter::InitAbilityActorInfo() { AAuraPlayerState* AuraPlayerState = GetPlayerState\u0026lt;AAuraPlayerState\u0026gt;(); check(AuraPlayerState); AbilitySystemComponent = AuraPlayerState-\u0026gt;GetAbilitySystemComponent(); AbilitySystemComponent-\u0026gt;InitAbilityActorInfo(AuraPlayerState,this); AttributeSet = AuraPlayerState-\u0026gt;GetAttributeSet(); } 这样就把玩家角色和AuraPlayerState链接起来了，AbilitySystemComponent 和 AttributeSet 都初始化了.\nAttribute https://github.com/BillEliot/GASDocumentation_Chinese?tab=readme-ov-file#43-attribute\nAttribute里定义生命值，FGameplayAttributeData Health; FGameplayAttributeData 是一个结构体，其数值是浮点型，结构体里面有一个BaseValue和一个CurrentValue，假如当前生命值是100，BaseValue = CurrentValue = 100 ， 有一个持续10秒的加50生命值的buff，一个NPC吃了一个buff 这是他生命值发生的变化， BaseValue = 100 ， CurrentValue = 100 + 50 = 150，10秒后 buff结束，CurrentValue就会变回BaseValue， 此时 BaseValue = CurrentValue = 100.\n即刻(Instant)GameplayEffect可以永久性的修改BaseValue, 而持续(Duration)和无限(Infinite)GameplayEffect可以修改CurrentValue. 周期性(Periodic)GameplayEffect被视为即刻(Instant)GameplayEffect并且可以修改BaseValue.\nAttributeSet.h里提供了一个Help宏，它被注释了，这个宏提供4个函数，Getter、Setter、Init以及一个静态的GetAttribute\n1 2 3 4 5 #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\ GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName) 将它复制到自己的类里面使用，定义一个Health属性，并且初始化为100.\n1 2 3 UPROPERTY(BlueprintReadOnly\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); 药瓶 Effect Actor 这个Actor这样修改属性只是为了简单测试，属性修改要使用GE. 当角色碰到这个Actor时 角色的Health会增加50.\n附 教程里因为版本不同 名称不同的对照，一些属性名称 , 还有打起来贼他妈麻烦的代码片段， 都可以到这复制\nGameplayEffectAssetTag 【=】 Tags This Effect Has GrantedTags 【=】 Grant Tags to Target Actor Ongoing Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Application Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Removal Tag Requirements 【=】 Require Tags to Apply / Continue This Effect Remove Gameplay Effect With Tags 【=】 Remove Other Effects\nArmor,ArmorPenetration,BlockChance,\nCriticalHitChance,CriticalHitDamage,CriticalHitResistance,\nHealthRegeneration,ManaRegeneration\nAttribute.Primary.Intelligence Row_Strength Row_Intelligence Row_Resilience Row_Vigor\nRow_Armor Row_ArmorPenetration Row_BlockChance Row_CriticalHitChance Row_CriticalHitDamage Row_CriticalHitResistance Row_HealthRegeneration Row_ManaRegeneration Row_MaxHealth Row_MaxMana\nAuraGameplayTags.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;GameplayTagContainer.h\u0026#34; struct FAuraGameplayTags { public: static const FAuraGameplayTags\u0026amp; Get() {return GameplayTags;} static void InitializeNativeGameplayTags(); FGameplayTag Attribute_Primary_Strength; FGameplayTag Attribute_Primary_Intelligence; FGameplayTag Attribute_Primary_Resilience; FGameplayTag Attribute_Primary_Vigor; FGameplayTag Attribute_Secondary_Armor; FGameplayTag Attribute_Secondary_ArmorPenetration; FGameplayTag Attribute_Secondary_BlockChance; FGameplayTag Attribute_Secondary_CriticalHitChance; FGameplayTag Attribute_Secondary_CriticalHitDamage; FGameplayTag Attribute_Secondary_CriticalHitResistance; FGameplayTag Attribute_Secondary_HealthRegeneration; FGameplayTag Attribute_Secondary_ManaRegeneration; FGameplayTag Attribute_Secondary_MaxHealth; FGameplayTag Attribute_Secondary_MaxMana; FGameplayTag InputTag_LMB; FGameplayTag InputTag_RMB; FGameplayTag InputTag_1; FGameplayTag InputTag_2; FGameplayTag InputTag_3; FGameplayTag InputTag_4; FGameplayTag Damage; FGameplayTag Effect_HitReact; private: static FAuraGameplayTags GameplayTags; }; AuraGameplayTags.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026#34;AuraGameplayTags.h\u0026#34; #include \u0026#34;GameplayTagsManager.h\u0026#34; FAuraGameplayTags FAuraGameplayTags::GameplayTags; void FAuraGameplayTags::InitializeNativeGameplayTags() { GameplayTags.Attribute_Primary_Strength = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Strength\u0026#34;), FString(\u0026#34;Increases physical damage\u0026#34;)); GameplayTags.Attribute_Primary_Intelligence = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Intelligence\u0026#34;), FString(\u0026#34;Increases magical damage\u0026#34;)); GameplayTags.Attribute_Primary_Resilience = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Resilience\u0026#34;), FString(\u0026#34;Increases Armor and ArmorPenetration\u0026#34;)); GameplayTags.Attribute_Primary_Vigor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Primary.Vigor\u0026#34;), FString(\u0026#34;Increases Health\u0026#34;)); //////////////////// GameplayTags.Attribute_Secondary_Armor = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.Armor\u0026#34;), FString(\u0026#34;Reduce damage taken\u0026#34;)); GameplayTags.Attribute_Secondary_ArmorPenetration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ArmorPenetration\u0026#34;), FString(\u0026#34;Ignore percentage of enemy\u0026#34;)); GameplayTags.Attribute_Secondary_BlockChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.BlockChance\u0026#34;), FString(\u0026#34;Chance to cut incoming damage in half\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitChance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitChance\u0026#34;), FString(\u0026#34;Chance to double damage plus critical hit bonus\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitDamage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitDamage\u0026#34;), FString(\u0026#34;Bonus damage added when a critical hit is scored\u0026#34;)); GameplayTags.Attribute_Secondary_CriticalHitResistance = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.CriticalHitResistance\u0026#34;), FString(\u0026#34;Reduces critical hit chance of attacking enemies\u0026#34;)); GameplayTags.Attribute_Secondary_HealthRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.HealthRegeneration\u0026#34;), FString(\u0026#34;Amount of Health regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_ManaRegeneration = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.ManaRegeneration\u0026#34;), FString(\u0026#34;Amount of Mana regeneration every 1 second\u0026#34;)); GameplayTags.Attribute_Secondary_MaxHealth = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxHealth\u0026#34;), FString(\u0026#34;Maximum amount of Health\u0026#34;)); GameplayTags.Attribute_Secondary_MaxMana = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Attribute.Secondary.MaxMana\u0026#34;), FString(\u0026#34;Maximum amount of Mana\u0026#34;)); ///////////// GameplayTags.InputTag_LMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.LMB\u0026#34;), FString(\u0026#34;Input Tag for Left Mouse Button\u0026#34;)); GameplayTags.InputTag_RMB = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.RMB\u0026#34;), FString(\u0026#34;Input Tag for Right Mouse Button\u0026#34;)); GameplayTags.InputTag_1 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.1\u0026#34;), FString(\u0026#34;Input Tag for Key 1\u0026#34;)); GameplayTags.InputTag_2 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.2\u0026#34;), FString(\u0026#34;Input Tag for Key 2\u0026#34;)); GameplayTags.InputTag_3 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.3\u0026#34;), FString(\u0026#34;Input Tag for Key 3\u0026#34;)); GameplayTags.InputTag_4 = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;InputTag.4\u0026#34;), FString(\u0026#34;Input Tag for Key 4\u0026#34;)); //////////////////// GameplayTags.Damage = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Damage\u0026#34;), FString(\u0026#34;Damage\u0026#34;)); GameplayTags.Effect_HitReact = UGameplayTagsManager::Get().AddNativeGameplayTag (FName(\u0026#34;Effect.HitReact\u0026#34;), FString(\u0026#34;Tag granted when Hit Reacting\u0026#34;)); } AuraAttributeSet.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Strength, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Strength; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Strength); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Intelligence, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Intelligence; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Intelligence); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Resilience, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Resilience; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Resilience); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Vigor, Category=\u0026#34;Primary Attributes\u0026#34;) FGameplayAttributeData Vigor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Vigor); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxHealth, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxHealth; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxHealth); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_MaxMana, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData MaxMana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,MaxMana); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Armor, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData Armor; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Armor); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ArmorPenetration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ArmorPenetration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ArmorPenetration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_BlockChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData BlockChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,BlockChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitChance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitChance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitChance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitDamage, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitDamage); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_CriticalHitResistance, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData CriticalHitResistance; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,CriticalHitResistance); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_HealthRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData HealthRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,HealthRegeneration); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_ManaRegeneration, Category=\u0026#34;Secondary Attributes\u0026#34;) FGameplayAttributeData ManaRegeneration; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,ManaRegeneration); /////////////// UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Health, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Health; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Health); UPROPERTY(BlueprintReadOnly,ReplicatedUsing=OnRep_Mana, Category=\u0026#34;Vital Attributes\u0026#34;) FGameplayAttributeData Mana; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,Mana); ///////////////// UPROPERTY(BlueprintReadOnly, Category=\u0026#34;Meta Attributes\u0026#34;) FGameplayAttributeData IncomingDamage; ATTRIBUTE_ACCESSORS(UAuraAttributeSet,IncomingDamage); //////////////////// UFUNCTION() void OnRep_Strength(const FGameplayAttributeData\u0026amp; OldStrength)const; UFUNCTION() void OnRep_Intelligence(const FGameplayAttributeData\u0026amp; OldIntelligence)const; UFUNCTION() void OnRep_Resilience(const FGameplayAttributeData\u0026amp; OldResilience)const; UFUNCTION()\tvoid OnRep_Vigor(const FGameplayAttributeData\u0026amp; OldVigor)const; UFUNCTION()\tvoid OnRep_MaxHealth(const FGameplayAttributeData\u0026amp; OldMaxHealth)const; UFUNCTION()\tvoid OnRep_MaxMana(const FGameplayAttributeData\u0026amp; OldMaxMana)const; UFUNCTION()\tvoid OnRep_Armor(const FGameplayAttributeData\u0026amp; OldArmor)const; UFUNCTION()\tvoid OnRep_ArmorPenetration(const FGameplayAttributeData\u0026amp; OldArmorPenetration)const; UFUNCTION()\tvoid OnRep_BlockChance(const FGameplayAttributeData\u0026amp; OldBlockChance)const; UFUNCTION()\tvoid OnRep_CriticalHitChance(const FGameplayAttributeData\u0026amp; OldCriticalHitChance)const; UFUNCTION()\tvoid OnRep_CriticalHitDamage(const FGameplayAttributeData\u0026amp; OldCriticalHitDamage)const; UFUNCTION()\tvoid OnRep_CriticalHitResistance(const FGameplayAttributeData\u0026amp; OldCriticalHitResistance)const; UFUNCTION()\tvoid OnRep_HealthRegeneration(const FGameplayAttributeData\u0026amp; OldHealthRegeneration)const; UFUNCTION()\tvoid OnRep_ManaRegeneration(const FGameplayAttributeData\u0026amp; OldManaRegeneration)const; UFUNCTION()\tvoid OnRep_Health(const FGameplayAttributeData\u0026amp; OldHealth)const; UFUNCTION()\tvoid OnRep_Mana(const FGameplayAttributeData\u0026amp; OldMana)const; AuraAttributeSet.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 UAuraAttributeSet::UAuraAttributeSet() { const FAuraGameplayTags\u0026amp; GameplayTags = FAuraGameplayTags::Get(); TagToAttribute.Add(GameplayTags.Attribute_Primary_Strength,\tGetStrengthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Intelligence,\tGetIntelligenceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Resilience,\tGetResilienceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Primary_Vigor,\tGetVigorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_Armor,\tGetArmorAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ArmorPenetration,\tGetArmorPenetrationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_BlockChance,\tGetBlockChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitChance,\tGetCriticalHitChanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitDamage,\tGetCriticalHitDamageAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_CriticalHitResistance,\tGetCriticalHitResistanceAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_HealthRegeneration,\tGetHealthRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_ManaRegeneration,\tGetManaRegenerationAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxHealth,\tGetMaxHealthAttribute); TagToAttribute.Add(GameplayTags.Attribute_Secondary_MaxMana,\tGetMaxManaAttribute); } AuraAttributeSet.cpp 这是一个宏，那些属性的网络同步函数写起来真逆天，用这个宏去写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define ATTRIBUTE_REP(Name)\\ void UAuraAttributeSet::OnRep_##Name(const FGameplayAttributeData\u0026amp; Old##Name)const\\ {\\ GAMEPLAYATTRIBUTE_REPNOTIFY(UAuraAttributeSet,Name,Old##Name);\\ }; #define ATTRIBUTE_NOTIFY(Name)\\ DOREPLIFETIME_CONDITION_NOTIFY(UAuraAttributeSet,Name,COND_None,REPNOTIFY_Always); #pragma region Net ATTRIBUTE_REP(Health)\tATTRIBUTE_REP(Mana) ATTRIBUTE_REP(Strength)\tATTRIBUTE_REP(Intelligence)\tATTRIBUTE_REP(Resilience)\tATTRIBUTE_REP(Vigor) ATTRIBUTE_REP(Armor)\tATTRIBUTE_REP(ArmorPenetration)\tATTRIBUTE_REP(BlockChance)\tATTRIBUTE_REP(CriticalHitChance) ATTRIBUTE_REP(MaxHealth)\tATTRIBUTE_REP(MaxMana)\tATTRIBUTE_REP(CriticalHitDamage)ATTRIBUTE_REP(CriticalHitResistance) ATTRIBUTE_REP(HealthRegeneration)\tATTRIBUTE_REP(ManaRegeneration) void UAuraAttributeSet::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); ATTRIBUTE_NOTIFY(Health)\tATTRIBUTE_NOTIFY(Mana) ATTRIBUTE_NOTIFY(Strength)\tATTRIBUTE_NOTIFY(Intelligence)\tATTRIBUTE_NOTIFY(Resilience)\tATTRIBUTE_NOTIFY(Vigor) ATTRIBUTE_NOTIFY(Armor)\tATTRIBUTE_NOTIFY(ArmorPenetration)\tATTRIBUTE_NOTIFY(BlockChance)\tATTRIBUTE_NOTIFY(CriticalHitChance) ATTRIBUTE_NOTIFY(MaxHealth)\tATTRIBUTE_NOTIFY(MaxMana)\tATTRIBUTE_NOTIFY(CriticalHitDamage)\tATTRIBUTE_NOTIFY(CriticalHitResistance) ATTRIBUTE_NOTIFY(HealthRegeneration)\tATTRIBUTE_NOTIFY(ManaRegeneration) } #pragma endregion ","date":"2025-01-10T11:59:56+08:00","permalink":"https://akaklya.github.io/p/gas-a-%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88/","title":"GAS A - 技能系统总览"},{"content":"示例 点击按钮自动创建GE，并且避免重名\n修改LOGO图标，要手动把svg文件放到Shader文件夹里(示例代码是这样写的)\n可以修改代码 放到别的位置去，\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #define RootToContentDir Style-\u0026gt;RootToContentDir void FElemental_EditorModule::StartupModule() { const FString ProjectShaderDir = FPaths::Combine(FPaths::ProjectDir(), TEXT(\u0026#34;Shaders\u0026#34;)); //[const ISlateStyle*] -\u0026gt; [ISlateStyle*] -\u0026gt; [FSlateStyleSet*] FSlateStyleSet* Style = static_cast\u0026lt;FSlateStyleSet*\u0026gt;(const_cast\u0026lt;ISlateStyle*\u0026gt;(\u0026amp;FAppStyle::Get())); Style-\u0026gt;SetContentRoot(ProjectShaderDir); Style-\u0026gt;Set(\u0026#34;AppIcon\u0026#34;, new IMAGE_BRUSH_SVG(\u0026#34;ELIcon\u0026#34;, FVector2f(50.f, 50.f), FStyleColors::White)); RegisterMenus(); } static void CreateBP() { UEditorAssetSubsystem* EditorAssetSubsystem = GEditor-\u0026gt;GetEditorSubsystem\u0026lt;UEditorAssetSubsystem\u0026gt;(); IContentBrowserSingleton\u0026amp; CB = IContentBrowserSingleton::Get(); const auto Path = CB.GetCurrentPath(); int32 RandName = 0; FString BaseName; FString PackageName; do { RandName++; BaseName = FString::Printf(TEXT(\u0026#34;MyGameplayEffect%d\u0026#34;), RandName); PackageName = FPaths::Combine(Path.GetInternalPathString(), BaseName); } while (EditorAssetSubsystem-\u0026gt;DoesAssetExist(PackageName)); UPackage * Package = CreatePackage(*PackageName); UBlueprint* Blueprint = FKismetEditorUtilities::CreateBlueprint(UGameplayEffect::StaticClass(), Package, *BaseName, BPTYPE_Normal, UBlueprint::StaticClass(), UBlueprintGeneratedClass::StaticClass()); if (Blueprint) { FAssetRegistryModule::AssetCreated(Blueprint); Package-\u0026gt;MarkPackageDirty(); } } void FElemental_EditorModule::RegisterMenus() { auto Visible = [](){return GEditor-\u0026gt;PlayWorld == nullptr;}; UToolMenu* Menu = UToolMenus::Get()-\u0026gt;ExtendMenu(\u0026#34;LevelEditor.LevelEditorToolBar.PlayToolBar\u0026#34;); FToolMenuSection\u0026amp; Section = Menu-\u0026gt;AddSection(\u0026#34;PlayGameExtensions\u0026#34;, TAttribute\u0026lt;FText\u0026gt;(), FToolMenuInsert(\u0026#34;Play\u0026#34;, EToolMenuInsertType::After)); const FUIAction UIAction = FUIAction(FExecuteAction::CreateStatic(CreateBP), FCanExecuteAction::CreateLambda(Visible),FIsActionChecked(),FIsActionButtonVisible::CreateLambda(Visible)); const FToolMenuEntry CommonMapEntry = FToolMenuEntry::InitToolBarButton( \u0026#34;CreateGE\u0026#34;,UIAction,FText::FromString(\u0026#34;GE\u0026#34;),FText::FromString(\u0026#34;Create GameplayEffect\u0026#34;), FSlateIcon(FAppStyle::GetAppStyleSetName(), \u0026#34;Icons.Blueprint\u0026#34;)); Section.AddEntry(CommonMapEntry); } Build.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PublicDependencyModuleNames.AddRange( new string[] { \u0026#34;Core\u0026#34;,\u0026#34;AssetDefinition\u0026#34;, \u0026#34;GameplayAbilities\u0026#34;, \u0026#34;EngineAssetDefinitions\u0026#34;,\u0026#34;ToolMenus\u0026#34;,\u0026#34;ContentBrowser\u0026#34;,\u0026#34;ContentBrowserData\u0026#34; } ); PrivateDependencyModuleNames.AddRange( new string[] { \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;Slate\u0026#34;, \u0026#34;SlateCore\u0026#34; } ","date":"2025-01-09T21:38:46+08:00","permalink":"https://akaklya.github.io/p/%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91-%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%93%9D%E5%9B%BE-%E4%BF%AE%E6%94%B9%E7%BC%96%E8%BE%91%E5%99%A8%E5%9B%BE%E6%A0%87/","title":"编辑器开发 - 创建指定类型蓝图 - 修改编辑器图标"},{"content":"需要会一些模板.\n类型别名 模板类片段:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename InElementType, typename InAllocatorType\u0026gt; class TArray { template \u0026lt;typename OtherInElementType, typename OtherAllocator\u0026gt; friend class TArray; public: using SizeType = typename InAllocatorType::SizeType ; using ElementType = InElementType; using AllocatorType = InAllocatorType; private: using USizeType = typename std::make_unsigned_t\u0026lt;SizeType\u0026gt;; public: using ElementAllocatorType = std::conditional_t\u0026lt; AllocatorType::NeedsElementType, typename AllocatorType::template ForElementType\u0026lt;ElementType\u0026gt;, typename AllocatorType::ForAnyElementType \u0026gt;; static_assert(std::is_signed_v\u0026lt;SizeType\u0026gt;, \u0026#34;TArray only supports signed index types\u0026#34;); } 使用TArray存放Actor时，默认的别名类型:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using Array = TArray\u0026lt;AActor*\u0026gt;; //signed int using ArraySizeType = Array::SizeType; //AActor* using ArrayElementType = Array::ElementType; // TSizedDefaultAllocator\u0026lt;32\u0026gt; using ArrayAllocatorType = Array::AllocatorType; // TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor*\u0026gt; using ArrayElementAllocatorType = Array::ElementAllocatorType; // TSizedHeapAllocator\u0026lt;32\u0026gt; using ArrayAllocatorTypeTypedef = ArrayAllocatorType::Typedef; //signed int using ArrayAllocatorSizeType = ArrayAllocatorType::SizeType; AllocatorType TArray::AllocatorType 默认分配器是 TSizedDefaultAllocator\u0026lt;32\u0026gt;\n作用：定义容器使用的 内存分配器类型（如 FDefaultAllocator、TInlineAllocator）。 设计原因： 允许用户自定义内存管理策略（堆分配、栈分配、内存池等）。 SizeType 作用：定义容器中 索引和大小 的类型（如 int32、int64）。 设计原因： 由分配器 InAllocatorType 决定，允许不同分配器根据需求选择不同大小的整数类型（例如，小内存容器用 int32，大内存用 int64）。 示例： 若分配器定义为 TSizedHeapAllocator\u0026lt;32\u0026gt;，则 SizeType 可能是 int32。 SizeType来自于分配器的SizeType，因为默认分配器使用 TSizedDefaultAllocator\u0026lt;32\u0026gt;，所以要去找TSizedDefaultAllocator里面的SizeType是什么.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 using SizeType = typename InAllocatorType::SizeType ; //----------分配器类-------// template \u0026lt;int IndexSize\u0026gt; class TSizedDefaultAllocator : public TSizedHeapAllocator\u0026lt;IndexSize\u0026gt; { public: typedef TSizedHeapAllocator\u0026lt;IndexSize\u0026gt; Typedef; }; template \u0026lt;int IndexSize, typename BaseMallocType = FMemory\u0026gt; class TSizedHeapAllocator { public: using SizeType = typename TBitsToSizeType\u0026lt;IndexSize\u0026gt;::Type; } //---------------------// template \u0026lt;int IndexSize\u0026gt; struct TBitsToSizeType { // Fabricate a compile-time false result that\u0026#39;s still dependent on the template parameter static_assert(IndexSize == IndexSize+1, \u0026#34;Unsupported allocator index size.\u0026#34;); }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;8\u0026gt; { using Type = int8; }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;16\u0026gt; { using Type = int16; }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;32\u0026gt; { using Type = int32; }; template \u0026lt;\u0026gt; struct TBitsToSizeType\u0026lt;64\u0026gt; { using Type = int64; }; //----------UE在Windows环境下的int类型--------------// // 8-bit signed integer typedef\tsigned char\tint8; // 16-bit signed integer typedef signed short int\tint16; // 32-bit signed integer typedef signed int\tint32; // 64-bit signed integer typedef signed long long\tint64; TSizedDefaultAllocator 继承自 TSizedHeapAllocator， TSizedHeapAllocator中定义了SizeType，\n通过偏特化，当IndexSize是32时 ，SizeType = int32.\nElementType 作用：表示容器存储的 元素类型（如 int、FString）。 设计原因： 直接透传模板参数 InElementType，简化代码中对元素类型的引用。 1 2 3 using Array = TArray\u0026lt;AActor*\u0026gt;; //AActor* using ArrayElementType = Array::ElementType; TArray存放Actor*，那么ElementType就是AActor*类型.\nUSizeType 作用：将 SizeType 转换为 无符号整数类型（如 uint32、uint64）。 设计原因： 在需要无符号运算的场景（如内存块大小计算）避免负数溢出问题。 ElementAllocatorType 1 2 3 4 5 using ElementAllocatorType = std::conditional_t\u0026lt; AllocatorType::NeedsElementType, typename AllocatorType::template ForElementType\u0026lt;ElementType\u0026gt;, typename AllocatorType::ForAnyElementType \u0026gt;; 作用：根据分配器是否需要元素类型，选择具体的 内存分配器实现。\n设计原因：\n**NeedsElementType = true**：分配器需要知道元素类型（例如，为元素构造/析构或对齐优化）。此时使用 ForElementType\u0026lt;ElementType\u0026gt;，即与元素类型绑定的分配器。\n**NeedsElementType = false**：分配器不依赖元素类型（例如，原始内存块管理）。此时使用 ForAnyElementType，即通用分配器。\n默认的分配器定义了这个NeedsElementType类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;int IndexSize, typename BaseMallocType = FMemory\u0026gt; class TSizedHeapAllocator { public: using SizeType = typename TBitsToSizeType\u0026lt;IndexSize\u0026gt;::Type; private: using USizeType = std::make_unsigned_t\u0026lt;SizeType\u0026gt;; public: enum { NeedsElementType = true }; enum { RequireRangeCheck = true }; } 因此通过std::conditional_t的匹配，选择ForElementType\nTArray存放AActor时，类型为:TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor\u0026gt;\n1 2 // TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor*\u0026gt; using ArrayElementAllocatorType = Array::ElementAllocatorType; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using ElementAllocatorType = std::conditional_t\u0026lt; AllocatorType::NeedsElementType, typename AllocatorType::template ForElementType\u0026lt;ElementType\u0026gt;, typename AllocatorType::ForAnyElementType \u0026gt;; //---------conditional的源码---------// template \u0026lt;bool _Test, class _Ty1, class _Ty2\u0026gt; struct conditional { // Choose _Ty1 if _Test is true, and _Ty2 otherwise using type = _Ty1; }; template \u0026lt;class _Ty1, class _Ty2\u0026gt; struct conditional\u0026lt;false, _Ty1, _Ty2\u0026gt; { using type = _Ty2; }; template \u0026lt;bool _Test, class _Ty1, class _Ty2\u0026gt; using conditional_t = typename conditional\u0026lt;_Test, _Ty1, _Ty2\u0026gt;::type; 当第一个bool值为true时，即 AllocatorType::NeedsElementType 为true，\n那么conditional的type选择 AllocatorType::template ForElementType\n如果是false，conditional的type将会选择 AllocatorType::ForAnyElementType\nstatic_assert 1 static_assert(std::is_signed_v\u0026lt;SizeType\u0026gt;, \u0026#34;TArray only supports signed index types\u0026#34;); 作用：编译时检查 SizeType 是否为 有符号整数类型。\n设计原因：\n安全性：有符号整数可以表示负数，便于处理 InvalidIndex（如 INDEX_NONE = -1）。\n兼容性：UE 代码中许多接口依赖有符号索引（如 TArray::Find 返回 int32）。\n错误预防：避免用户误用无符号类型导致索引计算错误（如 0u - 1 溢出为最大值）。\n总结 组件 功能 设计目标 **SizeType** 定义索引和容量类型，由分配器决定 支持不同内存规模的容器 **ElementType** 容器存储的元素类型 泛型编程的核心 **AllocatorType** 内存分配策略（堆、栈、池等） 灵活的内存管理 **USizeType** 无符号类型，用于内存大小计算 避免无符号运算的溢出问题 **ElementAllocatorType** 根据分配器需求选择类型相关或无关的实现 优化内存操作（构造/析构、对齐） **static_assert** 强制 SizeType 为有符号类型 确保索引逻辑安全 构造函数 TArray的成员变量\n1 2 3 ElementAllocatorType AllocatorInstance; SizeType ArrayNum; SizeType ArrayMax; SizeType = int32 = signed int\nElementAllocatorType = TSizedHeapAllocator\u0026lt;32\u0026gt;::ForElementType\u0026lt;AActor*\u0026gt;\n默认构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Constructor, initializes element number counters. */ FORCEINLINE TArray() : ArrayNum(0) , ArrayMax(AllocatorInstance.GetInitialCapacity()) {} SizeType GetInitialCapacity() const { return 0; } // 创建一个空的 TArray（元素类型为 int32） TArray\u0026lt;int32\u0026gt; MyArray; // MyArray 初始状态：Num() = 0, Max() = Allocator 的初始容量（例如 4） 只定义一个TArray Array，不传入任何参数时，Num和Max都设为0.\n从原始数组构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Constructor from a raw array of elements. * * @param Ptr A pointer to an array of elements to copy. * @param Count The number of elements to copy from Ptr. * @see Append */ FORCEINLINE TArray(const ElementType* Ptr, SizeType Count) { if (Count \u0026lt; 0) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. // 首先转换为 USizeType 以防止负数大小在符号扩展时产生异常大的值。 UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)Count); } check(Ptr != nullptr || Count == 0); CopyToEmpty(Ptr, Count, 0); } // 原始 C 风格数组 int32 RawArray[] = {10, 20, 30}; // 从 RawArray 构造 TArray（复制前3个元素） TArray\u0026lt;int32\u0026gt; MyArray(RawArray, 3); // MyArray 内容：{10, 20, 30} CopyToEmpty 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template \u0026lt;typename OtherElementType, typename OtherSizeType\u0026gt; void CopyToEmpty(const OtherElementType* OtherData, OtherSizeType OtherNum, SizeType PrevMax) { //类型转换 SizeType NewNum = (SizeType)OtherNum; //检测 溢出/丢失精度 checkf((OtherSizeType)NewNum == OtherNum, TEXT(\u0026#34;Invalid number of elements to add to this array type: %lld\u0026#34;), (long long)NewNum); //更新元素数量 ArrayNum = NewNum; //如果 OtherNum 或 PrevMax 不为零，则需要调整当前数组的大小以适应新数据 if (OtherNum || PrevMax) { //调整数组的容量以适应新的元素数量。 ResizeForCopy(NewNum, PrevMax); //构造元素 ConstructItems\u0026lt;ElementType\u0026gt;((void*)GetData(), OtherData, OtherNum); } else { // 设为0 ArrayMax = AllocatorInstance.GetInitialCapacity(); } SlackTrackerNumChanged(); } ConstructItems 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Constructs a range of items into memory from a set of arguments. The arguments come from an another array. * * @param\tDest\tThe memory location to start copying into. * @param\tSource\tA pointer to the first argument to pass to the constructor. * @param\tCount\tThe number of elements to copy. */ template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; TIsBitwiseConstructible\u0026lt;DestinationElementType, SourceElementType\u0026gt;::Value) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCEINLINE void ConstructItems(void* Dest, const SourceElementType* Source, SizeType Count) { if (Count) { FMemory::Memcpy(Dest, Source, sizeof(SourceElementType) * Count); } } // template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; !TIsBitwiseConstructible\u0026lt;DestinationElementType, SourceElementType\u0026gt;::Value) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCENOINLINE void ConstructItems(void* Dest, const SourceElementType* Source, SizeType Count) { while (Count) { ::new ((void*)Dest) DestinationElementType(*Source); // Placement new 构造 ++(DestinationElementType*\u0026amp;)Dest; // 指针步进 ++Source; --Count; } } 这两个模板函数用于将源数组元素构造到目标内存中，根据类型是否支持位拷贝（bitwise copy）选择不同的构造策略。\n通过模板特化和类型特性检查，在保证类型安全的前提下，为简单类型提供高效内存拷贝，为复杂类型提供安全的逐个构造逻辑，是 UE 容器高性能设计的核心机制之一。\n第一个版本 即使用Memcpy， 是 位拷贝优化版本（快速路径）\nTIsBitwiseConstructible 类型特性检查，判断 SourceElementType 是否可以直接按位复制到 DestinationElementType 的内存中（如基本类型、POD 类型）\nFMemory::Memcpy 直接内存拷贝，效率高（O(n) 时间，无额外构造/析构调用）\n使用场景:\n基础类型：int32, float, FVector 等。 POD 类型：无自定义构造函数/析构函数的结构体。 内存布局兼容的类型：保证 Source 和 Dest 的二进制兼容性。 第二个版本 即使用while循环，是逐个构造版本（安全路径）\n!TIsBitwiseConstructible 类型不兼容位拷贝时启用此版本\nPlacement new 在目标内存地址调用构造函数（支持非 POD 类型）\n指针步进 手动移动目标指针到下一个元素位置\n使用场景:\n非 POD 类型：如包含 FString、TSharedPtr 等需要构造/析构的类型。 有自定义构造逻辑：需要调用拷贝构造函数或转换构造函数。 操作 位拷贝版本 逐个构造版本 时间复杂度 O(n)（内存连续拷贝） O(n)（循环调用构造函数） 适用类型 简单类型 复杂类型 内存安全性 依赖类型兼容性 安全 应用场景:\n容器扩容：TArray::Add 或 TArray::Append 时选择最优构造方式。 序列化：反序列化二进制数据到对象。 内存复用：重用已分配内存避免重复构造。 从TArrayView构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename OtherElementType, typename OtherSizeType\u0026gt; explicit TArray(const TArrayView\u0026lt;OtherElementType, OtherSizeType\u0026gt;\u0026amp; Other); //--------------// template\u0026lt;typename InElementType, typename InAllocatorType\u0026gt; template\u0026lt;typename OtherElementType, typename OtherSizeType\u0026gt; FORCEINLINE TArray\u0026lt;InElementType, InAllocatorType\u0026gt;::TArray(const TArrayView\u0026lt;OtherElementType, OtherSizeType\u0026gt;\u0026amp; Other) { CopyToEmpty(Other.GetData(), Other.Num(), 0); } // 原始 C 风格数组 int32 RawArray[] = {10, 20, 30}; // 创建一个 TArrayView（视图） TArrayView\u0026lt;int32\u0026gt; View = MakeArrayView(RawArray, 3); // 从 View 构造 TArray（复制数据） TArray\u0026lt;int32\u0026gt; MyArray(View); // MyArray 内容：{10, 20, 30} 初始化列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Initializer list constructor */ TArray(std::initializer_list\u0026lt;InElementType\u0026gt; InitList) { // This is not strictly legal, as std::initializer_list\u0026#39;s iterators are not guaranteed to be pointers, but // this appears to be the case on all of our implementations. Also, if it\u0026#39;s not true on a new implementation, // it will fail to compile rather than behave badly. CopyToEmpty(InitList.begin(), (SizeType)InitList.size(), 0); } // 直接通过初始化列表构造 TArray\u0026lt;FString\u0026gt; MyArray = {\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;}; // MyArray 内容：{\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;} 注释里面叽里呱啦说啥呢？\n// 严格来说，这是不合法的，因为 std::initializer_list 的迭代器并不保证是指针，\n// 但是在我们所有的实现中似乎都是这样的情况。此外，如果在新的实现中它不是指针，\n// 那么它将会编译失败，而不是表现糟糕。\n合法性问题：从技术上讲，假设 std::initializer_list 的迭代器是指针是不符合标准的，因为标准并没有保证这一点。\n实际实现情况：尽管标准没有保证，但在当前的所有实现中，这些迭代器实际上确实是指针。\n安全性：如果在未来某个新的实现中，这种假设不再成立（即迭代器不是指针），那么代码会在编译时就报错，而不是在运行时产生难以调试的行为问题。这提供了一种早期检测错误的方式，避免了潜在的运行时错误。\n跨分配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Copy constructor with changed allocator. Use the common routine to perform the copy. * * @param Other The source array to copy. */ template \u0026lt; typename OtherElementType, typename OtherAllocator UE_REQUIRES(UE::Core::Private::TArrayElementsAreCompatible_V\u0026lt;ElementType, const OtherElementType\u0026amp;\u0026gt;) \u0026gt; FORCEINLINE explicit TArray(const TArray\u0026lt;OtherElementType, OtherAllocator\u0026gt;\u0026amp; Other) { CopyToEmpty(Other.GetData(), Other.Num(), 0); } // 源数组（使用默认分配器） TArray\u0026lt;int32, FDefaultAllocator\u0026gt; SourceArray = {1, 2, 3}; // 目标数组（使用其他分配器，如栈分配器） TArray\u0026lt;int32, TInlineAllocator\u0026lt;16\u0026gt;\u0026gt; MyArray(SourceArray); // MyArray 内容：{1, 2, 3}（元素类型兼容即可拷贝） 拷贝构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Copy constructor. Use the common routine to perform the copy. * * @param Other The source array to copy. */ FORCEINLINE TArray(const TArray\u0026amp; Other) { CopyToEmpty(Other.GetData(), Other.Num(), 0); } TArray\u0026lt;FVector\u0026gt; SourceArray; SourceArray.Add(FVector(1.0f, 2.0f, 3.0f)); // 拷贝构造 TArray\u0026lt;FVector\u0026gt; MyArray(SourceArray); // MyArray 内容：{FVector(1,2,3)} 带预分配内存的拷贝构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Copy constructor. Use the common routine to perform the copy. * * @param Other The source array to copy. * @param ExtraSlack Tells how much extra memory should be preallocated * at the end of the array in the number of elements. */ FORCEINLINE TArray(const TArray\u0026amp; Other, SizeType ExtraSlack) { CopyToEmptyWithSlack(Other.GetData(), Other.Num(), 0, ExtraSlack); } TArray\u0026lt;int32\u0026gt; SourceArray = {100, 200}; // 拷贝构造并预留 5 个额外空间 TArray\u0026lt;int32\u0026gt; MyArray(SourceArray, 5); // MyArray 内容：{100, 200} // MyArray 容量：2（元素数） + 5（额外空间） = 7 ExtraSlack 数组末尾按元素的数量预先分配多少额外内存。\n移动构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 FORCEINLINE TArray(TArray\u0026amp;\u0026amp; Other) { MoveOrCopy(*this, Other, 0); } //-------------------------// template \u0026lt; typename OtherElementType, typename OtherAllocator UE_REQUIRES(UE::Core::Private::TArrayElementsAreCompatible_V\u0026lt;ElementType, OtherElementType\u0026amp;\u0026amp;\u0026gt;) \u0026gt; FORCEINLINE explicit TArray(TArray\u0026lt;OtherElementType, OtherAllocator\u0026gt;\u0026amp;\u0026amp; Other) { MoveOrCopy(*this, Other, 0); } //---------------------------// template \u0026lt; typename OtherElementType UE_REQUIRES(UE::Core::Private::TArrayElementsAreCompatible_V\u0026lt;ElementType, OtherElementType\u0026amp;\u0026amp;\u0026gt;) \u0026gt; TArray(TArray\u0026lt;OtherElementType, AllocatorType\u0026gt;\u0026amp;\u0026amp; Other, SizeType ExtraSlack) { MoveOrCopyWithSlack(*this, Other, 0, ExtraSlack); } MoveOrCpoy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 template \u0026lt;typename FromArrayType, typename ToArrayType\u0026gt; static FORCEINLINE void MoveOrCopy(ToArrayType\u0026amp; ToArray, FromArrayType\u0026amp; FromArray, SizeType PrevMax) { if constexpr (UE::Core::Private::CanMoveTArrayPointersBetweenArrayTypes\u0026lt;FromArrayType, ToArrayType\u0026gt;()) { // Move static_assert(std::is_same_v\u0026lt;TArray, ToArrayType\u0026gt;, \u0026#34;MoveOrCopy is expected to be called with the current array type as the destination\u0026#34;); using FromAllocatorType = typename FromArrayType::AllocatorType; using ToAllocatorType = typename ToArrayType::AllocatorType; if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } ToArray .ArrayNum = (SizeType)FromArray.ArrayNum; ToArray .ArrayMax = (SizeType)FromArray.ArrayMax; // Ensure the destination container could hold the source range (when the allocator size types shrink) if constexpr (sizeof(USizeType) \u0026lt; sizeof(typename FromArrayType::USizeType)) { if (ToArray.ArrayNum != FromArray.ArrayNum || ToArray.ArrayMax != FromArray.ArrayMax) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)ToArray.ArrayNum); } } FromArray.ArrayNum = 0; FromArray.ArrayMax = FromArray.AllocatorInstance.GetInitialCapacity(); FromArray.SlackTrackerNumChanged(); ToArray.SlackTrackerNumChanged(); } else { // Copy ToArray.CopyToEmpty(FromArray.GetData(), FromArray.Num(), PrevMax); } } MoveOrCopy 是用于在两个 TArray（或类似容器）之间高效地 移动或拷贝数据 的模板函数。\n其核心逻辑是：\n移动（Move）：若源数组（FromArray）和目标数组（ToArray）的 内存分配器（Allocator）和元素类型兼容，直接转移内存所有权（零拷贝）。 拷贝（Copy）：若条件不满足，则执行深拷贝。 片段1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } //------------------------------------------------// template \u0026lt;typename FromAllocatorType, typename ToAllocatorType\u0026gt; struct TCanMoveBetweenAllocators { enum { Value = false }; }; template \u0026lt;uint8 FromIndexSize, uint8 ToIndexSize\u0026gt; struct TCanMoveBetweenAllocators\u0026lt;TSizedHeapAllocator\u0026lt;FromIndexSize\u0026gt;, TSizedHeapAllocator\u0026lt;ToIndexSize\u0026gt;\u0026gt; { // Allow conversions between different int width versions of the allocator enum { Value = true }; }; template \u0026lt;uint8 FromIndexSize, uint8 ToIndexSize\u0026gt; struct TCanMoveBetweenAllocators\u0026lt;TSizedDefaultAllocator\u0026lt;FromIndexSize\u0026gt;, TSizedDefaultAllocator\u0026lt;ToIndexSize\u0026gt;\u0026gt; : TCanMoveBetweenAllocators\u0026lt;typename TSizedDefaultAllocator\u0026lt;FromIndexSize\u0026gt;::Typedef, typename TSizedDefaultAllocator\u0026lt;ToIndexSize\u0026gt;::Typedef\u0026gt; {}; TCanMoveBetweenAllocators 接受两个模板参数\n传入的两个都不是TSizedHeapAllocator或TSizedDefaultAllocator，Value为false，\n传入的都是TSizedHeapAllocator，Value为true\n传入的都是TSizedDefaultAllocator，则根据TSizedDefaultAllocator内部的兼容性判断true和false.\nValue=true 调用MoveToEmptyFromOtherAllocator\nValue=false 调用MoveToEmpty\n高僧解释:\nTCanMoveBetweenAllocators :你给我传的是什么东西我请问了，\n传俩TSizedHeapAllocator给我，OK 我回答你true.\n传俩TSizedDefaultAllocator，我只能说 具体问题具体分析.\n传来两个既不是TSizedHeapAllocator 也不是 TSizedDefaultAllocator，那我只能告诉你 false.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } //-----------------------------------// template \u0026lt;typename OtherAllocator\u0026gt; FORCEINLINE void MoveToEmptyFromOtherAllocator(typename OtherAllocator::ForAnyElementType\u0026amp; Other) { // 检查当前分配器实例和传入的分配器实例不是同一个对象 checkSlow((void*)this != (void*)\u0026amp;Other); // 如果当前分配器已经有分配的数据，则释放这些数据 if (Data) { BaseMallocType::Free(Data); } // 将源分配器的数据指针赋值给当前分配器 Data = Other.Data; // 将源分配器的数据指针设置为 nullptr，表示它现在为空 Other.Data = nullptr; } FORCEINLINE void MoveToEmpty(ForAnyElementType\u0026amp; Other) { // 调用模板函数，指定 TSizedHeapAllocator 作为模板参数 this-\u0026gt;MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026gt;(Other); } 这两段代码的核心区别在于 分配器类型兼容性处理，具体分为两种情况：\n1. 当分配器类型兼容时 (TCanMoveBetweenAllocators = true)\n模板参数：显式指定源分配器类型 FromAllocatorType。 目的： 当源分配器和目标分配器 类型不同但兼容（如 TSizedHeapAllocator\u0026lt;32\u0026gt; 和 TSizedHeapAllocator\u0026lt;64\u0026gt;），通过模板参数传递源分配器的类型，确保正确调用其内存管理逻辑（如释放旧内存、接管新内存）。 示例场景： 源数组使用 TSizedHeapAllocator\u0026lt;32\u0026gt;，目标数组使用 TSizedHeapAllocator\u0026lt;64\u0026gt;，但两者支持跨分配器移动。 2. 当分配器类型不兼容时 (TCanMoveBetweenAllocators = false)\n实际调用： MoveToEmpty 内部调用 MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026gt;，即强制将源分配器视为默认的 TSizedHeapAllocator。 目的： 当分配器类型 不兼容 时，假设源分配器与目标分配器共享相同的默认内存管理策略（如堆分配），直接通过默认逻辑转移内存。 风险： 若源分配器实际类型非 TSizedHeapAllocator，可能导致未定义行为（如内存泄漏或崩溃）。因此此路径仅在类型严格兼容时安全。 场景 1：同类型分配器移动\n1 2 TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt; Source, Dest; MoveOrCopy(Dest, Source, 0); 调用路径： MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt;。 行为： 安全转移内存，无额外开销。 场景 2：不同类型分配器移动（但兼容）\n1 2 3 TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt; Source; TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;64\u0026gt;\u0026gt; Dest; MoveOrCopy(Dest, Source, 0); 调用路径： MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt;。 行为： 根据源分配器类型释放旧内存，正确接管新内存。 场景 3：不兼容分配器移动\n1 2 3 TArray\u0026lt;int32, TInlineAllocator\u0026lt;16\u0026gt;\u0026gt; Source; TArray\u0026lt;int32, TSizedHeapAllocator\u0026lt;32\u0026gt;\u0026gt; Dest; MoveOrCopy(Dest, Source, 0); 调用路径： MoveToEmpty → MoveToEmptyFromOtherAllocator\u0026lt;TSizedHeapAllocator\u0026gt;。 行为： 错误！TInlineAllocator（栈分配）与 TSizedHeapAllocator（堆分配）策略不同，强制转换导致未定义行为。 条件 调用方式 安全性 适用场景 分配器兼容 (TCanMove=true) 显式模板参数传递 (FromAllocatorType) 高 不同类型但内存策略兼容的分配器 分配器不兼容 (TCanMove=false) 强制默认分配器类型 (TSizedHeapAllocator) 低 仅限同类型或设计确保安全的分配器 设计原则：\n零开销抽象：通过编译时分支选择最优路径。 类型安全：利用模板特性确保内存操作正确性。 扩展性：允许自定义分配器通过特化声明兼容性。 最佳实践：\n自定义分配器：若需支持跨类型移动，需特化 TCanMoveBetweenAllocators。 谨慎使用默认路径：确保不兼容分配器的移动操作在设计中无害。 片段2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ToArray.ArrayNum = (SizeType)FromArray.ArrayNum; ToArray.ArrayMax = (SizeType)FromArray.ArrayMax; // 确保目标容器能够容纳源容器中的数据范围，特别是在分配器大小类型缩小的情况下。 // 检查目标容器的大小类型 USizeType 是否比源容器的大小类型小。 if constexpr (sizeof(USizeType) \u0026lt; sizeof(typename FromArrayType::USizeType)) { //检查目标容器的当前元素数量 (ArrayNum) 和最大容量 (ArrayMax) 是否与源容器相匹配。 if (ToArray.ArrayNum != FromArray.ArrayNum || ToArray.ArrayMax != FromArray.ArrayMax) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)ToArray.ArrayNum); } } //----------------------------------------------------------------// void UE::Core::Private::OnInvalidArrayNum(unsigned long long NewNum) { UE_LOG(LogCore, Fatal, TEXT(\u0026#34;Trying to resize TArray to an invalid size of %llu\u0026#34;), NewNum); for (;;); } UE::Core::Private::OnInvalidArrayNum Log使用了Fatal，引擎崩溃报错.\n1 2 3 4 FromArray.ArrayNum = 0; FromArray.ArrayMax = FromArray.AllocatorInstance.GetInitialCapacity(); FromArray.SlackTrackerNumChanged(); ToArray.SlackTrackerNumChanged(); FromArray的ArrayNum、ArrayMax设置为0，\n总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 if constexpr (UE::Core::Private::CanMoveTArrayPointersBetweenArrayTypes\u0026lt;FromArrayType, ToArrayType\u0026gt;()) { // Move static_assert(std::is_same_v\u0026lt;TArray, ToArrayType\u0026gt;, \u0026#34;MoveOrCopy is expected to be called with the current array type as the destination\u0026#34;); using FromAllocatorType = typename FromArrayType::AllocatorType; using ToAllocatorType = typename ToArrayType::AllocatorType; //判断传入的两个分配器能否移动 if constexpr (TCanMoveBetweenAllocators\u0026lt;FromAllocatorType, ToAllocatorType\u0026gt;::Value) { //移动分配器 ToArray.AllocatorInstance.template MoveToEmptyFromOtherAllocator\u0026lt;FromAllocatorType\u0026gt;(FromArray.AllocatorInstance); } else { ToArray.AllocatorInstance.MoveToEmpty(FromArray.AllocatorInstance); } //拿来吧你 ToArray .ArrayNum = (SizeType)FromArray.ArrayNum; ToArray .ArrayMax = (SizeType)FromArray.ArrayMax; // 确保目标容器能够容纳源容器中的数据范围，特别是在分配器大小类型缩小的情况下。 // 检查目标容器的大小类型 USizeType 是否比源容器的大小类型小。 if constexpr (sizeof(USizeType) \u0026lt; sizeof(typename FromArrayType::USizeType)) { //检查目标容器的当前元素数量 (ArrayNum) 和最大容量 (ArrayMax) 是否与源容器相匹配。 if (ToArray.ArrayNum != FromArray.ArrayNum || ToArray.ArrayMax != FromArray.ArrayMax) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. // 触发崩溃 UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)ToArray.ArrayNum); } } //FromArray的ArrayNum、ArrayMax设为0 FromArray.ArrayNum = 0; FromArray.ArrayMax = FromArray.AllocatorInstance.GetInitialCapacity(); FromArray.SlackTrackerNumChanged(); ToArray.SlackTrackerNumChanged(); } 析构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** Destructor. */ ~TArray() { DestructItems(GetData(), ArrayNum); // note ArrayNum, ArrayMax and data pointer are not invalidated // they are left unchanged and use-after-destruct will see them the same as before destruct } //--------------------------------// template \u0026lt; typename ElementType, typename SizeType UE_REQUIRES(sizeof(ElementType) \u0026gt; 0 \u0026amp;\u0026amp; std::is_trivially_destructible_v\u0026lt;ElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCEINLINE void DestructItems(ElementType* Element, SizeType Count) { } template \u0026lt; typename ElementType, typename SizeType UE_REQUIRES(sizeof(ElementType) \u0026gt; 0 \u0026amp;\u0026amp; !std::is_trivially_destructible_v\u0026lt;ElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCENOINLINE void DestructItems(ElementType* Element, SizeType Count) { while (Count) { // We need a typedef here because VC won\u0026#39;t compile the destructor call below if ElementType itself has a member called ElementType typedef ElementType DestructItemsElementTypeTypedef; Element-\u0026gt;DestructItemsElementTypeTypedef::~DestructItemsElementTypeTypedef(); ++Element; --Count; } } is_trivially_destructible_v 检查给定类型的析构函数是否是平凡的（trivial）。\n平凡析构函数：类型没有用户定义的析构函数，所有非静态成员和基类都有平凡析构函数。\n示例：基本数据类型、简单的POD（Plain Old Data）结构体、某些标准库类型（如 std::array 当元素类型为平凡类型时）。\n非平凡析构函数：类型有用户定义的析构函数，或者其成员或基类有非平凡析构函数。\n示例：用户定义析构函数的类、包含标准库容器（如 std::vector）的类、从具有非平凡析构函数的基类派生的类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;array\u0026gt; // 基本数据类型 std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;int\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true // 简单结构体 struct Trivial { int x; double y; }; std::cout \u0026lt;\u0026lt; \u0026#34;Trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;Trivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true // 用户定义析构函数 struct NonTrivial { ~NonTrivial() noexcept {} int x; double y; }; std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;NonTrivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 成员类型有非平凡析构函数 struct NonTrivialMember { std::string str; }; std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivialMember: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;NonTrivialMember\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 基类有非平凡析构函数 struct Base { ~Base() noexcept {} }; struct Derived : public Base { int x; }; std::cout \u0026lt;\u0026lt; \u0026#34;Derived: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;Derived\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 标准库容器 std::vector\u0026lt;int\u0026gt; vec; std::cout \u0026lt;\u0026lt; \u0026#34;std::vector\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;decltype(vec)\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 标准库类型（当元素类型为平凡类型时） std::array\u0026lt;int, 5\u0026gt; arr; std::cout \u0026lt;\u0026lt; \u0026#34;std::array\u0026lt;int, 5\u0026gt;: \u0026#34; \u0026lt;\u0026lt; std::is_trivially_destructible_v\u0026lt;decltype(arr)\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true POD\n根据C++标准，POD类型必须满足以下条件：\n平凡的默认构造函数（Trivial Default Constructor）： 类型没有用户定义的默认构造函数，或者它的默认构造函数是平凡的（即编译器生成的默认构造函数）。 平凡的析构函数（Trivial Destructor）： 类型没有用户定义的析构函数，或者它的析构函数是平凡的（即编译器生成的析构函数）。 平凡的拷贝/移动操作（Trivial Copy/Move Operations）： 类型没有用户定义的拷贝构造函数、拷贝赋值运算符、移动构造函数或移动赋值运算符，或者这些操作是平凡的（即编译器生成的操作）。 标准布局（Standard Layout）： 类型的所有非静态数据成员都具有相同的访问控制（public, protected, private），并且基类和非静态数据成员不能有虚函数或虚基类。\n所有非静态数据成员都必须具有标准布局类型（standard-layout type）。\n类型没有虚函数或虚基类。\n**std::is_trivial**：检查类型是否有平凡的构造函数、析构函数和拷贝/移动操作。\n**std::is_standard_layout**：检查类型是否具有标准布局。\n平凡类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; struct Trivial { int x; double y; }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; // 检查是否为平凡类型 std::cout \u0026lt;\u0026lt; \u0026#34;Trivial is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;Trivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true // 检查是否为标准布局类型 std::cout \u0026lt;\u0026lt; \u0026#34;Trivial is standard layout: \u0026#34; \u0026lt;\u0026lt; std::is_standard_layout_v\u0026lt;Trivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: true return 0; } 非平凡类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #include \u0026lt;string\u0026gt; struct NonTrivial { ~NonTrivial() noexcept {} int x; double y; }; struct NonStandardLayout { virtual void foo() {} int x; double y; }; struct NonTrivialMember { std::string str; int x; double y; }; int main() { std::cout \u0026lt;\u0026lt; std::boolalpha; // 检查是否为平凡类型 std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivial is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;NonTrivial\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false std::cout \u0026lt;\u0026lt; \u0026#34;NonStandardLayout is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;NonStandardLayout\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false std::cout \u0026lt;\u0026lt; \u0026#34;NonTrivialMember is trivial: \u0026#34; \u0026lt;\u0026lt; std::is_trivial_v\u0026lt;NonTrivialMember\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false // 检查是否为标准布局类型 std::cout \u0026lt;\u0026lt; \u0026#34;NonStandardLayout is standard layout: \u0026#34; \u0026lt;\u0026lt; std::is_standard_layout_v\u0026lt;NonStandardLayout\u0026gt; \u0026lt;\u0026lt; std::endl; // 输出: false return 0; } TArray存放的 对象类型 与 析构时DestructItems:\n**平凡类型（int、float、原始指针等）**触发空实现，无额外操作。 **非平凡类型（如含资源的类）**触发显式析构，确保资源释放。 指针类型始终触发空实现，需手动管理指向的内存。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 当TArray存放需要显式析构的类型时（即非平凡可析构类型，如拥有自定义析构函数的类）， 会调用第二个版本的DestructItems，从而逐个调用元素的析构函数。 调用第一个空实现的DestructItems的影响： 对于平凡可析构类型（如int、float、指针等），这是安全的，因为它们无需显式析构。 但如果错误地应用于非平凡类型（如资源持有类），会导致资源泄漏，因为析构函数未被调用。 存放 int、float等基础类型 时： 调用第一个版本的DestructItems，因为它们属于平凡可析构类型。 存放 int*、float*指针 时： 同样调用第一个版本，指针类型自身是平凡可析构的。注意指针指向的内存不会被自动释放。 存放 有析构函数的类Obj 时： 存放Obj对象（TArray\u0026lt;Obj\u0026gt;）：Obj非平凡可析构，调用第二个版本，显式析构每个元素。 存放Obj*指针（TArray\u0026lt;Obj*\u0026gt;）：指针类型平凡可析构，调用第一个版本，不析构指针指向的对象。 存放 无析构函数的类Obj2 时： 存放Obj2对象（TArray\u0026lt;Obj2\u0026gt;）：若Obj2及其成员均为平凡类型，调用第一个版本； 则（如含非平凡成员），调用第二个版本。 存放Obj2*指针（TArray\u0026lt;Obj2*\u0026gt;）：调用第一个版本，指针自身无需析构。 总结 构造函数 示例场景 默认构造 创建空数组 原始数组构造 从 C 数组或内存块初始化 TArrayView 构造 从数据视图（无所有权）初始化 初始化列表构造 快速初始化小型数组 跨分配器拷贝 不同内存策略的数组间复制数据 普通拷贝构造 同类型数组的深拷贝 带额外容量的拷贝构造 预分配空间以减少后续扩容开销 移动构造 减少临时对象的开销 增删改查 方法 功能 时间复杂度 示例 Push / Add 在数组末尾添加元素 均摊 O(1) TArray\u0026lt;int\u0026gt; arr; ``arr.Add(1); Pop 移除并返回数组末尾元素 O(1) int val = arr.Pop(); Top / Last 获取数组末尾元素（不移除） O(1) int val = arr.Last(); Emplace 在末尾直接构造元素（避免拷贝） 均摊 O(1) arr.Emplace(42); Pop Pop 函数是 TArray 类中的一个成员函数，用于从数组中移除并返回最后一个元素。\n这个函数还提供了可选的收缩（shrink）功能，允许在移除元素后调整数组的容量以节省内存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // * * // *从数组中弹出元素。 // * // * @param allowshrink是否允许在删除元素期间收缩数组。 // * @返回弹出的元素。 // * ElementType Pop(EAllowShrinking AllowShrinking = EAllowShrinking::Yes) { //确保数组至少有一个元素 RangeCheck(0); //获取数组中最后一个元素（索引为 ArrayNum - 1）。 //使用 MoveTempIfPossible 将其转换为右值引用，从而启用移动语义。 //这可以避免不必要的拷贝操作，提高性能。 ElementType Result = MoveTempIfPossible(GetData()[ArrayNum - 1]); //从数组中移除最后一个元素。 RemoveAtImpl(ArrayNum - 1); if (AllowShrinking == EAllowShrinking::Yes) { //释放未使用的内存。 ResizeShrink(); } return Result; } template \u0026lt;typename T\u0026gt; UE_INTRINSIC_CAST FORCEINLINE constexpr std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp; MoveTempIfPossible(T\u0026amp;\u0026amp; Obj) noexcept { //定义一个类型别名 CastType，它是移除了引用属性后的 T 类型。 using CastType = std::remove_reference_t\u0026lt;T\u0026gt;; //将传入的对象 Obj 转换为右值引用，并返回。 //这样做的目的是启用移动语义。 return (CastType\u0026amp;\u0026amp;)Obj; } MoveTempIfPossible 右值引用 参数 **T\u0026amp;\u0026amp; Obj**：使用了通用引用（universal reference），可以接受左值引用或右值引用。 返回类型 **std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp;**：移除 T 的引用属性后将其转换为右值引用。 将一个引用转换为右值引用（rvalue reference）， 这是 UE 中 std::move 的等价实现。\n与 MoveTemp 不同，它不会进行静态断言，因此在模板或宏中使用时更加灵活，不会中断编译。\n因为在模板或宏中使用时，参数的具体类型可能不明确，但你仍然希望在可以的情况下利用移动语义，而不中断编译。\n左值右值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyClass { public: MyClass() = default; MyClass(MyClass\u0026amp;\u0026amp; other) noexcept { // 移动构造函数的实现 } }; // 使用 MoveTempIfPossible template \u0026lt;typename T\u0026gt; void ProcessObject(T\u0026amp;\u0026amp; Obj) { MyClass MovedObj = MoveTempIfPossible(Obj); } int main() { MyClass Obj; ProcessObject(Obj); // 左值引用 ProcessObject(MyClass()); // 右值引用 return 0; } Obj 是一个左值引用。MoveTempIfPossible 会将其转换为右值引用，从而触发移动构造函数。 MyClass() 是一个临时对象（右值）。MoveTempIfPossible 也会将其转换为右值引用，从而触发移动构造函数。 Add 在数组末尾添加一个新项，可能会重新分配整个数组以容纳它。\n返回一个索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 FORCEINLINE SizeType Add(const ElementType\u0026amp; Item) { CheckAddress(\u0026amp;Item); return Emplace(Item); } FORCEINLINE SizeType Add(ElementType\u0026amp;\u0026amp; Item) { CheckAddress(\u0026amp;Item); return Emplace(MoveTempIfPossible(Item)); } // 检查指定的地址是否不是容器内元素的一部分。 // 用于在实现中检查引用参数是否会因为可能的重新分配而失效。 FORCEINLINE void CheckAddress(const ElementType* Addr) const { checkf(Addr \u0026lt; GetData() || Addr \u0026gt;= (GetData() + ArrayMax), TEXT(\u0026#34;Attempting to use a container element (%p) which already comes from the container being modified (%p, ArrayMax: %lld, ArrayNum: %lld, SizeofElement: %d)!\u0026#34;), Addr, GetData(), (long long)ArrayMax, (long long)ArrayNum, sizeof(ElementType)); } Emplace 在数组的末尾构造一个新元素，可能会重新分配整个数组来容纳它。\n返回一个索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * Constructs a new item at the end of the array, possibly reallocating the whole array to fit. * * @param Args The arguments to forward to the constructor of the new item. * @return Index to the new item */ template \u0026lt;typename... ArgsType\u0026gt; FORCEINLINE SizeType Emplace(ArgsType\u0026amp;\u0026amp;... Args) { //增加数组的大小，并返回新元素将要插入的位置索引。 const SizeType Index = AddUninitialized(); //GetData() 返回指向数组数据的指针，GetData() + Index 计算出新元素应放置的位置。 //使用 ::new 进行原位构造（placement new）， //直接在指定内存位置构造新对象，避免额外的拷贝或移动操作。 //Forward\u0026lt;ArgsType\u0026gt;(Args)... 将参数完美转发给构造函数。 ::new((void*)(GetData() + Index)) ElementType(Forward\u0026lt;ArgsType\u0026gt;(Args)...); return Index; } FORCEINLINE SizeType AddUninitialized() { //确保数组内部状态的一致性，防止非法状态。 //checkSlow((ArrayNum \u0026gt;= 0) \u0026amp; (ArrayMax \u0026gt;= ArrayNum)); CheckInvariants(); // ArrayNum = ArrayNum + 1 const USizeType OldNum = (USizeType)ArrayNum; const USizeType NewNum = OldNum + (USizeType)1; ArrayNum = (SizeType)NewNum; if (NewNum \u0026gt; (USizeType)ArrayMax) { //如果 NewNum 超过了 ArrayMax，则调用 ResizeGrow 增加数组的容量。 ResizeGrow((SizeType)OldNum); } else { //调用 SlackTrackerNumChanged 更新松弛（slack）信息。 SlackTrackerNumChanged(); } //返回 OldNum，即新元素将要插入的位置索引。 return OldNum; } FPrivateToken 让TArray可以调用私有构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 class FMyType { private: struct FPrivateToken { explicit FPrivateToken() = default; }; public: // This has an equivalent access level to a private constructor, // as only friends of FMyType will have access to FPrivateToken, // but Emplace can legally call it since it\u0026#39;s public. explicit FMyType(FPrivateToken, int32 Int, float Real, const TCHAR* String); }; TArray\u0026lt;FMyType\u0026gt; Arr; Arr.Emplace(FMyType::FPrivateToken{}, 5, 3.14f, TEXT(\u0026#34;Banana\u0026#34;)); Remove 1 2 3 4 5 6 7 8 9 SizeType Remove(const ElementType\u0026amp; Item) { // 检查指定的地址是否不是容器内元素的一部分。 CheckAddress(\u0026amp;Item); // Element is non-const to preserve compatibility with existing code with a non-const operator==() member function // 元素是非 const 的，以保持与现有代码中具有非 const operator==() 成员函数的兼容性 return RemoveAll([\u0026amp;Item](ElementType\u0026amp; Element) { return Element == Item; }); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 template \u0026lt;class PREDICATE_CLASS\u0026gt; SizeType RemoveAll(const PREDICATE_CLASS\u0026amp; Predicate) { //如果为空，则直接返回 0，因为没有元素可以移除。 //OriginalNum 记录数组的原始大小 const SizeType OriginalNum = ArrayNum; if (!OriginalNum) { return 0; // nothing to do, loop assumes one item so need to deal with this edge case here } //指向数组数据的指针。 ElementType* Data = GetData(); //WriteIndex ReadIndex分别用于写入和读取操作的索引。 SizeType WriteIndex = 0; //不断增加，直到遇到与当前运行类型不同的元素。 SizeType ReadIndex = 0; //根据第一个元素是否满足谓词，初始化 bNotMatch 变量。 //如果bNotMatch = false，则说明匹配成功，在do-while中的if-else会执行false分支 //else分支调用DestructItems，销毁元素 //如果bNotMatch = true，匹配失败，if-else执行true分支，移动元素重新排序 bool bNotMatch = !::Invoke(Predicate, Data[ReadIndex]); // use a ! to guarantee it can\u0026#39;t be anything other than zero or one do { //记录当前运行的起始位置。 SizeType RunStartIndex = ReadIndex++; while (ReadIndex \u0026lt; OriginalNum \u0026amp;\u0026amp; bNotMatch == !::Invoke(Predicate, Data[ReadIndex])) { ReadIndex++; } //计算当前运行的长度。 SizeType RunLength = ReadIndex - RunStartIndex; checkSlow(RunLength \u0026gt; 0); if (bNotMatch) { // this was a non-matching run, we need to move it if (WriteIndex != RunStartIndex) { //将这些元素移动到 WriteIndex 指向的位置 RelocateConstructItems\u0026lt;ElementType\u0026gt;((void*)(Data + WriteIndex), Data + RunStartIndex, RunLength); } //更新 WriteIndex，使其指向下一个需要写入数据的位置。 WriteIndex += RunLength; } else { // this was a matching run, delete it //销毁这些元素。 DestructItems(Data + RunStartIndex, RunLength); } bNotMatch = !bNotMatch; } while (ReadIndex \u0026lt; OriginalNum); ArrayNum = WriteIndex; SlackTrackerNumChanged(); //返回被移除的元素数量，即原始数组大小减去当前数组大小。 return OriginalNum - ArrayNum; } 模板参数 **PREDICATE_CLASS**：谓词类实例的类型。 参数 **Predicate**：一个谓词对象，用于判断某个元素是否需要被移除。 返回值 **SizeType**：返回被移除的元素数量。 获取原始数组大小： 如果数组为空，直接返回 0。 初始化变量： 获取数组数据指针 Data。 初始化读取索引 ReadIndex 和写入索引 WriteIndex。 根据第一个元素的状态初始化 bNotMatch 变量。 遍历数组： 使用 do...while 循环遍历数组，每次处理一段连续的匹配或非匹配元素段（运行）。 内层循环：找到一段连续的匹配或非匹配元素。 处理非匹配运行：将这些元素移动到 WriteIndex 指向的位置，并更新 WriteIndex。 处理匹配运行：销毁这些元素。 切换 bNotMatch 的值，准备处理下一个运行。 更新数组大小： 更新数组的有效元素数量 ArrayNum 为 WriteIndex。 返回结果： 返回被移除的元素数量。 RemoveAt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void RemoveAt(SizeType Index, EAllowShrinking AllowShrinking = EAllowShrinking::Yes) { RangeCheck(Index); RemoveAtImpl(Index); if (AllowShrinking == EAllowShrinking::Yes) { // 根据需要 缩小数组大小 ResizeShrink(); } } void RemoveAtImpl(SizeType Index) { // 获取要移除元素的位置 ElementType* Dest = GetData() + Index; // 销毁该位置的元素 DestructItem(Dest); // Skip relocation in the common case that there is nothing to move. // 在没有东西可移动的情况下，跳过重定位。 SizeType NumToMove = (ArrayNum - Index) - 1; if (NumToMove) { RelocateConstructItems\u0026lt;ElementType\u0026gt;((void*)Dest, Dest + 1, NumToMove); //将一组元素从一个位置移动到另一个位置 //传入参数是两个指针，所以TCanBitwiseRelocate_V通过，则调用的函数是: //FMemory::Memmove(Dest, Source, sizeof(SourceElementType) * Count); } // 减少数组的有效元素数量 --ArrayNum; // 更新松弛信息（如果有的话） SlackTrackerNumChanged(); } 1 2 3 4 5 6 7 8 9 namespace UE::Core::Private::MemoryOps { template \u0026lt;typename DestinationElementType, typename SourceElementType\u0026gt; constexpr inline bool TCanBitwiseRelocate_V = std::is_same_v\u0026lt;DestinationElementType, SourceElementType\u0026gt; || ( TIsBitwiseConstructible\u0026lt;DestinationElementType, SourceElementType\u0026gt;::Value \u0026amp;\u0026amp; std::is_trivially_destructible_v\u0026lt;SourceElementType\u0026gt; ); } 条件:\n如果 DestinationElementType 和 SourceElementType 是相同的类型。 DestinationElementType 可以从 SourceElementType 逐位构造，并且 SourceElementType 是平凡可析构的（trivially destructible）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; UE::Core::Private::MemoryOps::TCanBitwiseRelocate_V\u0026lt;DestinationElementType, SourceElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCEINLINE void RelocateConstructItems(void* Dest, SourceElementType* Source, SizeType Count) { static_assert(!std::is_const_v\u0026lt;SourceElementType\u0026gt;, \u0026#34;RelocateConstructItems: Source cannot be const\u0026#34;); /* All existing UE containers seem to assume trivial relocatability (i.e. memcpy\u0026#39;able) of their members, * so we\u0026#39;re going to assume that this is safe here. However, it\u0026#39;s not generally possible to assume this * in general as objects which contain pointers/references to themselves are not safe to be trivially * relocated. * * However, it is not yet possible to automatically infer this at compile time, so we can\u0026#39;t enable * different (i.e. safer) implementations anyway. */ FMemory::Memmove(Dest, Source, sizeof(SourceElementType) * Count); } template \u0026lt; typename DestinationElementType, typename SourceElementType, typename SizeType UE_REQUIRES(sizeof(DestinationElementType) \u0026gt; 0 \u0026amp;\u0026amp; sizeof(SourceElementType) \u0026gt; 0 \u0026amp;\u0026amp; !UE::Core::Private::MemoryOps::TCanBitwiseRelocate_V\u0026lt;DestinationElementType, SourceElementType\u0026gt;) // the sizeof here should improve the error messages we get when we try to call this function with incomplete types \u0026gt; FORCENOINLINE void RelocateConstructItems(void* Dest, SourceElementType* Source, SizeType Count) { static_assert(!std::is_const_v\u0026lt;SourceElementType\u0026gt;, \u0026#34;RelocateConstructItems: Source cannot be const\u0026#34;); //逐个元素地调用构造函数和析构函数进行移动。 while (Count) { // We need a typedef here because VC won\u0026#39;t compile the destructor call below if SourceElementType itself has a member called SourceElementType typedef SourceElementType RelocateConstructItemsElementTypeTypedef; ::new ((void*)Dest) DestinationElementType((SourceElementType\u0026amp;\u0026amp;)*Source); ++(DestinationElementType*\u0026amp;)Dest; (Source++)-\u0026gt;RelocateConstructItemsElementTypeTypedef::~RelocateConstructItemsElementTypeTypedef(); --Count; } } DestructItem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;typename ElementType\u0026gt; FORCEINLINE void DestructItem(ElementType* Element) { //如果 ElementType 的大小为 0，说明这是一个不完整的类型。 //虽然这种情况不应该发生，但这段代码可以帮助生成更有意义的编译错误信息。 if constexpr (sizeof(ElementType) == 0) { // Should never get here, but this construct should improve the error messages we get when we try to call this function with incomplete types } //检测不是平凡可析构的 else if constexpr (!std::is_trivially_destructible_v\u0026lt;ElementType\u0026gt;) { // We need a typedef here because VC won\u0026#39;t compile the destructor call below if ElementType itself has a member called ElementType //避免编译器在某些情况下（如 ElementType 自身有一个成员也叫 ElementType） //无法正确解析析构函数调用的问题。 typedef ElementType DestructItemsElementTypeTypedef; //显式调用对象的析构函数，通过 typedef 确保析构函数调用的语法正确。 Element-\u0026gt;DestructItemsElementTypeTypedef::~DestructItemsElementTypeTypedef(); } } 该函数针对类型 T 进行了优化，不会动态分派析构函数调用（如果 T 的析构函数是虚函数）。\nTop 返回顶部元素，即最后一个。\n1 2 3 4 5 6 7 8 9 FORCEINLINE ElementType\u0026amp; Top() UE_LIFETIMEBOUND { return Last(); } FORCEINLINE const ElementType\u0026amp; Top() const UE_LIFETIMEBOUND { return Last(); } Last 返回数组中从末尾开始计数的第 n 个元素.\nIndexFromTheEnd（可选）索引从数组的末尾（默认= 0）\n1 2 3 4 5 6 7 8 FORCEINLINE ElementType\u0026amp; Last(SizeType IndexFromTheEnd = 0) UE_LIFETIMEBOUND { RangeCheck(ArrayNum - IndexFromTheEnd - 1); return GetData()[ArrayNum - IndexFromTheEnd - 1]; } //获取倒数第二个元素 int\u0026amp; secondLastElement = MyArray.Last(1); Sort 假设项类型定义了 \u0026lt; 运算符，对数组进行排序。\n注意：\n如果你的数组包含原始指针，它们将在排序过程中自动解引用。 因此，你的数组将根据被指向的值进行排序，而不是指针本身的值。 如果这不是你想要的行为，请直接使用 Algo::Sort(MyArray)。 自动解引用行为不会发生在智能指针上。 1 2 3 4 void Sort() { Algo::Sort(*this, TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;(TLess\u0026lt;\u0026gt;())); } Algo::Sort传入了*this 和 一个谓词TDereferenceWrapper\nTDereferenceWrapper又传入了 ElementType 和 TLess\u0026lt;\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Pass through for non-pointer types */ FORCEINLINE bool operator()(T\u0026amp; A, T\u0026amp; B) { return Predicate(A, B); } FORCEINLINE bool operator()(const T\u0026amp; A, const T\u0026amp; B) const { return Predicate(A, B); } }; template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper\u0026lt;T*, PREDICATE_CLASS\u0026gt; { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Dereference pointers */ FORCEINLINE bool operator()(T* A, T* B) const { return Predicate(*A, *B); } }; TLess\u0026lt;\u0026gt;只是个比大小的仿函数，重载了()运算符 进行比大小\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;\u0026gt; struct TLess\u0026lt;void\u0026gt; { template \u0026lt;typename T, typename U\u0026gt; FORCEINLINE bool operator()(T\u0026amp;\u0026amp; A, U\u0026amp;\u0026amp; B) const { return Forward\u0026lt;T\u0026gt;(A) \u0026lt; Forward\u0026lt;U\u0026gt;(B); } }; TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;` 下面简称为`TD 在TD里面，此时 T = ElementType，PREDICATE_CLASS = TLess\u0026lt;\u0026gt;\n并且把TLess\u0026lt;\u0026gt;存到一个Predicate变量里面。\nTD 也重载了()运算符，在里面执行Predicate的()运算符，\n此时Predicate是TLess\u0026lt;\u0026gt;类型，所以\n1 TD(A,B)`-\u0026gt;`TLess(A,B)`-\u0026gt;`比大小 那么A和B是从哪来的？再深入分析下去就看不懂了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Sort() { Algo::Sort(*this, TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;(TLess\u0026lt;\u0026gt;())); } //Algo::Sort template \u0026lt;typename RangeType, typename PredicateType\u0026gt; FORCEINLINE void Sort(RangeType\u0026amp;\u0026amp; Range, PredicateType Pred) { IntroSort(Forward\u0026lt;RangeType\u0026gt;(Range), MoveTemp(Pred)); } template \u0026lt;typename RangeType, typename PredicateType\u0026gt; FORCEINLINE void IntroSort(RangeType\u0026amp;\u0026amp; Range, PredicateType Predicate) { AlgoImpl::IntroSortInternal(GetData(Range), GetNum(Range), FIdentityFunctor(), MoveTemp(Predicate)); } TDereferenceWrapper的特化 抛开A、B不谈，这个Sort是怎么回事，为什么要如此复杂的层层包装，\n一个括号运算符重载 套了 另一个括号运算符的重载，怎么会这样？\nTDereferenceWrapper 的注释是:在排序函数中解引用指针类型的帮助类\n1 Algo::Sort(ArrayInt, TLess\u0026lt;\u0026gt;()); 这里直接使用了默认的 TLess\u0026lt;\u0026gt; 比较器。 TLess\u0026lt;\u0026gt; 使用标准的 \u0026lt; 运算符进行比较。 适用于非指针类型（如 int, float, 自定义类等） 或智能指针（如 std::shared_ptr, std::unique_ptr），这些类型的比较不需要额外的解引用操作。 如果对 TArray\u0026lt;int*\u0026gt; 进行TLess排序，排序将基于指针本身的内存地址，而不是指针所指向的整数值。\n这就和期望不符合，要的是对int排序，实际上却对int*排序了，排序对象不是值 而是指针。\n1 Algo::Sort(ArrayInt, TDereferenceWrapper\u0026lt;ElementType, TLess\u0026lt;\u0026gt;\u0026gt;(TLess\u0026lt;\u0026gt;())); 这里使用了 TDereferenceWrapper 来包裹 TLess\u0026lt;\u0026gt;。\nTDereferenceWrapper 会根据元素类型的不同行为有所不同：\n如果元素是指针类型（如 int*），则会自动解引用指针，使得排序基于指针所指向的实际值。\n如果元素是非指针类型，则直接使用 \u0026lt; 运算符进行比较。\n既然它能够根据 指针类型 或 非指针类型 随机应变，那么它是如何实现的？\n它会根据TArray存放的元素类型ElementType 进行偏特化，\n如果ElementType是int，那么就选取下方代码中的 第一个模板类.\n如果ElementType是int*，那么就选取下方代码中的 第二个模板类.\n第二个模板类是一个偏特化，当传入的T是一个T*样式的指针时，第二个模板类就会被选择.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Pass through for non-pointer types */ FORCEINLINE bool operator()(T\u0026amp; A, T\u0026amp; B) { return Predicate(A, B); } FORCEINLINE bool operator()(const T\u0026amp; A, const T\u0026amp; B) const { return Predicate(A, B); } }; template\u0026lt;typename T, class PREDICATE_CLASS\u0026gt; struct TDereferenceWrapper\u0026lt;T*, PREDICATE_CLASS\u0026gt; { const PREDICATE_CLASS\u0026amp; Predicate; TDereferenceWrapper(const PREDICATE_CLASS\u0026amp; InPredicate) : Predicate(InPredicate) {} /** Dereference pointers */ FORCEINLINE bool operator()(T* A, T* B) const { return Predicate(*A, *B); } }; 第二个模板类的括号运算符重载，对A、B进行了解引用。\n到此就真相大白了，原来是这么设计的，\n在编译时就根据TArray存放的数据类型 选择合适的模板类进行排序。\n根据 指针类型/非指针类型，TDereferenceWrapper从下面的两条路径里选择:\n1 2 TD(A,B)`-\u0026gt;`TLess(A,B)`-\u0026gt;`比大小 TD(*A,*B)`-\u0026gt;`TLess(A,B)`-\u0026gt;`比大小 Find 两个版本，\n1.传入元素和索引，判断 索引处的元素 = 传入的元素\n2.传入元素，遍历查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 FORCEINLINE bool Find(const ElementType\u0026amp; Item, SizeType\u0026amp; Index) const { Index = this-\u0026gt;Find(Item); return Index != INDEX_NONE; } SizeType Find(const ElementType\u0026amp; Item) const { // 返回指向第一个数组条目的指针 const ElementType* RESTRICT Start = GetData(); // 遍历数组，查找指定元素 for (const ElementType* RESTRICT Data = Start, *RESTRICT DataEnd = Data + ArrayNum; Data != DataEnd; ++Data) { if (*Data == Item) { return static_cast\u0026lt;SizeType\u0026gt;(Data - Start); } } return INDEX_NONE; } 在Engine\\Source\\Runtime\\Core\\Public\\Misc\\CoreMiscDefines.h中 有定义\n1 enum {INDEX_NONE= -1}; 所以查找失败时 返回-1.\nRESTRICT Engine\\Source\\Runtime\\Core\\Public\\HAL\\Platform.h\n1 #define RESTRICT __restrict 类型限定符，用于指针声明，表示该指针是唯一指向其目标对象的指针。\n当能确保某个指针不会与其他指针指向同一块内存时，\n可以使用 __restrict 来帮助编译器生成更高效的代码。这在循环和函数参数传递中特别有用，\n因为这些地方通常涉及大量的内存访问操作。\n1 2 3 4 5 void foo(int *__restrict p, int *__restrict q) { *p = 5; // 编译器知道 p 和 q 指向不同的对象 *q = 10; } __restrict 告诉编译器指针 p 和 q 不会指向同一块内存区域。\n因此，编译器可以假设对 *p 和 *q 的修改不会相互影响，从而进行更多的优化，例如重排序指令或减少不必要的内存屏障。\n1 2 3 4 5 6 7 void processArrays(int *__restrict a, int *__restrict b, int *__restrict c, size_t n) { for (size_t i = 0; i \u0026lt; n; ++i) { a[i] = b[i] + c[i]; } } __restrict 关键字告诉编译器：\na、b 和 c 指向的内存区域互不重叠。 因此，编译器可以假设对 a[i]、b[i] 和 c[i] 的访问不会互相干扰。 总结:\n**__restrict** 关键字：用于指示编译器优化内存访问，告诉编译器指针不会指向相同的内存区域。 作用：允许编译器进行更多的优化，如指令重排和向量化，从而提高代码性能。 注意事项：确保指针确实不会指向相同的内存区域，否则可能导致未定义行为。 FindByPredicate 1 2 3 4 5 6 7 8 9 10 11 12 13 class TGetValue { public: bool operator()(int x) { return x%2 ==0; } }; TArray\u0026lt;int\u0026gt; ArrayInt; ArrayInt = {2,3,5,7,50}; auto FindValue = *ArrayInt.FindByPredicate([](int x){return x==2;}); auto FindValue2 = *ArrayInt.FindByPredicate(TGetValue()); 自定义匹配方法，可以传入仿函数、lambda函数 等等..\n总之就是遍历TArray中的元素，执行传入的谓词，如果谓词的结果为true 则if(true) 返回Data.\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename Predicate\u0026gt; ElementType* FindByPredicate(Predicate Pred) { for (ElementType* RESTRICT Data = GetData(), *RESTRICT DataEnd = Data + ArrayNum; Data != DataEnd; ++Data) { if (::Invoke(Pred, *Data)) { return Data; } } return nullptr; } Invoke 用于统一调用不同类型的可调用对象（如普通函数指针、lambda 表达式、成员函数指针等）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //通用可调用对象 template \u0026lt;typename FuncType, typename... ArgTypes\u0026gt; FORCEINLINE auto Invoke(FuncType\u0026amp;\u0026amp; Func, ArgTypes\u0026amp;\u0026amp;... Args) -\u0026gt; decltype(Forward\u0026lt;FuncType\u0026gt;(Func)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...)) { return Forward\u0026lt;FuncType\u0026gt;(Func)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...); } //成员变量访问 template \u0026lt;typename ReturnType, typename ObjType, typename TargetType\u0026gt; FORCEINLINE auto Invoke(ReturnType ObjType::*pdm, TargetType\u0026amp;\u0026amp; Target) -\u0026gt; decltype(UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*pdm) { return UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*pdm; } //成员函数调用 template \u0026lt; typename PtrMemFunType, typename TargetType, typename... ArgTypes, typename ObjType = TMemberFunctionPtrOuter_T\u0026lt;PtrMemFunType\u0026gt; \u0026gt; FORCEINLINE auto Invoke(PtrMemFunType PtrMemFun, TargetType\u0026amp;\u0026amp; Target, ArgTypes\u0026amp;\u0026amp;... Args) -\u0026gt; decltype((UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*PtrMemFun)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...)) { return (UE::Core::Private::DereferenceIfNecessary\u0026lt;ObjType\u0026gt;(Forward\u0026lt;TargetType\u0026gt;(Target), \u0026amp;Target).*PtrMemFun)(Forward\u0026lt;ArgTypes\u0026gt;(Args)...); } 三种形态，分别是 通用可调用对象、成员变量访问、成员函数调用\n在前面的例子中，FindByPredicate传入了一个lambda表达式 ，又测试了重载了括号运算符的仿函数类.\n这些情况都是通过第一个版本 通用可调用对象 进行调用的.\nForward 1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;typename T\u0026gt; UE_INTRINSIC_CAST FORCEINLINE constexpr T\u0026amp;\u0026amp; Forward(std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp; Obj) noexcept { return (T\u0026amp;\u0026amp;)Obj; } template \u0026lt;typename T\u0026gt; UE_INTRINSIC_CAST FORCEINLINE constexpr T\u0026amp;\u0026amp; Forward(std::remove_reference_t\u0026lt;T\u0026gt;\u0026amp;\u0026amp; Obj) noexcept { return (T\u0026amp;\u0026amp;)Obj; } 完美转发\n用于在函数调用过程中保留参数的值类别（value category），即保持参数是左值还是右值的特性。\n这使得函数可以将参数“完美”地转发给其他函数，而不会引入不必要的拷贝或转换。\n左值引用：当传入左值时，Forward 返回左值引用。 右值引用：当传入右值时，Forward 返回右值引用。 万能引用 T\u0026amp;\u0026amp;\n根据传入的参数类型推导为左值引用或右值引用。\n1 2 3 4 template \u0026lt;typename T\u0026gt; void foo(T\u0026amp;\u0026amp; param) { // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; void process(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename Func, typename... Args\u0026gt; void wrapper(Func\u0026amp;\u0026amp; func, Args\u0026amp;\u0026amp;... args) { // 使用 std::forward 进行完美转发 std::forward\u0026lt;Func\u0026gt;(func)(std::forward\u0026lt;Args\u0026gt;(args)...); } int main() { int value = 42; // 左值 //std::forward\u0026lt;int\u0026amp;\u0026gt;(value) 将 value 作为左值引用转发给 process。 wrapper(process, value); // 右值 //std::forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(100) 将 100 作为右值引用转发给 process。 wrapper(process, 100); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;memory\u0026gt; class MyClass { public: template \u0026lt;typename... Args\u0026gt; static std::unique_ptr\u0026lt;MyClass\u0026gt; create(Args\u0026amp;\u0026amp;... args) { return std::make_unique\u0026lt;MyClass\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } private: MyClass(int x, double y) : x_(x), y_(y) {} int x_; double y_; }; int main() { auto obj1 = MyClass::create(10, 3.14); // 右值 int a = 20; auto obj2 = MyClass::create(a, 2.71); // 左值 return 0; } create 函数是一个工厂函数，接受任意数量的参数并使用 std::make_unique 创建 MyClass 对象。 使用 std::forward\u0026lt;Args\u0026gt;(args)... 来完美转发构造参数，确保它们的值类别得以保留。 Reserve 保留内存，使数组至少可以包含Number元素。\nNumber-分配后数组应该能够包含的元素数量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 FORCEINLINE void Reserve(SizeType Number) { checkSlow(Number \u0026gt;= 0); if (Number \u0026lt; 0) { // Cast to USizeType first to prevent sign extension on negative sizes, producing unusually large values. UE::Core::Private::OnInvalidArrayNum((unsigned long long)(USizeType)Number); } else if (Number \u0026gt; ArrayMax) { ResizeTo(Number); } } Init 设置数组的大小，用给定的元素填充它。\nElement-用来填充数组的元素。\nNumber-分配后数组应该能够包含的元素数量。\n1 2 3 4 5 6 7 8 void Init(const ElementType\u0026amp; Element, SizeType Number) { Empty(Number); for (SizeType Index = 0; Index \u0026lt; Number; ++Index) { Add(Element); } } 其它函数 TOptional Why TOptional is my new favourite tool\nTOptional主要功能:\n表示存在或不存在的值。\n提供类型安全的方式来处理可能缺失的值。\n提供丰富的操作接口来检查是否有值、获取值以及处理没有值的情况。\n类似于C++标准库中的 std::optional。它用于表示一个值可能存在或不存在的状态。TOptional 提供了一种安全且类型安全的方式来处理可选值，避免了使用原始指针或特殊标记值（如 -1 或 nullptr）来表示缺失值的常见问题。\n零额外内存开销: TOptional 的大小与 TArray 相同，无需存储额外状态标志。\n侵入式操作高效性:\t直接通过 TArray 内部字段标记状态，无运行时性能损失。\n类型安全:\t仅允许 TOptional 通过友元访问 FIntrusiveUnsetOptionalState 构造函数。\nTArray 中的侵入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 FIntrusiveUnsetOptionalState是一个用于侵入式数据结构的辅助工具类，主要目的是管理数据结构中元素的可选状态标记。 // 静态标记，告知 TOptional 此类型（TArray）支持侵入式未设置状态。 constexpr static bool bHasIntrusiveUnsetOptionalState = true; //指定用于标记的类型（此处为 TArray 自身）。 using IntrusiveUnsetOptionalStateType = TArray; //创建一个特殊状态的 TArray，通过 ArrayMax = -1 表示未初始化。 explicit TArray(FIntrusiveUnsetOptionalState Tag) : ArrayNum(0) , ArrayMax(-1) { // 使用 ArrayMax = -1 标记未设置状态 // Use ArrayMax == -1 as our intrusive state so that the destructor still works without change, as it doesn\u0026#39;t use ArrayMax. } // 允许 TOptional 检查 TArray 是否处于未设置状态。 bool operator==(FIntrusiveUnsetOptionalState Tag) const { return ArrayMax == -1; } 使用举例1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //声明一个未设置的 TOptional\u0026lt;TArray\u0026gt; TOptional\u0026lt;TArray\u0026lt;int32\u0026gt;\u0026gt; OptionalArray; // 检查是否未设置 if (!OptionalArray.IsSet()) { // 输出：未初始化 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;OptionalArray is unset.\u0026#34;)); } // 赋值一个有效的 TArray OptionalArray = TArray\u0026lt;int32\u0026gt;{1, 2, 3}; // 检查状态 if (OptionalArray.IsSet()) { // 输出：元素数量为3 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Element count: %d\u0026#34;), OptionalArray-\u0026gt;Num()); } 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026#34;Misc/Optional.h\u0026#34; #include \u0026#34;UObject/ObjectMacros.h\u0026#34; void ExampleUsageOfTOptional() { // 定义一个 TOptional\u0026lt;int\u0026gt; TOptional\u0026lt;int\u0026gt; optionalInt; // 初始化为有值 TOptional\u0026lt;int\u0026gt; optionalIntWithValue = 42; if (optionalIntWithValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithValue has a value: %d\u0026#34;), optionalIntWithValue.GetValue()); } // 初始化为无值 TOptional\u0026lt;int\u0026gt; optionalIntWithoutValue = TOptional\u0026lt;int\u0026gt;(); if (!optionalIntWithoutValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithoutValue does not have a value\u0026#34;)); } // 使用 GetValueOr 提供默认值 int defaultValue = optionalIntWithoutValue.GetValueOr(0); UE_LOG(LogTemp, Log, TEXT(\u0026#34;DefaultValue is: %d\u0026#34;), defaultValue); // 重置为无值状态 optionalIntWithValue.Reset(); if (!optionalIntWithValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithValue has been reset and does not have a value\u0026#34;)); } // 设置新值 optionalIntWithValue = 10; if (optionalIntWithValue.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;optionalIntWithValue now has a new value: %d\u0026#34;), optionalIntWithValue.GetValue()); } } GetData GetData 返回指向第一个数组条目的指针，如果ArrayMax == 0，则返回指向nullptr的指针。\n以下文本中 函数的解释顺序 就是 函数的调用顺序.\nGetData()-\u0026gt;GetAllocation()-\u0026gt;GetAllocation()\n1 2 3 4 FORCEINLINE ElementType* GetData() UE_LIFETIMEBOUND { return (ElementType*)AllocatorInstance.GetAllocation(); } 这个函数通过调用 AllocatorInstance.GetAllocation() 获取分配的内存块，\n并将其转换为 ElementType* 类型，从而返回指向数组数据的指针。\n1 2 3 4 FORCEINLINE ElementType* GetAllocation() const { return (ElementType*)ForAnyElementType::GetAllocation(); } GetAllocation 函数是 AllocatorInstance 的成员函数，负责返回实际分配的内存块。\n在这个函数中，ForAnyElementType::GetAllocation() 被调用来获取实际的内存块，\n并将其转换为 ElementType* 类型。\n最终，ForAnyElementType::GetAllocation() 调用了另一个 GetAllocation 函数：\n1 2 3 4 5 6 7 8 9 FORCEINLINE FScriptContainerElement* GetAllocation() const { return Data; } //----------------------// /** A type which is used to represent a script type that is unknown at compile time. */ struct FScriptContainerElement {}; FScriptContainerElement* Data; 这里的 Data 是一个指向 FScriptContainerElement 类型的指针.\nFScriptContainerElement 是一个空结构体，主要用于表示一种在编译时未知的具体类型。\n总结: GetData()最终返回的是一个Data\n1 2 3 4 5 6 7 8 9 10 +-------------------+ | MyArray | +-------------------+ | AllocatorInstance| | +---------------+| | | Data |---\u0026gt; [10, 20, 30] (指向实际存储元素的内存块) | +---------------+| | ArrayNum: 3 | | ArrayMax: 4 | +-------------------+ Data 是 AllocatorInstance 中的一个成员变量，指向实际存储数组元素的内存块。\n这个内存块通常是在堆上分配的，并且由 AllocatorInstance 进行管理。\nGetData() 函数会通过 AllocatorInstance.GetAllocation() 返回 Data 指针，\n即指向 [10, 20, 30] 这个内存块的首地址。\nGetTypeSize 1 2 3 4 FORCEINLINE static constexpr uint32 GetTypeSize() { return sizeof(ElementType); } ElementType就是TArray中的int32，相当于sizeof(int32)\nGetSlack 返回此数组中的闲置数量。\n1 2 3 4 FORCEINLINE SizeType GetSlack() const { return ArrayMax - ArrayNum; } CheckInvariants 1 2 3 4 FORCEINLINE void CheckInvariants() const { checkSlow((ArrayNum \u0026gt;= 0) \u0026amp; (ArrayMax \u0026gt;= ArrayNum)); // \u0026amp; for one branch } 使用了按位与操作符 \u0026amp; 而不是逻辑与操作符 \u0026amp;\u0026amp;，目的是为了确保两个条件都在同一分支中被评估，\n即使第一个条件为假也不会短路跳过第二个条件。\n虽然在这个上下文中两者的效果是相同的，但按位与可以确保所有条件都被检查到。\n**CheckInvariants 函数：**用于验证 TArray 的内部状态是否合法，确保 ArrayNum 和 ArrayMax 满足基本的约束条件。\n**目的：**通过这些检查，可以在开发过程中捕获潜在的错误，如非法的状态设置或数组管理不当，从而提高代码的健壮性和可靠性。\n**性能考虑：**使用 checkSlow 宏确保这些检查只在调试版本中生效，在发布版本中被优化掉，以避免不必要的性能开销。\nRangeCheck 检查index是否在数组范围内。\n1 2 3 4 5 6 7 8 9 10 FORCEINLINE void RangeCheck(SizeType Index) const { CheckInvariants(); // Template property, branch will be optimized out if constexpr (AllocatorType::RequireRangeCheck) { checkf((Index \u0026gt;= 0) \u0026amp; (Index \u0026lt; ArrayNum),TEXT(\u0026#34;Array index out of bounds: %lld into an array of size %lld\u0026#34;),(long long)Index, (long long)ArrayNum); // \u0026amp; for one branch } } AllocatorType::RequireRangeCheck\n在默认的情况下，AllocatorType是TSizedHeapAllocator\nTSizedHeapAllocator::RequireRangeCheck = true.\n1 2 3 4 5 6 7 8 9 template \u0026lt;int IndexSize, typename BaseMallocType = FMemory\u0026gt; class TSizedHeapAllocator { //.............. public: enum { NeedsElementType = true }; enum { RequireRangeCheck = true }; //.............. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //*检查指定下标范围是否在数组范围内。 //* //* @param Index要检查的范围起始位置的索引。 //* @param Count范围中元素的数量。 FORCEINLINE void RangeCheck(SizeType Index, SizeType Count) const { CheckInvariants(); // Template property, branch will be optimized out if constexpr (AllocatorType::RequireRangeCheck) { checkf((Count \u0026gt;= 0) \u0026amp; (Index \u0026gt;= 0) \u0026amp; (Index + Count \u0026lt;= ArrayNum), TEXT(\u0026#34;Array range out of bounds: index %lld and length %lld into an array of size %lld\u0026#34;), (long long)Index, (long long)Count, (long long)ArrayNum); // \u0026amp; for one branch } } IsValidIndex 测试index是否有效，即大于或等于0，小于数组中的元素数量。\n1 2 3 4 FORCEINLINE bool IsValidIndex(SizeType Index) const { return Index \u0026gt;= 0 \u0026amp;\u0026amp; Index \u0026lt; ArrayNum; } NumBytes SIZE_T，这是一个无符号整数类型，通常用于表示内存大小。\n1 2 3 4 5 6 7 /** @returns Number of bytes used, excluding slack */ FORCEINLINE SIZE_T NumBytes() const { return static_cast\u0026lt;SIZE_T\u0026gt;(ArrayNum) * sizeof(ElementType); //将 ArrayNum 转换为 SIZE_T 类型， //以确保与 sizeof(ElementType) 的乘积结果是 SIZE_T 类型，避免潜在的溢出问题。 } 计算数组当前使用的字节数，不包括未使用的额外空间（即所谓的“松弛”或“slack”）。\n这个函数对于了解数组的实际内存占用非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 TArray\u0026lt;int\u0026gt; MyArray; MyArray.Add(10); MyArray.Add(20); MyArray.Add(30); // 计算当前使用的字节数 SIZE_T bytesUsed = MyArray.NumBytes(); //NumBytes的计算过程 bytesUsed = static_cast\u0026lt;SIZE_T\u0026gt;(3) * sizeof(int); // 假设 sizeof(int) == 4 bytesUsed = 3 * 4; bytesUsed = 12; // 当前使用的字节数是 12 字节 GetAllocatedSize 返回容器分配的大小.\n1 2 3 4 5 6 7 8 9 FORCEINLINE SIZE_T GetAllocatedSize(void) const { return AllocatorInstance.GetAllocatedSize(ArrayMax, sizeof(ElementType)); } SIZE_T GetAllocatedSize(SizeType CurrentMax, SIZE_T NumBytesPerElement) const { return CurrentMax * NumBytesPerElement; } SIZE_T，这是一个无符号整数类型，通常用于表示内存大小。\n重载[] 访问数组中指定索引处的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Array bracket operator. Returns reference to element at given index. * * @returns Reference to indexed element. */ FORCEINLINE ElementType\u0026amp; operator[](SizeType Index) UE_LIFETIMEBOUND { RangeCheck(Index); return GetData()[Index]; } FORCEINLINE void RangeCheck(SizeType Index) const { CheckInvariants(); // Template property, branch will be optimized out if constexpr (AllocatorType::RequireRangeCheck) { checkf((Index \u0026gt;= 0) \u0026amp; (Index \u0026lt; ArrayNum),TEXT(\u0026#34;Array index out of bounds: %lld into an array of size %lld\u0026#34;),(long long)Index, (long long)ArrayNum); // \u0026amp; for one branch } } GetData 返回指向数组数据的指针，即实际存储数组元素的内存块的首地址。\n通过 GetData()[Index] 访问指定索引处的元素。\nUE_LIFETIMEBOUND 宏 用于 静态代码分析 的注解宏，其核心作用是标记函数返回的指针或引用 依赖于某个对象的生命周期，帮助开发者避免悬垂指针（Dangling Pointer）错误。\n编译警告/错误： 若返回的指针/引用的生命周期超出其依赖对象，静态分析工具（如 UE 的静态分析器或 Clang/GCC 的警告）会发出警告。 文档提示： 代码阅读者可以直观看出返回值需要谨慎处理生命周期。 该属性主要用于帮助静态分析工具检测潜在的生命周期问题。虽然它不会直接影响编译行为，但可以帮助开发者发现潜在的错误。 然而，过度使用可能会使代码变得冗长，因此需要合理使用。 宏定义在:\nEngine/Source/Runtime/Core/Public/MSVC/MSVCPlatform.h\nEngine/Source/Runtime/Core/Public/Clang/ClangPlatform.h\n1 2 3 4 5 6 7 8 #ifdef __has_cpp_attribute #if __has_cpp_attribute(msvc::lifetimebound) #define UE_LIFETIMEBOUND [[msvc::lifetimebound]] #endif #endif //---------------// #define UE_LIFETIMEBOUND [[clang::lifetimebound]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FContainer { public: int32* GetData() UE_LIFETIMEBOUND { return Data; // 返回指针，生命周期依赖 FContainer 实例 } private: int32* Data; }; void Test() { int32* Ptr; { FContainer Container; Ptr = Container.GetData(); // 警告：Ptr 的生命周期超出 Container } *Ptr = 42; // 危险！悬垂指针 } 函数接受一个引用类型的参数，并希望确保该引用在其整个生命周期内都是有效的\n1 2 3 4 void ProcessObject([[msvc::lifetimebound]] const MyClass\u0026amp; obj) { // 处理对象 } [[msvc::lifetimebound]] 标记了 obj 参数，表示该引用在其生命周期内应保持有效。\n如果编译器或静态分析工具检测到 obj 的生命周期可能超出其有效范围，会发出相应的警告或错误。\n对于返回值也可以使用 [[msvc::lifetimebound]] 来标记生命周期边界\n1 2 3 4 5 [[msvc::lifetimebound]] MyClass\u0026amp; GetObject() { static MyClass instance; return instance; } GetObject 返回一个静态对象的引用，并且使用 [[msvc::lifetimebound]] 标记返回值，确保返回的引用在其整个生命周期内都是有效的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; class MyClass { public: MyClass(int v) : value(v) {} void PrintValue() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } private: int value; }; // 使用 [[msvc::lifetimebound]] 标记函数参数 void ProcessObject([[msvc::lifetimebound]] const MyClass\u0026amp; obj) { obj.PrintValue(); } int main() { MyClass obj(42); ProcessObject(obj); // 正确使用，obj 在 ProcessObject 调用期间有效 // 下面的代码会导致悬空引用，静态分析工具可能会发出警告 // MyClass* ptr = new MyClass(100); // ProcessObject(*ptr); // delete ptr; // obj 已经被删除，ProcessObject 中的引用无效 return 0; } ","date":"2000-01-21T23:31:36+08:00","permalink":"https://akaklya.github.io/p/tarray/","title":"TArray"},{"content":"https://ue5wiki.com/\nUObject 反射系统 反射文档 反射知识库\nC++ 编译为 CPU 机器码，而 CPU 并不了解类或变量的概念。类只是为编译器提供如何设置 CPU 代码的信息，变量最终只转化为内存地址，因此CPU并不知道类的存在，这些信息是由软件自身来跟踪的。在 UE 中，这是通过反射系统实现的，所以你的代码可以“反映”其自身。\nUE4 拥有一个特别的工具叫做 UnrealHeaderTool，它收集你创建的那些宏，比如 UPROPERTY、UCLASS、USTRUCT，并生成额外的 C++ 代码，这些代码将类、函数和属性注册到反射系统中，这样引擎就能识别这些元素并跟踪它们。反射系统注册表中的每个元素都有一个对应的 UField 对象被创建，用来表示代码中的事物并存储有关它的信息。每个UObject类都有一个UClass对象，你可以通过调用GetClass()或StaticClass()来获取这个对象\nCDO 它的主要功能是存储类对象的默认状态并保存默认变量状态。在 C++ 中创建的每个标有 UCLASS() 的 UObject 类都会注册到反射系统。\n在C++创建一个Actor \u0026ndash;\u0026gt; AXActor，int32 K = 1 , 但是在构造函数里重新赋值 K=2，那么它的默认对象(CDO)的值就是2，\n1 2 3 4 UClass* XActor = AXActorStaticClass(); Uobject* XAObj = XActor-\u0026gt;GetDefaultObject(); AXACtor* CDO = Cast\u0026lt;AXActor\u0026gt;(XAObj); //CDO-\u0026gt;K 得到的值是2 1 StaticClass\u0026lt;UObject\u0026gt;` 或者 `UObject::StaticClass() 当UClass的 类默认对象（CDO）更改，引擎将尝试在加载类的所有实例时对这些实例应用这些更改。对于给定Object实例，如果 更新的变量值 与 旧CDO中的值 相匹配，则将更新为它在新CDO中保存的值。如果变量包含任何其他值，系统会假设这个值是故意设置的，这些更改将会被保留。\n例如，假设你在一个关卡中放置了多个 AEnemy Object并保存，然后将 AEnemy 构造函数中的默认Health值设置为100。再假设将Enemy_3的Health值设置为500，因为它们特别难对付。现在，假设你改变注意了，将Health的默认值增加到150。下次加载关卡时，虚幻意识到你更改了CDO，并将使用旧默认Health值（100）的所有AEnemy实例更新为使用Health值150。Enemy_3的Health将保持在500，因为它不使用旧的默认值。\n因为构造函数是在引擎和对象自身的初始化早期阶段调用的，你不应该在其中执行任何游戏逻辑代码，否则很可能会导致崩溃。你应该使用类中的其他事件，如PostInitProperties（在蓝图系统对对象所做的更改应用后调用）、PostInitComponents（在Actor中的组件被初始化后调用）或BeginPlay（当Actor被完全初始化时）。请注意，前两个事件也在你将Actor放置在关卡编辑器时被调用。\n总结来说，CDO的主要作用是在引擎中保持类的默认状态，使得即使是在C++中，也可以方便地获取到类的默认属性和行为。由于CDO是在引擎初始化期间创建的，因此在这个时候调用构造函数可能会导致不稳定的行为，所以开发者应该避免在构造函数中进行依赖于其他尚未初始化对象的操作。\n反射宏 其实 GENERATED_BODY 与GENERATED_UCLASS_BODY的区别在于：GENERATED_BODY声明并定义 了一个接收 const FObjectInitializer\u0026amp; 的构造函数，GENERATED_UCLASS_BODY只声明 了该构造函数，需要用户自己提供一个定义。\n核心 容器 特性 TArray TMap TSet 存储方式 连续内存 哈希表（键值对） 哈希表（唯一元素） 重复元素 允许 键唯一，值可重复 元素唯一 查找效率 O(n)（线性搜索） O(1)（平均） O(1)（平均） 插入/删除效率 末尾高效，中间低效 O(1)（平均） O(1)（平均） 内存占用 紧凑 较高（哈希表开销） 较高（哈希表开销） 典型场景 顺序访问、排序、随机访问 键值映射、快速键查找 唯一元素集合、存在性检查 实现:\n容器类型 UE 实现 STL 实现 特点 TArray 动态数组（类似 std::vector） std::vector 连续内存，支持快速随机访问，预分配内存优化。 TSet 哈希表（开放寻址法） std::unordered_set 使用线性探测解决冲突，内存紧凑，缓存友好。 TMap 哈希表（开放寻址法） std::unordered_map 类似 TSet，存储键值对，支持快速查找。 TMultiMap 哈希表（链地址法） std::unordered_multimap 支持重复键，链地址法解决冲突。 UE 不使用红黑树的原因\n性能考量： 哈希表的平均时间复杂度为 O(1)，而红黑树为 O(log N)。在游戏开发中，高频查找场景更倾向于哈希表。 内存布局： 开放寻址哈希表的内存连续，利于缓存命中，适合数据密集型操作。 用途:\n容器 适用场景 示例 TArray 需要快速随机访问、顺序遍历或堆栈式操作的数据集合 玩家背包物品列表、技能释放队列 TSet 需要快速查找唯一元素、不关心顺序的集合 玩家已解锁的成就集合、场景中激活的触发器列表 TMap 需要键值对映射、通过键快速查找值的场景 玩家属性表（键：属性名，值：数值）、NPC对话选项映射 TArray:\n1 2 3 4 5 6 7 8 9 10 11 // 存储需要频繁遍历的粒子系统实例 TArray\u0026lt;UParticleSystemComponent*\u0026gt; ActiveParticles; // 每帧遍历更新 for (auto\u0026amp; Particle : ActiveParticles) { Particle-\u0026gt;Tick(deltaTime); } // 实现优先级队列（见后文与二叉堆关系） TArray\u0026lt;int32\u0026gt; PriorityQueue; PriorityQueue.HeapPush(5, FGreater\u0026lt;int32\u0026gt;()); TSet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 存储玩家已收集的唯一道具ID TSet\u0026lt;FName\u0026gt; CollectedItemIDs; if (!CollectedItemIDs.Contains(NewItemID)) { CollectedItemIDs.Add(NewItemID); } // 快速判断敌人是否在警戒列表 TSet\u0026lt;AEnemy*\u0026gt; AlertedEnemies; if (AlertedEnemies.Contains(TargetEnemy)) { TriggerAlarm(); } TMap:\n1 2 3 4 5 6 7 8 // 存储玩家技能冷却时间 TMap\u0026lt;FName, float\u0026gt; SkillCooldowns; SkillCooldowns.Add(\u0026#34;Fireball\u0026#34;, 5.0f); float* Cooldown = SkillCooldowns.Find(\u0026#34;Fireball\u0026#34;); // 本地化文本映射 TMap\u0026lt;FString, FText\u0026gt; LocalizedTexts; FText WelcomeText = LocalizedTexts[\u0026#34;Welcome\u0026#34;]; 举例来说，如果需要保持一列特有元素并需要经常添加、移除或搜索它们，那么可以使用TArray这个容器，但实际上TSet是一个更好的选择。\nTArray TArray优化\nTArray 的堆操作不是线程安全的，多线程环境下需手动加锁。\nUObject管理\nUObject 是 UE 中所有游戏对象的基类（如 AActor、UActorComponent），其生命周期由 垃圾回收 系统自动管理，核心机制如下：\n(1) 引用计数与可达性分析\n根对象（Roots）：通过 UPROPERTY() 标记的引用、全局对象等被视为“根”，不会被回收。 引用链追踪：GC 定期从根对象出发，标记所有可达对象，未被标记的对象会被回收。 托管对象：所有 UObject 派生类实例必须由 UE 引擎创建（通过 NewObject 或 CreateDefaultSubobject）。 (2) TArray 对 UObject 的管理\n当 TArray 存储 UObject 指针时，需显式声明引用关系以确保 GC 正确工作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 UCLASS() class MyActor : public AActor { GENERATED_BODY() public: UPROPERTY() // 必须标记 UPROPERTY()，否则 GC 可能误回收 TArray\u0026lt;UMyObject*\u0026gt; MyObjects; // 存储 UObject 指针 }; void AMyActor::ManageObjects() { UMyObject* Obj = NewObject\u0026lt;UMyObject\u0026gt;(this); // 创建对象 MyObjects.Add(Obj); // 添加引用 MyObjects.RemoveAt(0); // 移除引用（若对象不再被引用，可能被 GC 回收） } 规则 说明 UPROPERTY() 标记 容器内的 UObject 指针必须标记 UPROPERTY()，否则 GC 无法追踪引用。 手动销毁限制 禁止直接调用 delete 销毁 UObject，必须由 GC 自动回收。 弱引用 使用 TWeakObjectPtr\u0026lt;UMyObject\u0026gt; 存储弱引用，避免阻止 GC 回收。 生命周期：\n1 2 3 4 5 6 7 8 9 10 // 创建对象 UMyObject* Obj = NewObject\u0026lt;UMyObject\u0026gt;(this); MyObjects.Add(Obj); // Obj 被 MyObjects 引用 // 移除引用 MyObjects.Remove(Obj); // 此时若 Obj 无其他引用，GC 会将其标记为待回收 // 强制触发 GC（调试用） GetWorld()-\u0026gt;ForceGarbageCollection(true); 堆栈式操作\n在 UE 的 TArray 中，“堆栈式操作”指的是支持类似 栈（Stack）数据结构 的后进先出（LIFO）操作。尽管 TArray 本质是动态数组，但它提供了与栈一致的接口，允许开发者在数组末尾高效地添加或移除元素。\nTArray 内部使用连续内存（类似 std::vector），Push/Pop 操作仅需修改数组末尾指针。 这是通过以下方法实现的：\n方法 功能 时间复杂度 示例 Push / Add 在数组末尾添加元素 均摊 O(1) TArray\u0026lt;int\u0026gt; arr; arr.Add(1); Pop 移除并返回数组末尾元素 O(1) int val = arr.Pop(); Top / Last 获取数组末尾元素（不移除） O(1) int val = arr.Last(); Emplace 在末尾直接构造元素（避免拷贝） 均摊 O(1) arr.Emplace(42); 应用场景\n临时数据缓存：如子弹轨迹点、动画状态记录。 撤销/重做系统：将操作记录按栈顺序压入和弹出。 递归算法替代：手动管理调用栈，避免堆栈溢出。 最佳实践\n优先使用 TArray 的栈式接口：简化临时数据管理。 严格标记 UPROPERTY()：避免 UObject 被意外回收。 弱引用与强引用分离：使用 TWeakObjectPtr 管理非所有权引用。 堆栈式操作 与 UObject\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 在 Actor 中定义栈式 UObject 缓存 UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY() TArray\u0026lt;UMyObject*\u0026gt; ObjectStack; // 栈式缓存 void PushObject(UMyObject* Obj) { ObjectStack.Push(Obj); // 引用由 ObjectStack 持有 } UMyObject* PopObject() { if (ObjectStack.Num() == 0) return nullptr; UMyObject* Obj = ObjectStack.Pop(); // 移除引用 return Obj; // 调用者需确保新引用关系，否则 Obj 可能被 GC 回收 } }; 跨帧引用：若从栈中取出 UObject 后未重新建立有效引用（如赋值给 UPROPERTY() 变量），对象可能被 GC 回收。\n线程安全：GC 仅在游戏线程运行，异步操作中需谨慎处理 UObject 指针。\n二叉堆\nTArray 提供了对 二叉堆（Binary Heap） 的原生支持（通过 HeapPush、HeapPop 等方法），这使得 TArray 可以直接用于实现 优先队列（Priority Queue）。\n1. 二叉堆的核心特性\n数据结构：完全二叉树，通过数组（TArray）实现。 性质： 最小堆：父节点的值 \u0026lt;= 子节点的值（堆顶为最小值）。 最大堆：父节点的值 \u0026gt;= 子节点的值（堆顶为最大值）。 操作时间复杂度： 插入（HeapPush）：O(log n) 弹出堆顶（HeapPop）：O(log n) 获取堆顶（HeapTop）：O(1) 2. 使用 TArray 实现堆的优势\n优势 说明 内存高效 连续内存布局，缓存友好，适合高频操作。 内置接口 直接使用 HeapPush/HeapPop，无需手动实现堆调整逻辑。 灵活性 支持自定义比较规则（如按优先级、时间戳、权重排序）。 性能稳定 时间复杂度为 O(log n)，适合实时游戏逻辑。 使用场景与示例:\n(1) AI 行为优先级调度\n场景：AI 需要根据优先级处理多个任务（如“攻击”优先级高于“移动”）。 实现：使用 TArray 作为最小堆，按优先级排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 定义任务结构体 struct FAI_Task { FString Name; int32 Priority; // 优先级（值越小越优先） }; // 自定义比较规则（最小堆） struct FCompareTaskPriority { FORCEINLINE bool operator()(const FAI_Task\u0026amp; A, const FAI_Task\u0026amp; B) const { return A.Priority \u0026lt; B.Priority; } }; // AI 任务队列 TArray\u0026lt;FAI_Task\u0026gt; TaskHeap; // 添加任务 TaskHeap.HeapPush(FAI_Task{\u0026#34;Attack\u0026#34;, 1}, FCompareTaskPriority()); // 高优先级 TaskHeap.HeapPush(FAI_Task{\u0026#34;Move\u0026#34;, 3}, FCompareTaskPriority()); TaskHeap.HeapPush(FAI_Task{\u0026#34;Idle\u0026#34;, 5}, FCompareTaskPriority()); // 执行最高优先级任务 FAI_Task NextTask; TaskHeap.HeapPop(NextTask, FCompareTaskPriority(), false); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Executing task: %s\u0026#34;), *NextTask.Name); // 输出 \u0026#34;Attack\u0026#34; (2) 伤害事件处理队列\n场景：在战斗中，多个伤害事件需要按优先级处理（如“暴击”优先于“普通攻击”）。 实现：使用 TArray 作为最大堆，按伤害值排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 定义伤害事件结构体 struct FDamageEvent { float Damage; AActor* Source; }; // 使用 UE 内置的浮点数比较规则（最大堆） TArray\u0026lt;FDamageEvent\u0026gt; DamageHeap; // 添加伤害事件 DamageHeap.HeapPush({100.0f, Player}, TGreater\u0026lt;FDamageEvent\u0026gt;()); // 暴击 DamageHeap.HeapPush({50.0f, Enemy}, TGreater\u0026lt;FDamageEvent\u0026gt;()); // 处理最高伤害事件 FDamageEvent TopDamage; DamageHeap.HeapPop(TopDamage, TGreater\u0026lt;FDamageEvent\u0026gt;(), false); ApplyDamage(TopDamage.Source, TopDamage.Damage); // 先处理 100 点伤害 委托 示例:\n1 2 3 4 5 DECLARE_DELEGATE_OneParam(FStringDelegate, FString); class FMyClass { FStringDelegate WriteToLogDelegate; }; 乱七八糟 Log 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;, Package-\u0026gt;GetName(), ErrorCode); 1 UE_LOGFMT(LogCore, Warning, \u0026#34;Loading `{Name}` failed with error {Error}\u0026#34;,(\u0026#34;Name\u0026#34;, Package-\u0026gt;GetName()), (\u0026#34;Error\u0026#34;, ErrorCode),(\u0026#34;Flags\u0026#34;, LoadFlags)); 1 GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT(\u0026#34;This is an Example on-screen debug message.\u0026#34;)); 1 2 3 std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Hello, {}!\\n\u0026#34;, \u0026#34;World\u0026#34;); // std::format printf(\u0026#34;Hello, %s!\\n\u0026#34;, \u0026#34;World\u0026#34;); // printf std::cout \u0026lt;\u0026lt; \u0026#34;Hello, \u0026#34; \u0026lt;\u0026lt; \u0026#34;World\u0026#34; \u0026lt;\u0026lt; \u0026#34;!\\n\u0026#34;; // iostreams 私有变量访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template \u0026lt;class T\u0026gt; struct TAccessPrivate { static inline typename T::Type Value; }; template \u0026lt;class T,typename T::Type Value\u0026gt; struct TAccessPrivateStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivate\u0026lt;T\u0026gt;::Value = Value; } }; static inline FAccessPrivateStub AccessPrivateStub; }; //---------------------// struct AccessPalette { typedef TSharedPtr\u0026lt;class SMaterialPalette\u0026gt; (FMaterialEditor::*Type); }; template struct TAccessPrivateStub\u0026lt;AccessPalette,\u0026amp;FMaterialEditor::Palette\u0026gt;; //--------------------// TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 代码的目标\n这段代码的目标是访问一个类的私有成员变量（例如 FMaterialEditor::Palette），而不使用 friend 声明。它通过模板和静态初始化的技巧来实现这一点。\n代码结构\n代码分为以下几个部分：\nTAccessPrivate 模板：用于存储私有成员的指针。 TAccessPrivateStub 模板：用于在静态初始化时设置私有成员的指针。 AccessPalette 结构体：定义了一个类型别名，用于描述私有成员的类型。 模板特化：将 TAccessPrivateStub 特化为 AccessPalette 和 FMaterialEditor::Palette。 访问私有成员：通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 访问私有成员。 详细分析\n1. TAccessPrivate 模板\n1 2 3 4 5 template \u0026lt;class T\u0026gt; struct TAccessPrivate { static inline typename T::Type Value; }; 这是一个模板类，T 是一个类型参数。 T::Type 是一个嵌套类型别名，需要在特化时定义。 Value 是一个静态成员变量，类型是 T::Type，用于存储私有成员的指针。 作用：\nTAccessPrivate 的作用是提供一个全局的存储位置，用于保存私有成员的指针。 2. TAccessPrivateStub 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;class T, typename T::Type Value\u0026gt; struct TAccessPrivateStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivate\u0026lt;T\u0026gt;::Value = Value; } }; static inline FAccessPrivateStub AccessPrivateStub; }; 这是一个模板类，接受两个参数： T：一个类型，需要定义 T::Type。 Value：一个 T::Type 类型的值（通常是私有成员的指针）。 在 TAccessPrivateStub 内部，定义了一个嵌套类 FAccessPrivateStub，其构造函数将 Value 赋值给 TAccessPrivate\u0026lt;T\u0026gt;::Value。 AccessPrivateStub 是一个静态成员变量，类型是 FAccessPrivateStub。 作用：\nTAccessPrivateStub 的作用是在静态初始化时，通过 FAccessPrivateStub 的构造函数将私有成员的指针（Value）赋值给 TAccessPrivate\u0026lt;T\u0026gt;::Value。 由于 AccessPrivateStub 是静态的，它的构造函数会在程序启动时自动调用，从而完成赋值。 3. AccessPalette 结构体\n1 2 3 4 struct AccessPalette { typedef TSharedPtr\u0026lt;class SMaterialPalette\u0026gt; (FMaterialEditor::*Type); }; 这是一个结构体，定义了一个嵌套类型别名 Type。 Type 是一个指向 FMaterialEditor 成员函数的指针类型，返回值为 TSharedPtr\u0026lt;class SMaterialPalette\u0026gt;。 作用：\nAccessPalette 的作用是描述私有成员的类型。在这里，Type 表示 FMaterialEditor::Palette 的类型。 4. 模板特化\n1 template struct TAccessPrivateStub\u0026lt;AccessPalette, \u0026amp;FMaterialEditor::Palette\u0026gt;; 这里对 TAccessPrivateStub 进行了特化： T 被特化为 AccessPalette。 Value 被特化为 \u0026amp;FMaterialEditor::Palette（即私有成员的指针）。 由于 TAccessPrivateStub 的静态成员 AccessPrivateStub 会在程序启动时初始化，其构造函数会将 \u0026amp;FMaterialEditor::Palette 赋值给 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 作用：\n通过特化，TAccessPrivateStub 的静态初始化将私有成员的指针存储到 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 中。 5. 访问私有成员\n1 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value，可以访问到 FMaterialEditor::Palette，即使它是私有的。 这是因为 TAccessPrivateStub 的静态初始化已经将 \u0026amp;FMaterialEditor::Palette 赋值给了 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 为什么可以访问私有成员？\n关键点 1：静态初始化\nTAccessPrivateStub 的静态成员 AccessPrivateStub 会在程序启动时初始化。 在初始化时，FAccessPrivateStub 的构造函数会将 \u0026amp;FMaterialEditor::Palette 赋值给 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value。 静态初始化发生在 main 函数执行之前，此时编译器不会检查私有成员的访问权限。 关键点 2：绕过访问控制\n虽然 FMaterialEditor::Palette 是私有的，但 TAccessPrivateStub 的静态初始化在程序启动时完成了对私有成员指针的存储。 之后，通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 可以间接访问私有成员。 关键点 3：模板的特化\n模板特化允许在编译时为特定的类型和值生成代码。 在这里，特化将 AccessPalette 和 \u0026amp;FMaterialEditor::Palette 绑定在一起，使得 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 存储了私有成员的指针。 总结\n静态初始化：通过 TAccessPrivateStub 的静态成员，在程序启动时将私有成员的指针存储到 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 中。 模板特化：通过特化将 AccessPalette 和 \u0026amp;FMaterialEditor::Palette 绑定在一起。 间接访问：通过 TAccessPrivate\u0026lt;AccessPalette\u0026gt;::Value 访问私有成员。 这种方法虽然巧妙，但违背了 C++ 的封装原则，通常不建议在实际项目中使用。它依赖于静态初始化和模板特化的特性，绕过了访问控制机制。\n私有函数访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 目标类，包含私有成员函数 class MyClass { private: void VoidFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Private function called!\u0026#34; \u0026lt;\u0026lt; std::endl; } int IntVarFunc(int a) { cout \u0026lt;\u0026lt; \u0026#34;func: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 55; } }; // 模板类，用于存储私有成员函数的指针 template \u0026lt;typename T, typename FuncPtr\u0026gt; struct TAccessPrivateFunction { static inline FuncPtr Value; // 存储私有成员函数的指针 }; // 模板类，用于在静态初始化时设置私有成员函数的指针 template \u0026lt;typename T, typename FuncPtr, FuncPtr Value\u0026gt; struct TAccessPrivateFunctionStub { struct FAccessPrivateStub { FAccessPrivateStub() { TAccessPrivateFunction\u0026lt;T, FuncPtr\u0026gt;::Value = Value; // 在静态初始化时设置指针 } }; static inline FAccessPrivateStub AccessPrivateStub; // 静态成员，触发构造函数 }; // 定义私有成员函数的类型 using CallVoidFunc = void (MyClass::*)(); // 特化模板，将私有成员函数的指针存储到 TAccessPrivateFunction 中 template struct TAccessPrivateFunctionStub\u0026lt;MyClass, CallVoidFunc, \u0026amp;MyClass::VoidFunc\u0026gt;; void VoidFuncTemplate() { MyClass obj; // 获取私有成员函数的指针 auto pFunc = TAccessPrivateFunction\u0026lt;MyClass, CallVoidFunc\u0026gt;::Value; // 调用私有成员函数 (obj.*pFunc)(); } // 定义私有成员函数的类型 using CallIntVarFunc = int (MyClass::*)(int); // 特化模板，将私有成员函数的指针存储到 TAccessPrivateFunction 中 template struct TAccessPrivateFunctionStub\u0026lt;MyClass, CallIntVarFunc, \u0026amp;MyClass::IntVarFunc\u0026gt;; void IntVarFuncTemplate() { MyClass obj; // 获取私有成员函数的指针 auto pFunc = TAccessPrivateFunction\u0026lt;MyClass, CallIntVarFunc\u0026gt;::Value; // 调用私有成员函数，并传递参数 int result = (obj.*pFunc)(10); // 调用 PrivateFunction(10) std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } int main() { VoidFuncTemplate(); IntVarFuncTemplate(); return 0; } 替换为空函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;windows.h\u0026gt; class A { public: void Func() { std::cout \u0026lt;\u0026lt; \u0026#34;A::Func()\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 用于提取成员函数指针地址的工具函数 template \u0026lt;typename T, typename U\u0026gt; void* getMemberFunctionAddress(U T::* memberFunc) { union { U T::* ptr; void* addr; } u; u.ptr = memberFunc; return u.addr; } // 空函数的机器码（直接返回） const unsigned char emptyFunc[] = { 0xC3 }; // x86 的 RET 指令 int main() { A a; // 获取 Func 的地址 void* funcAddress = getMemberFunctionAddress(\u0026amp;A::Func); // 修改内存权限为可写 DWORD oldProtect; if (!VirtualProtect(funcAddress, sizeof(emptyFunc), PAGE_EXECUTE_READWRITE, \u0026amp;oldProtect)) { std::cerr \u0026lt;\u0026lt; \u0026#34;VirtualProtect failed: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; return 1; } // 用空函数的机器码覆盖 Func std::memcpy(funcAddress, emptyFunc, sizeof(emptyFunc)); // 恢复内存权限 DWORD temp; if (!VirtualProtect(funcAddress, sizeof(emptyFunc), oldProtect, \u0026amp;temp)) { std::cerr \u0026lt;\u0026lt; \u0026#34;VirtualProtect failed: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; return 1; } // 调用 Func，此时不会打印任何内容 a.Func(); return 0; } ","date":"2000-01-20T20:37:57+08:00","permalink":"https://akaklya.github.io/p/u-/","title":"U++"},{"content":"简介 设计模式是软件工程中一系列被广泛认可的解决特定问题的最佳实践。它们为常见问题提供了模板或指导方针，帮助开发者创建更加灵活、可维护和可复用的代码。C++作为一种多范式编程语言，支持面向对象和泛型编程等特性，因此非常适合实现各种设计模式。\n☆☆在C++中，绝大部分的模式 最终都是通过 指针指向一个多态对象 表达灵活性。☆☆对于C++特供版本来说，很多设计模式都是通过 继承抽象类 使用多态来实现，但是有些情况 使用函数指针会更好。例如观察者模式的最后一个例子 使用了函数指针，避免创建类。使用模板编程，将运行期的开销 提前到编译期，也是一种C++特供方法。\n文中的所有代码都不是伪代码，全都可以运行。有些设计模式并不常用 甚至是过时的。\n主要的设计模式分类\n创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性。\n工厂方法、抽象工厂、生成器、原型、单例\n结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n适配器、桥接、组合、装饰、外观、享元、代理\n行为模式负责对象间的高效沟通和职责委派。\n责任链、命令、迭代器、 中介者、备忘录、观察者、 状态、策略、模板方法、访问者\n设计模式中的抽象思维\n耦合：两个模块相互依赖，修改其中一个模块，那么另外一个也要修改。模块之间相互影响的关系叫做两个模块之间存在耦合关系。\n解耦合：通过修改程序代码，切换两个模块之间的依赖关系，对任意一个模块的修改，不会影响到另外一个模块，就叫做两个模块之间解耦合。\n抽象思维强调对象的本质属性，主要应用于一些软件设计中的解耦合过程。\n软件开发中需求变化频繁的，开发人员要尝试寻找变化点，把 变化部分 和 稳定部分 分离开来，在变化的地方应用设计模式。\n对于某一项任务，有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或由于固有原因无法和任务的整体结构同时实现，(出现 一个早一个晚 的关系)， 如何在确定稳定操作的前提下，灵活应对各个子步骤的变化或晚期实现需求？即 稳定中有变化\n面向对象设计原则 代码与技巧不重要，要在这个学习的过程中 建立抽象思维模型\n封装，隐藏内部实现\n继承，复用现有代码\n多态，改写对象行为\n解决复杂性：1.分解，大问题切分成小问题，复杂问题转为多个简单问题2.抽象，使用通用的技术，忽略事物非本质的细节，处理理想的对象模型.\n变化是复用的天敌，面向对象的优势在于抵御变化.\n依赖倒置原则 (DIP)\n高层模块(稳定) 不应该依赖于 低层模块(变化)，二者应该依赖于 抽象(稳定)抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape类有Draw函数 用来画东西，画家类可以使用Shape类画出各种形状，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Shape { public: virtual void Draw() = 0; } class Sphere : public Shape { public: virtual void Draw() override { //画一个圆形.... } } class Box : public Shape { .... } class Painter { public: TArray\u0026lt;Shape*\u0026gt; Shapes; void DrawSomething() { for(auto Shape : Shapes) { Shape-\u0026gt;Draw(); } } } int main() { Shape* SphereDrawer = new Sphere(); Shape* BoxDrawer = new Box(); Painter Painter; Painter.Shapes.add(SphereDrawer,BoxDrawer); // 开始画 Painter.DrawSomething(); //.... } TArray是一个数组，一行add可以添加多个元素。我不想用std::vector 不然要写两行push_back.\n当Sphere的Draw函数需要变化时，例如 添加或者删掉一点东西，或是因为其它原因，函数需要修改，此时Painter并没有被影响到，它的代码不会发生变动，只需要关注Sphere::Draw的修改即可.\n如果要新增一个三角形Triangle，只要继承自Shape类 重写Draw函数就好了，把Triangle传给Painter，就可以调用Draw来画一个三角形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Triangle : public Shape { public: virtual void Draw() override { //画一个三角形.... } } int main() { Shape* TriangleDrawer = new Triangle(); Painter Painter; Painter.Shapes.add(TriangleDrawer); Painter.DrawSomething(); } 新增了一个Triangle类，Painter类并不知道这些，也不需要知道，它只调用抽象类的虚函数就好了。\n高层模块(稳定) 不应该依赖于 底层模块(变化)\nPainter可看做是 高层模块，应该稳定，不依赖于 低层模块，Painter没有因为Sphere的变化而变化.\n抽象(稳定) 不应该依赖于 实现细节(变化)，实现细节应该依赖于 抽象(稳定).\nShape作为 抽象(稳定) 层，它的Draw没有依赖于具体的实现细节，使用子类来实现Draw.\n最终隔离变化，在Painter、Shape、Sphere中，变化的部分只有Sphere一个.\n通过这个画画的例子可以理解这句话了 \u0026mdash;\u0026gt; 现代软件设计的特征是“需求的频繁变化”，设计模式的要点是 “寻找变化点，在变化点处应用设计模式”，何时何地使用设计模式，比理解设计模式结构本身更重要.\n开放封闭原则 (OCP)\n对扩展开放，对更改封闭类模块应该是可扩展的，但是不可修改.\n单一职责原则(SRP)\n一个类应该仅有一个变化的原因.变化的方向隐含着类的责任.\nLiskov替换原则(LSP)\n子类必须能够替换它的基类（IS-A)\n继承表达类型抽象。\n接口隔离原则(ISP)\n不应该强迫客户程序依赖它们不用的方法\n接口应该小而完备\n优先使用对象组合，而不是类继承\n继承通常为“白箱复用”，对象组合通常为“黑箱复用”继承在某种程度上破坏了封装性，子类父类耦合度高对象组合则只要求被组合的对象具有良好定义的接口，耦合度低.\n封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响.\n针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某个接口\n客户程序无需知道对象的具体类型，只需要知道对象所具有的接口减少系统中各部分的依赖关系.\n产业强盛的标志 — 接口标准化\n雕版印刷：雕版印刷是在一定厚度的平滑的木板上，粘贴上抄写工整的书稿，薄而近乎透明的稿纸正面和木板相贴，字就成了反体，刻工人用刻刀把版面没有字迹的部分削去，印刷的时候，在凸起的字体上涂上墨汁，然后把纸覆在它的上面，轻轻拂拭纸背，字迹就留在纸上了。\n雕版印刷一版能印几百部甚至几千部书，但是制版很慢，而且有错字不容易更正。\n活字印刷：活字印刷术是一种印刷方法，使用可以移动的木刻字、金属或胶泥字块，用来取代传统的抄写，或是无法重复使用的雕版印刷。活字印刷的方法是先制成单字的阳文反文字模，然后按照稿件把单字挑选出来，排列在字盘内，涂墨印刷，印完后再将字模拆出，留待下次排印时再次使用。\n只印二三本，活字印刷并不比雕版印刷快。如果印成百上千份，工作效率就极其可观了，不仅能够节约大量的人力物力，而且可以大大提高印刷的速度和质量。\n模板方法模式 行为型模式\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n在固定步骤确定的情况下，通过多态机制在多个子类中对每个步骤的细节进行差异化实现。\n你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n下面的代码 基类里的JN_Burn函数是稳定的，执行了一套固定的流程，但是其中的某些步骤可以变化， 可以或必须被子类重写，才能完成整个流程. 总之就是 完形填空\n说白了就是重写虚函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 //父类 class Fighter { public: Fighter(int life, int magic, int attack) :m_life(life), m_magic(magic), m_attack(attack) {} virtual ~Fighter() {} //做父类时析构函数应该为虚函数 //对主角自身会产生影响，对敌人会产生影响。 //分析：对敌人产生影响，有函数effect_enemy。对主角自身产生影响，有函数effect_self。播放技能play_effect函数。 void JN_Burn() //技能“燃烧”,模板方法 { if (canUseJN() == false) //如果不能使用该技能，则直接返回 return; effect_enemy(); //对敌人产生的影响 effect_self(); //对主角自身产生的影响 play_effect(); //播放技能“燃烧”的技能特效 } private: virtual void effect_enemy() {} //函数体为空，表示啥也不做，如果要求必须在子类中重新实现该虚函数，则可以将该函数写成纯虚函数。 virtual void effect_self() {} void play_effect() { cout \u0026lt;\u0026lt; \u0026#34;播放 \\\u0026#34;燃烧\\\u0026#34; 特效\u0026#34; \u0026lt;\u0026lt; endl; //所有主角播放的技能特效都相同，因此不用写成一个虚函数并在子类中实现技能特效的播放。 } virtual bool canUseJN() = 0; //判断是否能使用技能“燃烧”，这是个纯虚函数声明，子类中必须重新实现canUseJN。 protected: //可能被子类访问，所以用protected修饰 //角色属性 int m_life; //生命值 int m_magic; //魔法 int m_attack; //攻击力 }; class F_Warrior :public Fighter { public: F_Warrior(int life, int magic, int attack) :Fighter(life, magic, attack) {} private: //对敌人产生的影响 virtual void effect_enemy() { cout \u0026lt;\u0026lt; \u0026#34;战士主角_让所有敌人每人失去500点生命，相关逻辑代码这里略......\u0026#34; \u0026lt;\u0026lt; endl; } //对主角自身产生的影响 virtual void effect_self() { cout \u0026lt;\u0026lt; \u0026#34;战士主角_自身失去300点生命值\u0026#34; \u0026lt;\u0026lt; endl; m_life -= 300; } virtual bool canUseJN() { if (m_life \u0026lt; 300) //生命值不够300点，不能使用技能“燃烧” return false; return true; } }; //------------------------- //“法师”类，父类为Fighter class F_Mage :public Fighter { public: F_Mage(int life, int magic, int attack) :Fighter(life, magic, attack) {} private: //对敌人产生的影响 virtual void effect_enemy() { cout \u0026lt;\u0026lt; \u0026#34;法师主角_让所有敌人每人失去650点生命，相关逻辑代码这里略......\u0026#34; \u0026lt;\u0026lt; endl; } //对主角自身产生的影响 virtual void effect_self() { cout \u0026lt;\u0026lt; \u0026#34;法师主角_自身失去100点魔法值\u0026#34; \u0026lt;\u0026lt; endl; m_magic -= 100; } virtual bool canUseJN() { if (m_magic \u0026lt; 100) //魔法值不够100点，不能使用技能“燃烧” return false; return true; } }; 输出：\n1 2 3 4 5 6 战士主角_让所有敌人每人失去500点生命，相关逻辑代码这里略...... 战士主角_自身失去300点生命值 播放 \u0026#34;燃烧\u0026#34; 特效 法师主角_让所有敌人每人失去650点生命，相关逻辑代码这里略...... 法师主角_自身失去100点魔法值 播放 \u0026#34;燃烧\u0026#34; 特效 工厂模式 简单工厂模式\nif-else 完了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 抽象产品角色 class Vehicle { public: virtual void drive() const = 0; }; // 具体产品角色 class Car : public Vehicle { public: Car() { std::cout \u0026lt;\u0026lt; \u0026#34;Creating a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Bus : public Vehicle { public: Bus() { std::cout \u0026lt;\u0026lt; \u0026#34;Creating a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 工厂角色 class VehicleFactory { public: static Vehicle* createVehicle(const std::string\u0026amp; type) { if (type == \u0026#34;car\u0026#34;) { return new Car(); } else if (type == \u0026#34;bus\u0026#34;) { return new Bus(); } else { throw std::invalid_argument(\u0026#34;Unknown vehicle type\u0026#34;); } } }; int main() { Vehicle* vehicle = VehicleFactory::createVehicle(\u0026#34;car\u0026#34;); vehicle-\u0026gt;drive(); delete vehicle; return 0; } 特点\n简单工厂模式将创建逻辑集中在一个工厂类中，适合产品类较少且创建逻辑简单的场景。 缺点是扩展性较差，新增产品类时需要修改工厂类的代码。 工厂方法模式 一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; // 抽象产品角色 - Vehicle class Vehicle { public: // 纯虚函数，定义了所有具体产品的接口 virtual void drive() const = 0; // 虚析构函数，确保派生类正确释放资源 virtual ~Vehicle() = default; }; // 具体产品角色 - Car class Car : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a car.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体产品角色 - Bus class Bus : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Driving a bus.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 抽象工厂角色 - VehicleFactory class VehicleFactory { public: // 工厂方法，返回一个抽象产品类型的指针 virtual Vehicle* createVehicle() const = 0; virtual ~VehicleFactory() = default; }; // 具体工厂角色 - CarFactory class CarFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Car; // 返回具体产品对象 } }; // 具体工厂角色 - BusFactory class BusFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Bus; // 返回具体产品对象 } }; int main() { // 创建CarFactory实例 VehicleFactory* carFactory = new CarFactory; Vehicle* car = carFactory-\u0026gt;createVehicle(); car-\u0026gt;drive(); // 输出: Driving a car. // 创建BusFactory实例 VehicleFactory* busFactory = new BusFactory; Vehicle* bus = busFactory-\u0026gt;createVehicle(); bus-\u0026gt;drive(); // 输出: Driving a bus. return 0; } 先搞结论，费这么大劲在干神魔？\nmain函数里面 虽然实际上创建了car和bus两个类，但是在整个main的代码里面，没有出现car和bus的具体类只有两个抽象的Vehicle类，没有依赖到具体类，\n扩展性:\n工厂方法模式使得系统更容易扩展新的产品类型和相应的工厂类,如果需要添加一种新的交通工具（例如自行车 Bike），只需创建一个新的具体产品类 Bike 和一个新的具体工厂类 BikeFactory,现有代码不需要做任何修改。符合开闭原则（OCP），即对扩展开放，对修改封闭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Bike : public Vehicle { public: void drive() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Riding a bike.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class BikeFactory : public VehicleFactory { public: Vehicle* createVehicle() const override { return new Bike; } }; 封装性:\n工厂方法模式通过封装对象的创建过程，将创建逻辑与使用逻辑分离，隐藏了对象创建的具体细节。\nVehicleFactory 抽象类定义了一个接口 createVehicle()，而具体的工厂类（如 CarFactory 和 BusFactory）实现了这个接口。客户端只需要调用 createVehicle() 方法即可获得一个 Vehicle 对象，无需关心具体的创建逻辑。\n遵循设计原则\n开闭原则（OCP）: 如前所述，系统可以通过添加新的产品和工厂类来扩展功能，而无需修改现有代码。 依赖倒置原则（DIP）: 客户端依赖于抽象接口（如 VehicleFactory 和 Vehicle），而不是具体的实现类。这使得系统的层次结构更加清晰，减少了模块间的依赖关系。 里氏替换原则（LSP）: 子类可以替代父类出现的地方而不影响程序的正确性。在我们的例子中，Car 和 Bus 可以替代 Vehicle 出现在任何需要 Vehicle 的地方。 new 还是 factory ?\n工厂方法模式\n优点：\n解耦：将对象的创建与使用分离，降低代码耦合度。 扩展性：新增产品类时，只需扩展工厂类，无需修改现有代码，符合开闭原则。 多态性：通过工厂方法返回基类指针或引用，支持运行时多态。 缺点：\n复杂性：增加了类的数量，代码结构更复杂。 性能开销：间接创建对象可能带来轻微性能损失。 new\n优点：\n简单直接：代码直观，易于理解。 性能：直接创建对象，无额外开销。 缺点：\n耦合度高：对象的创建与使用紧密耦合，修改时可能影响其他代码。 扩展性差：新增类时需要修改多处代码，违反开闭原则。 灵活性低：难以在运行时动态切换对象类型。 使用new创建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Product { public: virtual void use() = 0; }; class ConcreteProduct : public Product { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Product* Pro = new ConcreteProduct; // 用抽象类指针接收具体类对象 Pro-\u0026gt;use(); delete Pro; return 0; } 多态性：通过抽象类指针调用具体类的实现，实现了运行时多态。 直接依赖：main函数直接依赖具体类ConcreteProduct，需要显式地写出new ConcreteProduct。 耦合性：main函数与ConcreteProduct类耦合，如果将来需要替换为其他具体类，需要修改main函数。 使用工厂模式创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Product { public: virtual void use() = 0; }; class ConcreteProduct : public Product { public: void use() override { cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; endl; } }; class Factory { public: virtual Product* createProduct() = 0; }; class ConcreteFactory : public Factory { public: Product* createProduct() override { return new ConcreteProduct(); } }; int main() { Factory* factory = new ConcreteFactory(); // 创建具体工厂 Product* Pro = factory-\u0026gt;createProduct(); // 通过工厂创建对象 Pro-\u0026gt;use(); delete Pro; // 释放对象 delete factory; // 释放工厂 return 0; } 特点\n解耦：main函数只依赖抽象工厂和抽象产品，不依赖具体类。 扩展性：如果需要创建新的具体类，只需新增一个具体工厂和具体产品类，无需修改main函数。 灵活性：可以通过切换工厂来动态创建不同的具体对象。 区别对比\n特性 直接使用new创建对象 工厂方法模式 耦合性 main函数直接依赖具体类（ConcreteProduct） main函数只依赖抽象工厂和抽象产品，不依赖具体类 扩展性 修改具体类时需要修改main函数 新增具体类时只需扩展工厂，无需修改main函数 灵活性 无法动态切换具体类 可以通过切换工厂动态创建不同对象 代码复杂度 简单直接，代码量少 增加了工厂类，代码结构更复杂 运行时多态 支持（通过抽象类指针调用具体类方法） 支持（通过抽象类指针调用具体类方法） 总结\n如果代码规模较小，且不需要频繁扩展或修改具体类，直接使用new创建对象是更简单直接的选择。 如果需要解耦、扩展性和灵活性，工厂方法模式是更好的选择，尽管它会增加一些代码复杂性。 在示例中，虽然通过抽象类指针实现了多态，但仍然存在耦合性问题。如果未来需要替换ConcreteProduct为其他类，仍需修改main函数。而工厂方法模式可以避免这个问题。\n抽象工厂模式 一种创建型设计模式，它提供了一个接口用于创建一系列相关或依赖的对象，而无需指定它们的具体类。与工厂方法模式不同，抽象工厂模式关注的是产品族（一组相关的产品），而不是单一产品。\n假设正在开发一个跨平台的 UI 库，需要支持两种操作系统：Windows 和 macOS。每个操作系统有不同的按钮（Button）和文本框（TextBox）。需要通过抽象工厂模式来创建这些 UI 组件，确保客户端代码与具体平台解耦。\n产品抽象类 Button 和 TextBox。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 抽象产品：按钮 class Button { public: virtual void render() = 0; virtual ~Button() = default; }; // 抽象产品：文本框 class TextBox { public: virtual void render() = 0; virtual ~TextBox() = default; }; 定义具体产品类\n为每个平台实现具体的产品类。\nWindows\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Windows 按钮 class WindowsButton : public Button { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a button in Windows style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Windows 文本框 class WindowsTextBox : public TextBox { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a text box in Windows style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; mac\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // macOS 按钮 class MacOSButton : public Button { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a button in macOS style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // macOS 文本框 class MacOSTextBox : public TextBox { public: void render() override { std::cout \u0026lt;\u0026lt; \u0026#34;Rendering a text box in macOS style.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 定义抽象工厂类\n抽象工厂类定义了创建一组相关产品的方法。\n1 2 3 4 5 6 class GUIFactory { public: virtual Button* createButton() = 0; virtual TextBox* createTextBox() = 0; virtual ~GUIFactory() = default; }; Windows\n1 2 3 4 5 6 7 8 9 10 class WindowsFactory : public GUIFactory { public: Button* createButton() override { return new WindowsButton(); } TextBox* createTextBox() override { return new WindowsTextBox(); } }; mac\n1 2 3 4 5 6 7 8 9 10 class MacOSFactory : public GUIFactory { public: Button* createButton() override { return new MacOSButton(); } TextBox* createTextBox() override { return new MacOSTextBox(); } }; 客户端代码\n客户端代码通过抽象工厂创建一组相关的产品，而无需关心具体平台。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Application { private: GUIFactory* factory; Button* button; TextBox* textBox; public: Application(GUIFactory* factory) : factory(factory), button(nullptr), textBox(nullptr) {} void createUI() { button = factory-\u0026gt;createButton(); textBox = factory-\u0026gt;createTextBox(); } void renderUI() { if (button) button-\u0026gt;render(); if (textBox) textBox-\u0026gt;render(); } ~Application() { delete button; delete textBox; delete factory; } }; int main() { // 创建 Windows 风格的 UI GUIFactory* windowsFactory = new WindowsFactory(); Application windowsApp(windowsFactory); windowsApp.createUI(); windowsApp.renderUI(); // 创建 macOS 风格的 UI GUIFactory* macFactory = new MacOSFactory(); Application macApp(macFactory); macApp.createUI(); macApp.renderUI(); return 0; } 输出：\n1 2 3 4 Rendering a button in Windows style. Rendering a text box in Windows style. Rendering a button in macOS style. Rendering a text box in macOS style. 只有一个Application类，但是通过不同的工厂方法，可以填充出不同风格的Application.\n抽象产品类：\nButton 和 TextBox 是抽象基类，定义了 UI 组件的通用接口。 具体产品类：\nWindowsButton 和 WindowsTextBox 是 Windows 平台的具体实现。 MacOSButton 和 MacOSTextBox 是 macOS 平台的具体实现。 抽象工厂类：\nGUIFactory 定义了创建一组相关产品（按钮和文本框）的接口。 具体工厂类：\nWindowsFactory 和 MacOSFactory 分别实现了 Windows 和 macOS 平台的具体工厂。 客户端代码：\nApplication 类通过抽象工厂创建一组相关的 UI 组件，并调用它们的 render 方法。 客户端代码与具体平台解耦，只需切换工厂即可创建不同平台的 UI 组件。 优点\n解耦： 客户端代码只依赖抽象工厂和抽象产品，不依赖具体平台。 一致性： 确保创建的一组产品属于同一平台（如 Windows 或 macOS）。 扩展性： 新增平台时，只需添加新的具体工厂和具体产品类，无需修改现有代码。 缺点\n复杂性： 增加了类的数量，代码结构更复杂。 不易扩展新产品： 如果需要在抽象工厂中新增一个产品（如 Checkbox），需要修改所有具体工厂类。 适用场景\n需要创建一组相关或依赖的对象。 系统需要支持多个产品族（如多个平台、多个主题）。 客户端代码需要与具体产品的创建过程解耦。 原型模式 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n它允许通过复制现有对象来创建新对象，而不是通过构造函数 实例化类来创建。这种模式特别适用于创建复杂对象或当创建过程非常耗时、资源密集时。通过克隆（Clone）来创建对象，避免了直接依赖具体类。\n原型模式适用于以下场景：\n当对象的创建成本较高（例如需要复杂的初始化过程），而复制现有对象更高效时。 当系统需要动态地创建对象，且对象的类型在运行时才能确定时。 当需要避免使用new关键字直接创建对象，以减少耦合性。 假设正在开发一个图形编辑器，支持绘制多种形状（如圆形、矩形）。每种形状都是一个对象，且对象的创建成本较高（例如需要加载资源或初始化复杂状态）。可以使用原型模式，通过克隆现有对象来创建新对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 抽象原型类 class Shape { public: virtual ~Shape() = default; virtual Shape* clone() const = 0; // 克隆方法 virtual void draw() const = 0; // 绘制方法 }; class Circle : public Shape { private: int radius; public: Circle(int radius) : radius(radius) { std::cout \u0026lt;\u0026lt; \u0026#34;Circle构造 Radius:\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } // 显式定义拷贝构造函数 Circle(const Circle\u0026amp; other) : radius(other.radius) { std::cout \u0026lt;\u0026lt; \u0026#34;Circle克隆 Radius:\u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } // 实现克隆方法 Shape* clone() const override { return new Circle(*this); // 使用拷贝构造函数克隆对象 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; class Rectangle : public Shape { private: int width, height; public: Rectangle(int width, int height) : width(width), height(height) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle构造 Width:\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; Height:\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } Rectangle(const Rectangle\u0026amp; other) : width(other.width), height(other.height) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle克隆 Width:\u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; Height:\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } // 实现克隆方法 Shape* clone() const override { return new Rectangle(*this); // 使用拷贝构造函数克隆对象 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a rectangle with width \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; and height \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建原型对象 Shape* circlePrototype = new Circle(10); Shape* rectanglePrototype = new Rectangle(20, 30); // 克隆原型对象 Shape* circleClone = circlePrototype-\u0026gt;clone(); Shape* rectangleClone = rectanglePrototype-\u0026gt;clone(); // 使用克隆对象 circleClone-\u0026gt;draw(); rectangleClone-\u0026gt;draw(); return 0; } 优点\n高效创建对象： 当对象的创建成本较高时，通过克隆现有对象可以避免重复初始化。 动态创建对象： 可以在运行时动态地创建对象，而无需依赖具体类。 减少耦合性： 客户端代码只依赖抽象原型类，不依赖具体类。 缺点\n深拷贝问题： 如果对象包含指针或动态分配的资源，需要实现深拷贝，否则克隆对象会共享资源。 复杂性增加： 需要为每个类实现clone方法，增加了代码的复杂性。 扩展：深拷贝\n浅拷贝是指创建一个新的对象，并将原始对象中的成员变量的值复制到新对象中。如果成员变量是基本数据类型（如int, float, char等），则直接复制其值；如果成员变量是指针或引用，则仅复制指针或引用的地址，而不是所指向的对象。\n浅拷贝只复制了指针的地址，因此新对象和原对象共享同一块内存区域。如果两个对象共享同一块内存区域，在一个对象中修改这块内存的内容会影响另一个对象。此外，当其中一个对象被销毁时，可能会导致悬挂指针（dangling pointer）问题，因为另一个对象仍然持有已释放内存的指针。\n深拷贝是指创建一个新的对象，并且递归地复制所有成员变量，包括指针指向的对象。这意味着每个对象都有自己的独立副本，不会共享任何资源。\n深拷贝为每个对象分配独立的内存区域，确保每个对象都有自己的数据副本。由于每个对象都有自己的独立副本，因此在一个对象中修改数据不会影响其他对象，也不会出现悬挂指针的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ComplexShape : public Shape { private: int* data; // 动态分配的资源 public: ComplexShape(int value) { data = new int(value); } // 深拷贝构造函数 ComplexShape(const ComplexShape\u0026amp; other) { data = new int(*other.data); // 深拷贝 } // 实现克隆方法 std::unique_ptr\u0026lt;Shape\u0026gt; clone() const override { return std::make_unique\u0026lt;ComplexShape\u0026gt;(*this); // 使用深拷贝构造函数 } // 实现绘制方法 void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a complex shape with data \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } ~ComplexShape() { delete data; // 释放资源 } }; 特性 浅拷贝 深拷贝 基本数据类型 直接复制值 直接复制值 指针/引用类型 复制指针地址，共享同一块内存区域 分配新的内存区域，并复制指针指向的数据 资源管理 共享资源，可能导致悬挂指针问题 独立资源，安全可靠 性能 性能较高，只需复制指针地址 性能较低，需要分配新内存并复制数据 适用场景 对象没有复杂嵌套结构或不需要独立副本的情况 对象包含复杂嵌套结构或需要完全独立副本的情况 建造者模式 建造者模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n建造者模式适用于以下场景：\n当对象的创建过程非常复杂，包含多个步骤时。 当需要创建的对象有不同的表示，但构建过程相似时。 当希望将对象的构建过程与表示解耦时。 示例场景\n假设正在开发一个游戏，需要创建不同类型的角色（如英雄、怪物）。每个角色有多个属性（如名字、职业、武器、盔甲等），且这些属性的设置过程可能非常复杂。可以使用建造者模式来分离角色的构建过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; // 角色类（产品） class Character { public: Character() { std::cout \u0026lt;\u0026lt; \u0026#34;Character created\u0026#34; \u0026lt;\u0026lt; std::endl; } void setName(const std::string\u0026amp; name) { this-\u0026gt;name = name; } void setClass(const std::string\u0026amp; className) { this-\u0026gt;className = className; } void setWeapon(const std::string\u0026amp; weapon) { this-\u0026gt;weapon = weapon; } void setArmor(const std::string\u0026amp; armor) { this-\u0026gt;armor = armor; } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;-------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Class: \u0026#34; \u0026lt;\u0026lt; className \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Weapon: \u0026#34; \u0026lt;\u0026lt; weapon \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Armor: \u0026#34; \u0026lt;\u0026lt; armor \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;-------------------------\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::string name; std::string className; std::string weapon; std::string armor; }; // 抽象建造者 class CharacterBuilder { public: virtual ~CharacterBuilder() = default; virtual void buildName() = 0; virtual void buildClass() = 0; virtual void buildWeapon() = 0; virtual void buildArmor() = 0; virtual std::unique_ptr\u0026lt;Character\u0026gt; getResult() = 0; }; // 英雄建造者 class HeroBuilder : public CharacterBuilder { public: HeroBuilder() { character = std::make_unique\u0026lt;Character\u0026gt;(); // 使用智能指针 } void buildName() override { character-\u0026gt;setName(\u0026#34;Arthur\u0026#34;); } void buildClass() override { character-\u0026gt;setClass(\u0026#34;Knight\u0026#34;); } void buildWeapon() override { character-\u0026gt;setWeapon(\u0026#34;Sword\u0026#34;); } void buildArmor() override { character-\u0026gt;setArmor(\u0026#34;Plate Armor\u0026#34;); } std::unique_ptr\u0026lt;Character\u0026gt; getResult() override { return std::move(character); // 转移所有权 } private: std::unique_ptr\u0026lt;Character\u0026gt; character; }; // 怪物建造者 class MonsterBuilder : public CharacterBuilder { public: MonsterBuilder() { character = std::make_unique\u0026lt;Character\u0026gt;(); // 使用智能指针 } void buildName() override { character-\u0026gt;setName(\u0026#34;Goblin\u0026#34;); } void buildClass() override { character-\u0026gt;setClass(\u0026#34;Enemy\u0026#34;); } void buildWeapon() override { character-\u0026gt;setWeapon(\u0026#34;Claws\u0026#34;); } void buildArmor() override { character-\u0026gt;setArmor(\u0026#34;Leather Armor\u0026#34;); } std::unique_ptr\u0026lt;Character\u0026gt; getResult() override { return std::move(character); // 转移所有权 } private: std::unique_ptr\u0026lt;Character\u0026gt; character; }; // 指挥者 class CharacterDirector { public: void setBuilder(CharacterBuilder* builder) { this-\u0026gt;builder = builder; } std::unique_ptr\u0026lt;Character\u0026gt; construct() { builder-\u0026gt;buildName(); builder-\u0026gt;buildClass(); builder-\u0026gt;buildWeapon(); builder-\u0026gt;buildArmor(); return builder-\u0026gt;getResult(); } private: CharacterBuilder* builder; }; int main() { // 创建建造者和指挥者 HeroBuilder heroBuilder; MonsterBuilder monsterBuilder; CharacterDirector director; // 构建英雄角色 director.setBuilder(\u0026amp;heroBuilder); auto hero = director.construct(); hero-\u0026gt;display(); // 构建怪物角色 director.setBuilder(\u0026amp;monsterBuilder); auto monster = director.construct(); monster-\u0026gt;display(); return 0; } 优点\n分离构建过程与表示： 将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。 更好的控制构建过程： 指挥者类可以精确控制构建过程。 代码复用： 可以复用相同的构建过程来创建不同的产品。 缺点\n增加代码复杂性： 需要定义多个类（建造者、指挥者等），增加了代码的复杂性。 适用于复杂对象： 如果对象非常简单，使用建造者模式可能会显得过度设计。 策略模式 策略是一种行为设计模式， 它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。\n方便应对多重switch case 或 if else，随时间推移，switch 或 if中的代码需要扩展，写的越来越多，代码很长.\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n计算税，每个国家的税不同，计算方法不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 enum TaxBase { CN_Tax; US_Tax; DE_Tax }; class SalesOrder { TexBase Tax; public: double CalcTax() { if(Tex == CN_Tex) { } else if(Tex == US_Tax) { } else if(Tex == DE_Tax) { } //..... } } 每增加一个国家的计算方法，enum TexBase就要扩充一个枚举值，CalcTax要多一套if else.如果随着时间推移，后续增加的计算方法越多，代码越来越长，极端情况下 Cache甚至放不下代码，一部分代码需要放到内存 甚至是虚拟内存(硬盘)中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class TexStrategy { public: virtual double Calc(const Context\u0026amp; context) = 0; virtual ~TexStrategy(){} } class CNTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class USTax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class DETax : public TexStrategy { public: virtual double Calc(const Context\u0026amp; context) override { //********** */ } } class SalesOrder { private: TexStrategy* Strategy; public: SalesOrder(TexStrategy* InStrategy) : Strategy(InStrategy){} ~SalesOrder() { delete Strategy; } double CalcTex() { //.... Context context; double Tex = Strategy-\u0026gt;Calc(context); //..... return Tex; } } 需要扩充计算方法时，只要继承TexStrategy 写一个新的类即可，就能完成新的税种计算.SalesOrder是不需要修改的. 对于新增的类，甚至可以使用增量编译 单独编译一个dll.\n以上代码只是说明一个大概情况，下面的代码是可运行的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Strategy { public: virtual ~Strategy() = default; virtual std::string doAlgorithm(std::string_view data) const = 0; }; class Context { private: std::unique_ptr\u0026lt;Strategy\u0026gt; strategy_; public: explicit Context(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy = {}) : strategy_(std::move(strategy)) { } void set_strategy(std::unique_ptr\u0026lt;Strategy\u0026gt; \u0026amp;\u0026amp;strategy) { strategy_ = std::move(strategy); } void doSomeBusinessLogic() const { if (strategy_) { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it)\\n\u0026#34;; std::string result = strategy_-\u0026gt;doAlgorithm(\u0026#34;aecbd\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Context: Strategy isn\u0026#39;t set\\n\u0026#34;; } } }; class ConcreteStrategyA : public Strategy { public: std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result)); return result; } }; class ConcreteStrategyB : public Strategy { std::string doAlgorithm(std::string_view data) const override { std::string result(data); std::sort(std::begin(result), std::end(result), std::greater\u0026lt;\u0026gt;()); return result; } }; void clientCode() { Context context(std::make_unique\u0026lt;ConcreteStrategyA\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to normal sorting.\\n\u0026#34;; context.doSomeBusinessLogic(); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Strategy is set to reverse sorting.\\n\u0026#34;; context.set_strategy(std::make_unique\u0026lt;ConcreteStrategyB\u0026gt;()); context.doSomeBusinessLogic(); } int main() { clientCode(); return 0; } 输出结果\n1 2 3 4 5 6 7 Client: Strategy is set to normal sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) abcde Client: Strategy is set to reverse sorting. Context: Sorting data using the strategy (not sure how it\u0026#39;ll do it) edcba 这种设计模式 可以在运行时更改对象的算法，将算法和对象本身解耦. 对于这个例子，分辨出哪里是稳定的，哪里是变化的，算法可以通过扩展子类的方式 独立出来进行变化.\n有时候支持不使用的算法也是负担，例如 在计算税的if else版本的代码里，程序安装在America 只需要使用America部分，其它的if都是不必要的，代码在运行时 要加载到Cache、内存， 但是要使用的代码只有其中一小部分，所以其余的代码都是多余加载的。 使用策略模式可以顺便缓解这个情况.\n观察者模式 一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并自动更新。\n观察者模式的核心思想\n主题（Subject）：被观察的对象，维护一个观察者列表，并提供添加、删除和通知观察者的方法。 观察者（Observer）：接收主题通知的接口，通常包含一个 update 方法，用于接收主题的状态变化。 具体主题（Concrete Subject）：实现主题接口的具体类，负责管理状态并在状态变化时通知所有观察者。 具体观察者（Concrete Observer）：实现观察者接口的具体类，接收来自主题的通知并进行相应的处理。 按钮响应事件 当用户点击该按钮时，需要通知所有注册的监听器执行相应的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 观察者接口 class ButtonListener { public: virtual void onClick() = 0; }; // 主题类 - 按钮 class Button { private: std::vector\u0026lt;ButtonListener*\u0026gt; listeners; public: void addListener(ButtonListener* listener) { listeners.push_back(listener); } void notifyListeners() { for (auto* listener : listeners) { listener-\u0026gt;onClick(); } } void click() { std::cout \u0026lt;\u0026lt; \u0026#34;Button clicked!\u0026#34; \u0026lt;\u0026lt; std::endl; notifyListeners(); } }; // 具体观察者类 - ListenerA 和 ListenerB class ListenerA : public ButtonListener { public: void onClick() override { std::cout \u0026lt;\u0026lt; \u0026#34;Listener A: Handling button click event.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class ListenerB : public ButtonListener { public: void onClick() override { std::cout \u0026lt;\u0026lt; \u0026#34;Listener B: Handling button click event.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Button button; ListenerA listenerA; ListenerB listenerB; button.addListener(\u0026amp;listenerA); button.addListener(\u0026amp;listenerB); // 模拟点击按钮 button.click(); return 0; } 这不就是在Button类里面放一个vector，vector里面又存放了ButtonListener的基类，按下按钮时，遍历vector，逐个通知ButtonListener的onClick.\n新闻订阅服务 模拟一个新闻订阅服务，用户可以订阅不同的新闻主题。当有新的新闻更新时，所有订阅了该主题的用户都会收到通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; // 观察者接口 class NewsSubscriber { public: virtual void update(const std::string\u0026amp; news) = 0; }; // 主题类 - 新闻发布者 class NewsPublisher { private: std::unordered_map\u0026lt;std::string, std::vector\u0026lt;NewsSubscriber*\u0026gt;\u0026gt; subscribers; public: void subscribe(const std::string\u0026amp; topic, NewsSubscriber* subscriber) { subscribers[topic].push_back(subscriber); } void unsubscribe(const std::string\u0026amp; topic, NewsSubscriber* subscriber) { auto it = subscribers.find(topic); if (it != subscribers.end()) { auto\u0026amp; list = it-\u0026gt;second; list.erase(std::remove(list.begin(), list.end(), subscriber), list.end()); } } void notifySubscribers(const std::string\u0026amp; topic, const std::string\u0026amp; news) { auto it = subscribers.find(topic); if (it != subscribers.end()) { for (auto* sub : it-\u0026gt;second) { sub-\u0026gt;update(news); } } } void publishNews(const std::string\u0026amp; topic, const std::string\u0026amp; news) { std::cout \u0026lt;\u0026lt; \u0026#34;Publishing news on \u0026#34; \u0026lt;\u0026lt; topic \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; notifySubscribers(topic, news); } }; // 具体观察者类 - SubscriberA 和 SubscriberB class SubscriberA : public NewsSubscriber { public: void update(const std::string\u0026amp; news) override { std::cout \u0026lt;\u0026lt; \u0026#34;Subscriber A received news: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; } }; class SubscriberB : public NewsSubscriber { public: void update(const std::string\u0026amp; news) override { std::cout \u0026lt;\u0026lt; \u0026#34;Subscriber B received news: \u0026#34; \u0026lt;\u0026lt; news \u0026lt;\u0026lt; std::endl; } }; int main() { NewsPublisher publisher; SubscriberA subscriberA; SubscriberB subscriberB; publisher.subscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberA); publisher.subscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberB); publisher.publishNews(\u0026#34;Technology\u0026#34;, \u0026#34;New tech breakthrough!\u0026#34;); std::cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;\u0026lt;\u0026lt;std::endl; publisher.unsubscribe(\u0026#34;Technology\u0026#34;, \u0026amp;subscriberA); publisher.publishNews(\u0026#34;Technology\u0026#34;, \u0026#34;New tech AA!\u0026#34;); return 0; } 输出：\n1 2 3 4 5 6 Publishing news on Technology: New tech breakthrough! Subscriber A received news: New tech breakthrough! Subscriber B received news: New tech breakthrough! Publishing news on Technology: New tech AA! Subscriber B received news: New tech AA! 状态监控 模拟一个环境监测系统，它会根据传感器的数据变化来通知多个显示组件进行更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 观察者接口 class SensorObserver { public: virtual void onUpdate(float temperature, float humidity) = 0; }; // 主题类 - 传感器 class EnvironmentSensor { private: std::vector\u0026lt;SensorObserver*\u0026gt; observers; float temperature; float humidity; public: void addObserver(SensorObserver* observer) { observers.push_back(observer); } void removeObserver(SensorObserver* observer) { observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end()); } void notifyObservers() { for (auto* observer : observers) { observer-\u0026gt;onUpdate(temperature, humidity); } } void setMeasurements(float temperature, float humidity) { this-\u0026gt;temperature = temperature; this-\u0026gt;humidity = humidity; notifyObservers(); } }; // 具体观察者类 - DisplayA 和 DisplayB class DisplayA : public SensorObserver { public: void onUpdate(float temperature, float humidity) override { std::cout \u0026lt;\u0026lt; \u0026#34;Display A: Temperature is \u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;F and Humidity is \u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class DisplayB : public SensorObserver { public: void onUpdate(float temperature, float humidity) override { std::cout \u0026lt;\u0026lt; \u0026#34;Display B: Current readings are Temp=\u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34;F, Humidity=\u0026#34; \u0026lt;\u0026lt; humidity \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { EnvironmentSensor sensor; DisplayA displayA; DisplayB displayB; sensor.addObserver(\u0026amp;displayA); sensor.addObserver(\u0026amp;displayB); sensor.setMeasurements(75.0f, 60.0f); // 更新传感器数据 return 0; } 输出：\n1 2 Display A: Temperature is 75F and Humidity is 60% Display B: Current readings are Temp=75F, Humidity=60% 函数指针 使用C++函数指针实现观察者模式是一种相对直接的方法，它允许你定义一个或多个回调函数来响应特定事件。下面是一个简单的示例，演示了如何使用C++函数指针实现观察者模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 定义一个Subject类，用于管理观察者的注册和通知 class Subject { public: // 注册观察者（函数指针） void registerObserver(void (*observer)(std::string)) { observers.push_back(observer); } // 通知所有注册的观察者 void notifyObservers(std::string message) { for (auto observer : observers) { observer(message); } } private: std::vector\u0026lt;void(*)(std::string)\u0026gt; observers; // 存储所有观察者函数指针 }; // 定义两个观察者函数 void observer1(std::string message) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer 1 received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } void observer2(std::string message) { std::cout \u0026lt;\u0026lt; \u0026#34;Observer 2 received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } int main() { Subject subject; // 注册观察者 subject.registerObserver(observer1); subject.registerObserver(observer2); // 发生某个事件，通知所有观察者 subject.notifyObservers(\u0026#34;Event occurred!\u0026#34;); return 0; } 装饰模式 一种结构型设计模式，它允许动态地给对象添加功能，而无需修改其原始类。通过这种方式，可以在运行时为对象增加新的行为，同时保持代码的简洁性和灵活性。\n装饰模式的核心思想\n组件接口：定义了可以被装饰的对象的基础接口。 具体组件：实现了组件接口的基本功能。 装饰器基类：持有一个对组件接口的引用，并实现相同的接口，以确保可以像处理原始组件一样处理装饰器。 具体装饰器：扩展或修改组件的行为，通常通过在其方法中调用被装饰对象的方法，然后添加额外的功能。 角色能力增强： 在游戏中，玩家可以通过拾取道具或完成任务来获得新的能力或增强现有能力。例如，角色可以拾取一个加速道具，或者穿上一件增加防御力的盔甲。 武器升级： 玩家可以在游戏中找到不同的配件来升级他们的武器，如安装瞄准镜、消音器等。这些升级可以动态地改变武器的属性。 状态效果（Buff/Debuff）： 游戏中的角色可能会受到各种状态效果的影响，如中毒、燃烧、隐身等。这些状态效果可以在运行时动态地附加到角色上，并根据需要移除。 图形特效： 为了增强游戏的视觉效果，某些物品或技能可以给角色添加特殊的图形特效，如光环、粒子效果等。 要设计一个咖啡店系统，其中不同种类的咖啡可以通过添加调料（如糖、牛奶等）来定制。可以使用装饰模式来动态地给咖啡添加调料，而不需要创建大量的子类。\n继承实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 组件接口 - Beverage class Beverage { public: virtual ~Beverage() = default; virtual std::string getDescription() const = 0; virtual double cost() const = 0; }; // 具体组件 - Espresso class Espresso : public Beverage { public: std::string getDescription() const override { return \u0026#34;Espresso\u0026#34;; } double cost() const override { return 1.99; } }; // 装饰器基类 - CondimentDecorator class CondimentDecorator : public Beverage { protected: Beverage* beverage; public: explicit CondimentDecorator(Beverage* beverage) : beverage(beverage) {} }; // 具体装饰器 - Milk class Milk : public CondimentDecorator { public: explicit Milk(Beverage* beverage) : CondimentDecorator(beverage) {} std::string getDescription() const override { return beverage-\u0026gt;getDescription() + \u0026#34;, Milk\u0026#34;; } double cost() const override { return beverage-\u0026gt;cost() + 0.25; } }; // 具体装饰器 - Sugar class Sugar : public CondimentDecorator { public: explicit Sugar(Beverage* beverage) : CondimentDecorator(beverage) {} std::string getDescription() const override { return beverage-\u0026gt;getDescription() + \u0026#34;, Sugar\u0026#34;; } double cost() const override { return beverage-\u0026gt;cost() + 0.15; } }; int main() { // 创建基础饮料 Beverage* beverage = new Espresso(); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; // 添加装饰器 beverage = new Milk(beverage); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; beverage = new Sugar(beverage); // 输出描述和价格 std::cout \u0026lt;\u0026lt; \u0026#34;Description: \u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;getDescription() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Cost: $\u0026#34; \u0026lt;\u0026lt; beverage-\u0026gt;cost() \u0026lt;\u0026lt; std::endl; // 清理资源 delete beverage; return 0; } 套娃，一层套一层，调用getDescription() 或 cost() 都是逐层调用的，\n输出：\n1 2 3 4 5 6 7 8 Description: Espresso Cost: $1.99 Description: Espresso, Milk Cost: $2.24 Description: Espresso, Milk, Sugar Cost: $2.39 初始状态\nbeverage 指向 Espresso 对象。 调用 beverage-\u0026gt;getDescription() 返回 \u0026quot;Espresso\u0026quot;。 调用 beverage-\u0026gt;cost() 返回 1.99。 1 2 beverage-\u0026gt;getDescription() -\u0026gt; Espresso::getDescription() -\u0026gt; \u0026#34;Espresso\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Espresso::cost() -\u0026gt; 1.99 第一次装饰：添加 Milk\n创建一个新的 Milk 对象，并将 Espresso 对象传递给它的构造函数。 新的 Milk 对象内部持有一个指向 Espresso 对象的指针。 调用 beverage-\u0026gt;getDescription() 实际上调用了 Milk::getDescription()，该方法会调用 beverage-\u0026gt;getDescription()（即 Espresso::getDescription()），并附加 \u0026quot;Milk\u0026quot;。 调用 beverage-\u0026gt;cost() 实际上调用了 Milk::cost()，该方法会调用 beverage-\u0026gt;cost()（即 Espresso::cost()），并加上 0.25。 此时，beverage 指向的是 Milk 对象，而 Milk 对象内部持有对 Espresso 对象的引用。\n1 2 3 4 5 6 7 beverage-\u0026gt;getDescription() -\u0026gt; Milk::getDescription() -\u0026gt; Espresso::getDescription() + \u0026#34;, Milk\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Milk::cost() -\u0026gt; Espresso::cost() + 0.25 -\u0026gt; 1.99 + 0.25 = 2.24 第二次装饰：添加 Sugar\n创建一个新的 Sugar 对象，并将 Milk 对象传递给它的构造函数。\n新的 Sugar 对象内部持有一个指向 Milk 对象的指针。\n调用 beverage-\u0026gt;getDescription() 实际上调用了 Sugar::getDescription()，该方法会调用 beverage-\u0026gt;getDescription()（即 Milk::getDescription()），并附加 \u0026quot;Sugar\u0026quot;。\n调用 beverage-\u0026gt;cost() 实际上调用了 Sugar::cost()，该方法会调用 beverage-\u0026gt;cost()（即 Milk::cost()），并加上 0.15。\n此时，beverage 指向的是 Sugar 对象，而 Sugar 对象内部持有对 Milk 对象的引用，Milk 对象内部持有对 Espresso 对象的引用。\n1 2 3 4 5 6 7 8 9 10 beverage-\u0026gt;getDescription() -\u0026gt; Sugar::getDescription() -\u0026gt; Milk::getDescription() + \u0026#34;, Sugar\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk\u0026#34; + \u0026#34;, Sugar\u0026#34; -\u0026gt; \u0026#34;Espresso, Milk, Sugar\u0026#34; beverage-\u0026gt;cost() -\u0026gt; Sugar::cost() -\u0026gt; Milk::cost() + 0.15 -\u0026gt; (Espresso::cost() + 0.25) + 0.15 -\u0026gt; 1.99 + 0.25 + 0.15 = 2.39 单例模式 一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例。单例模式通常用于需要控制资源（如数据库连接、配置设置、日志记录器等）的场景，以避免重复创建多个实例带来的资源浪费或不一致状态。\n使用单例模式 首先要确保 真的需要这个模式吗？\n单例模式的核心要素\n私有构造函数：防止外部通过 new 操作符创建对象。 静态方法：提供一个全局访问点来获取唯一实例。 静态成员变量：保存该类的唯一实例。 线程安全：在多线程环境下，确保实例化过程是线程安全的。 方法 说明 饿汉式 简单直接，但可能造成资源浪费。 线程安全。 懒汉式 延迟初始化，节省资源。 需要额外处理线程安全问题。 双重检查锁定 解决了懒汉式在多线程环境下的线程安全问题。 代码较为复杂。在多线程下，受内存访问重新排序影响，可能会出现致命问题，需要额外处理 使用智能指针 自动管理内存，避免手动释放资源。 使用 std::call_once 确保线程安全。 静态局部变量 最简单且线程安全，推荐指数:☆☆☆☆☆☆☆☆☆☆☆ 表格列举的方法都图一乐，真正使用的话 推荐使用线程安全的，例如：饿汉式、静态局部变量法。\n饿汉式 饿汉式是最简单的单例模式实现方式，它在类加载时就初始化实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class Logger { private: static Logger instance; // 静态成员变量，存储唯一实例 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { return instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; // 定义静态成员变量 Logger Logger::instance; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); return 0; } 优点：\n实现简单，线程安全（因为实例在类加载时就已经创建）。 缺点：\n如果实例从未被使用，仍然会占用资源。 懒汉式 懒汉式是在第一次调用 getInstance 方法时才创建实例，这样可以避免不必要的资源浪费。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; class Logger { private: static Logger* instance; // 静态指针，指向唯一实例 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { if (instance == nullptr) { instance = new Logger(); } return *instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { delete instance; instance = nullptr; } }; // 定义静态成员变量 Logger* Logger::instance = nullptr; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); // 清理资源 Logger::destroyInstance(); return 0; } 优点：\n延迟实例化，节省资源。 缺点：\n不是线程安全的，如果在多线程环境中同时调用 getInstance，可能会创建多个实例。 双重检查锁定 为了解决懒汉式在多线程环境下的线程安全问题，可以使用双重检查锁定机制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Logger { private: static Logger* instance; // 静态指针，指向唯一实例 static std::mutex mutex; // 互斥锁，保证线程安全 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { if (instance == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (instance == nullptr) { instance = new Logger(); } } return *instance; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); delete instance; instance = nullptr; } }; // 定义静态成员变量 Logger* Logger::instance = nullptr; std::mutex Logger::mutex; int main() { Logger\u0026amp; logger = Logger::getInstance(); logger.log(\u0026#34;This is a test log message.\u0026#34;); // 清理资源 Logger::destroyInstance(); return 0; } 优点：\n在多线程环境下保证了线程安全。 通过双重检查减少了加锁的开销。 缺点：\n代码相对复杂一些。 不安全，reorder内存访问重新排序导致双重锁定失效问题。 双重检查修复 使用atomic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Logger { private: static std::atomic\u0026lt;Logger*\u0026gt; instance; // 使用 atomic 指针管理实例 static std::mutex mutex; // 互斥锁，保证线程安全 // 私有构造函数，防止外部实例化 Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 禁止拷贝构造和赋值操作 Logger(const Logger\u0026amp;) = delete; Logger\u0026amp; operator=(const Logger\u0026amp;) = delete; // 静态方法，提供全局访问点 static Logger\u0026amp; getInstance() { Logger* tmp = instance.load(std::memory_order_relaxed); //获得原子的指针 std::atomic_thread_fence(std::memory_order_acquire); // 内存屏障，防止重排序 if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Logger(); std::atomic_thread_fence(std::memory_order_release); //释放内存屏障 instance.store(tmp, std::memory_order_relaxed); } } return *tmp; } void log(const std::string\u0026amp; message) const { std::cout \u0026lt;\u0026lt; \u0026#34;Log: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } // 析构函数 ~Logger() { std::cout \u0026lt;\u0026lt; \u0026#34;Logger instance destroyed.\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态方法，释放资源 static void destroyInstance() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); delete instance.load(); instance.store(nullptr, std::memory_order_relaxed); } }; // 定义静态成员变量 std::atomic\u0026lt;Logger*\u0026gt; Logger::instance(nullptr); std::mutex Logger::mutex; 进一步优化\nC++11 提供了 std::call_once 和 std::once_flag，可以确保某个函数只会被调用一次，非常适合用于实现线程安全的单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: // 获取单例实例 static Singleton* getInstance() { std::call_once(flag, []() { instance = new Singleton(); }); return instance; } // 删除拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 静态成员变量 static Singleton* instance; static std::once_flag flag; }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; std::once_flag Singleton::flag; int main() { // 多线程测试 auto func = []() { Singleton* instance = Singleton::getInstance(); instance-\u0026gt;doSomething(); }; std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); return 0; } 优点\n线程安全，代码简洁。 避免了双重检查锁定的复杂性。 缺点\n需要 C++11 及以上支持。 使用静态局部变量 主播主播🥰 你的单例确～实很强👍 但还是太吃操作了😇 有没有更加简单又强势的英雄推荐一下吗🧐 有的兄弟（战术停顿）有的😋 这么强势的英雄当～然是不止一个了🤓 一共有九位，都是当～前版本t～0.5的超～标英雄👉 告诉主播，你想学习哪个😤\nC++11 保证了静态局部变量的初始化是线程安全的，因此可以直接使用静态局部变量来实现单例模式。\n请务必禁用 copy 构造函数和赋值运算符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; class Singleton { public: // 获取单例实例 static Singleton\u0026amp; getInstance() { static Singleton instance; // 线程安全的静态局部变量 return instance; } // 删除拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 多线程测试 auto func = []() { Singleton\u0026amp; instance = Singleton::getInstance(); instance.doSomething(); }; std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); return 0; } 优点\n代码简洁，线程安全。 无需手动管理内存。 延迟加载，只在第一次使用时才构造。 避免静态对象在不同编译单元构造顺序的问题。 缺点\n需要 C++11 及以上支持。 静态类 在 C++ 中，单例模式 和 静态类 是两种常见的实现全局唯一实例或工具类的方式。它们各有优势和适用场景，以下是它们的详细对比：\n单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。静态类是指所有成员（包括方法和数据）都是静态的类。它通常用于工具类或全局函数集合。\n静态类示例：\n1 2 3 4 5 6 7 8 9 10 11 class StaticClass { public: // 删除构造函数和拷贝构造函数 StaticClass() = delete; StaticClass(const StaticClass\u0026amp;) = delete; // 静态方法 static void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Doing something in StaticClass\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 特性 单例模式 静态类 实例化 延迟初始化，按需创建 无需实例化，直接调用静态方法 继承与多态 支持继承和多态 不支持继承和多态 线程安全 需要额外处理 通常是线程安全的 生命周期管理 需要手动管理 自动管理 适用场景 需要全局唯一实例的场景 工具类或全局函数集合 全局状态 引入全局状态 引入全局状态 扩展性 高（可继承、可扩展） 低（无法继承） 场景 单例模式 静态类 游戏管理器 ✔️ 适合管理全局状态 ❌ 不适合 资源管理器 ✔️ 适合按需加载资源 ❌ 不适合 音频管理器 ✔️ 适合管理全局音频 ❌ 不适合 数学工具类 ❌ 过度设计 ✔️ 适合工具函数 调试工具类 ❌ 过度设计 ✔️ 适合工具函数 输入工具类 ❌ 过度设计 ✔️ 适合工具函数 命令模式 命令模式是一种行为设计模式，它将请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。具体来说，命令模式允许你将请求发送者和请求接收者解耦，通过引入一个命令对象来封装请求调用的细节。\n发送者（调用者） 只需要知道如何调用命令对象的 execute() 方法，而不需要了解具体的实现细节。 接收者 只需要提供具体的操作方法，而不关心这些方法是如何被调用的。 命令对象 则充当了发送者和接收者之间的桥梁，封装了请求的具体执行逻辑。 说白了 就调用虚函数，完事了。假设有个Command命令基类，它有一个execute函数，只要是Command的子类 都可以接收过来，这些子类重写execute虚函数，就能做出不同的效果，调用者只要执行Command-\u0026gt;execute() 就行了。\n下面的例子创建了多个类来体现这个设计模式，但是在C++中 可以传递 Lambda函数、函数指针 什么的来调用函数。而不需要创建好几个类，就有点占地方了。\n正在开发一个遥控器应用，该应用可以控制多个家电设备（如灯、风扇等）。可以使用命令模式来实现遥控器的功能，使得遥控器与具体的设备操作解耦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // Command 接口 class Command { public: virtual ~Command() = default; virtual void execute() = 0; }; // Light 类（接收者） class Light { public: void on() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is ON\u0026#34; \u0026lt;\u0026lt; std::endl; } void off() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is OFF\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Fan 类（接收者） class Fan { public: void start() { std::cout \u0026lt;\u0026lt; \u0026#34;Fan is STARTED\u0026#34; \u0026lt;\u0026lt; std::endl; } void stop() { std::cout \u0026lt;\u0026lt; \u0026#34;Fan is STOPPED\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体命令类：打开灯 class LightOnCommand : public Command { private: Light\u0026amp; light; public: LightOnCommand(Light\u0026amp; light) : light(light) {} void execute() override { light.on(); } }; // 具体命令类：关闭灯 class LightOffCommand : public Command { private: Light\u0026amp; light; public: LightOffCommand(Light\u0026amp; light) : light(light) {} void execute() override { light.off(); } }; // 具体命令类：启动风扇 class FanStartCommand : public Command { private: Fan\u0026amp; fan; public: FanStartCommand(Fan\u0026amp; fan) : fan(fan) {} void execute() override { fan.start(); } }; // 具体命令类：停止风扇 class FanStopCommand : public Command { private: Fan\u0026amp; fan; public: FanStopCommand(Fan\u0026amp; fan) : fan(fan) {} void execute() override { fan.stop(); } }; // 调用者：遥控器 class RemoteControl { private: std::unique_ptr\u0026lt;Command\u0026gt; command; public: void setCommand(std::unique_ptr\u0026lt;Command\u0026gt; cmd) { command = std::move(cmd); } void pressButton() { if (command) { command-\u0026gt;execute(); } } }; int main() { // 创建接收者 Light light; Fan fan; // 创建命令对象 LightOnCommand lightOn(light); LightOffCommand lightOff(light); FanStartCommand fanStart(fan); FanStopCommand fanStop(fan); // 创建遥控器 RemoteControl remote; // 设置并按下按钮 remote.setCommand(std::make_unique\u0026lt;LightOnCommand\u0026gt;(lightOn)); remote.pressButton(); // 输出: Light is ON remote.setCommand(std::make_unique\u0026lt;LightOffCommand\u0026gt;(lightOff)); remote.pressButton(); // 输出: Light is OFF remote.setCommand(std::make_unique\u0026lt;FanStartCommand\u0026gt;(fanStart)); remote.pressButton(); // 输出: Fan is STARTED remote.setCommand(std::make_unique\u0026lt;FanStopCommand\u0026gt;(fanStop)); remote.pressButton(); // 输出: Fan is STOPPED return 0; } 这不就是 遥控器接收一个命令基类，调用命令基类里的execute函数，命令基类可以派生出子类，子类重写execute虚函数 执行出不同的效果，\n状态模式 一种行为设计模式，它允许对象在其内部状态改变时改变其行为。这种模式可以将状态的逻辑从对象中分离出来，使得状态转换更加清晰和易于管理。\n人的情绪可以是“开心”、“生气”或“平静”。根据他的情绪不同，他对同一件事情的反应也会不同。比如：\n当他开心时，有人跟他开玩笑他会笑得很开心。 当他生气时，同样的玩笑可能会让他愤怒地回应。 当他平静时，他可能只是微微一笑，或者完全不理会。 状态模式的核心元素\n上下文（Context）：这个人本身，他有不同的状态，并且根据当前的状态表现出不同的行为。 状态接口（State Interface）：定义了所有具体状态的公共接口，例如对玩笑的反应。 具体状态（Concrete States）：每种情绪的具体实现，如“开心”、“生气”和“平静”。 假设有一个简单的程序来模拟一个人的心情变化，并根据心情做出不同的反应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 定义状态接口 class Mood { public: virtual ~Mood() = default; virtual void reactToJoke() = 0; }; // 上下文类，持有当前状态 class Person { public: explicit Person(std::unique_ptr\u0026lt;Mood\u0026gt; mood) : currentMood_(std::move(mood)) {} void setMood(std::unique_ptr\u0026lt;Mood\u0026gt; mood) { currentMood_ = std::move(mood); } void hearJoke() { if (currentMood_) { currentMood_-\u0026gt;reactToJoke(); } } private: std::unique_ptr\u0026lt;Mood\u0026gt; currentMood_; }; // 具体状态类：开心 class HappyMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;哈哈，太好笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体状态类：生气 class AngryMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;你这是什么意思？别开玩笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体状态类：平静 class CalmMood : public Mood { public: void reactToJoke() override { std::cout \u0026lt;\u0026lt; \u0026#34;嗯...这有点意思。\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建一个初始状态为开心的人 auto person = std::make_unique\u0026lt;Person\u0026gt;(std::make_unique\u0026lt;HappyMood\u0026gt;()); // 听到一个笑话 person-\u0026gt;hearJoke(); // 输出: 哈哈，太好笑了！ // 切换到生气状态 person-\u0026gt;setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); person-\u0026gt;hearJoke(); // 输出: 你这是什么意思？别开玩笑了！ // 切换到平静状态 person-\u0026gt;setMood(std::make_unique\u0026lt;CalmMood\u0026gt;()); person-\u0026gt;hearJoke(); // 输出: 嗯...这有点意思。 return 0; } 清晰的行为转换：每个状态都有明确的行为，避免了大量的条件判断语句。 易于扩展：如果需要添加新的状态或修改现有状态的行为，只需添加或修改具体状态类，而不影响其他部分的代码。 更好的组织代码：将状态逻辑分离出来，使得代码更加模块化和易于维护。 状态机\n设计一个状态机来表现心情的变化，可以通过定义不同的状态和状态之间的转换规则来实现。状态机是一种模型，用于表示系统在不同状态下如何响应各种事件，并根据这些事件进行状态转换。\n设计步骤\n定义状态：首先确定有哪些可能的状态。 定义事件：确定哪些事件会触发状态的改变。 定义状态转换规则：明确每个状态下对每个事件的响应以及状态转换关系。 实现状态机：使用代码实现上述定义的状态、事件和转换规则。 状态转换规则\n开心(Happy) 听到笑话 (Joke)-\u0026gt; 更加开心（仍然保持开心状态） 受到表扬 (Praise) -\u0026gt; 更加开心（仍然保持开心状态） 受到批评 (Criticism)-\u0026gt; 生气 生气(Angry) 听到笑话 (Joke)-\u0026gt; 不理睬（仍然保持生气状态） 受到表扬 (Praise)-\u0026gt; 平静 受到批评 (Criticism)-\u0026gt; 更加生气（仍然保持生气状态） 平静(Calm) 听到笑话 (Joke)-\u0026gt; 轻微高兴（开心） 受到表扬 (Praise)-\u0026gt; 开心 受到批评 (Criticism)-\u0026gt; 生气 结合状态模式的思想，将每个状态作为一个类，并定义状态转换逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; // 定义状态接口 class Mood { public: virtual ~Mood() = default; virtual void handleEvent(const std::string\u0026amp; event) = 0; virtual std::string getStateName() const = 0; }; // 上下文类，持有当前状态 class Person { public: explicit Person(std::unique_ptr\u0026lt;Mood\u0026gt; mood) : currentMood_(std::move(mood)) {} void setMood(std::unique_ptr\u0026lt;Mood\u0026gt; mood) { currentMood_ = std::move(mood); } void handleEvent(const std::string\u0026amp; event) { if (currentMood_) { std::cout \u0026lt;\u0026lt; \u0026#34;Current mood: \u0026#34; \u0026lt;\u0026lt; currentMood_-\u0026gt;getStateName() \u0026lt;\u0026lt; std::endl; currentMood_-\u0026gt;handleEvent(event); } } private: std::unique_ptr\u0026lt;Mood\u0026gt; currentMood_; }; // 具体状态类：开心 class HappyMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;哈哈，太好笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;真不错，继续保持！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;哼，你说什么？\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); } } std::string getStateName() const override { return \u0026#34;Happy\u0026#34;; } }; // 具体状态类：生气 class AngryMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;你这是什么意思？别开玩笑了！\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;好吧，这还差不多。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;CalmMood\u0026gt;()); } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;你怎么能这么说！\u0026#34; \u0026lt;\u0026lt; std::endl; } } std::string getStateName() const override { return \u0026#34;Angry\u0026#34;; } }; // 具体状态类：平静 class CalmMood : public Mood { public: void handleEvent(const std::string\u0026amp; event) override { if (event == \u0026#34;HearJoke\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;嗯...这有点意思。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;HappyMood\u0026gt;()); } else if (event == \u0026#34;ReceivePraise\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;谢谢你的认可！\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;HappyMood\u0026gt;()); } else if (event == \u0026#34;ReceiveCriticism\u0026#34;) { std::cout \u0026lt;\u0026lt; \u0026#34;我会注意的。\u0026#34; \u0026lt;\u0026lt; std::endl; setMood(std::make_unique\u0026lt;AngryMood\u0026gt;()); } } std::string getStateName() const override { return \u0026#34;Calm\u0026#34;; } }; int main() { // 创建一个初始状态为开心的人 auto person = std::make_unique\u0026lt;Person\u0026gt;(std::make_unique\u0026lt;HappyMood\u0026gt;()); // 处理一系列事件 person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 哈哈，太好笑了！ person-\u0026gt;handleEvent(\u0026#34;ReceiveCriticism\u0026#34;); // 输出: 哼，你说什么？ Current mood: Angry person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 你这是什么意思？别开玩笑了！ person-\u0026gt;handleEvent(\u0026#34;ReceivePraise\u0026#34;); // 输出: 好吧，这还差不多。 Current mood: Calm person-\u0026gt;handleEvent(\u0026#34;HearJoke\u0026#34;); // 输出: 嗯...这有点意思。 Current mood: Happy person-\u0026gt;handleEvent(\u0026#34;ReceivePraise\u0026#34;); // 输出: 谢谢你的认可！ Current mood: Happy return 0; } 门面模式 一种结构型设计模式，它为复杂的子系统提供一个简化的接口。门面模式通过引入一个单一的接口类来隐藏系统的复杂性，使得外部与系统的交互更加简单和直观。\n门面模式的核心概念\n门面（Facade）：提供一个统一的接口，用于访问多个子系统的功能。客户端只需要与这个门面进行交互，而不需要直接调用各个子系统的具体实现。 子系统（Subsystem）：包含实际的功能模块或组件，通常由多个类组成，每个类负责特定的任务。 适用场景\n当需要简化一个复杂的子系统时。 当需要将子系统的实现细节与客户端代码解耦时。 当希望将一组复杂的类组织在一起，并对外提供一个简单的接口时。 当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。\n假设正在开发一个多媒体播放器，该播放器需要处理音频、视频和字幕等多个子系统。为了简化客户端代码的使用，可以使用门面模式来封装这些子系统的操作。\n子系统类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; // 音频子系统 class AudioPlayer { public: void loadAudio(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading audio: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void playAudio() { std::cout \u0026lt;\u0026lt; \u0026#34;Playing audio.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 视频子系统 class VideoPlayer { public: void loadVideo(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading video: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void playVideo() { std::cout \u0026lt;\u0026lt; \u0026#34;Playing video.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 字幕子系统 class SubtitleManager { public: void loadSubtitle(const std::string\u0026amp; fileName) { std::cout \u0026lt;\u0026lt; \u0026#34;Loading subtitle: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; std::endl; } void displaySubtitle() { std::cout \u0026lt;\u0026lt; \u0026#34;Displaying subtitle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 门面类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 门面类，提供一个简化的接口来操作多媒体播放器 class MediaFacade { public: MediaFacade() : audioPlayer(new AudioPlayer()), videoPlayer(new VideoPlayer()), subtitleManager(new SubtitleManager()) {} ~MediaFacade() { delete audioPlayer; delete videoPlayer; delete subtitleManager; } void playMedia(const std::string\u0026amp; audioFile, const std::string\u0026amp; videoFile, const std::string\u0026amp; subtitleFile) { // 加载并播放音频 audioPlayer-\u0026gt;loadAudio(audioFile); audioPlayer-\u0026gt;playAudio(); // 加载并播放视频 videoPlayer-\u0026gt;loadVideo(videoFile); videoPlayer-\u0026gt;playVideo(); // 加载并显示字幕 subtitleManager-\u0026gt;loadSubtitle(subtitleFile); subtitleManager-\u0026gt;displaySubtitle(); } private: AudioPlayer* audioPlayer; VideoPlayer* videoPlayer; SubtitleManager* subtitleManager; }; 客户端代码\n1 2 3 4 5 6 7 8 9 int main() { // 创建门面对象 MediaFacade mediaFacade; // 使用门面对象来播放多媒体文件 mediaFacade.playMedia(\u0026#34;audio.mp3\u0026#34;, \u0026#34;video.mp4\u0026#34;, \u0026#34;subtitle.srt\u0026#34;); return 0; } 输出：\n1 2 3 4 5 6 Loading audio: audio.mp3 Playing audio. Loading video: video.mp4 Playing video. Loading subtitle: subtitle.srt Displaying subtitle. 门面类 MediaFacade： 提供了一个简化的接口 playMedia，该接口内部调用了各个子系统的相应方法来完成多媒体播放任务。 通过门面类，客户端代码不需要直接与各个子系统进行交互，只需要调用门面提供的接口即可。 优点\n简化客户端代码：客户端只需要与门面进行交互，无需了解子系统的内部细节。 提高灵活性：可以在不改变客户端代码的情况下修改子系统的实现。 促进松耦合：门面类与子系统之间是松耦合的，便于维护和扩展。 扩展示例\n假设需要在播放多媒体文件之前检查文件是否存在，可以在门面类中添加相应的逻辑，而无需修改子系统类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;fstream\u0026gt; class MediaFacade { public: MediaFacade() : audioPlayer(new AudioPlayer()), videoPlayer(new VideoPlayer()), subtitleManager(new SubtitleManager()) {} ~MediaFacade() { delete audioPlayer; delete videoPlayer; delete subtitleManager; } bool fileExists(const std::string\u0026amp; fileName) { std::ifstream file(fileName); return file.good(); } void playMedia(const std::string\u0026amp; audioFile, const std::string\u0026amp; videoFile, const std::string\u0026amp; subtitleFile) { if (!fileExists(audioFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Audio file not found: \u0026#34; \u0026lt;\u0026lt; audioFile \u0026lt;\u0026lt; std::endl; return; } if (!fileExists(videoFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Video file not found: \u0026#34; \u0026lt;\u0026lt; videoFile \u0026lt;\u0026lt; std::endl; return; } if (!fileExists(subtitleFile)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Subtitle file not found: \u0026#34; \u0026lt;\u0026lt; subtitleFile \u0026lt;\u0026lt; std::endl; return; } // 加载并播放音频 audioPlayer-\u0026gt;loadAudio(audioFile); audioPlayer-\u0026gt;playAudio(); // 加载并播放视频 videoPlayer-\u0026gt;loadVideo(videoFile); videoPlayer-\u0026gt;playVideo(); // 加载并显示字幕 subtitleManager-\u0026gt;loadSubtitle(subtitleFile); subtitleManager-\u0026gt;displaySubtitle(); } private: AudioPlayer* audioPlayer; VideoPlayer* videoPlayer; SubtitleManager* subtitleManager; }; 在这个扩展示例中，在门面类中添加了 fileExists 方法来检查文件是否存在，并在 playMedia 方法中进行了相应的检查。这样，即使子系统类没有文件检查的功能，也可以通过门面类来增强其功能，而不会影响到现有的子系统实现。\n通过这种方式，门面模式可以简化复杂的系统接口，使其更易于使用和维护。\n在扩展检查文件存在性的例子中，无论内部如何变，在外部看来是没有变化的，依然可以使用相同的方式使用\n1 2 3 4 5 6 7 8 9 int main() { // 创建门面对象 MediaFacade mediaFacade; // 使用门面对象来播放多媒体文件 mediaFacade.playMedia(\u0026#34;audio.mp3\u0026#34;, \u0026#34;video.mp4\u0026#34;, \u0026#34;subtitle.srt\u0026#34;); return 0; } 解耦—内部子系统的变化 不会影响到接口的变化.\n门面模式中组件的内部是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。\n迭代器模式 一种行为设计模式，它提供了一种方法来顺序访问一个聚合对象中的各个元素，而无需暴露其内部表示。迭代器模式将遍历集合的职责从集合本身分离出来，使得不同的遍历方式可以独立于集合实现。\n迭代器模式的核心概念\nAggregate（聚合类）：定义了创建迭代器对象的接口。 Iterator（迭代器接口）：声明了遍历集合所需的方法，如 hasNext() 和 next()。 ConcreteIterator（具体迭代器类）：实现了迭代器接口，并保持对遍历过程的跟踪。 传统迭代器模式是面向对象风格，在C++中需要使用虚函数实现，性能不好C++标准库的迭代器采用模板编程，在编译时确定\n面向对象风格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 迭代器接口 class Iterator { public: virtual ~Iterator() = default; virtual bool hasNext() const = 0; virtual std::string next() = 0; }; // 聚合类接口 class Aggregate { public: virtual ~Aggregate() = default; virtual std::unique_ptr\u0026lt;Iterator\u0026gt; createIterator() const = 0; }; // 图书类 class Book { public: explicit Book(const std::string\u0026amp; title) : title_(title) {} std::string getTitle() const { return title_; } private: std::string title_; }; // 具体聚合类：图书集合 class BookCollection : public Aggregate { public: void addBook(const std::string\u0026amp; title) { books_.emplace_back(title); } std::unique_ptr\u0026lt;Iterator\u0026gt; createIterator() const override { return std::make_unique\u0026lt;BookIterator\u0026gt;(books_); } private: std::vector\u0026lt;Book\u0026gt; books_; }; // 具体迭代器类：从前向后遍历 class BookIterator : public Iterator { public: explicit BookIterator(const std::vector\u0026lt;Book\u0026gt;\u0026amp; books) : books_(books), index_(0) {} bool hasNext() const override { return index_ \u0026lt; books_.size(); } std::string next() override { if (!hasNext()) { throw std::out_of_range(\u0026#34;No more books.\u0026#34;); } return books_[index_++].getTitle(); } private: const std::vector\u0026lt;Book\u0026gt;\u0026amp; books_; size_t index_; }; int main() { // 创建图书集合并添加一些图书 auto bookCollection = std::make_unique\u0026lt;BookCollection\u0026gt;(); bookCollection-\u0026gt;addBook(\u0026#34;C++ Primer\u0026#34;); bookCollection-\u0026gt;addBook(\u0026#34;Effective C++\u0026#34;); bookCollection-\u0026gt;addBook(\u0026#34;Design Patterns\u0026#34;); // 获取迭代器并遍历图书集合 auto iterator = bookCollection-\u0026gt;createIterator(); while (iterator-\u0026gt;hasNext()) { std::cout \u0026lt;\u0026lt; iterator-\u0026gt;next() \u0026lt;\u0026lt; std::endl; } return 0; } 组合模式 一种结构型设计模式， 可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n组合模式的核心思想是：\n定义一个统一的接口（抽象类或基类），用于表示单个对象和组合对象。 单个对象和组合对象都实现这个接口。 组合对象可以包含其他组合对象或单个对象，从而形成树形结构。 假设正在开发一个文件系统，文件系统中有两种类型的对象：\n文件（File）：单个对象，没有子对象。 文件夹（Folder）：组合对象，可以包含文件或其他文件夹。 可以使用组合模式来表示文件系统的层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 抽象组件类 class FileSystemComponent { public: virtual ~FileSystemComponent() = default; virtual void display(int depth = 0) const = 0; // 显示组件信息 }; // 叶子类：文件 class File : public FileSystemComponent { public: File(const std::string\u0026amp; name) : name(name) {} void display(int depth = 0) const override { std::cout \u0026lt;\u0026lt; std::string(depth, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; \u0026#34;File: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; } private: std::string name; }; // 组合类：文件夹 class Folder : public FileSystemComponent { public: Folder(const std::string\u0026amp; name) : name(name) {} void addComponent(FileSystemComponent* component) { components.push_back(component); } void display(int depth = 0) const override { std::cout \u0026lt;\u0026lt; std::string(depth, \u0026#39;-\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Folder: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; for (const auto\u0026amp; component : components) { component-\u0026gt;display(depth + 2); // 递归显示子组件 } } private: std::string name; std::vector\u0026lt;FileSystemComponent*\u0026gt; components; }; int main() { // 创建文件 File* file1 = new File(\u0026#34;file1.txt\u0026#34;); File* file2 = new File(\u0026#34;file2.txt\u0026#34;); File* file3 = new File(\u0026#34;file3.txt\u0026#34;); // 创建文件夹 Folder* folder1 = new Folder(\u0026#34;Folder 1\u0026#34;); Folder* folder2 = new Folder(\u0026#34;Folder 2\u0026#34;); Folder* rootFolder = new Folder(\u0026#34;Root Folder\u0026#34;); // 构建树形结构 folder1-\u0026gt;addComponent(file1); folder1-\u0026gt;addComponent(file2); folder2-\u0026gt;addComponent(file3); rootFolder-\u0026gt;addComponent(folder1); rootFolder-\u0026gt;addComponent(folder2); // 显示文件系统结构 rootFolder-\u0026gt;display(); // 释放内存 delete file1; delete file2; delete file3; delete folder1; delete folder2; delete rootFolder; return 0; } 输出：\n1 2 3 4 5 6 Folder: Root Folder --Folder: Folder 1 ----File: file1.txt ----File: file2.txt --Folder: Folder 2 ----File: file3.txt 优点\n统一处理单个对象和组合对象： 客户端可以统一处理文件和文件夹，无需区分它们。 灵活性： 可以动态地添加或删除组件，构建复杂的树形结构。 可扩展性： 新增组件类型时，无需修改现有代码。 缺点\n设计复杂性： 需要定义抽象组件类、叶子类和组合类，增加了代码的复杂性。 类型检查： 在某些情况下，客户端可能需要检查组件的类型（如判断是否是文件夹），这可能会破坏组合模式的透明性。 适用场景\n表示部分-整体层次结构： 如文件系统、菜单系统、组织结构等。 统一处理单个对象和组合对象： 当客户端需要统一处理单个对象和组合对象时。 动态构建树形结构： 当需要动态地添加或删除组件时。 组合模式课后康复练习\n假设你有两个类的对象：产品和盒子。一个盒子可以包含多个产品或其他较小的盒子，这些小盒子也可以再包含产品或更小的盒子，以此类推。\n问题描述\n你需要开发一个订购系统，订单中可以包含：\n未包装的简单产品 装满产品的盒子 其他盒子（可能包含更多产品或盒子） 目标是计算每张订单的总价格。\n直接计算的问题\n直接计算所有项目的总价在现实中或许可行，但在程序中实现时会遇到以下困难：\n必须事先知道所有产品和盒子的类别。 需要了解所有盒子的嵌套层数和其他复杂细节。 这种方法非常繁琐且容易出错。 解决方案：组合模式\n组合模式通过使用通用接口来统一处理产品和盒子，并声明一个计算总价的方法。具体如下：\n定义通用接口： 声明一个计算总价的方法（例如 getPrice）。 实现叶子节点（产品）： 对于产品，该方法直接返回其价格。 实现组合节点（盒子）： 对于盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。 如果其中某个项目是另一个盒子，则当前盒子也会递归地遍历其中的所有项目，直到计算出所有内部组成部分的价格。 优点： 无需了解对象的具体类（无论是产品还是盒子）。 可以用相同的方式处理所有对象，无论它们是简单的还是复杂的结构。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 组件接口 class Component { public: virtual ~Component() = default; virtual double getPrice() const = 0; // 计算总价 }; // 产品类 class Product : public Component { public: Product(double price) : price_(price) {} double getPrice() const override { return price_; } private: double price_; }; // 盒子类 class Box : public Component { public: void add(std::unique_ptr\u0026lt;Component\u0026gt; component) { components_.push_back(std::move(component)); } double getPrice() const override { double total = 0.0; for (const auto\u0026amp; component : components_) { total += component-\u0026gt;getPrice(); } return total; } private: std::vector\u0026lt;std::unique_ptr\u0026lt;Component\u0026gt;\u0026gt; components_; }; int main() { // 创建一个盒子 auto box = std::make_unique\u0026lt;Box\u0026gt;(); // 向盒子中添加产品 box-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(10.0)); // 产品A box-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(20.0)); // 产品B // 创建另一个盒子并将其添加到第一个盒子中 auto nestedBox = std::make_unique\u0026lt;Box\u0026gt;(); nestedBox-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(5.0)); // 产品C nestedBox-\u0026gt;add(std::make_unique\u0026lt;Product\u0026gt;(15.0)); // 产品D box-\u0026gt;add(std::move(nestedBox)); // 计算并显示总价格 std::cout \u0026lt;\u0026lt; \u0026#34;Total Price: \u0026#34; \u0026lt;\u0026lt; box-\u0026gt;getPrice() \u0026lt;\u0026lt; std::endl; return 0; } Total Price: 50\n代理模式 一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n适用情况\n延迟初始化（Lazy Initialization）：在需要时才创建昂贵的对象。 访问控制：根据权限控制对对象的访问。 远程代理：代表远程对象进行操作，如网络请求。 虚拟代理：为复杂对象创建一个轻量级的占位符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;iostream\u0026gt; class Subject { public: virtual void Request() const = 0; }; class RealSubject : public Subject { public: void Request() const override { std::cout \u0026lt;\u0026lt; \u0026#34;RealSubject: Handling request.\\n\u0026#34;; } }; class Proxy : public Subject { private: RealSubject* real_subject_; bool CheckAccess() const { // Some real checks should go here. std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Checking access prior to firing a real request.\\n\u0026#34;; return true; } void LogAccess() const { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Logging the time of request.\\n\u0026#34;; } public: Proxy(RealSubject* real_subject) : real_subject_(new RealSubject(*real_subject)) {} ~Proxy() { delete real_subject_; } void Request() const override { if (this-\u0026gt;CheckAccess()) { this-\u0026gt;real_subject_-\u0026gt;Request(); this-\u0026gt;LogAccess(); } } }; void ClientCode(const Subject\u0026amp; subject) { // ... subject.Request(); // ... } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the client code with a real subject:\\n\u0026#34;; RealSubject* real_subject = new RealSubject; ClientCode(*real_subject); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Client: Executing the same client code with a proxy:\\n\u0026#34;; Proxy* proxy = new Proxy(real_subject); ClientCode(*proxy); delete real_subject; delete proxy; return 0; } 间接访问：通过代理对象间接访问实际对象，可以在不修改实际对象的情况下添加额外的功能。 权限检查和日志记录：在调用实际对象的方法之前和之后，代理可以执行额外的操作，如权限检查和日志记录。 扩展性：可以在代理类中轻松添加新功能，而不需要修改实际对象的类，提高了代码的可维护性和扩展性。 适配器模式 一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n示例：手机充电适配器\n在这个示例中：\nPhone类代表的手机，它需要一个USB接口来充电。 OldCharger类代表一个旧式的充电器，它只有圆形插头输出。 UsbAdapter类是适配器，它接受圆形插头输入，并提供USB接口输出，使手机可以使用旧式充电器充电。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 目标接口：USB充电接口 class UsbCharger { public: virtual void charge() = 0; virtual ~UsbCharger() {} // 虚析构函数以确保正确释放派生类对象 }; // 具体实现：手机类，需要USB充电接口 class Phone { private: UsbCharger* charger; public: Phone(UsbCharger* c) : charger(c) {} void chargePhone() { std::cout \u0026lt;\u0026lt; \u0026#34;Connecting phone to charger...\u0026#34; \u0026lt;\u0026lt; std::endl; charger-\u0026gt;charge(); std::cout \u0026lt;\u0026lt; \u0026#34;Phone is charging.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 需要被适配的类：旧式充电器，只有圆形插头接口 class OldCharger { public: void oldCharge() { std::cout \u0026lt;\u0026lt; \u0026#34;Using old charger with round pin plug.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 适配器类：适配旧式充电器到USB充电接口 class UsbAdapter : public UsbCharger { private: OldCharger* oldCharger; public: UsbAdapter(OldCharger* oc) : oldCharger(oc) {} void charge() override { std::cout \u0026lt;\u0026lt; \u0026#34;Adapting old charger to USB...\u0026#34; \u0026lt;\u0026lt; std::endl; oldCharger-\u0026gt;oldCharge(); // 使用旧式充电器的方法 } }; // main函数演示如何使用这些类 int main() { OldCharger oldCharger; UsbAdapter usbAdapter(\u0026amp;oldCharger); Phone myPhone(\u0026amp;usbAdapter); myPhone.chargePhone(); return 0; } 输出：\n1 2 3 4 连接充电器... 适配旧式充电器为USB接口.... 使用旧式充电器（圆形插头）充电. 充电中. 即使 OldCharger 不直接兼容 Phone 所需的 USB 接口，通过 UsbAdapter，Phone 也能成功使用 OldCharger 来充电。这就是适配器模式的核心思想。\n享元模式 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n享元模式的核心思想\n内部状态：可以在多个对象之间共享的状态。 外部状态：不能在对象之间共享的状态，必须由客户端代码提供。 假设正在开发一个文本编辑器，其中每个字符都有其自己的格式（如颜色、字体大小等）。如果为每个字符都创建一个新的对象，这将消耗大量的内存。通过使用享元模式，可以共享那些具有相同格式设置的对象，从而减少内存使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; // 享元接口 class CharacterStyle { public: virtual void display(char ch) const = 0; }; // 具体享元类 class ConcreteCharacterStyle : public CharacterStyle { private: std::string color; int fontSize; public: ConcreteCharacterStyle(const std::string\u0026amp; color, int fontSize) : color(color), fontSize(fontSize) {} void display(char ch) const override { std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; \u0026#34;, Color: \u0026#34; \u0026lt;\u0026lt; color \u0026lt;\u0026lt; \u0026#34;, Font Size: \u0026#34; \u0026lt;\u0026lt; fontSize \u0026lt;\u0026lt; std::endl; } }; // 享元工厂 class CharacterStyleFactory { private: std::unordered_map\u0026lt;std::string, CharacterStyle*\u0026gt; styles; std::string getKey(const std::string\u0026amp; color, int fontSize) const { return color + \u0026#34;_\u0026#34; + std::to_string(fontSize); } public: CharacterStyle* getStyle(const std::string\u0026amp; color, int fontSize) { std::string key = getKey(color, fontSize); if (styles.find(key) == styles.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Creating new style for: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; styles[key] = new ConcreteCharacterStyle(color, fontSize); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Reusing existing style for: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; } return styles[key]; } ~CharacterStyleFactory() { for (auto\u0026amp; pair : styles) { delete pair.second; } } }; // 使用享元模式的客户端代码 void displayText(CharacterStyleFactory\u0026amp; factory, const std::string\u0026amp; text, const std::string\u0026amp; color, int fontSize) { for (char ch : text) { CharacterStyle* style = factory.getStyle(color, fontSize); style-\u0026gt;display(ch); } } int main() { CharacterStyleFactory factory; // 显示不同字符但相同格式的文本 displayText(factory, \u0026#34;Hello\u0026#34;, \u0026#34;Red\u0026#34;, 12); displayText(factory, \u0026#34;World\u0026#34;, \u0026#34;Red\u0026#34;, 12); // 显示不同格式的文本 displayText(factory, \u0026#34;Test\u0026#34;, \u0026#34;Blue\u0026#34;, 14); return 0; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Creating new style for: Red_12 Character: H, Color: Red, Font Size: 12 Character: e, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: o, Color: Red, Font Size: 12 Reusing existing style for: Red_12 Character: W, Color: Red, Font Size: 12 Character: o, Color: Red, Font Size: 12 Character: r, Color: Red, Font Size: 12 Character: l, Color: Red, Font Size: 12 Character: d, Color: Red, Font Size: 12 Creating new style for: Blue_14 Character: T, Color: Blue, Font Size: 14 Character: e, Color: Blue, Font Size: 14 Character: s, Color: Blue, Font Size: 14 Character: t, Color: Blue, Font Size: 14 CharacterStyle 类：这是享元接口，定义了所有具体享元类必须实现的方法 display()。 ConcreteCharacterStyle 类：实现了 CharacterStyle 接口的具体享元类。它包含了字符的格式信息（颜色和字体大小），并负责显示字符。 CharacterStyleFactory 类：这是一个享元工厂，用于管理和共享享元对象。它通过一个哈希表来存储已经创建的享元对象，并根据请求返回相应的享元对象。 displayText 函数：这是客户端代码，展示了如何使用享元工厂来获取和显示字符。 当第一次请求“Red_12”格式时，工厂会创建一个新的 ConcreteCharacterStyle 对象。 在后续请求相同格式（“Red_12”）时，工厂会重用之前创建的对象，而不是再次创建新的对象。 同样地，当请求不同的格式（如“Blue_14”）时，工厂会创建一个新的 ConcreteCharacterStyle 对象。 通过这种方式，享元模式有效地减少了内存使用，特别是在处理大量相似对象的情况下。\n桥接模式 一种结构型设计模式，它将抽象部分与其实现部分分离，使它们可以独立变化。这种模式通过提供一个桥梁接口来实现两个层次的抽象，使得系统更加灵活和可扩展。\n桥接模式的核心思想\n抽象部分：定义了高层控制逻辑，但不关心具体的实现细节。 实现部分：定义了底层的具体实现，但不关心如何被使用。 桥梁接口：将抽象部分与实现部分连接起来，使得两者可以独立变化。 假设要设计一个绘图应用，其中包含不同类型的形状（如圆形和矩形），并且这些形状可以在不同的渲染器上绘制（如矢量渲染器和光栅渲染器）。\n抽象部分：定义了形状的类型（如圆形、矩形）。 实现部分：定义了渲染器的具体实现（如矢量渲染器、光栅渲染器）。 桥梁接口：将形状与渲染器连接起来，使得两者可以独立变化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 实现部分：渲染器接口 class Renderer { public: virtual void renderCircle(float x, float y, float radius) const = 0; virtual ~Renderer() {} }; // 具体实现：矢量渲染器 class VectorRenderer : public Renderer { public: void renderCircle(float x, float y, float radius) const override { std::cout \u0026lt;\u0026lt; \u0026#34;VectorRenderer: Drawing Circle at (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;) with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; // 具体实现：光栅渲染器 class RasterRenderer : public Renderer { public: void renderCircle(float x, float y, float radius) const override { std::cout \u0026lt;\u0026lt; \u0026#34;RasterRenderer: Drawing Circle at (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;) with radius \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } }; // 抽象部分：形状类 class Shape { protected: Renderer* renderer; public: Shape(Renderer* r) : renderer(r) {} virtual void draw() const = 0; virtual ~Shape() {} }; // 具体形状：圆形 class Circle : public Shape { private: float x, y, radius; public: Circle(float centerX, float centerY, float rad, Renderer* r) : Shape(r), x(centerX), y(centerY), radius(rad) { } void draw() const override { renderer-\u0026gt;renderCircle(x, y, radius); } }; // 客户端代码 void clientCode() { // 使用矢量渲染器绘制圆形 Renderer* vectorRenderer = new VectorRenderer(); Shape* circleWithVector = new Circle(1.0f, 2.0f, 3.0f, vectorRenderer); circleWithVector-\u0026gt;draw(); // 使用光栅渲染器绘制圆形 Renderer* rasterRenderer = new RasterRenderer(); Shape* circleWithRaster = new Circle(4.0f, 5.0f, 6.0f, rasterRenderer); circleWithRaster-\u0026gt;draw(); // 清理资源 delete circleWithVector; delete circleWithRaster; delete vectorRenderer; delete rasterRenderer; } int main() { clientCode(); return 0; } 这不就是把Renderer传给shape，让shape调用Renderer的renderCircle函数？而且Renderer类可以在运行时动态生成子类，可以把子类传给shape 从而实现shape能够调用任何Renderer子类的renderCircle函数.\n桥接模式的核心就是通过组合的方式，将抽象部分（如形状）与实现部分（如渲染器）解耦。具体来说，是通过将 Renderer 传给 Shape，使得 Shape 可以在运行时调用任何 Renderer 子类的 renderCircle 方法。这种方式不仅实现了分离关注点，还提供了极大的灵活性和可扩展性。\n桥接模式的关键点\n解耦抽象与实现：通过组合的方式，使得 Shape 和 Renderer 可以独立变化。 动态绑定：可以在运行时选择不同的 Renderer 实现，并将其传递给 Shape 对象。 灵活性：可以轻松添加新的 Shape 或 Renderer 类，而不需要修改现有代码。 备忘录模式 一种行为设计模式，它允许在不暴露对象实现细节的情况下保存和恢复对象的内部状态。这种模式通常用于需要回滚操作或撤销功能的场景中。\n备忘录模式的核心思想\n原发器（Originator）：负责创建和存储其内部状态的备忘录对象。 备忘录（Memento）：包含原发器对象的状态信息，但不允许其他对象访问这些信息，以保护封装性。 管理者（Caretaker）：负责保存备忘录对象，但不直接操作备忘录的内容。 假设正在开发一个简单的文本编辑器，用户可以输入文本并执行撤销操作。可以使用备忘录模式来保存和恢复文本编辑器的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 备忘录类 class Memento { public: std::string state; // 存储原发器的状态 // 只有原发器可以访问备忘录的私有成员 friend class TextEditor; Memento(){} Memento(const std::string\u0026amp; state) : state(state) {} std::string getState() const { return state; } }; // 原发器类 class TextEditor { private: std::string text; // 当前文本内容 public: void setText(const std::string\u0026amp; text) { this-\u0026gt;text = text; } std::string getText() const { return text; } // 创建备忘录 Memento createMemento() const { return Memento(text); } // 恢复状态 void restoreFromMemento(const Memento\u0026amp; memento) { text = memento.getState(); } }; // 管理者类 class History { public: void saveMemento(const Memento\u0026amp; memento) { this-\u0026gt;memento = memento; } Memento getMemento() const { return memento; } private: Memento memento; }; int main() { TextEditor editor; History history; // 编辑文本 editor.setText(\u0026#34;Version 1\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; // 保存状态 history.saveMemento(editor.createMemento()); // 继续编辑文本 editor.setText(\u0026#34;Version 2\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; // 恢复到之前的状态 editor.restoreFromMemento(history.getMemento()); std::cout \u0026lt;\u0026lt; \u0026#34;Restored Text: \u0026#34; \u0026lt;\u0026lt; editor.getText() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 Current Text: Version 1 Current Text: Version 2 Restored Text: Version 1 代码说明\n备忘录类（Memento）： 存储原发器的内部状态（如文本内容）。 通过私有构造函数和友元类确保只有原发器可以创建和访问备忘录对象。 原发器类（TextEditor）： 负责创建备忘录对象（createMemento 方法）。 可以使用备忘录对象恢复自身状态（restoreFromMemento 方法）。 管理者类（History）： 负责保存备忘录对象（saveMemento 方法）。 不能修改备忘录对象的内容，只能获取备忘录对象（getMemento 方法）。 客户端代码： 使用原发器编辑文本并保存状态。 使用管理者保存备忘录对象。 使用备忘录对象恢复原发器的状态。 优点\n封装性： 备忘录模式在不破坏封装性的前提下保存和恢复对象的状态。 简化原发器： 将状态保存和恢复的逻辑分离到备忘录和管理者中，简化了原发器的代码。 可扩展性： 可以轻松地支持多次撤销操作（通过保存多个备忘录对象）。 缺点\n资源消耗： 如果对象的状态很大或需要保存多个状态，可能会消耗大量内存。 复杂性： 引入了备忘录和管理者类，增加了代码的复杂性。 中介模式 职责链模式 访问器模式 解析器模式 ","date":"1575-01-01T00:53:52+08:00","permalink":"https://akaklya.github.io/p/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"C++设计模式"},{"content":"简介 多线程 多线程是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。\n多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。\n关键概念\n线程：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。 并发：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。 并行：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。 并发，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。\n特性 并发（Concurrency） 并行（Parallelism） 定义 多个任务交替执行，看似同时运行。 多个任务真正同时执行。 硬件需求 单核 CPU 即可实现。 需要多核 CPU 或多个处理器。 目标 提高资源利用率，增强系统响应性。 提高计算性能，加快任务完成速度。 适用场景 I/O 密集型任务（如网络请求、文件读写）。 计算密集型任务（如科学计算、图像处理）。 实现方式 通过时间片轮转或事件循环实现。 通过多核 CPU 或分布式计算实现。 示例 单核 CPU 上运行多个线程。 多核 CPU 上同时运行多个线程。 并发示例：\n一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。 一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。 并行示例：\n使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。 使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。 多线程的作用\n提高性能：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。 提高响应性：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。 简化设计：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。 异步处理：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。 实际应用场景\nWeb 服务器： 场景：处理大量并发请求。 实现：每个请求由一个独立线程处理，主线程继续接收新请求。 优势：提高并发处理能力，减少响应时间。 图形用户界面（GUI）应用程序： 场景：执行耗时任务（如文件处理、网络请求）时保持界面响应。 实现：耗时任务在后台线程执行，主线程负责更新界面。 优势：避免界面卡顿，提升用户体验。 数据处理与计算： 场景：大数据处理或复杂计算（如图像处理、科学计算）。 实现：将数据分块，每个线程处理一块。 优势：充分利用多核 CPU，加快处理速度。 游戏开发： 场景：同时处理图形渲染、物理模拟、AI 计算等任务。 实现：不同任务由不同线程处理，通过同步机制协调。 优势：提高游戏性能和流畅度。 实时系统： 场景：需要快速响应的系统（如自动驾驶、工业控制）。 实现：关键任务由独立线程处理，确保实时性。 优势：提高系统响应速度和可靠性。 多线程与进程 在操作系统中，进程和线程是两个核心概念，而主线程是进程中的一个特殊线程。\n主线程是进程的一部分：进程是资源的容器，而主线程是进程内的执行单元。 主线程的生命周期与进程紧密相关： 当主线程开始执行时，进程开始运行。 当主线程执行完毕（main 函数返回）且没有其他非守护线程运行时，进程结束。 主线程与其他线程的关系： 主线程可以创建和管理其他线程。 主线程和其他线程共享进程的资源（如内存、文件句柄等）。 主线程的结束不会立即终止其他线程，但如果主线程结束且没有其他非守护线程，进程会终止。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void worker() { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread started.\u0026#34; \u0026lt;\u0026lt; std::endl; // 创建一个子线程 std::thread t(worker); // 主线程继续执行 std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; // 等待子线程结束 t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 输出\n1 2 3 4 5 Main thread started. Worker thread is running... Main thread is running... Worker thread finished. Main thread finished. 线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换要保存很多中间状态切换线程会耗费本该属于程序运行的时间.\n多线程-A 线程创建 线程的多种创建方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;chrono\u0026gt; class Obj { public: Obj() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj is created\u0026#34; \u0026lt;\u0026lt; std::endl; } void operator()(int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Obj is called...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; } }; class Obj2 { public: Obj2() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj2 is created\u0026#34; \u0026lt;\u0026lt; std::endl; } void operator()() { std::cout \u0026lt;\u0026lt; \u0026#34;Obj2 is called...\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Obj3 { public: void Func(int value) { std::cout\u0026lt;\u0026lt;\u0026#34;Obj3::Func() \u0026#34;\u0026lt;\u0026lt; value \u0026lt;\u0026lt;std::endl; } }; void worker(int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; } int main() { //------------------------// std::thread t(worker,1); t.join(); //------------------------// std::thread t2([](int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; }, 2); t2.join(); //------------------------// std::function\u0026lt;void(int)\u0026gt; Func = [](int Value) { std::cout \u0026lt;\u0026lt; \u0026#34;Worker thread is running...\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; }; std::thread t3(Func, 3); t3.join(); //------------------------// std::thread t4(Obj(), 4); t4.join(); //------------------------// Obj2 obj2; std::thread t5(obj2); t5.join(); //------------------------// Obj3 obj3; std::thread t6(\u0026amp;Obj3::Func,\u0026amp;obj3,233); //或 std::thread t6(\u0026amp;Obj3::Func,std::ref(obj3),233); t6.join(); return 0; } join 与 detach 行为 使用 join() 使用 detach() 主线程是否等待 是 否 子线程的生命周期 主线程等待子线程结束后才退出 子线程在后台运行，主线程不等待 资源管理 子线程资源在线程结束后自动释放 子线程资源在线程结束后自动释放 线程状态 主线程可以获取子线程的状态(如是否完成)。 主线程无法获取子线程的状态。 适用场景 需要确保子线程完成任务后再继续执行 子线程是独立任务，主线程无需等待 join() 的适用场景\n任务依赖： 主线程需要子线程的计算结果。 例如：并行计算中，主线程等待所有子线程完成并汇总结果。 资源清理： 主线程在退出前必须确保所有子线程已完成。 例如：多线程下载工具，主线程等待所有下载线程完成后再退出。 detach() 的适用场景\n后台任务： 子线程是独立任务，主线程无需关心其何时完成。 例如：日志记录线程、监控线程。 异步处理： 子线程执行耗时操作，主线程继续响应用户输入。 例如：GUI 应用程序中，后台线程处理文件读写，主线程保持界面响应。 如果需要确保子线程完成任务，使用 join()。 如果希望子线程在后台运行，使用 detach()。 不要既不调用 join() 也不调用 detach()，这会导致程序未定义行为。 被 detach() 的线程独立运行，主线程无法再控制或等待它。 子线程资源在线程结束后自动释放 当一个线程被 detach() 后，它变成了一个独立运行的线程，不再与创建它的线程（通常是主线程）关联。此时，线程的管理权交给了 C++ 运行时库 和 操作系统。\nC++ 运行时库：C++ 运行时库会负责管理线程的资源（如栈空间、线程 ID 等）。 操作系统：操作系统负责调度线程的执行，并在线程结束后回收其资源。 一旦线程被 detach()，就无法再通过 join() 等待其结束，也无法再获取其状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void task(int id) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时任务 std::cout \u0026lt;\u0026lt; \u0026#34;线程任务 \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; 完成.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { // 场景 1：使用 join() std::thread t1(task, 1); std::cout \u0026lt;\u0026lt; \u0026#34;主线程t1创建，调用join...\u0026#34; \u0026lt;\u0026lt; std::endl; t1.join(); // 主线程等待 t1 完成 std::cout \u0026lt;\u0026lt; \u0026#34;主线程在t1结束后继续.\u0026#34; \u0026lt;\u0026lt; std::endl; // 场景 2：使用 detach() std::thread t2(task, 2); std::cout \u0026lt;\u0026lt; \u0026#34;主线程t2创建，调用detach...\u0026#34; \u0026lt;\u0026lt; std::endl; t2.detach(); // 主线程不等待 t2，直接继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;t2已经分离，主线程继续运行...\u0026#34; \u0026lt;\u0026lt; std::endl; // 主线程等待一段时间，确保 t2 有机会运行 std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout \u0026lt;\u0026lt; \u0026#34;主线程完成.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 输出\n1 2 3 4 5 6 7 主线程t1创建，调用join... 线程任务 1 完成. 主线程在t1结束后继续. 主线程t2创建，调用detach... t2已经分离，主线程继续运行... 线程任务 2 完成. 主线程完成. 线程t1创建后 调用join()， t1在睡觉，主线程会卡住，2秒后 t1执行完毕 主线程才继续运行，线程t2创建后 调用detach()，此时 主线程不再等待t2，继续执行，与此同时t2在睡觉，2秒后睡醒 执行完毕.\njoinable() 用于检查一个线程对象是否可以被 join() 或 detach()。它的作用是判断线程对象是否关联了一个可执行的线程。管理线程生命周期的重要工具，尤其在多线程编程中需要确保资源正确释放时。\n检查线程状态： 如果线程对象关联了一个可执行的线程（即线程正在运行或尚未启动），则 joinable() 返回 true。 如果线程对象没有关联可执行的线程（即线程已经结束、被 join() 或 detach()），则 joinable() 返回 false。 在程序退出前，检查所有线程是否已完成，避免资源泄漏。 防止错误操作： 在调用 join() 或 detach() 之前，可以使用 joinable() 检查线程对象的状态，避免重复调用或无效调用。 如果线程已经被 join() 或 detach()，再次调用会导致程序崩溃。 线程状态 joinable() 返回值 线程已创建但未启动 true 线程正在运行 true 线程已结束但未调用 join() 或 detach() true 线程已被 join() false 线程已被 detach() false 默认构造的线程对象（未关联线程） false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void task() { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时任务 std::cout \u0026lt;\u0026lt; \u0026#34;Task finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(task); // 创建线程 // 检查线程是否可 join if (t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is joinable.\u0026#34; \u0026lt;\u0026lt; std::endl; t.join(); // 等待线程结束 } // 再次检查线程是否可 join if (!t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is no longer joinable.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 输出\n1 2 3 Thread is joinable. Task finished. Thread is no longer joinable. 线程传参 当一个线程被 detach() 后，它会独立运行，不再与创建它的线程（通常是主线程）关联。如果这个线程使用了 主线程或函数局部的资源（如局部变量、栈内存等），而主线程或函数结束后这些资源被销毁，会导致线程访问无效的内存，从而引发 未定义行为\n访问已释放的内存：\n如果线程访问了已经被销毁的局部变量或栈内存，可能会导致程序崩溃（如段错误）。 数据损坏：\n如果线程尝试修改已释放的内存，可能会导致数据损坏或其他不可预知的行为。 未定义行为：\n由于访问无效内存，程序的行为是不可预测的，可能表现为崩溃、输出错误结果，或者看似正常运行但隐藏严重问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; class MyString { public: MyString(const std::string\u0026amp; str) : str_(str) { std::cout \u0026lt;\u0026lt; \u0026#34;MyString 创建\u0026#34; \u0026lt;\u0026lt; std::endl; } // 显式定义拷贝构造函数 MyString(const MyString\u0026amp; other) : str_(other.str_) { std::cout \u0026lt;\u0026lt; \u0026#34;MyString 拷贝创建\u0026#34; \u0026lt;\u0026lt; std::endl; } std::string str_; }; // --------TaskA--------- // void TaskA(const MyString\u0026amp; message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskA: \u0026#34; \u0026lt;\u0026lt; message.str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskA() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskA, local_message); t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskA finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } // --------TaskA--------- // // --------TaskB--------- // void TaskB(MyString* message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskB: \u0026#34; \u0026lt;\u0026lt; message-\u0026gt;str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskB() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskB, \u0026amp;local_message); t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskB finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } // --------TaskB--------- // int main() { run_taskA(); run_taskB(); std::this_thread::sleep_for(std::chrono::seconds(3)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread finished.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } TaskA成功运行，TaskB会发生错误.\n只调用TaskA的输出：发现有两个MyString创建了，\n1 2 3 4 5 MyString 创建 MyString 拷贝创建 run_taskA finished. TaskA: Hello, World! Main thread finished. 值传递：线程函数通过值传递的方式接收参数，线程内部会保存一份独立的拷贝，因此即使局部变量被销毁，线程仍然可以访问有效的数据。 拷贝构造函数：如果没有显式定义拷贝构造函数，编译器会生成默认的拷贝构造函数，执行浅拷贝，且不会输出日志。 生命周期：线程内部的拷贝对象的生命周期与线程绑定，在线程函数执行期间一直有效。 修复TaskB\n把detach改为join，run_taskB函数 会等待线程运行完成才结束.\n1 2 3 4 5 6 7 8 9 10 11 12 13 void TaskB(MyString* message) { std::this_thread::sleep_for(std::chrono::seconds(2)); std::cout \u0026lt;\u0026lt; \u0026#34;TaskB: \u0026#34; \u0026lt;\u0026lt; message-\u0026gt;str_ \u0026lt;\u0026lt; std::endl; // 访问局部资源 } void run_taskB() { MyString local_message(std::string(\u0026#34;Hello, World!\u0026#34;)); std::thread t(TaskB, \u0026amp;local_message); t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;run_taskB finished.\u0026#34; \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 MyString 创建 TaskB: Hello, World! run_taskB finished. Main thread finished. 在这个例子中，TaskA创建了2个MyString，明明是常量引用，但实际上是值传递TaskB使用指针传递，两个MyString是同一个对象，那么在run_taskB结束后，这个MyString访问就错误了.detach子线程时 不能传递指针.\n在多线程编程中，正确传递函数参数非常重要，尤其是在涉及局部资源时。如果传递方式不当，可能会导致线程访问无效的内存，从而引发未定义行为。\n传递方式 适用场景 注意事项 值传递 大多数场景，确保线程安全 数据会被拷贝，可能有一定开销 引用传递 需要修改原始数据的场景 必须确保原始数据的生命周期长于线程 指针传递 需要共享数据的场景 使用智能指针（如 std::shared_ptr）管理资源，避免悬空指针 移动语义 大数据或不可拷贝的对象 转移所有权后，原始对象不再有效 Lambda 捕获 一次性使用的场景，简洁直观 通过值捕获或引用捕获传递参数 参数传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void func(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } int main() { char c[] = \u0026#34;world\u0026#34;; std::thread t(func, c); // 传递 C 风格字符串 t.detach(); std::cout \u0026lt;\u0026lt; \u0026#34;main\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } std::string 的创建时机：\n当线程函数 func 开始执行时，会尝试从 const char* 创建 std::string。 如果此时 c 已经被销毁，const char* 指向无效的内存，导致未定义行为。 情况 1：c 未被销毁\n如果线程在 c 被销毁之前完成了 std::string 的创建，程序会正常运行。 情况 2：c 被销毁\n如果线程在 c 被销毁之后才开始执行，尝试从已销毁的 c 创建 std::string，会导致未定义行为。 解决方法：\nstd::thread t(func, string(c))显式地将 char c[] 转换为 std::string. 1 2 char c[] = \u0026#34;world\u0026#34;; std::thread t(func, string(c)); string会在此时构造，在 c销毁之前 创建string。\nstd::thread t(func, string(c)) 构造了第一个string，传递给void func(const std::string\u0026amp; str)时，调用string的拷贝构造 又创建了第二个string.\n常量引用 在这个例子里，void func(const std::string\u0026amp; str)已经用常量引用了，还构造了2个string如果不使用常量引用，void func(std::string str) 不得构造3个string吗？\n不使用常量引用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; class A { public: int Value = -321; A() { cout \u0026lt;\u0026lt; \u0026#34;A 默认构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造 \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt;endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造 \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(A A) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; std::thread t(func, A(c)); t.detach(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 拷贝构造在 传入的a的基础上，将Value值加1，以此区分不同的拷贝构造.\n输出：\n1 2 3 4 5 6 7 A 初始化构造 1 A 拷贝构造 2 ~A 1 A 拷贝构造 3 Hello 3 ~A 3 ~A 2 拷贝构造了2个A， 一共有3个A被创造了，\n使用常量引用：\n把Func的参数改为常量引用\n1 2 3 4 void func(const A\u0026amp; A) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 A 初始化构造 1 A 拷贝构造 2 ~A 1 Hello 2 ~A 2 线程ID 线程 ID 是操作系统或运行时库为每个线程分配的唯一标识符,它用于区分和识别不同的线程。在多线程编程中，线程 ID 是一个重要的概念，可以帮助开发者调试、监控和管理线程。线程 ID 是唯一的、不可预测的，并且在线程销毁后失效。\n在 C++ 中，可以通过以下方式获取线程 ID：\n（1）当前线程的 ID\n使用 std::this_thread::get_id() 获取当前线程的 ID。 （2）线程对象的 ID\n使用 std::thread::get_id() 获取线程对象的 ID。如 t.get_id(); 使用线程ID 观察A类是在哪个线程里创建的，主线程还是子线程？\n常量引用版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; \u0026#34; 线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } }; void func(const A\u0026amp; A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; int c = 1; std::thread t(func, A(c)); t.detach(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 输出：\n1 2 3 4 5 6 7 8 主线程ID: 2608 A 初始化构造1 线程ID: 2608 A 拷贝构造2 线程ID: 2608 A 析构1 线程ID: 2608 func子线程ID: 19240 Hello 2 A 析构2 线程ID: 19240 主线程ID:2608，子线程ID: 192402个A类的构造 都是在主线程完成的，但是第2个A类的析构却在子线程里.\n构造过程：\n在主线程中创建临时对象 A(c)。 由于函数参数是常量引用，编译器可能会进行一次拷贝构造以传递给子线程的函数。 因此，两个构造操作都在主线程中完成。 析构过程：\n第一个对象在主线程中被析构。 第二个对象在子线程中被析构。 值传递版本：\n1 2 3 4 5 void func(A A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 主线程ID: 12340 A 初始化构造1 线程ID: 12340 A 拷贝构造2 线程ID: 12340 A 析构1 线程ID: 12340 A 拷贝构造3 线程ID: 10368 func子线程ID: 10368 Hello 3 A 析构3 线程ID: 10368 A 析构2 线程ID: 10368 实际运行中，主线程ID:12340，子线程ID:10368，3个A类中， 前2个在主线程构造，第3个在子线程构造后2个都在子线程中析构.\n构造过程： 在主线程中创建临时对象 A(c)。 由于函数参数是按值传递，编译器会进行两次拷贝构造：一次是在主线程中创建临时对象，另一次是将该对象传递给子线程的函数。 因此，前两个构造操作在主线程中完成，第三个构造操作在子线程中完成。 析构过程： 第一个对象在主线程中被析构。 后两个对象在子线程中被析构。 上面测试的函数为 std::thread t(func, A(c));,如果是std::thread t(func, c); 会发生什么？\n常量引用版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void func(const A\u0026amp; A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; int c = 1; std::thread t(func, c); t.join(); this_thread::sleep_for(chrono::seconds(1)); return 0; } 输出：\n1 2 3 4 5 6 主线程ID: 14908 A 初始化构造1 线程ID: 19900 func子线程ID: 19900 Hello 1 A 析构1 线程ID: 19900 构造过程： 由于直接传递整数 c，在子线程中通过构造函数 A(int V) 创建对象。 所有构造操作都在子线程中完成。 析构过程： 对象在子线程中被析构。 值传递版本：\n1 2 3 4 5 void func(A A) { cout\u0026lt;\u0026lt;\u0026#34;func子线程ID: \u0026#34;\u0026lt;\u0026lt;this_thread::get_id()\u0026lt;\u0026lt;endl; std::cout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } 输出：\n1 2 3 4 5 6 主线程ID: 15064 A 初始化构造1 线程ID: 4928 func子线程ID: 4928 Hello 1 A 析构1 线程ID: 4928 构造过程： 类似于常量引用版本，所有构造操作都在子线程中完成。 析构过程： 对象在子线程中被析构。 可以看到，不管是 常量引用 还是 值传递，A类都在子线程中构造，并且只构造一次，虽然比std::thread t(func, A(c));构造次数的少，但是暗藏危机.\n总结\n常量引用版本 (std::thread t(func, A(c));): 构造操作主要在主线程中完成，但部分析构操作会在子线程中发生。 值传递版本 (std::thread t(func, A(c));): 构造操作分布在主线程和子线程中，析构操作主要在子线程中完成。 使用 std::thread t(func, c);: 不论是常量引用还是值传递，构造和析构操作都集中在子线程中完成。 在detach()情况下，使用常量引用版本的std::thread t(func, A(c)); 安全高效.\n线程传参-类对象 前面已经证实了，即便是常量引用，也会生成第二个类对象， 在常量引用的情况下，如果将类对象作为线程参数 在线程函数里面修改对象的数据，那么在主线程里面的那个 不会受到影响。\n主线程中有一个 A类型的 MyA 变量，在传给线程函数时，会调用拷贝构造 创建第二个A类，因此线程函数不会影响到MyA的数据。\n在线程中修改A对象 还有一个问题，因为是常量引用，所以无法修改，但是在变量前面添加mutable就能够修改.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: mutable int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(const A\u0026amp; A) { A.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; A MyA(5); std::thread t(func,MyA); t.join(); this_thread::sleep_for(chrono::seconds(1)); cout\u0026lt;\u0026lt;\u0026#34;主线程A的Value \u0026#34; \u0026lt;\u0026lt; MyA.Value \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 4 5 6 7 A 初始化构造5 A 拷贝构造6 子线程A的Value 123 A 析构123 主线程A的Value 5 A 析构5 虽然使用mutable让变量可修改，但是修改无效啊，并且如果要在线程中修改对象的内容，改的变量很多的话，那每个变量都要加mutable，这河里吗？\nstd::ref 在上面的例子中，要修改const的对象，并且修改了还无效， 双重错误，那有没有更好的办法呢？我们说 有的\nstd::ref 是 C++ 标准库中的一个工具，位于 \u0026lt;functional\u0026gt; 头文件中。它的主要作用是创建一个对象的引用包装器，使得函数参数可以按引用传递而不是按值传递。允许将引用传递给需要值传递的函数或对象这对于避免不必要的拷贝和确保对同一个对象进行操作非常有用，尤其是在使用标准库算法或线程时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;format\u0026gt; using namespace std; class A { public: int Value = -321; A(int V) : Value(V) { cout \u0026lt;\u0026lt; \u0026#34;A 初始化构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } A(const A\u0026amp; a) { Value = a.Value + 1; cout \u0026lt;\u0026lt; \u0026#34;A 拷贝构造\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A 析构\u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; endl; } }; void func(A\u0026amp; A) { A.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; A.Value \u0026lt;\u0026lt; std::endl; } int main() { int c = 1; A MyA(5); std::thread t(func,std::ref(MyA)); t.join(); this_thread::sleep_for(chrono::seconds(1)); cout\u0026lt;\u0026lt;\u0026#34;主线程A的Value \u0026#34; \u0026lt;\u0026lt; MyA.Value \u0026lt;\u0026lt; endl; return 0; } 输出:\n1 2 3 4 A 初始化构造5 子线程A的Value 123 主线程A的Value 123 A 析构123 std::ref为什么那么神奇？为什么会这样？\nstd::reference_wrapper 是一个模板类，其简化实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename T\u0026gt; class reference_wrapper { public: // 构造函数，接受一个引用并保存其地址 reference_wrapper(T\u0026amp; ref) : ptr(\u0026amp;ref) {} // 隐式类型转换运算符，将 reference_wrapper 转换为 T\u0026amp; operator T\u0026amp;() const { return *ptr; } private: T* ptr; // 保存引用的指针 }; 构造函数： reference_wrapper(T\u0026amp; ref) 接受一个引用，并将其地址保存到成员变量 ptr 中。 隐式类型转换运算符： operator T\u0026amp;() const 是一个类型转换运算符，它允许 reference_wrapper\u0026lt;T\u0026gt; 对象隐式转换为 T\u0026amp; 类型。 当需要 T\u0026amp; 类型时，编译器会自动调用这个运算符。 1 2 3 4 5 6 7 8 9 10 11 void func(A\u0026amp; a) { a.Value = 123; std::cout \u0026lt;\u0026lt; \u0026#34;子线程A的Value \u0026#34; \u0026lt;\u0026lt; a.Value \u0026lt;\u0026lt; std::endl; } int main() { A MyA(5); std::thread t(func, std::ref(MyA)); // std::ref(MyA) 返回 reference_wrapper\u0026lt;A\u0026gt; t.join(); return 0; } 具体过程：\n传递参数： std::ref(MyA) 返回一个 std::reference_wrapper\u0026lt;A\u0026gt; 对象。 这个对象被传递给 std::thread 的构造函数。 线程内部存储： std::thread 将 std::reference_wrapper\u0026lt;A\u0026gt; 对象拷贝到线程的内部存储中。 调用线程函数： 当线程启动时，std::thread 会调用线程函数 func，并将存储的参数传递给它。 由于 func 的参数类型是 A\u0026amp;，而实际传递的是 std::reference_wrapper\u0026lt;A\u0026gt;，编译器会尝试将 std::reference_wrapper\u0026lt;A\u0026gt; 转换为 A\u0026amp;。 隐式转换： 编译器：编译器在调用线程函数时，发现参数类型不匹配（std::reference_wrapper\u0026lt;A\u0026gt; vs A\u0026amp;），于是尝试查找合适的转换方式。 隐式类型转换运算符：std::reference_wrapper\u0026lt;A\u0026gt; 中定义的 operator A\u0026amp;() 提供了从 std::reference_wrapper\u0026lt;A\u0026gt; 到 A\u0026amp; 的转换规则。 自动调用：编译器根据规则自动调用 operator A\u0026amp;()，完成类型转换。 总结\n隐式转换的触发：当 std::reference_wrapper\u0026lt;A\u0026gt; 需要转换为 A\u0026amp; 时，编译器会自动调用 operator A\u0026amp;()。 转换的实现：std::reference_wrapper 中定义的隐式类型转换运算符提供了转换规则。 应用场景：std::ref 通过 std::reference_wrapper 实现引用传递，适用于需要值传递但希望避免拷贝的场景。 智能指针 在多线程编程中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）可以有效地管理资源的生命周期，并避免内存泄漏和其他资源管理问题。\nshared_ptr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;memory\u0026gt; // 包含智能指针 class MyClass { public: MyClass(int value) : value_(value) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass 创建: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } ~MyClass() { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass 销毁: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } void print() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value_ \u0026lt;\u0026lt; std::endl; } int value_; }; void task(std::shared_ptr\u0026lt;MyClass\u0026gt; ptr) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 ptr-\u0026gt;print(); // 访问共享对象 ptr-\u0026gt;value_ = 100; } int main() { // 创建 shared_ptr auto ptr = std::make_shared\u0026lt;MyClass\u0026gt;(42); // 创建线程，传递 shared_ptr std::thread t(task, ptr); // 主线程继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;主线程继续执行...\u0026#34; \u0026lt;\u0026lt; std::endl; t.join(); // 等待线程结束 std::cout\u0026lt;\u0026lt;\u0026#34;主线程的Value:\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;value_\u0026lt;\u0026lt;std::endl; return 0; } 1 2 3 4 5 MyClass 创建: 42 主线程继续执行... Value: 42 主线程的Value:100 MyClass 销毁: 100 std::make_shared\u0026lt;MyClass\u0026gt;(42) 创建了一个 MyClass 对象，并由 std::shared_ptr 管理。 std::thread t(task, ptr) 将 ptr 传递给线程函数 task。 线程函数 task 通过 std::shared_ptr 访问 MyClass 对象。 当线程和主线程都结束时，std::shared_ptr 的引用计数变为 0，MyClass 对象被自动销毁。 std::unique_ptr\n1 2 3 4 5 // 创建 unique_ptr auto ptr = std::make_unique\u0026lt;MyClass\u0026gt;(42); // 创建线程，传递 unique_ptr（必须使用 std::move） std::thread t(task, std::move(ptr)); std::make_unique\u0026lt;MyClass\u0026gt;(42) 创建了一个 MyClass 对象，并由 std::unique_ptr 管理。 std::thread t(task, std::move(ptr)) 将 ptr 的所有权转移给线程函数 task。 线程函数 task 通过 std::unique_ptr 访问 MyClass 对象。 当线程结束时，std::unique_ptr 被销毁，MyClass 对象被自动销毁。 特性 std::shared_ptr std::unique_ptr 所有权 共享所有权，多个指针可以指向同一个对象 独占所有权，只能有一个指针指向对象 拷贝 可以拷贝 不能拷贝，只能移动 性能 有引用计数的开销 无额外开销 适用场景 需要共享所有权的场景 需要独占所有权的场景 线程安全：std::shared_ptr 的引用计数是线程安全的，但对象的访问需要额外的同步机制（如 std::mutex）。 多线程-B CPU 瞎jb转，线程跟了瞎jb干\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void MyPrint(int i) { cout \u0026lt;\u0026lt; \u0026#34;线程开始，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程结束，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { vector\u0026lt;thread\u0026gt; threads; for (int i = 0; i \u0026lt; 10; i++) { threads.push_back(thread(MyPrint, i)); } for (auto\u0026amp; t : threads) { t.join(); } cout \u0026lt;\u0026lt; \u0026#34;main thread end\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 线程开始，编号：0线程开始，编号：线程开始，编号：线程开始，编号：线程开始，编号：6线程开始，编号：线程开始，编号：9 线程结束，编号：0 线程结束，编号：6 5 线程结束，编号：5 8 线程结束，编号：8 3线程开始，编号：1 线程结束，编号：1 线程开始，编号：2 线程结束，编号：2 线程结束，编号：9 4 线程结束，编号：4 线程开始，编号：7 线程结束，编号：7 线程结束，编号：3 main thread end 多个线程运行时确实会受到CPU时间片轮转（time-slicing）的影响。这是操作系统调度器用来管理多个线程或进程执行的一种机制。\n时间片轮转 是操作系统用于管理多线程环境下的CPU时间分配的一种机制。\n它会影响多线程程序的执行顺序和性能，尤其是上下文切换带来的开销。\n为了优化多线程程序，应该尽量减少不必要的上下文切换，合理分配任务，并使用合适的同步机制。\n数据共享 多个线程读取同一个数据\n1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt; vec = { 1,2,3 }; void MyPrint(int i) { // cout \u0026lt;\u0026lt; \u0026#34;线程开始，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; // cout \u0026lt;\u0026lt; \u0026#34;线程结束，编号：\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl cout\u0026lt;\u0026lt;\u0026#34;线程ID: \u0026#34;\u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; vec[0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; vec[1] \u0026lt;\u0026lt;\u0026#34; \u0026#34; \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; endl; } 输出：\n1 2 3 4 5 6 7 8 9 10 11 线程ID: 线程ID: 线程ID: 21108线程ID: 线程ID: 线程ID: 21224线程ID: 线程ID: 183921 2 31 2 3 线程ID: 211761 2 3 线程ID: 222561 2 3 25601 2 3 1 2 3 220161 2 3 233601 2 3 229761 2 3 221361 2 3 main thread end 线程执行顺序不可控，如果一堆线程对同一个数据 有读有写，比如 多个线程读，同时有多个线程写，会造成错误。\n下面的代码会崩溃\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;format\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; class A { public: void InMsgQueue() { for (int i = 0;i \u0026lt; 100000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; MsgQueue.push_back(i); } } void OutMsgQueue() { for (int i = 0;i \u0026lt; 100000;i++) { if (!MsgQueue.empty()) { int Command = MsgQueue.front(); MsgQueue.pop_front(); } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } private: list\u0026lt;int\u0026gt; MsgQueue; }; int main() { A a; std::thread T_InMsg(\u0026amp;A::InMsgQueue, \u0026amp;a); std::thread T_OutMsg(\u0026amp;A::OutMsgQueue, \u0026amp;a); T_InMsg.join(); T_OutMsg.join(); return 0; } 互斥量 互斥量（Mutex）是一种同步机制，用于在并发编程中保护共享资源，确保在同一时间只有一个线程可以访问该资源。互斥量的主要目的是防止多个线程同时访问和修改共享数据，从而避免竞态条件（race condition）和其他并发问题。\n它的实现依赖于操作系统的底层同步机制，通常是对操作系统提供的原语（Windows 的 CRITICAL_SECTION）的封装。\n锁的状态通过原子操作或内存屏障来保证线程安全。\nstd::mutex 内部维护一个等待队列，用于存储被阻塞的线程。 当线程尝试获取锁时，如果锁已被其他线程持有，当前线程会被阻塞，并放入等待队列。 等待队列通常由另一个互斥锁（如 queue_mutex）保护，以确保线程安全。 当锁被释放时，操作系统会从等待队列中唤醒一个线程，使其继续执行。 当线程无法获取锁时，会调用操作系统的阻塞原语（如 futex 或 WaitForSingleObject）将线程挂起。 当锁被释放时，会调用操作系统的唤醒原语（如 futex_wake 或 WakeByAddressSingle）唤醒一个等待线程。 互斥量的工作原理\n锁定（Lock）：当一个线程想要访问共享资源时，它首先尝试获取互斥量的锁。如果互斥量当前没有被其他线程持有，则该线程成功获取锁，并开始访问共享资源。 解锁（Unlock）：当线程完成对共享资源的操作后，它会释放互斥量的锁，允许其他等待的线程获取锁并访问资源。 阻塞（Block）：如果一个线程尝试获取已经被其他线程持有的互斥量锁，该线程会被阻塞，直到持有锁的线程释放锁为止。 lock()：尝试获取互斥量的锁。如果锁已被其他线程持有，调用线程将被阻塞，直到锁可用。\ntry_lock()：尝试获取互斥量的锁，但不会阻塞。如果锁不可用，函数立即返回失败状态。\nunlock()：释放互斥量的锁，允许其他线程获取锁并访问共享资源。\nstd::mutex 是最基本的互斥量类型，适用于大多数场景。\nstd::recursive_mutex 支持递归锁定，适用于需要在一个线程中多次锁定同一个互斥量的情况。\nstd::timed_mutex 和 std::shared_timed_mutex 提供了带超时功能和共享锁的支持，适用于更复杂的同步需求。\n使用mutex，运行稳定，每次只有一个线程访问资源，但是线程运行顺序不稳定..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { private: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; mtx.lock(); MsgQueue.push_back(i); mtx.unlock(); } } bool OutMsg(int\u0026amp; InCommand) { mtx.lock(); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); mtx.unlock(); return true; } mtx.unlock(); return false; } void OutMsgQueue() { int command = 0; for (int i = 0;i \u0026lt; 2000;i++) { if (OutMsg(command)) { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } }; lock_guard 主播主播🥰你的牢锁确～实很强👍 但还是太吃操作了😇 有没有更加简单又强势的英雄推荐一下吗🧐 有的兄弟（战术停顿）有的😋 这么强势的英雄当～然是不止一个了🤓 一共有九位，都是当～前版本t～0.5的超～标英雄👉 告诉主播，你想学习哪个😤\nstd::lock_guard 通过 RAII 机制自动管理互斥量的锁定和解锁操作，从而避免手动管理锁可能导致的错误，如忘记释放锁或在异常情况下未能正确解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout\u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mtx); MsgQueue.push_back(i); } } bool OutMsg(int\u0026amp; InCommand) { std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mtx); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); return true; } return false; } lock_guard 构造时就上锁，析构时解锁.\n下面是lock_guard的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;class _Mutex\u0026gt; class _NODISCARD_LOCK lock_guard { // class with destructor that unlocks a mutex public: using mutex_type = _Mutex; explicit lock_guard(_Mutex\u0026amp; _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } lock_guard(_Mutex\u0026amp; _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don\u0026#39;t lock ~lock_guard() noexcept { _MyMutex.unlock(); } lock_guard(const lock_guard\u0026amp;) = delete; lock_guard\u0026amp; operator=(const lock_guard\u0026amp;) = delete; private: _Mutex\u0026amp; _MyMutex; }; 另一个构造函数是什么？ 两个构造函数的区别在于 第二个参数，\n1 2 lock_guard(_Mutex\u0026amp; _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don\u0026#39;t lock 当mutex已经上锁时，召唤lock_guard会再次对mutex上锁 就会错误， 因此有了这个版本的构造函数lock_guard构造时 不自动锁上mutex\n1 2 3 4 5 6 7 8 9 10 11 12 13 void thread_func() { // 手动锁定互斥量 mtx.lock(); // 使用 std::adopt_lock 告诉 lock_guard 互斥量已经被锁定 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 访问共享资源 std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock_guard 自动解锁互斥量 } 死锁 死锁（Deadlock）是并发编程中的一种常见问题，指的是两个或多个线程或进程在执行过程中，由于争夺资源而陷入无限等待的状态。每个线程都持有某些资源并等待获取其他线程持有的资源，导致所有这些线程都无法继续执行。\n有两个线程，都需要同时锁住两个互斥量，才可以进行某项操作，但它们分别都只锁住了一个互斥，都等着再给另一个互斥加锁。于是，双方毫无进展，因为它们同在苦苦等待对方解锁互斥，这种情形称为死锁。\n有两个线程A和B，两个锁L1和L2，两个线程都需要锁住L1、L2才能继续执行线程A执行时 先锁了L1，A正准备锁L2时 发生了上下文切换，此时，线程B开始执行，B锁住了L2，然后去锁L1， 此时 两个锁在两个不同的线程中锁住，发生死锁。\n这种情形下，没有任何一个线程能够同时拥有两个锁，没有任何一个线程能继续运行。\n因此，只要保证锁的顺序一致，就可避免死锁， 如:线程AB都先锁L1 再锁L2。\nstd::lock\nstd::lock 是 C++ 标准库提供的一个函数，用于原子化地锁定多个互斥量（mutex）。它的主要作用是避免在锁定多个互斥量时发生死锁。通过 std::lock，可以确保所有互斥量要么全部成功锁定，要么全部不锁定，从而避免了潜在的死锁问题。\n如果任何一个互斥量无法锁定，它会自动解锁之前已经锁定的所有互斥量，并重新尝试锁定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx1; std::mutex mtx2; void threadFuncA() { std::lock(mtx1, mtx2); // 原子化锁定两个互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); // 采用已锁定的互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 采用已锁定的互斥量 std::cout \u0026lt;\u0026lt; \u0026#34;Thread A acquired both mutexes.\u0026#34; \u0026lt;\u0026lt; std::endl; } void threadFuncB() { std::lock(mtx1, mtx2); // 原子化锁定两个互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); // 采用已锁定的互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // 采用已锁定的互斥量 std::cout \u0026lt;\u0026lt; \u0026#34;Thread B acquired both mutexes.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(threadFuncA); std::thread t2(threadFuncB); t1.join(); t2.join(); return 0; } unique_lock std::unique_lock 是 C++ 标准库提供的一个通用的互斥量管理类，比 std::lock_guard 更加灵活。它提供了更丰富的功能来管理互斥量的锁定和解锁操作，适用于更复杂的并发场景。\n灵活性：与 std::lock_guard 不同，std::unique_lock 允许延迟锁定、尝试锁定和递归锁定等高级操作。 可移动但不可复制：std::unique_lock 可以通过移动语义进行转移，但不能被复制。 支持多种锁定策略：除了基本的锁定和解锁操作外，还支持尝试锁定（try_lock）、超时锁定（try_lock_for/try_lock_until）等功能。 手动管理锁状态：允许显式地锁定和解锁互斥量，这在某些需要更精细控制锁状态的场景中非常有用。 特性 std::unique_lock std::lock_guard 锁定时机 可以延迟锁定 总是在构造时锁定 解锁时机 可以手动解锁 总是在析构时解锁 锁定策略 支持多种锁定策略 仅支持锁定和解锁 可移动性 可移动 不可移动 适用场景 复杂的同步需求 简单的同步需求 使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 创建并锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } int main() { std::thread t1(threadFunc); std::thread t2(threadFunc); t1.join(); t2.join(); return 0; } unique_lock的构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 explicit unique_lock(_Mutex\u0026amp; _Mtx) // 构造并且锁住 unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) // 加强版 构造，假设已经锁定 unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) // 构造但不锁 unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) // 构造，尝试锁住 template \u0026lt;class _Rep, class _Period\u0026gt; unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) // 构造 超时锁 template \u0026lt;class _Clock, class _Duration\u0026gt; unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) // 构造 超时锁 ~unique_lock() noexcept { if (_Owns) { _Pmtx-\u0026gt;unlock(); }} 构造函数 功能 explicit unique_lock(_Mutex\u0026amp; _Mtx) 构造时立即锁定互斥锁。 unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) 接管已经锁定的互斥锁。 unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) 构造时不锁定互斥锁，后续手动锁定。 unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) 构造时尝试锁定互斥锁，失败不阻塞。 unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) 构造时尝试在指定相对时间内锁定互斥锁，超时失败。 unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) 构造时尝试在指定绝对时间点前锁定互斥锁，超时失败。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //unique_lock(_Mutex\u0026amp; _Mtx) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 创建并锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, adopt_lock_t) void threadFunc() { mtx.lock(); // 手动锁定 mtx std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 假设 mtx 已经被锁定 std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, defer_lock_t) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 创建但不锁定 mtx std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟一些工作负载 lock.lock(); // 显式锁定 mtx std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; // 当离开作用域时，lock 自动解锁 mtx } //unique_lock(_Mutex\u0026amp; _Mtx, try_to_lock_t) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); // 尝试锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex.\u0026#34; \u0026lt;\u0026lt; std::endl; } } //unique_lock(_Mutex\u0026amp; _Mtx, const chrono::duration\u0026lt;_Rep, _Period\u0026gt;\u0026amp; _Rel_time) void threadFunc() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::chrono::seconds(2)); // 尝试在2秒内锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex within 2 seconds.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex within 2 seconds.\u0026#34; \u0026lt;\u0026lt; std::endl; } } //unique_lock(_Mutex\u0026amp; _Mtx, const chrono::time_point\u0026lt;_Clock, _Duration\u0026gt;\u0026amp; _Abs_time) void threadFunc() { auto now = std::chrono::system_clock::now(); auto timeout = now + std::chrono::seconds(2); // 设置超时时间为当前时间加上2秒 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, timeout); // 尝试在指定时间点前锁定 mtx if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Thread successfully locked the mutex before the timeout.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Thread failed to lock the mutex before the timeout.\u0026#34; \u0026lt;\u0026lt; std::endl; } } 其它函数\n名称 描述 lock 阻止调用线程，直到线程获取关联的 mutex 的所有权。 mutex 检索指向关联的 mutex 的存储指针。 owns_lock 指定调用线程是否拥有关联的 mutex。 release 解除 unique_lock 对象与关联的 mutex 对象的关联。 swap 将关联的 mutex 和所有权状态与指定对象的互换。 try_lock 在不阻止的情况下尝试获取关联 mutex 的所有权。 try_lock_for 在不阻止的情况下尝试获取关联 mutex 的所有权。 try_lock_until 在不阻止的情况下尝试获取关联 mutex 的所有权。 unlock 释放关联的 mutex 的所有权。 operator= 从指定对象复制存储的 mutex 指针和关联的所有权状态。 所有权转移：\nunique_lock重载运算符，接收一个右值unique_lock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 unique_lock\u0026amp; operator=(unique_lock\u0026amp;\u0026amp; _Other) noexcept /* strengthened */ { if (this != _STD addressof(_Other)) { if (_Owns) { _Pmtx-\u0026gt;unlock(); } _Pmtx = _Other._Pmtx; _Owns = _Other._Owns; _Other._Pmtx = nullptr; _Other._Owns = false; } return *this; } std::mutex mutexA; std::unique_lock\u0026lt;std::mutex\u0026gt; ulA(mutexA); std::unique_lock\u0026lt;std::mutex\u0026gt; ulB(std::move(mutexA)); 从函数返回局部unique_lock\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::mutex mtx; std::unique_lock\u0026lt;std::mutex\u0026gt; get_unlocked_lock() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 创建但不锁定 mtx return lock; // 返回未锁定的 unique_lock } void threadFunc() { auto lock = get_unlocked_lock(); lock.lock(); // 显式锁定 mutex std::cout \u0026lt;\u0026lt; \u0026#34;Thread is accessing shared resource.\u0026#34; \u0026lt;\u0026lt; std::endl; lock.unlock(); // 显式解锁 mutex } 线程安全的cout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #pragma once #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; // 定义一个全局互斥锁 std::mutex coutMutex; // 定义一个线程安全的输出类 class SafeCout { public: // 构造函数 SafeCout() = default; // 重载 \u0026lt;\u0026lt; 运算符，支持各种基本类型 template\u0026lt;typename T\u0026gt; SafeCout\u0026amp; operator\u0026lt;\u0026lt;(const T\u0026amp; value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(coutMutex); // 自动管理锁 std::cout \u0026lt;\u0026lt; value; return *this; // 返回当前对象，以便链式调用 } }; // 全局实例化 SafeCout 对象 SafeCout cout_f; condition_variable std::condition_variable 是 C++11 标准库中提供的一个同步原语，用于线程间的通信。它允许一个线程等待某个条件变为真，而另一个线程在条件满足时通知等待的线程继续执行。std::condition_variable 通常与 std::mutex 一起使用，以确保对共享资源的安全访问。\n基本概念\nstd::condition_variable：这是一个类模板，提供了等待和通知机制。它允许一个或多个线程等待某个条件变量被通知。 std::mutex：互斥锁，用于保护共享资源，防止多个线程同时访问导致数据竞争。 std::unique_lock\u0026lt;std::mutex\u0026gt;：与 std::mutex 配合使用，提供更灵活的锁定机制，并且可以与 std::condition_variable 结合使用。 主要方法\nstd::condition_variable 提供了以下主要方法：\nwait()：使当前线程阻塞，直到条件变量被通知。通常与 std::unique_lock 一起使用。 notify_one()：唤醒一个等待该条件变量的线程（如果有）。 notify_all()：唤醒所有等待该条件变量的线程。 wait函数： _Pred是谓词\n1 2 3 4 5 6 7 8 9 10 11 void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; _Lck) noexcept /* strengthened */ { // wait for signal // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow _Cnd_wait(_Mycnd(), _Lck.mutex()-\u0026gt;_Mymtx()); } template \u0026lt;class _Predicate\u0026gt; void wait(unique_lock\u0026lt;mutex\u0026gt;\u0026amp; _Lck, _Predicate _Pred) { while (!_Pred()) { wait(_Lck); } } 谓词返回 true： 初始检查时 _Pred() 返回 true，因此不会进入 while 循环，也不会调用 wait(_Lck)。 锁 _Lck 保持锁定状态，没有释放也没有重新获取。 谓词返回 false： 初始检查时 _Pred() 返回 false，进入 while 循环并调用 wait(_Lck)。 wait(_Lck) 会释放互斥锁 _Lck，使当前线程进入等待状态，直到被其他线程通过 notify_one() 或 notify_all() 唤醒。 被唤醒后，线程会重新获取互斥锁 _Lck 并再次检查谓词，直到谓词返回 true。 如果调用了没有谓词的wait版本，也就是第一个，那么相当于 谓词 返回了false. 解锁互斥量.\n使用场景\nstd::condition_variable 适用于以下几种常见场景：\n生产者-消费者问题：生产者生成数据并放入队列，消费者从队列中取出数据进行处理。当队列为空时，消费者等待；当队列中有数据时，生产者通知消费者。 任务调度：主线程等待子线程完成任务后继续执行。 事件驱动系统：一个线程等待某个事件发生，另一个线程在事件发生时通知等待的线程。 问题代码：不停的判断list是否为空，占用资源，有没有一种方法 当队列为空时，取队列的方法应该等待，有数据时 才进行读取，而不是不断的判空？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class A { private: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { cout \u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; unique_lock\u0026lt;mutex\u0026gt; lock(mtx); MsgQueue.push_back(i); } } bool OutMsg(int\u0026amp; InCommand) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); if (!MsgQueue.empty()) { InCommand = MsgQueue.front(); MsgQueue.pop_front(); return true; } return false; } void OutMsgQueue() { int command = 0; for (int i = 0;i \u0026lt; 2000;i++) { if (OutMsg(command)) { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; is empty\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue end\u0026#34; \u0026lt;\u0026lt; endl; } }; 使用condition_variable\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class A { public: list\u0026lt;int\u0026gt; MsgQueue; std::mutex mtx; std::condition_variable cv; public: void InMsgQueue() { for (int i = 0;i \u0026lt; 2000;i++) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); MsgQueue.push_back(i); cout \u0026lt;\u0026lt; \u0026#34;InMsgQueue \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; list size:\u0026#34; \u0026lt;\u0026lt; MsgQueue.size() \u0026lt;\u0026lt; endl; cv.notify_all(); //把wait的线程唤醒,OutMsgQueue()里面的wait被唤醒 //...其它处理代码 } } void OutMsgQueue() { int command = 0; while (true) { unique_lock\u0026lt;mutex\u0026gt; lock(mtx); //返回false 解锁互斥量，堵塞在这里，直到其它线程调用notify_one()或notify_all()为止 //返回true 锁上，往下执行 cv.wait(lock, [this] {return !MsgQueue.empty();}); command = MsgQueue.front(); MsgQueue.pop_front(); cout \u0026lt;\u0026lt; \u0026#34;OutMsgQueue \u0026#34; \u0026lt;\u0026lt; command \u0026lt;\u0026lt;\u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34; list size:\u0026#34; \u0026lt;\u0026lt; MsgQueue.size() \u0026lt;\u0026lt; endl; lock.unlock(); } } }; 线程执行是反复横跳的，这一段运行起来的效果是，InMsgQueue已经给List插入了N个元素后，OutMsgQueue才执行，例如：InMsgQueue执行了2秒，然后才执行OutMsgQueue.notify_one也不会每次都生效，例如OutMsgQueue已经被唤醒了，正在执行wait之后的操作，没有卡在wait()，\n那么notify_one就不会唤醒OutMsgQueue，因为没有东西可以唤醒。\n有2个OutMsgQueue线程函数，线程A堵塞在wait，线程B已经被唤醒且正在执行一些被唤醒后的操作\nnotify_one() 的行为\n等待状态：\n只有当线程处于等待状态（即调用了 wait() 方法并且尚未返回）时，它才能被 notify_one() 唤醒。 如果一个线程已经从 wait() 返回并重新获得了互斥锁，则它不再是等待状态，不会被 notify_one() 唤醒 唤醒机制：\nnotify_one() 只会发出一次通知信号，尝试唤醒一个等待的线程。 操作系统会选择一个等待的线程来唤醒（如果有多个等待的线程，选择哪个线程是未定义的行为）。 如果没有等待的线程或被唤醒的线程没有实际开始运行（例如因为它已经被唤醒），则通知信号将被忽略。 谁决定了 notify_one() 唤醒哪一个线程？这是由操作系统级别的条件变量机制决定的：\n等待队列：所有等待在条件变量上的线程会被放入一个等待队列中。 选择机制：当 notify_one() 被调用时，操作系统会从等待队列中选择一个线程来唤醒。具体选择哪个线程是未定义的行为，通常取决于操作系统的调度策略。 notify_all() 的行为\n调用 notify_all()：所有等待的线程（如线程 A）会被唤醒，并尝试重新获取互斥锁。线程 B 不受影响，因为它不在等待状态。 竞争互斥锁：被唤醒的线程会竞争互斥锁，只有一个线程能够成功获取锁并继续执行，其他线程将继续等待。 可以确保所有等待的线程都有机会被唤醒并处理新的消息或任务。 单例模式 Magic Static\nC++11 引入了局部静态变量的线程安全初始化特性，即所谓的“Magic Static”。当一个函数内的局部静态变量被首次访问时，编译器会确保其初始化是线程安全的，并且只执行一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Singleton { public: // 获取单例对象的静态方法 static Singleton\u0026amp; getInstance() { static std::unique_ptr\u0026lt;Singleton\u0026gt; instance(new Singleton()); return *instance; } // 示例方法 void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton is doing something!\u0026#34; \u0026lt;\u0026lt; std::endl; } private: // 私有构造函数和析构函数 Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton created!\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton destroyed!\u0026#34; \u0026lt;\u0026lt; std::endl; } // 禁用拷贝构造函数和赋值运算符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; }; 双重检查锁定（DCLP）\n双重检查锁定是一种优化的懒加载单例模式实现方式，通过减少锁的竞争来提高性能。它的核心思想是先检查指针是否为空，如果不是空则直接返回实例；如果是空，则进入临界区再次检查并创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { public: static Singleton* getInstance() { if (instance == nullptr) // 第一次检查 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); if (instance == nullptr) // 第二次检查 { instance = new Singleton(); } } return instance; } private: Singleton() {} // 私有构造函数防止外部实例化 static Singleton* instance; static std::mutex mutex_; }; Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex_; 在并发编程和计算机体系结构中，\u0026ldquo;reorder\u0026rdquo;（重排序）指的是编译器或处理器对指令执行顺序进行调整的过程。这种重排序旨在优化程序性能，但如果不加以适当控制，可能会导致多线程程序中的数据竞争和不一致问题。\n编译器重排序（Compiler Reordering）\n编译器为了优化代码的执行效率，可能会改变源代码中指令的实际执行顺序。这种优化通常基于静态分析，目的是减少指令依赖、提高流水线利用率等。例如：\n1 2 3 4 5 6 7 int a = 0; int b = 0; void foo() { a = 1; // 操作1 b = 2; // 操作2 } 编译器可能将 b = 2 放在 a = 1 之前执行，因为这两个操作是独立的，不会互相影响。然而，在多线程环境中，这样的重排序可能会导致不可预期的行为。\n处理器重排序（Processor Reordering）\n现代处理器为了提高指令吞吐量和执行效率，也会对指令执行顺序进行重排。处理器重排序通常发生在以下几种情况下：\n指令级并行：处理器可以同时执行多个独立的指令。 内存访问重排序：处理器可以重新安排读写内存的操作顺序，以减少缓存未命中和等待时间。 1 2 3 4 5 6 7 8 // 线程1 a = 1; flag = true; // 线程2 if (flag) { assert(a == 1); } 如果没有适当的同步机制，处理器可能会先执行 flag = true，然后再执行 a = 1，这会导致线程2在检查 flag 时看到 true，但在读取 a 时仍然看到旧值 0，从而导致断言失败。\n内存模型（Memory Model）\n为了处理这些重排序问题，C++ 标准引入了内存模型的概念。内存模型定义了多线程程序中可见性和顺序的规则。C++11 及之后的标准提供了多种内存顺序（memory order），用于显式地控制指令的执行顺序和可见性。\nstd::memory_order_relaxed：最宽松的内存顺序，仅保证原子操作本身的原子性，不提供任何同步或顺序保证。 std::memory_order_consume：消费操作，依赖于其他线程的写操作，并确保这些写操作在当前线程中可见。 **std::memory_order_acquire：获取操作，保证在此操作之后的所有读写操作都不会被重排到此操作之前。 std::memory_order_release：释放操作，保证在此操作之前的所有读写操作都不会被重排到此操作之后。 std::memory_order_acq_rel：结合获取和释放操作，适用于读-修改-写操作。 std::memory_order_seq_cst：最严格的内存顺序，提供全局顺序一致性，但可能会带来较大的性能开销。 volatile 关键字告诉编译器不要对该变量进行重排序和优化。然而，C++ 中的 volatile 并不能解决所有重排序问题，尤其是处理器级别的重排序问题。\n这种方法并不推荐，因为它无法解决所有重排序问题，特别是处理器级别的重排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton { public: static Singleton* getInstance() { if (instance == nullptr) { // 第一次检查 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); if (instance == nullptr) { // 第二次检查 instance = new Singleton(); } } return instance; } private: Singleton() {} static volatile Singleton* instance; // 使用 volatile static std::mutex mutex_; }; volatile Singleton* Singleton::instance = nullptr; 更推荐的方法是使用 std::atomic 和适当的内存顺序来显式地控制指令的执行顺序和可见性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; class Singleton { public: static Singleton* getInstance() { Singleton* tmp = instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire); if (tmp == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); tmp = instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Singleton(); std::atomic_thread_fence(std::memory_order_release); instance.store(tmp, std::memory_order_relaxed); } } return tmp; } private: Singleton() {} // 私有构造函数防止外部实例化 static std::atomic\u0026lt;Singleton*\u0026gt; instance; static std::mutex mutex_; }; std::atomic\u0026lt;Singleton*\u0026gt; Singleton::instance(nullptr); std::mutex Singleton::mutex_; std::memory_order_relaxed：用于初步检查 instance 是否为 nullptr，因为此时只需要保证原子性，不需要严格的同步保证。 std::atomic_thread_fence(std::memory_order_acquire)：在进入临界区之前使用获取内存屏障，确保读取到的 instance 值是最新的。 std::atomic_thread_fence(std::memory_order_release)：在存储 instance 之后使用释放内存屏障，确保所有写操作已经完成，其他线程可以看到最新的值。 特性 Magic Static 双重检查锁定 (DCLP) 实现复杂度 简单 复杂 线程安全性 内置线程安全 需要显式加锁 懒加载 支持，但不可控 完全可控 性能 高（无锁） 中等（较少锁竞争） 资源管理 自动管理生命周期 需要手动管理 依赖环境 需要 C++11 及以上标准 标准 C++，但需注意内存顺序问题 call_once std::call_once 是 C++11 标准库提供的一个工具，用于确保某个函数或可调用对象在多线程环境中仅被调用一次。它通常与 std::once_flag 一起使用，以实现线程安全的单次初始化。\nstd::call_once：这是一个函数模板，接受一个 std::once_flag 对象和一个可调用对象（如函数、lambda 表达式或函数对象）。它保证传入的可调用对象只会被执行一次，即使在多线程环境下多个线程同时尝试调用。 std::once_flag：这是一个特殊的标记对象，用来标识某个操作是否已经执行过。每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例。 std::once_flag 必须是全局或静态变量：每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例，并且该实例必须具有持久的生命周期（即不能是局部变量）。 std::call_once 和 std::once_flag 主要用于以下场景：\n单例模式：确保单例对象的初始化只发生一次。 全局变量初始化：确保某些全局资源或配置只初始化一次。 其他一次性操作：任何需要确保只执行一次的操作都可以使用 std::call_once。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; std::once_flag onceFlag; int initializedValue = 0; void initialize() { std::call_once(onceFlag, []() { initializedValue = 42; std::cout \u0026lt;\u0026lt; \u0026#34;Initialization complete.\u0026#34; \u0026lt;\u0026lt; std::endl; }); } void threadFunc(int threadId) { initialize(); std::cout \u0026lt;\u0026lt; \u0026#34;Thread \u0026#34; \u0026lt;\u0026lt; threadId \u0026lt;\u0026lt; \u0026#34;: initializedValue = \u0026#34; \u0026lt;\u0026lt; initializedValue \u0026lt;\u0026lt; std::endl; } int main() { std::thread t1(threadFunc, 1); std::thread t2(threadFunc, 2); t1.join(); t2.join(); return 0; } 输出\n1 2 3 Initialization complete. Thread 1: initializedValue = 42 Thread 2: initializedValue = 42 单例使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { public: static Singleton\u0026amp; getInstance() { std::call_once(initFlag, []() { instance.reset(new Singleton()); std::cout \u0026lt;\u0026lt; \u0026#34;Singleton instance created.\u0026#34; \u0026lt;\u0026lt; std::endl; }); return *instance; } void doSomething() const { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton instance doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } private: Singleton() { std::cout \u0026lt;\u0026lt; \u0026#34;Singleton constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;) = delete; // 禁止拷贝构造 Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; // 禁止赋值操作 static std::unique_ptr\u0026lt;Singleton\u0026gt; instance; static std::once_flag initFlag; }; // 初始化静态成员变量 std::unique_ptr\u0026lt;Singleton\u0026gt; Singleton::instance = nullptr; std::once_flag Singleton::initFlag; int main() { std::thread t1([]() { Singleton\u0026amp; singleton = Singleton::getInstance(); singleton.doSomething(); }); std::thread t2([]() { Singleton\u0026amp; singleton = Singleton::getInstance(); singleton.doSomething(); }); t1.join(); t2.join(); return 0; } 异步 async \u0026amp; future std::async 是 C++11 标准引入的一个函数模板，用于启动异步任务。它允许你以一种简便的方式创建和管理异步任务，并且可以获取这些任务的返回值。std::async 返回一个 std::future 对象，该对象可以在稍后用来获取任务的结果。\nstd::future 是 C++11 标准库中的一部分，用于处理异步操作的结果。它提供了一种机制来获取异步任务的返回值或异常，并允许你等待任务完成。\n创建future\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //带有_Policy的构造 template \u0026lt;class Function, class... _ArgTypes\u0026gt; future\u0026lt;_Invoke_result_t\u0026lt;decay_t\u0026lt;Function\u0026gt;, decay_t\u0026lt;_ArgTypes\u0026gt;...\u0026gt;\u0026gt; async(launch _Policy, Function\u0026amp;\u0026amp; _Fnarg, _ArgTypes\u0026amp;\u0026amp;... _Args) //不指定_Policy 就会调用这个版本的构造，此版本将会调用带有_Policy的构造， //并且_Policy策略是launch::async+launch::deferred template \u0026lt;class Function, class... _ArgTypes\u0026gt; future\u0026lt;_Invoke_result_t\u0026lt;decay_t\u0026lt;Function\u0026gt;, decay_t\u0026lt;_ArgTypes\u0026gt;...\u0026gt;\u0026gt; async(Function\u0026amp;\u0026amp; _Fnarg, _ArgTypes\u0026amp;\u0026amp;... _Args) { return async(launch::async | launch::deferred, forward\u0026lt;Function\u0026gt;(_Fnarg), forward\u0026lt;_ArgTypes\u0026gt;(_Args)...); } _Policy：指定任务的执行策略，可以是 std::launch::async 或 std::launch::deferred，或者两者的组合（默认情况下是 std::launch::async | std::launch::deferred）。 _Fnarg：要异步执行的函数或可调用对象。 _Args：传递给函数 f 的参数。 1 2 3 4 STD enum class launch { // names for launch options passed to async async = 0x1, deferred = 0x2 }; 如果选择了 std::launch::async，则立即在一个新线程中启动任务。\n如果选择了 std::launch::deferred，则延迟执行任务，直到调用 get() 或 wait() 方法。\n调用 std::future::get() 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。\n如果任务已经完成，则直接返回结果。\nfuture的函数\n名称 描述 get 检索存储在关联异步状态中的结果。 share 将对象转换为 shared_future。 valid 指定对象是否不为空。 wait 阻止当前线程，直到关联异步状态为准备就绪。 wait_for 进行阻止，直到关联异步状态为准备就绪或已过指定时间。 wait_until 进行阻止，直到关联异步状态为准备就绪或直到指定时间点。 阻塞行为：当调用 get() 方法时，如果异步任务尚未完成，当前线程会被阻塞，直到任务完成并返回结果。 异常处理：如果异步任务抛出异常，get() 方法会重新抛出该异常，并且当前线程会被阻塞直到异常被抛出。 延迟执行：如果使用 std::launch::deferred 策略，get() 方法不仅会阻塞，还会触发任务的实际执行。 超时等待：可以使用 wait_for 或 wait_until 方法设置超时时间，避免无限期等待。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool loop = true; int add(int a, int b) { this_thread::sleep_for(std::chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;add\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; loop = false; return a + b; } int main() { // 启动异步任务 std::future\u0026lt;int\u0026gt; result = std::async(add, 5, 3); // 主线程继续做其他事情 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else.\\n\u0026#34;; while (loop) { std::cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; this_thread::sleep_for(std::chrono::milliseconds(1)); } // 获取异步任务的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread Get Result.\\n\u0026#34;; int sum = result.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 4 5 6 7 8 9 Main thread is doing something else. ..................................... .................................... ..................................... ......................................... .......................................... .....................................add .Main thread Get Result. Result: 8 异步不会卡主线程，主线程一直在打印\u0026hellip;. 直到子线程执行完毕，\n假如调用异步任务的结果时，异步线程还没有执行完成，主线程会堵塞 直到异步线程执行完毕。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int add(int a, int b) { this_thread::sleep_for(std::chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;add\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return a + b; } int main() { // 启动异步任务 std::future\u0026lt;int\u0026gt; result = std::async(add, 5, 3); // 主线程继续做其他事情 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else.\\n\u0026#34;; // 获取异步任务的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread Get Result.\\n\u0026#34;; int sum = result.get();//卡在这里 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 1 2 3 4 5 Main thread is doing something else. Main thread Get Result. //在这里卡住，等待异步结果出来 才继续执行。 add Result: 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyClass { public: // 成员函数，接受两个整数并返回它们的和 int computeSum(int a, int b) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 return a + b; } }; int main() { MyClass obj; // 创建类的对象 // 使用 std::async 启动异步任务，调用成员函数 computeSum auto future = std::async(\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); std::cout \u0026lt;\u0026lt; \u0026#34;Doing some work in the main thread.\u0026#34; \u0026lt;\u0026lt; std::endl; // 获取异步任务的结果 int result = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } std::launch\n1 2 3 4 STD enum class launch { // names for launch options passed to async async = 0x1, deferred = 0x2 }; 如果选择了 std::launch::async，则立即在一个新线程中启动任务。\n如果选择了 std::launch::deferred，则延迟执行任务，直到调用 get() 或 wait() 方法。\n调用 std::future::get() 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。\n如果任务已经完成，则直接返回结果。\n如果将上面创建future的函数改为\n1 auto future = std::async(std::launch::deferred,\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); 那么future的函数将会在主线程中执行，因为没有用launch::async.\n下面的两种方式都会在新线程中执行，\n1 2 3 4 //新线程延迟到get()时执行 auto future = std::async(\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); //新线程立即执行 auto future = std::async(std::launch::async,\u0026amp;MyClass::computeSum, \u0026amp;obj, 5, 3); async vs thread\n使用std::thread，如果系统资源紧张，线程创建会失败，执行std::thread可能导致程序崩溃.std::async是创建异步任务，使用launch::deferred时不创建新线程，\nasync构造函数 默认使用了 launch::async | launch::deferred，\n如果系统资源充足，可能会选择 std::launch::async 并创建一个新线程来立即执行任务。 如果系统资源紧张或任务数量较多，可能会选择 std::launch::deferred，延迟任务的执行，直到你请求其结果时才执行。 判断是否创建线程\n1 2 3 4 5 6 7 8 std::thread thread; std::future\u0026lt;int\u0026gt; future = std::async(func); std::future_status status = future.wait_for(std::chrono::seconds(0)); if (status == std::future_status::deferred) { //线程被延迟执行 std::cout\u0026lt;\u0026lt;future.get()\u0026lt;\u0026lt;std::endl; } wait_for\nwait_for 方法，允许你在指定的时间内等待异步任务完成。如果在指定时间内任务完成了，wait_for 会返回一个指示任务状态的枚举值；如果超时，则返回一个表示超时的状态。\n应用场景：当你希望避免无限期等待异步任务完成时，可以使用 wait_for 方法设置超时时间，并根据任务状态采取不同的操作。 1 2 template\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; 参数：timeout_duration 是一个时间间隔，指定了你愿意等待的最大时间。 返回值：返回枚举值，表示当前任务的状态： std::future_status::ready：任务已经完成。 std::future_status::timeout：任务未完成，并且达到了超时时间。 std::future_status::deferred：任务被延迟执行（仅适用于使用 std::launch::deferred 启动的任务）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; int longComputation(int x) { std::this_thread::sleep_for(std::chrono::seconds(3)); // 模拟长时间计算 return x * x; } int main() { // 使用 std::async 启动异步任务，并获取 std::future 对象 auto future = std::async(std::launch::async, longComputation, 5); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for the result with timeout...\u0026#34; \u0026lt;\u0026lt; std::endl; // 设置超时时间为1秒 auto status = future.wait_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;End Wait...\u0026#34; \u0026lt;\u0026lt; std::endl; switch (status) { case std::future_status::ready: std::cout \u0026lt;\u0026lt; \u0026#34;Result is ready: \u0026#34; \u0026lt;\u0026lt; future.get() \u0026lt;\u0026lt; std::endl; break; case std::future_status::timeout: std::cout \u0026lt;\u0026lt; \u0026#34;Timeout occurred before the result was ready.\u0026#34; \u0026lt;\u0026lt; std::endl; break; case std::future_status::deferred: std::cout \u0026lt;\u0026lt; \u0026#34;The task has been deferred and will be executed on call to get().\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return 0; } 输出： 函数执行需要3秒，但是只等待了1秒，超时。\n1 2 3 Waiting for the result with timeout... End Wait... Timeout occurred before the result was ready. std::packaged_task std::packaged_task 是 C++11 标准库中的一个类模板，用于封装可调用对象（如函数、lambda 表达式或函数对象），并允许你异步执行这些对象。它与 std::future 配合使用，可以获取任务的执行结果。\n主要用途\n封装可调用对象：将可调用对象（如函数、lambda 表达式或函数对象）封装到 std::packaged_task 中。 异步执行：可以在不同的线程中执行封装的任务，并通过 std::future 获取结果。 异常处理：如果任务抛出异常，可以通过 std::future::get() 捕获并重新抛出该异常。 名称 描述 get_future 返回具有相同关联异步状态的 future 对象。 make_ready_at_thread_exit 调用存储在关联异步状态中的可调用的对象，并以原子方式存储返回值。 reset 替换关联异步状态。 swap 将关联异步状态与指定对象交换。 valid 指定对象是否具有关联异步状态。 简单使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; int add(int a, int b) { return a + b; } int main() { // 创建一个 packaged_task，包装 add 函数 std::packaged_task\u0026lt;int(int, int)\u0026gt; task(add); // 获取与任务关联的 future std::future\u0026lt;int\u0026gt; result = task.get_future(); // 在另一个线程中执行任务 //move(task) 或 ref(task) std::thread t(std::move(task), 2, 3); t.join(); // 获取任务结果 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; std::endl; return 0; } promise std::promise 是 C++11 标准库中的一个类模板，用于在不同的线程之间设置异步结果或异常。它通常与 std::future 配合使用，以便在一个线程中设置值或异常，并在另一个线程中获取这些值或异常。\n主要用途\n设置异步结果：在一个线程中通过 std::promise 设置某个值。 获取异步结果：在另一个线程中通过关联的 std::future 获取该值。 异常处理：如果任务抛出异常，可以通过 std::promise 将异常传递给 std::future。 名称 描述 get_future 返回与此 promise 关联的 future。 set_exception 以原子方式设置此 promise 的结果以指示异常。 set_exception_at_thread_exit 以原子方式设置此 promise 的结果以指示异常，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。 set_value 以原子方式设置此 promise 的结果以指示值。 set_value_at_thread_exit 以原子方式设置此 promise 的结果以指示值，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。 swap 用指定的 promise 对象的关联的异步状态交换此 promise 的关联的异步状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void computeSum(std::promise\u0026lt;int\u0026gt;\u0026amp; prom, int a, int b) { int sum = a + b; prom.set_value(sum); // 设置结果 } int main() { std::promise\u0026lt;int\u0026gt; prom; std::thread t1(computeSum,std::ref(prom),2,3); t1.join(); std::future\u0026lt;int\u0026gt; fut = prom.get_future(); auto sum = fut.get(); std::cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 多个线程之间传值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void step1(std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = 10; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 1 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt;std::endl; } void step2(int input, std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = input * 2; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 2 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } void step3(int input, std::promise\u0026lt;int\u0026gt; prom) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 int result = input + 5; prom.set_value(result); std::cout \u0026lt;\u0026lt; \u0026#34;Step 3 completed,Value:\u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } int main() { std::promise\u0026lt;int\u0026gt; p1, p2, p3; std::future\u0026lt;int\u0026gt; f1 = p1.get_future(); std::future\u0026lt;int\u0026gt; f2 = p2.get_future(); std::future\u0026lt;int\u0026gt; f3 = p3.get_future(); // 启动第一个步骤，并将结果存储在p1中 std::thread t1(step1, std::move(p1)); // 启动第二个步骤，并等待第一个步骤的结果，将结果存储在p2中 std::thread t2(step2, f1.get(),std::move(p2)); // 启动第三个步骤，并等待第二个步骤的结果，将结果存储在p3中 std::thread t3(step3, f2.get(), std::move(p3)); // 获取最终结果 int final_result = f3.get(); // 如果任务未完成，这里会阻塞 std::cout \u0026lt;\u0026lt; \u0026#34;Final result: \u0026#34; \u0026lt;\u0026lt; final_result \u0026lt;\u0026lt; std::endl; t1.join(); t2.join(); t3.join(); return 0; } 输出：\n1 2 3 4 Step 1 completed,Value:10 Step 2 completed,Value:20 Step 3 completed,Value:25 Final result: 25 shared_future std::shared_future 是 C++11 标准库中的一个类模板，它是 std::future 的扩展版本，允许多个线程共享同一个异步结果。与 std::future 不同的是，std::shared_future 可以被多次拷贝，并且每个拷贝都可以独立地获取异步任务的结果或异常。\nstd::shared_future 通常通过 std::future 的 share() 方法获得。一旦你有了 std::shared_future 对象，就可以在多个线程中使用它来获取异步结果。\n主要用途\n共享异步结果：允许多个线程共享同一个异步结果。 多次获取结果：可以在多个地方调用 get() 方法来获取同一个异步任务的结果，而不会导致阻塞或重复执行任务。 异常处理：如果任务抛出异常，可以通过 std::shared_future::get() 捕获并重新抛出该异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;Tool.h\u0026#34; int computeSum(int a, int b) { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return a + b; } void printResult(const std::shared_future\u0026lt;int\u0026gt;\u0026amp; fut) { printf(\u0026#34;Result:%d \\n\u0026#34;, fut.get()); // 获取异步任务的结果 } int main() { // 使用 std::async 启动异步任务，并获取 std::future 对象 auto future = std::async(std::launch::async, computeSum, 5, 3); // 将 std::future 转换为 std::shared_future std::shared_future\u0026lt;int\u0026gt; sharedFut = future.share(); // 在多个线程中获取异步任务的结果 std::thread t1(printResult, sharedFut); std::thread t2(printResult, sharedFut); t1.join(); t2.join(); std::this_thread::sleep_for(std::chrono::seconds(3)); printf(\u0026#34;Main thread value:%d\u0026#34;, sharedFut.get()); return 0; } 输出：\n1 2 3 Result:8 Result:8 Main thread value:8 atomic std::atomic 是 C++11 标准库中的一个模板类，用于提供原子操作的支持。原子操作是指不可分割的操作，在多线程环境中可以保证对共享数据的访问是安全的，不会出现竞态条件（race condition）。\n原语：操作系统或编程语言提供的基本构建块或不可再分的操作单元。要么完全执行，要么完全不执行 原子：指那些不可分割的操作或数据结构，在并发环境中保持一致性。 原子化：将一系列操作视为一个不可分割的整体，确保这些操作要么全部成功，要么全部失败。 原子操作：在执行过程中不会被中断的操作，通常用于确保并发环境下的线程安全性。\n主要用途\n线程安全：确保对共享变量的操作在多线程环境中是线程安全的。 无锁编程：通过原子操作实现高效的无锁编程。 内存顺序控制：允许你控制内存顺序，以优化性能或确保特定的内存可见性。 基本概念\n原子类型：std::atomic\u0026lt;T\u0026gt; 是一个模板类，其中 T 是你要进行原子操作的数据类型。\n原子操作：包括读取、写入、交换、比较并交换等操作，这些操作都是原子性的，即它们不会被其他线程中断。\n函数：\nload()：获取当前值（原子读取）。\nstore(value)：设置新值（原子写入）。\nfetch_add(arg) 和 fetch_sub(arg)：增加或减少当前值，并返回旧值。\nfetch_and(arg), fetch_or(arg), fetch_xor(arg)：按位与、或、异或操作，并返回旧值。\ncompare_exchange_weak(expected, desired)\n如果 atomic 的当前值 (currentValue) 等于 expected： 将 atomicPoint 更新为 desired。 返回 true。更新成功。 如果 atomic 的当前值 (currentValue) 不等于 expected： 更新 expected 为 atomicPoint 的当前值 (currentValue)。 返回 false。更新失败。 compare_exchange_strong(expected, desired)\n与 compare_exchange_weak 类似，但没有伪失败的情况。\n基础操作\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::atomic\u0026lt;int\u0026gt; atomicInt(0); // 定义一个原子整型变量，并初始化为0 std::cout \u0026lt;\u0026lt; \u0026#34;Initial value: \u0026#34; \u0026lt;\u0026lt; atomicInt.load() \u0026lt;\u0026lt; std::endl; atomicInt.store(42); // 设置值为42 std::cout \u0026lt;\u0026lt; \u0026#34;Updated value: \u0026#34; \u0026lt;\u0026lt; atomicInt.load() \u0026lt;\u0026lt; std::endl; return 0; } 写数值\n每个线程让Value+10000, 5个线程的执行结果应该为：50000，但是每次运行的Value结果是随机的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; int Value = 0; void incrementCounter(int id) { for (int i = 0; i \u0026lt; 10000; ++i) { Value++; } } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都增加计数器 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(incrementCounter, i + 1); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } std::cout \u0026lt;\u0026lt; \u0026#34;Final counter value: \u0026#34; \u0026lt;\u0026lt; Value \u0026lt;\u0026lt; std::endl; return 0; } 使用atomic\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; std::atomic\u0026lt;int\u0026gt; atomicCounter(0); void incrementCounter(int id) { for (int i = 0; i \u0026lt; 10000; ++i) { atomicCounter.fetch_add(1); // 原子增加 } printf(\u0026#34;Thread %d done \\n\u0026#34;, id); } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都增加计数器 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(incrementCounter, i + 1); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } std::cout \u0026lt;\u0026lt; \u0026#34;Final counter value: \u0026#34; \u0026lt;\u0026lt; atomicCounter.load() \u0026lt;\u0026lt; std::endl; return 0; } 输出：\n1 2 3 4 5 6 Thread 2 done Thread 5 done Thread 4 done Thread 1 done Thread 3 done Final counter value: 50000 1 2 3 4 5 6 7 8 9 10 11 12 std::atomic\u0026lt;int\u0026gt; atm(0); atm += 1; //原子操作 atm = atm + 1;//不是原子操作 //读atm是原子操作，但这一行不是原子操作 cout\u0026lt;\u0026lt; atm \u0026lt;\u0026lt; endl; //使用load原子读值 atomic\u0026lt;int\u0026gt; atm2(atm.load()); auto atm3(atm.load()); //store原子写入 atm2.store(12); 自定义类型的原子操作\n虽然 std::atomic 支持大多数基本数据类型，但对于自定义类型，需要满足一些条件才能使用原子操作：\n类型必须是可平凡复制的（Trivially Copyable）。 类型必须有一个公共的默认构造函数。 如果你需要对自定义类型进行原子操作，可以通过封装和手动实现 CAS 操作来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;atomic\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; struct Point { int x, y; Point(int x_ = 0, int y_ = 0) : x(x_), y(y_) {} }; std::atomic\u0026lt;Point\u0026gt; atomicPoint(Point(0, 0)); void updatePoint(int dx, int dy) { Point oldVal, newVal; do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; // 创建多个线程，每个线程都更新点的位置 for (int i = 0; i \u0026lt; 5; ++i) { threads.emplace_back(updatePoint, i, i); } // 等待所有线程完成 for (auto\u0026amp; t : threads) { t.join(); } Point finalValue = atomicPoint.load(); std::cout \u0026lt;\u0026lt; \u0026#34;Final point position: (\u0026#34; \u0026lt;\u0026lt; finalValue.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; finalValue.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 有一个全局的原子变量 atomicPoint，它是一个 Point 结构体类型的对象。多个线程可能会同时尝试修改这个变量。为了确保这些修改是安全且没有冲突的，需要使用原子操作来实现这一点。\n1 2 3 4 5 6 7 8 9 std::atomic\u0026lt;Point\u0026gt; atomicPoint(Point(0, 0)); void updatePoint(int dx, int dy) { Point oldVal, newVal; do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); } 1 2 oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); load()：这是一个原子操作，用来读取 atomicPoint 当前的值，并将其存储在 oldVal 中，以便在此基础上计算新的值\nnewVal：基于 oldVal 和增量值 dx 和 dy 计算出的新 Point 对象。\n1 2 3 4 do { oldVal = atomicPoint.load(); newVal = Point(oldVal.x + dx, oldVal.y + dy); } while (!atomicPoint.compare_exchange_weak(oldVal, newVal)); compare_exchange_weak(oldVal, newVal)：这是一个关键的原子操作，用于比较并交换（CAS，Compare-And-Swap）。\n比较部分：首先检查 atomicPoint 当前的值是否与 oldVal 相等。 交换部分：如果相等，则将 atomicPoint 更新为 newVal，返回true；如果不相等，则不会更新 atomicPoint，而是更新 oldVal 为 atomicPoint 的当前值，返回false。 循环机制：\n如果 compare_exchange_weak 返回 false，说明在我们读取 oldVal 和尝试更新之间，有其他线程已经修改了 atomicPoint 的值。 此时，我们需要重新加载最新的 oldVal，重新计算 newVal，然后再次尝试更新。 如果在尝试更新时发现 atomicPoint 已经被其他线程修改，则重新加载最新值并重新计算新值，直到成功为止。 检查 atomicPoint 和 刚才读取的 atomicPoint (oldVal) 的值是否相同，如果值不一样，那就说明atomicPoint被其它线程篡改了。相等 ， 说明没有线程修改atomicPoint，可以把newVal给它，函数返回true不相等，说明有线程修改了atomicPoint ，此时就要把oldval给它，返回false，重新进入循环体计算newVal的值。\n多线程-C 线程池 服务器 \u0026mdash;\u0026gt; 客户端， 每来一个客户端 就创建一个新线程给客户服务.网络游戏 2万个玩家，不可能给每个玩家创建一个线程，创建线程可能会因为资源不够而失败，也有线程切换造成的消耗，\n线程池是一种设计模式，用于管理和复用一组工作线程，以提高应用程序的性能和资源利用率。它通过预先创建一组线程，并将这些线程放入一个“池”中，以便在需要执行任务时可以快速分配和重用这些线程，而不需要频繁地创建和销毁线程。\n通过复用一组工作线程来处理多个任务，减少了线程创建和销毁的开销，提高了系统的响应速度和资源利用率。\n线程数量过多，因为线程切换时 需要切换上下文，所以性能效率下降，\n线程池的主要优点\n减少线程创建和销毁的开销： 创建和销毁线程是一个相对昂贵的操作，涉及内存分配、上下文切换等。使用线程池可以避免频繁创建和销毁线程，从而提高性能。 提高响应速度： 当有新的任务到达时，线程池中的空闲线程可以立即开始处理任务，而不是等待新线程的创建。这使得应用程序能够更快地响应请求。 控制并发线程数量： 线程池允许你设定最大并发线程数，防止系统因为创建过多线程而导致资源耗尽或系统崩溃。 资源管理： 线程池可以更好地管理系统资源，确保不会因为过度创建线程而导致内存或其他资源的耗尽。 线程池的基本组成\n一个典型的线程池通常包含以下几个部分：\n任务队列（Task Queue）： 存储待执行的任务。当有新的任务提交到线程池时，任务会被加入到这个队列中。 工作线程（Worker Threads）： 预先创建的一组线程，负责从任务队列中取出任务并执行。 线程池管理器（Pool Manager）： 负责管理线程池的状态，包括创建和销毁线程、监控线程状态、处理任务队列等。 任务调度机制： 决定如何从任务队列中取出任务并分配给空闲的工作线程。 线程池的工作流程\n初始化线程池： 在程序启动时，线程池会根据配置预先创建一组工作线程，并将它们放入池中。 提交任务： 当有新的任务需要执行时，任务会被提交到线程池的任务队列中。 任务分配： 空闲的工作线程会从任务队列中取出任务并开始执行。 如果所有线程都在忙于执行任务，则新任务会被暂时存储在任务队列中，直到有线程空闲下来。 任务完成： 工作线程完成任务后，会返回线程池中继续等待下一个任务。 关闭线程池： 当不再需要线程池时，可以通过调用相应的 API 来关闭线程池，释放所有资源。 线程池的应用场景\nWeb服务器： 处理客户端请求时，每个请求都可以作为一个独立的任务交给线程池中的线程处理。 数据库查询： 数据库查询操作通常比较耗时，可以将查询请求提交到线程池中异步执行，避免阻塞主线程。 图像处理： 对大量图像进行处理时，可以将每张图像的处理任务提交到线程池中并发执行。 批量数据处理： 批量处理大量数据时，可以将每个数据块的处理任务提交到线程池中并行执行。 ","date":"1574-01-01T13:05:38+08:00","permalink":"https://akaklya.github.io/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"C++多线程"},{"content":"简介 迭代器（Iterator）是一种用于遍历容器（如 std::vector, std::list, std::map 等）中元素的工具。它们提供了一种统一的方式来访问和操作容器中的数据，无论这些容器是如何实现的。迭代器的设计灵感来源于指针的概念，但它们提供了更抽象和灵活的操作接口。迭代器可以看作是“智能指针”，它们不仅能够指向容器中的某个位置，还能通过一系列标准操作进行移动、访问和修改容器中的元素。\nSTL 的六大组件通过 迭代器 作为粘合剂，将以下五个东西有机整合。\n数据存储（容器） 数据操作（算法） 行为策略（仿函数） 接口改造（适配器） 内存管理（分配器） 这种设计使得代码高度模块化、可复用且高效，成为C++泛型编程的典范。容器库 算法库\n容器类型 特点 时间复杂度（平均） 时间复杂度（最坏） 适用场景 std::vector 动态数组，支持随机访问 O(1) O(n) 需要频繁随机访问，且大多数操作集中在尾部 std::deque 双端队列，支持两端高效插入和删除 O(1) O(n) 需要在两端频繁插入和删除 std::list 双向链表，支持任意位置高效插入和删除 O(1) O(n) 需要频繁在任意位置插入和删除 std::forward_list 单向链表，支持高效插入和删除 O(1) O(n) 需要单向遍历和高效的插入/删除操作 std::set 有序集合，基于平衡二叉搜索树 O(log n) O(log n) 需要保持元素有序 std::multiset 有序多重集合，允许重复元素 O(log n) O(log n) 需要保持元素有序且允许重复元素 std::map 有序映射，基于平衡二叉搜索树 O(log n) O(log n) 需要保持键有序 std::multimap 有序多重映射，允许重复键 O(log n) O(log n) 需要保持键有序且允许重复键 std::unordered_set 无序集合，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multiset 无序多重集合，允许重复元素 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复元素 std::unordered_map 无序映射，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multimap 无序多重映射，允许重复键 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复键 std::stack LIFO 数据结构，基于其他容器实现 O(1) O(1) 需要栈操作 std::queue FIFO 数据结构，基于其他容器实现 O(1) O(1) 需要队列操作 std::priority_queue 优先队列，基于堆实现 O(log n) O(log n) 需要优先级管理的数据结构 设计哲学与优势\n解耦与复用： 算法与容器解耦，一个算法可作用于多种容器。 分配器与容器解耦，内存策略可灵活替换。 零开销抽象： 迭代器通过编译时多态（模板）实现，无运行时开销。 仿函数的内联优化比函数指针更高效。 扩展性： 用户可自定义容器（需提供迭代器）、算法（如支持新迭代器类型）、分配器等。 组件 作用 容器 存储和管理数据（如 vector, list, map） 算法 对数据进行操作（如 sort, find, transform） 迭代器 连接容器和算法，提供统一的元素访问接口 仿函数 封装可调用行为（如比较、运算），作为算法的策略参数 适配器 改造组件接口（如 stack 适配 deque，reverse_iterator 反向遍历） 分配器 管理容器的内存分配与释放（如自定义内存池） 联动:\n场景 参与的组件 示例 遍历容器 容器、迭代器 for (auto it = vec.begin(); ...) 排序算法 算法、迭代器、仿函数 sort(vec.begin(), vec.end(), comp) 容器适配栈 容器、适配器 stack\u0026lt;int, deque\u0026lt;int\u0026gt;\u0026gt; s 自定义内存管理 容器、分配器 vector\u0026lt;int, PoolAllocator\u0026lt;int\u0026gt;\u0026gt; 反向遍历 容器、迭代器、迭代器适配器 reverse_iterator rbegin() 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; int main() { int ia[5] = {30, 210, 12, 47, 89}; vector\u0026lt;int\u0026gt; vi(ia, ia + 5); // Container - vector //vector\u0026lt;int，allocator\u0026lt;int\u0026gt;\u0026gt; vi(ia, ia + 5); //统计小于30的元素 //Iterator - vi.begin(), vi.end() //Algorithm - count_if cout \u0026lt;\u0026lt; count_if(vi.begin(), vi.end(), [](int x) {return x \u0026lt; 30;}) \u0026lt;\u0026lt; endl; //统计大于等于30的元素 //Function Adapter - not_fn cout \u0026lt;\u0026lt; count_if(vi.begin(), vi.end(), not_fn([](int x) {return x \u0026lt; 30;})) \u0026lt;\u0026lt; endl; } 分配器 分配器（Allocator）是用于管理内存分配和释放的组件。它们主要用于标准库容器（如 std::vector, std::list, std::deque 等）中，以提供一致且高效的内存管理机制。\n主要职责：\n分配内存：为容器中的元素分配所需的内存。 释放内存：当容器不再需要某些内存时，释放这些内存。 构造和析构对象：在分配的内存上构造对象，并在需要时析构对象。 EASTL 开局 EASTL主要由容器、算法和迭代器组成。\n容器的一个例子是链表，而算法的一个例子是排序函数；迭代器则是用于遍历容器和算法的实体。\nEASTL包含相当多的容器和算法，每个都是一个非常干净、高效且经过单元测试的实现。\n我们可以自信地说，你不太可能找到更好的实现（无论是商业还是其他），因为这些实现是多年智慧和勤奋工作的结果。\nEAST 包含并扩展了标准 C++ STL 的功能，同时以各种对游戏开发有用的方式对其进行改进。\nEASTL 的大部分设计与标准 STL 相同，因为 STL 的大部分设计都经过精心设计，可用于多种用途。\nEASTL 与标准 STL 实现不同的主要方面基本上如下：\n具有简化且更灵活的自定义分配方案。 代码明显更易于阅读。 具有扩展容器和算法。 具有专为游戏开发而设计的优化。 唯一与STL不兼容的差异是内存分配的情况。\n为EASTL定义自定义分配器的方法与标准STL略有不同，尽管它们有90%的相似度。\n然而，那10%的不同之处却使得EASTL在大多数情况下比标准STL更易于使用且功能更强大。\n没有自定义分配器的容器在EASTL和标准STL之间的行为是相同的。\n某些 STL 实现（尤其是 Microsoft STL）的性能特征较差，因此不适合游戏开发。EASTL 比所有现有的 STL 实现都快。 STL 有时很难调试，因为大多数 STL 实现都使用晦涩难懂的变量名称和不寻常的数据结构。 STL 分配器有时使用起来很痛苦，因为它们有很多要求，并且一旦绑定到容器就无法修改。 STL 包含过多的功能，这些功能可能会导致代码大于预期。告诉程序员他们不应该使用该功能并不容易。 STL 是通过非常深入的函数调用实现的。这会导致在未优化构建中不可接受的性能，有时在优化构建中也是如此。 STL 不支持包含对象的对齐。 STL 容器不允许在未提供要从中复制的条目的情况下将条目插入容器。这可能效率低下。 在现有 STL 实现（如 STLPort）中找到的有用的 STL 扩展（例如 slist、hash_map shared_ptr）是不可移植的，因为它们在其他版本的 STL 中不存在，或者在 STL 版本之间不一致。 STL 缺乏游戏程序员认为有用的有用扩展（例如 intrusive_list），但在便携式 STL 环境中可以最好地优化这些扩展。 STL 的规范限制了我们有效使用它的能力。例如，STL 向量不能保证使用连续内存，因此不能安全地用作数组。 STL 强调正确性而不是性能，而有时您可以通过降低学术纯粹性来获得显着的性能提升。 STL 容器具有私有实现，不允许您以可移植的方式处理其数据，但有时这是一件重要的事情（例如节点池）。 所有现有版本的 STL 都至少在其某些容器的空版本中分配内存。这并不理想，并且会阻止优化，例如容器内存重置，在某些情况下可以大大提高性能。 STL 编译速度很慢，因为大多数现代 STL 实现都非常大。 存在一些法律问题，使我们很难自由地使用可移植的 STL 实现，例如 STLPort。 我们在 STL 的设计和实施中没有发言权，因此无法改变它以满足我们的需求。 可读性是 EASTL 比许多其他模板化库（尤其是 Microsoft STL 和 STLPort）更好的实现。\n我们尽一切努力使 EASTL 代码清晰明了。有时我们需要提供优化（特别是与 type_traits 和 iterator 类型相关）会导致代码不那么简单，但效率恰好是我们的首要任务，因此它凌驾于所有其他考虑因素之上。\n容器 原型容器：定义了所有非适配器容器都必须实现的基本功能。 适配器容器：如栈、队列等，这些容器通常基于其他基础容器构建，并且其具体实现可能会有所不同。 一致性：通过设定统一的标准，EASTL确保了不同容器之间的兼容性和易用性，减少了学习和使用成本。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 template \u0026lt;class T, class Allocator = EASTLAllocator\u0026gt; class container { public: typedef container\u0026lt;T, Allocator\u0026gt;\tthis_type; typedef T value_type; typedef T*\tpointer; typedef const T*\tconst_pointer; typedef\tT\u0026amp; reference; typedef const T\u0026amp; const_reference; typedef ptrdiff_t difference_type; typedef impl_defined size_type; typedef impl-defined iterator; typedef impl-defined const_iterator; typedef reverse_iterator\u0026lt;iterator\u0026gt; reverse_iterator; typedef reverse_iterator\u0026lt;const_iterator\u0026gt; reverse_const_iterator; typedef Allocator allocator_type; public: container(const allocator_type\u0026amp; allocator = allocator_type()); container(const this_type\u0026amp; x); this_type\u0026amp; operator=(this_type\u0026amp; x); void swap(this_type\u0026amp; x); void reset(); allocator_type\u0026amp; get_allocator(); void set_allocator(allocator_type\u0026amp; allocator); iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; bool validate() const; int validate_iterator(const_iterator i) const; protected: allocator_type mAllocator; }; template \u0026lt;class T, class Allocator\u0026gt; bool operator==(const container\u0026lt;T, Allocator\u0026gt;\u0026amp; a, const container\u0026lt;T, Allocator\u0026gt;\u0026amp; b); template \u0026lt;class T, class Allocator\u0026gt; bool operator!=(const container\u0026lt;T, Allocator\u0026gt;\u0026amp; a, const container\u0026lt;T, Allocator\u0026gt;\u0026amp; b); 分配器不交换：当两个容器通过交换操作互换内容时，它们各自的分配器不会被交换，这意味着每个容器将继续使用其原来的分配策略。 避免不必要的内存分配：EASTL的设计原则之一是尽量减少不必要的内存分配。新构造的空容器不会预先分配内存，这与某些其他容器库不同，后者可能会预先分配一个初始节点。 空容器的状态：无论是新创建的还是已经存在的空容器，都不会包含任何已构造的对象，包括所谓的“结束”节点。只有在设计确实需要并且有文档说明的情况下，才会构造用户对象。 reset函数的作用：reset函数用于快速重置容器到空状态，而无需释放容器内对象占用的内存。这对于临时使用的容器特别有用，因为它可以快速清理容器而不涉及复杂的内存管理。 显式验证机制：为了平衡性能和安全性，EASTL提供了显式的验证功能（如validate和validate_iterator），允许用户在需要时手动检查容器和迭代器的有效性，而不是每次都自动进行这种可能耗费大量资源的检查。这种方法既保证了灵活性，也确保了性能。 通过这些设计，EASTL旨在提高性能和易用性，同时为开发者提供更多的控制权和灵活性。\n分配器 STL分配器的问题：\n类级别定义：STL容器的分配器是在类级别定义的，而不是在实例级别，这使得为每个容器实例定义不同的分配器变得复杂。\n代码膨胀：由于分配器模板需要针对每种类型重新绑定，这导致了代码膨胀。\n不可访问性：容器构造后，你无法再访问其分配器，这限制了对分配器的操作和管理。\nEASTL的改进：\n单一分配器接口：EASTL采用了一个统一的分配器类接口，所有容器都使用这个接口，简化了内存分配的管理和使用。 灵活的分配器操作：EASTL容器允许用户访问、查询、命名和更改分配器，提供了更大的灵活性和控制权。 分配器在容器操作中的行为：\n交换操作：当容器A与容器B交换内容时，两个容器都会保留其原始分配器，而不是交换分配器。 赋值操作：将容器A赋值给容器B时，容器B会保留其原始分配器，而不是继承容器A的分配器。 智能交换：如果两个容器的分配器相同，EASTL会执行智能交换（更高效的方式）。如果分配器不同，则执行暴力交换（逐元素复制）。 通过这些改进，EASTL不仅解决了STL中分配器相关的一些痛点，还提高了内存管理的灵活性和效率，使开发者能够更好地控制容器的行为和性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // EASTL allocator class allocator { public: allocator(const char* pName = NULL); void* allocate(size_t n, int flags = 0); void* allocate(size_t n, size_t alignment, size_t offset, int flags = 0); void deallocate(void* p, size_t n); const char* get_name() const; void set_name(const char* pName); }; allocator* GetDefaultAllocator(); 固定大小的容器 EASTL提供了诸如fixed_list这样的固定大小容器，它们通过固定大小的连续内存池来实现。\nfixed_list具有以下特点：\n没有额外的空间开销。 不会导致内存碎片化。 分配速度非常快。 实现方式：\nEASTL通过继承自常规容器的子类来实现固定容器，这些子类将其常规容器的分配器设置为指向自身。 这种设计使得fixed_list的实现非常简洁，主要包括构造函数和分配器函数。 设计的优点：\n减少代码膨胀：由于实现简单，避免了大量的重复代码。 易于扩展：用户可以轻松地基于现有的实现进行扩展和修改。 简化实现：保持了实现的简单性和清晰度。 设计的小缺点：\n父类list中有一个指向自身的指针，占用了4个字节的空间。 如果采用不同的设计（例如策略模板参数），可以节省这4个字节，但会带来其他问题，如实现复杂化、用户扩展难度增加以及可能的代码膨胀。 为什么不采用策略设计：\n实现复杂化：策略设计会使容器的实现更加复杂。 用户扩展难度增加：复杂的实现会使用户难以扩展和修改容器。 潜在的代码膨胀：虽然可以节省每个容器实例中的4字节空间，但由于策略设计可能导致更多的代码膨胀，反而浪费了更多的内存。 通过这种方式，EASTL在简化实现和提高灵活性的同时，权衡了一些小的性能损失，确保了整体的设计简洁性和易用性。\n算法 算法设计哲学：\nEASTL算法遵循标准C++算法的设计原则，强调使用迭代器而非容器。 通过使用迭代器，算法可以处理容器的任意子范围，并且可以应用于非容器的数据结构（如C数组）。 灵活性和通用性：\n这种设计使得算法更加灵活和通用，用户可以轻松指定要操作的数据范围，而不需要局限于特定类型的容器。 例如，find算法接受两个迭代器参数，允许在任意范围内查找元素。 性能优化：\nEASTL算法不仅与商业库中的最佳STL算法一样优化，而且在很多情况下表现更好。 EASTL算法利用类型特征和迭代器类型进行优化，以生成更高效的代码。例如，对于整数数组或POD类型的数据，EASTL会在适当的情况下使用memcpy来代替逐对象复制，从而提高性能。 复杂性和实现难度：\nEASTL算法和相关支持代码使用了一些高级的C++技巧，尽管代码本身易于阅读，但实现和维护这些优化需要深厚的C++知识和经验。 开发和维护EASTL相比简单的库需要更多的努力和专业知识，但由于其带来的性能提升，这种权衡被认为是值得的。 总结来说，EASTL通过精心设计的算法和高级优化技术，在保持灵活性和通用性的同时，显著提升了性能。尽管这增加了开发和维护的复杂性，但最终的性能优势使其成为高性能应用的理想选择。\n智能指针 EASTL实现了以下智能指针类型：\nshared_ptr shared_array weak_ptr instrusive_ptr scoped_ptr scoped_array linked_ptr linked_array 除了linked_ptr和linked_array之外，其他智能指针都是来自Boost库中广为人知的智能指针。\n这些智能指针的行为与Boost中的非常相似，但有两个例外：\n分配器赋值：\nEASTL智能指针允许你为它们分配一个分配器。 这使得EASTL在内存分配和跟踪方面具有更多的控制权，因为Boost智能指针单方面使用全局operator new从全局堆中分配内存。 shared_ptr的删除机制：\nEASTL的shared_ptr通过模板参数实现删除，而不是通过动态分配的虚拟成员对象接口。 优点: EASTL避免了堆分配、避免了虚拟函数调用，并减少了模板类的泛滥。 缺点: 如果EASTL的shared_ptr容器持有void指针，则除非用户手动指定自定义删除器模板参数，否则无法调用其包含对象的析构函数。这种情况表明EASTL更高效但安全性较低。如果这个问题在未来成为一个问题，我们可以重新审视这个话题。 list::size is O(n) 链表类的设计决策\n当前设计：\nEASTL中的 list、slist 和 intrusive_list 类不缓存链表的大小。 获取链表大小的操作需要遍历整个链表并计数节点，因此是一个O(n)操作。 支持缓存大小的理由：\n符合C++标准：根据C++标准，std::list的size函数应为O(1)操作。 常见实现方式：许多C++标准库的实现都包含一个成员变量来缓存链表的大小。 性能优势：更新一个整数大小是非常快的，用户可以快速获取链表的大小。 用户期望：许多开发者期望size函数能够快速执行。 反对缓存大小的理由：\n增加内存开销：每个链表实例需要额外的4个字节来存储大小。 增加处理开销：每次插入或删除节点时，都需要更新大小变量，增加了少量的处理开销。 仅对size函数有益：缓存大小仅对size函数有效，对其他操作无明显改善。 intrusive_list的特殊性：对于intrusive_list，缓存大小可能会带来更多问题，因为它的节点管理机制不同。 最终决策与理由:\n性能优先：由于EASTL主要针对游戏开发，性能是最关键的因素。因此，EASTL选择不缓存链表的大小，以避免额外的内存和处理开销。 灵活性：如果用户确实需要快速的size函数，他们可以自行实现大小缓存。这样既保持了库的轻量化，又满足了特定需求。 basic_string不使用写时复制 ————以下内容只是介绍 写时复制 机制——与EASTL无关————\nCopy-on-Write（写时复制，简称COW） 是一种优化技术，广泛应用于操作系统、数据库和编程语言中，用于提高资源管理的效率。\n它通过延迟实际数据的复制操作，直到真正需要修改数据时才进行复制，从而节省内存和计算资源。\n工作原理\n共享数据：当一个对象或数据结构被复制时，初始阶段并不会创建一个新的副本。相反，原始对象和新对象会共享同一份数据。 检测写操作：如果任何一个对象尝试修改共享的数据（即执行写操作），系统会检测到这一操作，并为该对象创建一份独立的数据副本。 独立修改：在创建了新的副本之后，只有执行写操作的对象会使用这份新的副本，而其他对象仍然共享原始数据。 避免不必要的复制：如果多个对象只是读取数据而不进行任何修改，它们可以继续共享同一份数据，无需进行额外的复制操作。 1 2 3 4 string str1 = \u0026#34;Hello\u0026#34;; string str2 = str1; // 此时 str1 和 str2 共享同一份数据 str2[0] = \u0026#39;J\u0026#39;; // 尝试将第一个字符改为 \u0026#39;J\u0026#39; 写时复制机制会触发，系统会为 str2 创建一个新的副本，并在新副本上进行修改，而 str1 仍然指向原来的 \u0026quot;Hello\u0026quot;。\n对于STL标准库来说，std::string在C++11后不再支持COW机制.\n————以上内容只是介绍 写时复制 机制——与EASTL无关————\nCoW机制可以在某些情况下提高效率，但其带来的额外复杂性和开销使其在许多应用场景中并不适用。\n对于高性能需求的游戏开发环境，线程安全和内存管理的复杂性使得CoW字符串的实现面临诸多挑战。\n因此，EASTL选择不在主要的basic_string实现中使用CoW机制，而是考虑为特定需求提供一个独立的cow_string类，以便在不影响整体性能的情况下满足特定需求。\nCoW字符串的缺点包括：\n引用计数：字符串需要有一个引用计数，这增加了字符串的内存使用。 线程安全：在多线程环境下，原子操作和互斥锁非常昂贵，特别是在较弱的内存系统上，如游戏主机平台。 非const访问器函数：所有非const字符串访问器函数都需要进行共享检查，并且第一次这样的检查需要分离字符串。类似地，所有字符串赋值也需要进行共享检查。如果你在赋值之前访问了字符串，那么赋值不会导致共享字符串，因为字符串已经被分离。 字符串共享频率低：大多数情况下，字符串并不会被共享。在某些情况下，引用计数所需的总内存可能超过通过共享表示节省的内存。 cow_string类的考虑：EASTL正在考虑添加一个cow_string类。有些系统的字符串使用模式可能会从CoW共享中受益。这种功能最好保存在一个单独的字符串实现中，这样其他字符串使用不会受到影响。 配置 EASTL要求覆盖全局new\n1 2 3 4 5 6 7 8 9 10 void* __cdecl operator new[](size_t size, const char* name, int flags, unsigned debugFlags, const char* file, int line) { return new uint8_t[size]; } void* __cdecl operator new[](unsigned __int64 size, unsigned __int64 alignment, unsigned __int64 offset, char const* pName, int flags, unsigned int debugFlags, char const* file, int line) { return new uint8_t[size]; } 容器 Array Array\n实现了一个符合C++标准TR1的模板数组类。 这个类允许你像使用STL vector一样使用内置的C风格数组。 它不允许你改变其大小，因为它就像一个C内置数组一样。 我们的实现努力去除函数调用嵌套，因为这会使我们在调试构建中由于函数调用开销而难以进行性能分析。 注意，根据C++标准更新提案的要求，这里故意将其定义为一个具有公共数据的结构体（struct）。 使用示例 1 2 3 4 5 eastl::array\u0026lt;int, 5\u0026gt; arr{1,2,3,4,5}; for (auto value : arr) { cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 类型别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 template \u0026lt;typename T, size_t N = 1\u0026gt; struct array { public: typedef array\u0026lt;T, N\u0026gt; this_type; typedef T value_type; typedef value_type\u0026amp; reference; typedef const value_type\u0026amp; const_reference; typedef value_type* iterator; typedef const value_type* const_iterator; typedef eastl::reverse_iterator\u0026lt;iterator\u0026gt; reverse_iterator; typedef eastl::reverse_iterator\u0026lt;const_iterator\u0026gt; const_reverse_iterator; typedef eastl_size_t size_type; // See config.h for the definition of eastl_size_t, which defaults to size_t. typedef ptrdiff_t difference_type; } using ArrayTest = eastl::array\u0026lt;int,5\u0026gt;; // eastl::array\u0026lt;int, 5\u0026gt; using Array_this_type = ArrayTest::this_type; //BEGIN—— 类型别名 都来自于T ——BEGIN // int using Array_value_type = ArrayTest::value_type; // int\u0026amp; using Array_reference = ArrayTest::reference; //const int\u0026amp; using Array_const_reference = ArrayTest::const_reference; // int* using Array_iterator = ArrayTest::iterator; // const int* using Array_const_iterator = ArrayTest::const_iterator; // eastl::reverse_iterator\u0026lt;int*\u0026gt; using Array_reverse_iterator = ArrayTest::reverse_iterator; // eastl::reverse_iterator\u0026lt;const int*\u0026gt; using Array_const_reverse_iterator = ArrayTest::const_reverse_iterator; //END—— 类型别名 都来自于T ——END // unsigned long long using Array_size_type = ArrayTest::size_type; // long long using Array_difference_type = ArrayTest::difference_type; 聚合初始化 1 2 3 4 5 // Note that the member data is intentionally public. // This allows for aggregate initialization of the // object (e.g. array\u0026lt;int, 5\u0026gt; a = { 0, 3, 2, 4 }; ) // do not use this member directly (use data() instead). value_type mValue[N]; 注意，成员数据有意是公开的。 这允许对对象进行聚合初始化（例如，array\u0026lt;int, 5\u0026gt; a = {0,3,2,4};） 不要直接使用这个成员（使用data（）代替）。 eastl::array 维护了一个C风格数组.\n这个eastl::array类没有显式定义构造函数，是为了保持其作为聚合类型的特性，从而允许通过聚合初始化直接初始化其公有成员数组mValue。\n源码注释里: 故意不提供构造函数、析构函数或赋值操作符。\n聚合类型的定义：C++规定，满足以下条件的类或结构体是聚合类型：\n没有用户提供的构造函数（包括默认构造函数）； 所有非静态成员都是公有的； 没有基类和虚函数。 eastl::array符合这些条件，因此它是一个聚合类型。\n支持聚合初始化：聚合类型允许通过花括号列表直接初始化成员，无需定义构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct S { int a; int b; }; S s = {1, 2}; // 直接初始化公有成员a和b //-----------------// struct my_struct { int Valueint = 1; int mValue[2]; float Valuefloat = 2 ; }; my_struct s = {.mValue= {2, 3}, .Value= 2.5}; my_struct s2 = {2,{4,5},7.2}; 1 eastl::array\u0026lt;int, 5\u0026gt; arr {1, 2, 3, 4, 5}; 聚合初始化的作用：初始化列表{1, 2, 3, 4, 5}会直接赋值给mValue数组的对应元素。 底层实现：编译器将初始化列表中的值按顺序填充到mValue的每个位置，等同于： value_type mValue[5] = {1, 2, 3, 4, 5}; 如果初始化列表元素少于N，剩余元素会默认初始化（如int类型初始化为0）；\n若多于N，编译器会报错。\n**std::array**的设计一致性：C++标准库的std::array同样没有显式构造函数，依赖聚合初始化。eastl::array遵循这一设计，确保接口兼容性和性能优化。 性能优势：避免构造函数的调用开销，编译器可直接生成高效的初始化代码。 总结:\neastl::array不定义构造函数，是为了保持聚合类型的特性，允许用户通过花括号初始化列表直接填充公有成员数组mValue。\n这种设计简化了实现，提高了效率，并与标准库的std::array行为一致。\n初始化时，编译器直接将列表值按顺序赋给mValue，无需构造函数介入。\n成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int main() { eastl::array\u0026lt;int, 5\u0026gt; arr {7,2,3,4,5}; // 输出:size:5 maxsize:5 empty:false data[0]:7 cout \u0026lt;\u0026lt; format(\u0026#34;size:{} maxsize:{} empty:{} data[0]:{} \\n\u0026#34;, arr.size(),arr.max_size(),arr.empty(),arr.data()[0]); arr.data()[0] = 120; // 输出:data[0]:120 cout \u0026lt;\u0026lt; format(\u0026#34;data[0]:{} \\n\u0026#34;,arr.data()[0]); arr[0] = 64; // 输出:data[0]:64 cout \u0026lt;\u0026lt; format(\u0026#34;data[0]:{} \\n\u0026#34;,arr[0]); arr.at(0) = 32; // 输出:data[0]:32 cout \u0026lt;\u0026lt; format(\u0026#34;data[0]:{} \\n\u0026#34;,arr.at(0)); //输出 32 2 3 4 5 for (auto i : arr) { cout \u0026lt;\u0026lt; std::format(\u0026#34;{} \u0026#34;,i); } cout \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; // 输出 front:32 back:5 cout \u0026lt;\u0026lt; format(\u0026#34;front:{} back:{} \\n\u0026#34;,arr.front(),arr.back()); } 输出结果:\nsize:5 maxsize:5 empty:false data[0]:7 data[0]:120 data[0]:64 data[0]:32 32 2 3 4 5 front:32 back:5 Vector Vector\n使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int main() { eastl::vector\u0026lt;int\u0026gt; vec; vec.push_back(127); vec.push_back(2); vec.push_back(3); vec.push_back(355); for (auto\u0026amp; i : vec) { // 输出 127 2 3 355 cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; auto begin = vec.begin(); auto end = vec.end()-1; // begin:127 end:355 cout \u0026lt;\u0026lt; \u0026#34;begin:\u0026#34; \u0026lt;\u0026lt; *begin \u0026lt;\u0026lt;\u0026#34; end:\u0026#34;\u0026lt;\u0026lt;*end \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; //size:4 cout\u0026lt;\u0026lt; format(\u0026#34;size:{} \\n\u0026#34;,vec.size()); //capacity:4 rbegin:355 rend:127 cout\u0026lt;\u0026lt; format(\u0026#34;capacity:{} rbegin:{} rend:{} \\n\u0026#34;,vec.capacity(),*vec.rbegin(),*(vec.rend()-1)); vec.reserve(10); //size:4 capacity:10 cout \u0026lt;\u0026lt; format(\u0026#34;size:{} capacity:{}\\n\u0026#34;,vec.size(),vec.capacity()); //begin:127 end:355 cout \u0026lt;\u0026lt; format(\u0026#34;begin:{} end:{} \\n\u0026#34;,*vec.begin(),*(vec.end()-1)); } // 输出： // 127 2 3 355 // begin:127 end:355 // size:4 // capacity:4 rbegin:355 rend:127 // size:4 capacity:10 // begin:127 end:355 size 当前元素个数 capacity 当前容量 vec容量为10，但只有3个元素，那么size = 3,capacity = 10 扩容机制 下图是stl::vector，但是算法和EASTL是一样的.可作为参考.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;T, Allocator\u0026gt;::size() const EA_NOEXCEPT { return (size_type)(mpEnd - mpBegin); } vector\u0026lt;T, Allocator\u0026gt;::capacity() const EA_NOEXCEPT { return (size_type)(internalCapacityPtr() - mpBegin); } //---------------------------// eastl::compressed_pair\u0026lt;T*, allocator_type\u0026gt; mCapacityAllocator; T*\u0026amp; internalCapacityPtr() EA_NOEXCEPT { return mCapacityAllocator.first(); } T* const\u0026amp; internalCapacityPtr() const EA_NOEXCEPT { return mCapacityAllocator.first(); } size = end - begin.\n例如:vector里面有5个元素: 1,2,3,4,5 . begin 指向1 ， end指向5的下一个位置.\nCapacity = 整个空间 - begin. 即为vector的整个空间容量.\n**internalCapacityPtr()**：返回指向当前分配的内存块的容量结束位置的指针。\nvector 创建时size=0，capacity=0\nvector 有一个元素，触发扩容，size=1,capacity=1\nvector 当后续再插入元素 空间不够时，整个空间扩容2倍.\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { eastl::vector\u0026lt;int\u0026gt; vec; cout \u0026lt;\u0026lt; format(\u0026#34;size:{} capacity:{}\\n\u0026#34;,vec.size(),vec.capacity()); for (int i = 0 ; i \u0026lt; 18 ; i++) { vec.push_back(i); cout \u0026lt;\u0026lt; format(\u0026#34;AddValue:{} size:{} capacity:{}\\n\u0026#34;,i,vec.size(),vec.capacity()); } cout \u0026lt;\u0026lt; format(\u0026#34;front:{} back:{} \\n\u0026#34;,vec.front(),vec.back()); } 输出:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 size:0 capacity:0 AddValue:0 size:1 capacity:1 AddValue:1 size:2 capacity:2 AddValue:2 size:3 capacity:4 AddValue:3 size:4 capacity:4 AddValue:4 size:5 capacity:8 AddValue:5 size:6 capacity:8 AddValue:6 size:7 capacity:8 AddValue:7 size:8 capacity:8 AddValue:8 size:9 capacity:16 AddValue:9 size:10 capacity:16 AddValue:10 size:11 capacity:16 AddValue:11 size:12 capacity:16 AddValue:12 size:13 capacity:16 AddValue:13 size:14 capacity:16 AddValue:14 size:15 capacity:16 AddValue:15 size:16 capacity:16 AddValue:16 size:17 capacity:32 AddValue:17 size:18 capacity:32 front:0 back:17 容量不够时 扩容2倍.\n插入与扩容\n1 2 3 4 5 6 7 inline void vector\u0026lt;T, Allocator\u0026gt;::push_back(const value_type\u0026amp; value) { if(mpEnd \u0026lt; internalCapacityPtr()) ::new((void*)mpEnd++) value_type(value); else DoInsertValueEnd(value); } **mpEnd**：指向当前 vector 中最后一个已使用的元素之后的位置。 **internalCapacityPtr()**：返回指向当前分配的内存块的容量结束位置的指针。 该条件检查当前 vector 是否有足够的空间来容纳新元素。\n如果 mpEnd 小于 internalCapacityPtr()，则表示当前容量足够，可以直接插入新元素。\n::new((void*)mpEnd++) value_type(value); 放置式 new 操作符，用于在指定地址上构造对象。这里使用的是 mpEnd 所指向的地址，并且在构造后将 mpEnd 向前移动一位。\nDoInsertValueEnd(value); 当前容量不足时，调用此函数处理插入操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;typename T, typename Allocator\u0026gt; template\u0026lt;typename... Args\u0026gt; void vector\u0026lt;T, Allocator\u0026gt;::DoInsertValueEnd(Args\u0026amp;\u0026amp;... args) { const size_type nPrevSize = size_type(mpEnd - mpBegin); const size_type nNewSize = GetNewCapacity(nPrevSize); pointer const pNewData = DoAllocate(nNewSize); pointer pNewEnd = eastl::uninitialized_move(mpBegin, mpEnd, pNewData); ::new((void*)pNewEnd) value_type(eastl::forward\u0026lt;Args\u0026gt;(args)...); pNewEnd++; eastl::destruct(mpBegin, mpEnd); DoFree(mpBegin, (size_type)(internalCapacityPtr() - mpBegin)); mpBegin = pNewData; mpEnd = pNewEnd; internalCapacityPtr() = pNewData + nNewSize; } template \u0026lt;typename T, typename Allocator\u0026gt; inline typename VectorBase\u0026lt;T, Allocator\u0026gt;::size_type VectorBase\u0026lt;T, Allocator\u0026gt;::GetNewCapacity(size_type currentCapacity) { // This needs to return a value of at least currentCapacity and at least 1. return (currentCapacity \u0026gt; 0) ? (2 * currentCapacity) : 1; } GetNewCapacity 如果当前容量为0，则扩容为1，其它情况下都扩容2倍.\n1. 计算当前大小与新容量\n当前大小：通过 mpEnd - mpBegin 获取当前元素数量。 新容量：调用 GetNewCapacity(nPrevSize) 确定扩容后的新容量（通常按固定策略，如翻倍）。 2. 分配新内存\n使用 DoAllocate(nNewSize) 分配大小为 nNewSize 的新内存块 pNewData。 3. 迁移旧数据\n移动构造：通过 eastl::uninitialized_move 将旧数据移动到新内存。这一步调用元素的移动构造函数，转移资源所有权。 构造新元素：在新内存末尾（pNewEnd）使用 placement new 和完美转发 Args\u0026amp;\u0026amp;... 直接构造新元素，避免额外拷贝。 4. 清理旧内存\n析构旧元素：调用 eastl::destruct 析构旧内存中的元素（移动后的源对象仍需析构，但资源已转移）。 释放旧内存：通过 DoFree 释放原内存块，需传入原指针和容量（确保内存正确释放）。 5. 更新内部指针\n**mpBegin**：指向新内存起始位置。 **mpEnd**：指向新内存的末尾（即最后一个元素的下一个位置）。 **internalCapacityPtr()**：更新为新内存的容量终点（pNewData + nNewSize）。 右值版本 调用移动构造\n1 2 3 4 5 6 7 8 template \u0026lt;typename T, typename Allocator\u0026gt; inline void vector\u0026lt;T, Allocator\u0026gt;::push_back(value_type\u0026amp;\u0026amp; value) { if (mpEnd \u0026lt; internalCapacityPtr()) ::new((void*)mpEnd++) value_type(eastl::move(value)); else DoInsertValueEnd(eastl::move(value)); } 右值引用：如果传递的是右值引用（rvalue reference），则会调用移动构造函数。 左值引用：如果传递的是左值引用（lvalue reference），则会调用拷贝构造函数。 list 该链表与 std::list 的主要区别如下：\n缺少部分不常用函数：\n这个链表没有实现 std::list 中一些不太常用的函数。任何需要的函数可以在以后添加。\n扩展函数提升性能：\n链表包含了一些扩展函数，可以提高性能。\n支持对象对齐要求：\n链表可以包含具有对齐要求的对象，而 std::list 在不进行一些繁琐且非便携的操作时无法做到这一点。\n针对目标平台的优化：\n链表包含了一些在标准库供应商提供的 STL 实现中不存在的优化。\n本地支持调试内存命名：\n链表本地支持调试内存命名。\n**size()** 函数的时间复杂度：\n默认情况下，list::size() 不是一个常数时间函数（类似于某些标准实现如 STLPort 和 SGI STL 中的 list::size），但与 Dinkumware 和 Metrowerks 中的 list 不同。可以通过设置 EASTL_LIST_SIZE_CACHE 选项来改变这一行为。\n提供可移植节点定义：\n链表提供了保证可移植的节点定义，允许用户编写自定义固定大小的节点分配器，并确保其可移植性。\n易读、调试和可视化：\n链表更容易阅读、调试和可视化。\n适应无异常处理环境：\n链表能够适应没有异常处理的环境，这在控制台或嵌入式环境中有时是必要的。\n减少深层嵌套函数调用：\n链表减少了深层嵌套函数调用，并允许用户在调试构建中启用强制内联，以减少代码膨胀。\n不保留成员变量 **size**：\n链表不保留成员变量 size。这意味着链表比 std::list 更小（取决于 std::list 的实现），并且对于大多数操作来说更快。然而，list::size 函数的速度较慢。\n**size_type** 定义为 **eastl_size_t**：\nlist::size_type 定义为 eastl_size_t 而不是 size_t，以节省内存并在 64 位系统上运行更快。\nstring string\n实现了一个 basic_string 类，类似于 C++ 标准库中的 std::basic_string。basic_string 和 std::basic_string 的主要区别如下：\n扩展函数：basic_string 包含一些扩展函数，可以提高性能。 易用性：basic_string 包含一些扩展函数，使使用更加方便，例如成员 sprintf 函数和成员 tolower/toupper 函数。 调试内存命名：basic_string 本地支持调试内存命名。 可读性和调试：basic_string 更容易阅读、调试和可视化。 内部手动扩展基本函数：如 begin()、size() 等，以改进调试性能和优化器的成功率。 无异常处理环境适应性：basic_string 能够适应没有异常处理的环境，这在控制台或嵌入式环境中有时是必要的。 减少深层嵌套函数调用：允许用户在调试构建中启用强制内联，以减少代码膨胀。 不使用字符特性（char traits）：因此，EASTL 假设字符串将包含字符而不是像小部件这样的奇特事物。至少，basic_string 假设 value_type 是一个 POD（Plain Old Data）类型。 basic_string::size_type 定义为 **eastl_size_t**：而不是 size_t，以节省内存并在 64 位系统上运行更快。 数据保证连续：basic_string 数据保证是连续的。 数据保证以零终止：c_str() 函数保证返回与 data() 相同的指针，该指针保证与 \u0026amp;string[0] 的值相同。 set_capacity() 函数：释放多余的容量。在 std::basic_string 中唯一能做到这一点的方法是通过晦涩的技巧，例如使用 basic_string\u0026lt;char\u0026gt;(x).swap(x);。 force_size() 函数：单方面移动字符串结束位置（mpEnd）到给定位置。这对于用户通过外部方式（如 C 的 strcpy 或 sprintf）写入字符串时非常有用。 **substr() 函数偏离标准：返回一个带有此 get_allocator() 复制的新字符串。 basic_string不使用写时复制\nSSO优化 空结构体，用作标记类型，帮助区分不同的构造函数重载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // CtorDoNotInitialize 存在的原因是我们可以创建一个仅分配内存但不进行初始化的构造函数， // 并且不会与其他任何构造函数声明发生冲突。 struct CtorDoNotInitialize {}; // CtorSprintf 存在的原因是我们可以创建一个接受 printf 风格参数的构造函数， // 并且不会与其他任何构造函数声明发生冲突。 struct CtorSprintf {}; // CtorConvert 存在的原因是我们可以有一个实现字符串编码转换的构造函数， // 例如在 UCS2 char16_t 和 UTF8 char8_t 之间进行转换。 struct CtorConvert {}; // 用于确定我们是否处于 SSO（Short String Optimization，短字符串优化）或堆模式的掩码 // 小端序使用最高有效位（MSB） // 检测是否使用堆存储字符串。 static EA_CONSTEXPR_OR_CONST size_type kHeapMask = ~(size_type(~size_type(0)) \u0026gt;\u0026gt; 1); // 检测是否使用短字符串优化（SSO）。 static EA_CONSTEXPR_OR_CONST size_type kSSOMask = 0x80; // 当字符串数据从分配器获取时，内存视图的结构。 struct HeapLayout { value_type* mpBegin; // 字符串的起始位置。 size_type mnSize; // 字符串的大小。当前字符串中的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 size_type mnCapacity; // 字符串的容量。字符串可以容纳的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 }; SSO优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 短字符优化 //SSO 是一种常见的优化技术，用于在小字符串的情况下避免动态内存分配。 //通常，字符串类会在对象内部预留一小块缓冲区（称为 SSO 缓冲区），用于存储短字符串。 template \u0026lt;typename CharT, size_t = sizeof(CharT)\u0026gt; struct SSOPadding { //CharT：表示字符类型（如 char, wchar_t, char16_t, char32_t 等）。 //size_t：默认为 sizeof(CharT)，用于区分不同的字符类型。 //padding数组用于填充，以确保结构体的大小与字符类型的大小对齐。 char padding[sizeof(CharT) - sizeof(char)]; }; template \u0026lt;typename CharT\u0026gt; struct SSOPadding\u0026lt;CharT, 1\u0026gt; { // 模板特化以移除填充结构，避免零长度数组警告 // 同时，这也允许我们利用空基类优化（empty-base-class optimization）。 // 适用于 CharT 的大小为 1 字节的情况（例如 char 类型）。 }; // 当字符串数据能够在本地存储（无需堆分配）时的内存视图。 struct SSOLayout { // SSO_CAPACITY 计算公式：(HeapLayout 的大小 - 1 字节) / 字符类型的大小 static EA_CONSTEXPR_OR_CONST size_type SSO_CAPACITY = (sizeof(HeapLayout) - sizeof(char)) / sizeof(value_type); // mnSize 必须对应于 HeapLayout.mnCapacity 的最后一个字节，因此我们不希望编译器在 mnSize 后插入填充（如果 sizeof(value_type) != 1）； // 同时确保两种布局具有相同的大小。 struct SSOSize : SSOPadding\u0026lt;value_type\u0026gt; { char mnRemainingSize; // 剩余大小字段 }; value_type mData[SSO_CAPACITY]; // 用于存储字符串数据的本地缓冲区。 SSOSize mRemainingSizeField; // 剩余大小字段 }; HeapLayout 结构体：描述字符串在堆上的内存布局，包含字符串的起始位置、大小和容量。\nSSOLayout 结构体：用于描述字符串在本地缓冲区中的内存布局，适用于短字符串优化（SSO）。它包含一个本地缓冲区 mData 和一个剩余大小字段 mRemainingSizeField。\nSSO_CAPACITY：计算本地缓冲区的容量，确保能够存储短字符串而不需动态内存分配。\n实际应用：通过 SSOLayout 结构体，可以有效地管理短字符串的内存布局，减少不必要的动态内存分配，提高性能和效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // This view of memory is a utility structure for easy copying of the string data. //这个内存视图是一个实用结构，便于复制字符串数据。 struct RawLayout { //大小是 sizeof(HeapLayout)，这意味着它可以容纳一个 HeapLayout 结构体的所有数据。 char mBuffer[sizeof(HeapLayout)]; }; // 当字符串数据从分配器获取时，内存视图的结构。 struct HeapLayout { value_type* mpBegin; // 字符串的起始位置。 size_type mnSize; // 字符串的大小。当前字符串中的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 size_type mnCapacity; // 字符串的容量。字符串可以容纳的字符数，不包括结尾的 \u0026#39;0\u0026#39;。 }; 1 2 3 // 这实现了“短字符串优化”或 SSO。SSO 重用了字符串类现有的存储来保存足够短的字符串数据，从而避免了堆分配。 // 存储在字符串 SSO 缓冲区中的字符数量是可变的，并且取决于字符串字符的宽度。 // 此实现更倾向于保持一致的字符串大小，而不是增加字符串本地数据的大小以容纳一致数量的字符，尽管字符宽度不同。 Layout\n统一管理字符串存储： 使用联合体来管理不同类型的内存布局，使得字符串可以在堆上或本地缓冲区中存储，具体取决于字符串的长度。 通过 IsHeap() 和 IsSSO() 方法判断当前使用的是堆分配还是 SSO 缓冲区。 提供一致的接口： 提供了多种方法来获取和设置字符串的各种属性（如大小、容量、指针等），无论字符串是存储在堆上还是 SSO 缓冲区中，都能通过统一的接口进行操作。 支持拷贝和移动操作： 提供了拷贝构造函数、赋值运算符以及移动构造函数和赋值运算符，确保对象可以安全地进行拷贝和移动操作。 使用 Copy 和 Move 方法来处理不同情况下的数据复制和移动。 灵活的初始化和重置： 默认情况下，字符串以 SSO 模式初始化（ResetToSSO 方法）。 提供了 Swap 方法用于交换两个 Layout 对象的内容。 Layout 成员函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 构造与赋值： 构造函数：默认构造函数将字符串初始化为 SSO 模式。拷贝构造函数和移动构造函数分别用于拷贝和移动对象。 赋值运算符：提供了拷贝赋值和移动赋值运算符。 状态检查： IsHeap()：检查当前是否使用堆分配。 IsSSO()：检查当前是否使用 SSO 缓冲区。 获取指针： SSOBufferPtr()：获取 SSO 缓冲区的指针。 HeapBeginPtr()：获取堆分配字符串的起始指针。 BeginPtr()：根据当前模式返回相应的起始指针。 EndPtr()：根据当前模式返回相应的结束指针（指向字符串末尾的空字符）。 CapacityPtr()：根据当前模式返回相应的容量指针（指向缓冲区末尾）。 获取和设置大小与容量： GetSSOSize()：获取 SSO 缓冲区中的字符串大小。 GetHeapSize()：获取堆分配字符串的大小。 GetSize()：根据当前模式返回相应的字符串大小。 SetSSOSize()：设置 SSO 缓冲区中的字符串大小。 SetHeapSize()：设置堆分配字符串的大小。 SetSize()：根据当前模式设置相应的字符串大小。 SetHeapCapacity()：设置堆分配字符串的容量。 GetHeapCapacity()：获取堆分配字符串的容量。 拷贝与移动： Copy()：实现深拷贝。 Move()：实现移动操作。 Swap()：交换两个 Layout 对象的内容。 重置： ResetToSSO()：将字符串重置为 SSO 模式，并将其内容清空。 总结\nLayout 结构体：通过联合体管理不同类型的内存布局（堆分配、SSO 缓冲区和原始数据视图），实现了短字符串优化（SSO）。 主要功能：提供了一致的接口来获取和设置字符串的各种属性，支持拷贝和移动操作，并且可以根据需要在堆分配和 SSO 缓冲区之间切换。 实际应用：通过这种设计，可以有效地减少不必要的动态内存分配，提高性能和效率，同时保持代码的简洁性和可靠性。 在 Layout 结构体中，字符串可以存储在两个不同的地方：\nSSO 缓冲区（Short String Optimization Buffer）： 当字符串长度较短时，字符串数据会被存储在 SSOLayout 中的本地缓冲区 mData 中。 这种情况下，字符串不会占用额外的堆内存。 堆分配（Heap Allocation）： 当字符串长度超过 SSO 缓冲区的容量时，字符串数据会被存储在堆上，具体通过 HeapLayout 结构体中的指针 mpBegin 来指向堆上的内存块。 获取不同版本的指针\n1 2 3 4 5 6 7 8 9 10 11 12 inline value_type* BeginPtr() EA_NOEXCEPT { return IsHeap() ? HeapBeginPtr() : SSOBeginPtr(); } inline const value_type* BeginPtr() const EA_NOEXCEPT { return IsHeap() ? HeapBeginPtr() : SSOBeginPtr(); } inline value_type* HeapEndPtr() EA_NOEXCEPT { return heap.mpBegin + heap.mnSize; } inline const value_type* HeapEndPtr() const EA_NOEXCEPT { return heap.mpBegin + heap.mnSize; } string 成员函数 cppreference-string\nEASTL的很多函数都和STL中的相同.\nbasic_string 类提供了多种构造函数，以支持不同场景下的字符串初始化。\n默认构造：创建空字符串。 带分配器的构造：允许指定分配器。 部分复制构造：从现有字符串中复制部分内容。 带长度和数据的构造：使用指定长度的数据初始化字符串。 C 字符串构造：使用以空字符结尾的 C 字符串初始化。 填充构造：创建包含多个相同字符的字符串。 拷贝构造：创建现有字符串的副本。 带分配器的拷贝构造：创建现有字符串的副本，并使用指定分配器。 范围构造：使用指定范围的数据初始化字符串。 不初始化构造：创建未初始化的字符串对象。 格式化构造：使用格式化字符串初始化。 初始化列表构造：使用初始化列表初始化。 移动构造：使用右值引用移动构造。 带分配器的移动构造：使用右值引用移动构造，并使用指定分配器。 视图构造：使用字符串视图初始化。 部分视图构造：使用字符串视图中的部分内容初始化。 模板转换构造：支持不同字符类型的转换构造。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Implicit conversion operator //这个隐式转换操作符允许将 basic_string 对象隐式转换为 basic_string_view\u0026lt;T\u0026gt; 类型的对象。 operator basic_string_view\u0026lt;T\u0026gt;() const EA_NOEXCEPT; //---------------// void printview(eastl::string_view sv) { cout \u0026lt;\u0026lt; sv.data() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { eastl::string s = \u0026#34;Hello World\u0026#34;; printview(s); } void swap(this_type\u0026amp; x)\n交换两个 basic_string 对象的内容。考虑了分配器的兼容性，以确保高效地交换内容，同时避免不必要的内存分配和拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T, typename Allocator\u0026gt; void basic_string\u0026lt;T, Allocator\u0026gt;::swap(this_type\u0026amp; x) { // If allocators are equivalent... if(get_allocator() == x.get_allocator() || (internalLayout().IsSSO() \u0026amp;\u0026amp; x.internalLayout().IsSSO())) { // We leave mAllocator as-is. eastl::swap(internalLayout(), x.internalLayout()); } else // else swap the contents. { const this_type temp(*this); // Can\u0026#39;t call eastl::swap because that would *this = x; // itself call this member swap function. x = temp; } } 目的：交换两个 basic_string 对象的内容。 实现方式 如果分配器相同或两者都使用 SSO 缓冲区，则直接交换内部布局。 如果分配器不同，则通过创建临时对象的方式进行交换。 优点 当分配器兼容时，交换操作非常高效，因为它只交换一些指针和状态信息，而不涉及实际数据的拷贝。 即使分配器不兼容，也能保证正确的交换行为。 assign\n这个函数提供了一种方式来安全地将一个basic_string实例的内容复制到另一个实例中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const eastl::string\u0026amp; sv) { os \u0026lt;\u0026lt; sv.data(); return os; } int main() { eastl::string s; // assign(size_type count, CharT ch) s.assign(4, \u0026#39;=\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;====\u0026#34; eastl::string const c(\u0026#34;Exemplary\u0026#34;); // assign(const basic_string\u0026amp; str) s.assign(c); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; == \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; // \u0026#34;Exemplary == Exemplary\u0026#34; // assign(const basic_string\u0026amp; str, size_type pos, size_type count) s.assign(c, 0, c.length() - 1); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;Exemplar\u0026#34;; // assign(basic_string\u0026amp;\u0026amp; str) s.assign(eastl::string(\u0026#34;C++ by \u0026#34;) + \u0026#34;example\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C++ by example\u0026#34; // assign(const CharT* s, size_type count) s.assign(\u0026#34;C-style string\u0026#34;, 7); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style\u0026#34; // assign(const CharT* s) s.assign(\u0026#34;C-style\\0string\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style\u0026#34; char mutable_c_str[] = \u0026#34;C-style string\u0026#34;; // assign(InputIt first, InputIt last) s.assign(eastl::begin(mutable_c_str), eastl::end(mutable_c_str) - 1); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style string\u0026#34; // assign(::initializer_list\u0026lt;CharT\u0026gt; ilist) s.assign({\u0026#39;C\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;}); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // \u0026#34;C-style\u0026#34; } 输出\n1 2 3 4 5 6 7 8 ==== Exemplary == Exemplary Exemplar C++ by example C-style C-style C-style string C-style append\n追加多个字符或整个字符串\n使用示例\n1 2 3 4 eastl::string s = \u0026#34;hello\u0026#34;; eastl::string s2 = \u0026#34;world\u0026#34;; s.append(s2); s.append(\u0026#34;ddd\u0026#34;); 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 template \u0026lt;typename T, typename Allocator\u0026gt; basic_string\u0026lt;T, Allocator\u0026gt;\u0026amp; basic_string\u0026lt;T, Allocator\u0026gt;::append(const value_type* pBegin, const value_type* pEnd) { //如果pBegin和pEnd不同，则说明有字符需要追加。 if(pBegin != pEnd) { //当前字符串的大小 const size_type nOldSize = internalLayout().GetSize(); //要追加的字符数 const size_type n = (size_type)(pEnd - pBegin); //当前字符串的容量 const size_type nCapacity = capacity(); //追加后的新字符串大小 const size_type nNewSize = nOldSize + n; //如果新的字符串大小超过当前容量，则需要重新分配内存。 if(nNewSize \u0026gt; nCapacity) { //计算新的容量 const size_type nLength = GetNewCapacity(nCapacity, nNewSize - nCapacity); //分配新内存 pointer pNewBegin = DoAllocate(nLength + 1); //将现有字符和要追加的字符复制到新分配的内存中 pointer pNewEnd = CharStringUninitializedCopy(internalLayout().BeginPtr(), internalLayout().EndPtr(), pNewBegin); pNewEnd = CharStringUninitializedCopy(pBegin, pEnd, pNewEnd); //标记字符串的结束位置 *pNewEnd = 0; //设置新的开始指针、容量和大小，并释放旧的内存 DeallocateSelf(); internalLayout().SetHeapBeginPtr(pNewBegin); internalLayout().SetHeapCapacity(nLength); internalLayout().SetHeapSize(nNewSize); } else { //如果新字符串大小不超过当前容量，则直接在现有内存中追加字符，并更新字符串大小 pointer pNewEnd = CharStringUninitializedCopy(pBegin, pEnd, internalLayout().EndPtr()); //标记字符串的结束位置 *pNewEnd = 0; internalLayout().SetSize(nNewSize); } } return *this; } push_back\n追加单个字符\n使用示例\n1 2 eastl::string s = \u0026#34;hell\u0026#34;; s.push_back(\u0026#39;o\u0026#39;); 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template \u0026lt;typename T, typename Allocator\u0026gt; inline void basic_string\u0026lt;T, Allocator\u0026gt;::push_back(value_type c) { //调用 append(size_type n, value_type c) 方法， //其中 n 是要追加的字符数（在这里是1），c 是要追加的字符。 append((size_type)1, c); } template \u0026lt;typename T, typename Allocator\u0026gt; basic_string\u0026lt;T, Allocator\u0026gt;\u0026amp; basic_string\u0026lt;T, Allocator\u0026gt;::append(size_type n, value_type c) { //检查是否需要追加 if (n \u0026gt; 0) { const size_type nSize = internalLayout().GetSize(); const size_type nCapacity = capacity(); //如果新的大小超过当前容量，则调用 reserve 方法重新分配内存 if((nSize + n) \u0026gt; nCapacity) reserve(GetNewCapacity(nCapacity, (nSize + n) - nCapacity)); //填充新字符 pointer pNewEnd = CharStringUninitializedFillN(internalLayout().EndPtr(), n, c); //标记字符串的结束位置 *pNewEnd = 0; //更新字符串的实际大小 internalLayout().SetSize(nSize + n); } return *this; } find、replace\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { eastl::string s = \u0026#34;hellohello\u0026#34;; eastl::string s2 = \u0026#34;world\u0026#34;; s.append(s2); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; eastl_size_t first = s.find(\u0026#34;hello\u0026#34;); s.replace(first, 5, \u0026#34;HELLO\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 输出\n1 2 hellohelloworld HELLOhelloworld find\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T, typename Allocator\u0026gt; typename basic_string\u0026lt;T, Allocator\u0026gt;::size_type basic_string\u0026lt;T, Allocator\u0026gt;::find(const value_type* p, size_type position, size_type n) const { if(EASTL_LIKELY(((npos - n) \u0026gt;= position) \u0026amp;\u0026amp; (position + n) \u0026lt;= internalLayout().GetSize())) // If the range is valid... { const value_type* const pTemp = eastl::search(internalLayout().BeginPtr() + position, internalLayout().EndPtr(), p, p + n); if((pTemp != internalLayout().EndPtr()) || (n == 0)) return (size_type)(pTemp - internalLayout().BeginPtr()); } return npos; } 查找范围的有效性检查： 确保 position 和 n 的组合不会导致溢出，并且查找范围在当前字符串的有效范围内。 使用 eastl::search 进行查找： 在指定范围内查找子串，eastl::search 是一个标准算法，用于在一个范围内查找另一个范围的首次出现。 判断查找结果： 如果找到匹配的子串，计算并返回其起始位置。 如果查找空子串或未找到匹配的子串，返回 npos。 HashTable 哈希表(Hash Table)，也称为散列表，是一种数据结构，它通过哈希函数将键映射到表中的一个位置来加速查找操作。哈希表可以在平均情况下以常数时间复杂度 O(1）进行插入、删除和查找操作，这使得它们在许多应用场景中非常高效。\n哈希表的基本概念\n哈希函数：用于将键转换为数组索引的函数。理想情况下，哈希函数应均匀分布键，以避免冲突。 桶（Bucket）：哈希表中的每个位置通常称为桶，每个桶可以存储一个或多个键值对。 冲突解决方法: 链地址法（Separate Chaining）：每个桶是一个链表（或其他数据结构），用于存储具有相同哈希值的所有元素。 开放寻址法（Open Addressing）：当发生冲突时，使用某种策略找到另一个空桶来存储元素。常见的策略包括线性探测、二次探测和双重哈希。 哈希表的主要操作\n插入（Insert）：将一个新的键值对插入哈希表中。 查找（Find/Search）：根据键查找对应的值。 删除（Delete）：从哈希表中删除指定的键值对。 1 2 3 4 5 6 7 8 9 10 11 12 13 插入操作 1.使用哈希函数计算键的哈希值。 2.将哈希值映射到哈希表的一个桶。 3.如果该桶为空，则直接插入键值对；如果该桶已占用，则使用冲突解决方法处理。 查找操作 1.使用哈希函数计算键的哈希值。 2.找到对应的桶，并在桶内查找是否存在该键。 3.如果存在，则返回对应的值；否则返回未找到的结果。 删除操作 1.使用哈希函数计算键的哈希值。 2.找到对应的桶，并在桶内查找并删除该键值对。 优点\n高效查找：在理想情况下，哈希表的查找、插入和删除操作的时间复杂度均为 O(1)。 灵活性：支持多种数据类型的键值对。 可扩展性：可以通过调整桶的数量和负载因子来优化性能。 缺点\n冲突处理：尽管哈希函数设计得再好，也无法完全避免冲突。冲突处理会影响性能。 空间开销：为了减少冲突，通常需要预留更多的空间，导致空间利用率较低。 扩容问题：当哈希表接近满载时，需要进行扩容操作，这涉及重新计算所有元素的哈希值并重新分配位置，代价较高。 哈希表广泛应用于各种算法和系统中，以下是几个典型的应用场景：\n字典和集合：如 C++ STL 中的 unordered_map 和 unordered_set，Python 中的 dict 和 set。 缓存机制：如 LRU 缓存（Least Recently Used Cache）。 去重和计数：例如统计文档中单词出现的频率。 数据库索引：提高查询效率。 编译器符号表：管理变量名和函数名等符号信息。 hash_set 实现了一个 hash_set，这是一个哈希唯一项容器。查找操作的时间复杂度为 O(1)（即非常快），但容器不是排序的。\n需要注意的是，查找操作只有在哈希表分布良好（没有冲突）时才是 O(1)。\n当表变得越来越差时，查找操作的时间复杂度会接近 O(n)。\n运用set,为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是 hash table,都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable 没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有。\nset_max_load_factor\n如果你想让哈希表永远不会增加其桶的使用量，可以调用 set_max_load_factor 并传入一个非常高的值，例如 100000.f。\nfind_as\n为了支持能够在字符串哈希表中通过字符指针高效查找的功能（即不需要将字符指针转换为字符串对象），我们提供了 find_as 函数。这个函数允许你使用不同于哈希表键类型的键进行查找。\n1 2 3 4 5 6 7 // 示例 1：使用默认哈希和比较函数 hash_set\u0026lt;string\u0026gt; hashSet; auto i = hashSet.find_as(\u0026#34;hello\u0026#34;); // 使用默认哈希和比较函数 // 示例 2：显式指定哈希和比较函数（省略命名空间以简化） hash_set\u0026lt;string\u0026gt; hashSet; auto i = hashSet.find_as(\u0026#34;hello\u0026#34;, hash\u0026lt;char*\u0026gt;(), equal_to\u0026lt;\u0026gt;()); 智能指针 智能指针（Smart Pointer）是 C++ 中用于管理动态分配对象生命周期的一种工具。\n通过封装原始指针，并利用 RAII 机制自动管理内存的分配和释放，从而避免常见的内存泄漏问题。\nRAII 机制 资源获取即初始化：在对象创建时获取资源，在对象销毁时释放资源。 作用域控制：智能指针在其作用域结束时自动释放所管理的对象，确保资源不会被遗忘或泄露。 自动内存管理 自动释放：智能指针会在其生命周期结束时自动释放所管理的对象，减少手动管理内存的复杂性和出错的可能性。 防止悬挂指针：智能指针能够检测到对象是否仍然被引用，从而防止悬挂指针的问题。 引用计数 共享所有权：多个智能指针可以共享同一个对象的所有权，只有当最后一个指向该对象的智能指针被销毁时，才会释放该对象。 线程安全：某些智能指针（如 std::shared_ptr）提供了线程安全的引用计数机制。 独占所有权 单一所有权：某些智能指针（如 std::unique_ptr）确保只有一个指针拥有某个对象的所有权，防止多个指针同时管理同一对象。 unique_ptr 独占所有权：一个 std::unique_ptr 对象只能指向一个对象，不能进行拷贝操作，但可以通过移动语义转移所有权。 轻量级：相比于 std::shared_ptr，std::unique_ptr 更加轻量，因为它不涉及引用计数。 更具体地说，unique_ptr 模板类存储一个指向动态分配对象的指针。该对象在 unique_ptr 的析构函数中自动删除，或者可以通过 unique_ptr::reset 函数手动删除。\n使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Object { public: int A = 0; Object(int v) : A(v) { cout\u0026lt;\u0026lt;\u0026#34;CreateObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } ~Object() { cout\u0026lt;\u0026lt;\u0026#34;DestroyObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; int main() { { using ObjectPtr = eastl::unique_ptr\u0026lt;Object\u0026gt;; Object* obj1 = new Object(100); ObjectPtr objpt1(obj1); ObjectPtr objpt2 = eastl::make_unique\u0026lt;Object\u0026gt;(200); cout \u0026lt;\u0026lt; format(\u0026#34;objpt1: {} objpt2:{} \\n\u0026#34;, objpt1-\u0026gt;A, objpt2-\u0026gt;A); // 交换 objpt1 和 objpt2 保存的指针 objpt1.swap(objpt2); cout \u0026lt;\u0026lt;\u0026#34;----------objpt2.reset()--------------\\n\u0026#34;; //reset - delete保存的指针. //调用objpt2保存的Object对象的析构函数. //然后，objpt2保存的指针是空指针. objpt2.reset(); cout \u0026lt;\u0026lt;\u0026#34;----------Move Test--------------\\n\u0026#34;; // 把ptr1的指针交给ptr2， // ptr1指针为空，ptr2拥有原先ptr1的指针. // 也可以说 ptr2接管了ptr1的指针. ObjectPtr ptr1(new Object(400)); cout \u0026lt;\u0026lt; format(\u0026#34;ptr1: {}\\n\u0026#34;, ptr1-\u0026gt;A); ObjectPtr ptr2 = eastl::move(ptr1); cout \u0026lt;\u0026lt; \u0026#34;move ptr1 ---\u0026gt; ptr2 \\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;ptr2: {}\\n\u0026#34;, ptr2-\u0026gt;A); if (auto ptr1object = ptr1.get()) { cout \u0026lt;\u0026lt; ptr1object-\u0026gt;A \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { cout \u0026lt;\u0026lt; \u0026#34;ptr1 is null\\n\u0026#34;; } cout \u0026lt;\u0026lt;\u0026#34;----------ptr2.reset(new Object(5000))--------------\\n\u0026#34;; ptr2.reset(new Object(5000)); cout \u0026lt;\u0026lt;\u0026#34;----------Main End--------------\\n\u0026#34;; } while (true) { } } 输出:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 CreateObj 100 CreateObj 200 objpt1: 100 objpt2:200 ----------objpt2.reset()-------------- DestroyObj 100 ----------Move Test-------------- CreateObj 400 ptr1: 400 move ptr1 ---\u0026gt; ptr2 ptr2: 400 ptr1 is null ----------ptr2.reset(new Object(5000))-------------- CreateObj 5000 DestroyObj 400 ----------Main End-------------- DestroyObj 5000 DestroyObj 200 release() 取出指针\nunique_ptr返回指针，并且把自己保存的设为空.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using ObjectPtr = eastl::unique_ptr\u0026lt;Object\u0026gt;; Object* Obj1 = new Object(100); ObjectPtr ObjPtr(Obj1); cout \u0026lt;\u0026lt; format(\u0026#34;Smart ObjPtr.A = {}\\n\u0026#34;, ObjPtr-\u0026gt;A); Object* ptr = ObjPtr.release(); cout \u0026lt;\u0026lt; format(\u0026#34;ptr.A = {}\\n\u0026#34;, ptr-\u0026gt;A); if (ObjPtr.get()) { cout \u0026lt;\u0026lt; format(\u0026#34;objPtr.A = {}\\n\u0026#34;, ObjPtr-\u0026gt;A); } else { cout \u0026lt;\u0026lt; \u0026#34;ObjPtr is nullptr\\n\u0026#34;; } 输出\n1 2 3 4 CreateObj 100 Smart ObjPtr.A = 100 ptr.A = 100 ObjPtr is nullptr 析构过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //销毁已拥有的指针。 //被拥有的指针引用的对象的析构函数将被调用。 ~unique_ptr() EA_NOEXCEPT { reset(); } //删除已拥有的指针，并获取传入指针的所有权。 //如果传入的指针与拥有的指针相同，则什么也不做。 // 例如: // unique_ptr\u0026lt;int\u0026gt; ptr(new int(3)); // ptr.reset(new int(4)); // deletes int(3) // ptr.reset(NULL); // deletes int(4) void reset(pointer pValue = pointer()) EA_NOEXCEPT { if (pValue != mPair.first()) { if (auto first = eastl::exchange(mPair.first(), pValue)) get_deleter()(first); } } deleter_type\u0026amp; get_deleter() EA_NOEXCEPT { return mPair.second(); } void operator()(T* p) const EA_NOEXCEPT { static_assert(eastl::internal::is_complete_type_v\u0026lt;T\u0026gt;, \u0026#34;Attempting to call the destructor of an incomplete type\u0026#34;); delete p; } 析构时调用reset函数，并且传入空指针.\neastl::exchange(mPair.first(), pValue) 交换两个指针，\n假设 unique_ptr 保存的有效指针 unique_ptr -\u0026gt; ptr 为 指针A.\n1.把 unique_ptr 里面保存的 指针A 与 nullptr 交换，此时 unique_ptr保存的是 nullptr.\nunique_ptr -\u0026gt; ptr = nullptr\nfirst= 指针A ，\n2.get_deleter() 取出删除器.\n删除器有两种，default_delete\u0026lt;T\u0026gt; default_delete\u0026lt;T[]\u0026gt; 分别是删除普通对象 和 删除数组对象.\n3.调用 删除器 的 ()运算符重载，把 first 作为参数传递进去. 这个重载运算符将调用delete 删除 first.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename T\u0026gt; struct default_delete { EA_CONSTEXPR default_delete() EA_NOEXCEPT = default; template \u0026lt;typename U\u0026gt; // Enable if T* can be constructed with U* (i.e. U* is convertible to T*). default_delete(const default_delete\u0026lt;U\u0026gt;\u0026amp;, typename eastl::enable_if\u0026lt;is_convertible\u0026lt;U*, T*\u0026gt;::value\u0026gt;::type* = 0) EA_NOEXCEPT {} void operator()(T* p) const EA_NOEXCEPT { static_assert(eastl::internal::is_complete_type_v\u0026lt;T\u0026gt;, \u0026#34;Attempting to call the destructor of an incomplete type\u0026#34;); delete p; } }; //-------------------// template \u0026lt;typename T\u0026gt; struct default_delete\u0026lt;T[]\u0026gt; { void operator()(T* p) const EA_NOEXCEPT { delete[] p; } } shared_ptr 共享所有权：多个 std::shared_ptr 对象可以共享同一个对象的所有权，每个 std::shared_ptr 都持有对对象的引用计数。 这个类实现了 C++11 标准库中的 shared_ptr 模板。\nshared_ptr 类似于 C++ 标准库中的 unique_ptr，但不同之处在于它允许通过引用计数在多个实例之间共享指针。\nshared_ptr 对象可以安全地进行拷贝，并且可以安全地用于 C++ 标准库容器中，如 std::vector 或 std::list。\n这个类不是线程安全的，因为你不能同时从两个线程使用它的同一个实例，也不能同时使用拥有相同指针的两个独立实例。\n使用标准的多线程互斥技术来解决前者的问题，并使用 shared_ptr_mt 来解决后者的问题。\n请注意，这与 C++11 标准不一致。\n如果你使用原始指针构造一个 shared_ptr，你不能仅用那个原始指针再构造另一个 shared_ptr。相反，你需要用最初创建的 shared_ptr 来构造额外的 shared_ptr。否则会导致崩溃。 使用 shared_ptr 是线程安全的，但它指向的对象并不自动是线程安全的。多个引用同一个对象的 shared_ptr 可以被多个线程任意使用。 你可以将单个 shared_ptr 在多个线程之间以所有方式共享，除了赋值操作。以下操作不是线程安全的，需要通过互斥锁或 shared_ptr 的原子函数来保护： 1 2 3 4 5 shared_ptr\u0026lt;Foo\u0026gt; pFoo; // 线程 1: shared_ptr\u0026lt;Foo\u0026gt; pFoo2 = pFoo; // 线程 2: pFoo = make_shared\u0026lt;Foo\u0026gt;(); shared_ptr:\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; class shared_ptr { //........... protected: element_type* mpValue; ref_count_sp* mpRefCount; //......... } 两个成员变量分别是 指针 和 引用计数块.\n引用计数块以指针形式存储，原因就是它是 new创建的，本体在内存条里，可以用指针指向它.\n这样就实现了 多个 shared_ptr 类拥有同一个引用计数块. 因为它们都可以获得 引用计数块的地址，并且用指针指向它.\n引用计数 ref_count_sp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct ref_count_sp { atomic\u0026lt;int32_t\u0026gt; mRefCount; /// Reference count on the contained pointer. Starts as 1 by default. atomic\u0026lt;int32_t\u0026gt; mWeakRefCount; /// Reference count on contained pointer plus this ref_count_sp object itself. Starts as 1 by default. public: ref_count_sp(int32_t refCount = 1, int32_t weakRefCount = 1) EA_NOEXCEPT; virtual ~ref_count_sp() EA_NOEXCEPT {} int32_t use_count() const EA_NOEXCEPT; void addref() EA_NOEXCEPT; void release(); void weak_addref() EA_NOEXCEPT; void weak_release(); ref_count_sp* lock() EA_NOEXCEPT; virtual void free_value() EA_NOEXCEPT = 0; // Release the contained object. virtual void free_ref_count_sp() EA_NOEXCEPT = 0; // Release this instance. #if EASTL_RTTI_ENABLED virtual void* get_deleter(const std::type_info\u0026amp; type) const EA_NOEXCEPT = 0; #else virtual void* get_deleter() const EA_NOEXCEPT = 0; #endif }; ref_count_sp 拥有两个原子变量\n强引用计数 (mRefCount)：跟踪有多少个 shared_ptr 实例指向同一个对象。 弱引用计数 (mWeakRefCount)：跟踪有多少个 weak_ptr 实例指向同一个对象。 release() 方法用于减少强引用计数，并在引用计数降为零时释放对象。\n1 2 3 4 5 6 7 8 9 10 11 inline void ref_count_sp::release() { EASTL_ASSERT((mRefCount.load(memory_order_relaxed) \u0026gt; 0)); if(mRefCount.fetch_sub(1, memory_order_release) == 1) { atomic_thread_fence(memory_order_acquire); free_value();//释放对象 } weak_release(); } fetch_sub：原子操作，减少引用计数并返回旧值。 free_value()：虚函数，在引用计数降为零时调用，实际执行的是派生类中的实现。 派生类 ref_count_sp_t 实现了具体的删除逻辑:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template \u0026lt;typename T, typename Allocator, typename Deleter\u0026gt; class ref_count_sp_t : public ref_count_sp { public: typedef ref_count_sp_t\u0026lt;T, Allocator, Deleter\u0026gt; this_type; typedef T value_type; typedef Allocator allocator_type; typedef Deleter deleter_type; value_type mValue; // This is expected to be a pointer. deleter_type mDeleter; allocator_type mAllocator; ref_count_sp_t(value_type value, deleter_type deleter, allocator_type allocator) : ref_count_sp(), mValue(value), mDeleter(eastl::move(deleter)), mAllocator(eastl::move(allocator)) {} void free_value() EA_NOEXCEPT override { mDeleter(mValue); mValue = nullptr; } void free_ref_count_sp() EA_NOEXCEPT override { allocator_type allocator; allocator.destroy(this); allocator.deallocate(this, 1); } }; free_value()：重写了基类的虚函数，使用 mDeleter 删除对象。 free_ref_count_sp()：重写了基类的虚函数，释放 ref_count_sp_t 对象本身。 shared_ptr 类封装了上述引用计数管理机制，并提供了用户接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; class shared_ptr { public: typedef shared_ptr\u0026lt;T\u0026gt; this_type; typedef T element_type; typedef typename shared_ptr_traits\u0026lt;T\u0026gt;::reference_type reference_type; // This defines what a reference to a T is. It\u0026#39;s always simply T\u0026amp;, except for the case where T is void, whereby the reference is also just void. typedef EASTLAllocatorType default_allocator_type; typedef default_delete\u0026lt;T\u0026gt; default_deleter_type; typedef weak_ptr\u0026lt;T\u0026gt; weak_type; protected: element_type* mpValue; ref_count_sp* mpRefCount; /// Base pointer to Reference count for owned pointer and the owned pointer. } 析构过程 1 2 3 4 5 6 7 ~shared_ptr() { if (mpRefCount) { mpRefCount-\u0026gt;release(); } } 析构时调用 mpRefCount-\u0026gt;release() 判断引用计数是否为0:\n1 2 3 4 5 6 7 8 9 10 11 inline void ref_count_sp::release() { EASTL_ASSERT((mRefCount.load(memory_order_relaxed) \u0026gt; 0)); if(mRefCount.fetch_sub(1, memory_order_release) == 1) { atomic_thread_fence(memory_order_acquire); free_value(); } weak_release(); } 如果为0，调用 free_value() , free_value()调用删除器的 ()运算符重载\n最终删除对象指针.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void free_value() EA_NOEXCEPT { mDeleter(mValue); mValue = nullptr; } //----------// deleter_type mDeleter; //mDeleter 实际上就是default_delete template \u0026lt;typename T\u0026gt; struct default_delete { #if defined(EA_COMPILER_GNUC) \u0026amp;\u0026amp; (EA_COMPILER_VERSION \u0026lt;= 4006) // GCC prior to 4.7 has a bug with noexcept here. EA_CONSTEXPR default_delete() = default; #else EA_CONSTEXPR default_delete() EA_NOEXCEPT = default; #endif template \u0026lt;typename U\u0026gt; // Enable if T* can be constructed with U* (i.e. U* is convertible to T*). default_delete(const default_delete\u0026lt;U\u0026gt;\u0026amp;, typename eastl::enable_if\u0026lt;is_convertible\u0026lt;U*, T*\u0026gt;::value\u0026gt;::type* = 0) EA_NOEXCEPT {} void operator()(T* p) const EA_NOEXCEPT { static_assert(eastl::internal::is_complete_type_v\u0026lt;T\u0026gt;, \u0026#34;Attempting to call the destructor of an incomplete type\u0026#34;); delete p; } }; 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Object { public: int A = 0; Object(int v) : A(v) { cout\u0026lt;\u0026lt;\u0026#34;CreateObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } ~Object() { cout\u0026lt;\u0026lt;\u0026#34;DestroyObj \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; int main() { { using ObjectPtr = eastl::shared_ptr\u0026lt;Object\u0026gt;; Object* Object1 = new Object(1); ObjectPtr ptr1(Object1); //仍然可以通过原始指针访问 Object1 //cout \u0026lt;\u0026lt; format(\u0026#34;Object1 value: {}\\n\u0026#34;, Object1-\u0026gt;A); //---------------------------------------------------// cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} value:{} \\n\u0026#34;, ptr1.use_count(),ptr1-\u0026gt;A); //ptr1 count: 1 value:1 ObjectPtr ptr2(ptr1); ptr2-\u0026gt;A = 5; cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} value:{} \\n\u0026#34;, ptr1.use_count(),ptr1-\u0026gt;A); //ptr1 count: 2 value:5 cout \u0026lt;\u0026lt; format(\u0026#34;ptr2 count: {} value:{} \\n\u0026#34;, ptr1.use_count(),ptr2-\u0026gt;A); //ptr2 count: 2 value:5 { ObjectPtr ptr3(ptr2); cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} ptr2 count: {} \\n\u0026#34;, ptr1.use_count(),ptr2.use_count()); //ptr1 count: 3 ptr2 count: 3 ObjectPtr ptr4(ptr3); cout \u0026lt;\u0026lt; format(\u0026#34;ptr3 count: {} ptr4 count: {} \\n\u0026#34;, ptr3.use_count(),ptr4.use_count()); //ptr3 count: 4 ptr4 count: 4 ObjectPtr ptr5(ptr4); ObjectPtr ptr6(ptr5); cout \u0026lt;\u0026lt; format(\u0026#34;ptr5 count: {} ptr6 count: {} \\n\u0026#34;, ptr5.use_count(),ptr6.use_count()); //ptr5 count: 6 ptr6 count: 6 } cout \u0026lt;\u0026lt; format(\u0026#34;ptr1 count: {} \\n\u0026#34;, ptr1.use_count()); //ptr1 count: 2 cout \u0026lt;\u0026lt;\u0026#34;---------- End --------------\\n\u0026#34;; } //DestroyObj 5 while(true){} } 输出\n1 2 3 4 5 6 7 8 9 10 CreateObj 1 ptr1 count: 1 value:1 ptr1 count: 2 value:5 ptr2 count: 2 value:5 ptr1 count: 3 ptr2 count: 3 ptr3 count: 4 ptr4 count: 4 ptr5 count: 6 ptr6 count: 6 ptr1 count: 2 ---------- End -------------- DestroyObj 5 safe_ptr safe_ptr 是一种自动且轻量的解决方案，用于解决悬空指针问题。\n类描述\n这个类是 weak_ptr 的一种替代方案，其主要优点是不需要分配额外的内存，但代价是稍微慢一些，并且不是线程安全的。\n在正常使用情况下，safe_ptr\u0026lt;T\u0026gt; 的行为与 T* 完全相同。当 safe_ptr 引用的原始指针被删除时，所有指向该原始指针的 SafePtrs 都会被设置为 NULL。\n工作原理\n这一机制通过让原始对象继承自 safe_object 类来实现。safe_object 类维护一个指向它的 SafePtrs 的链表。当一个 safe_object 被销毁时 会遍历其链表，将每个 SafePtr 的对象引用设置为 NULL。\n这种开销很小——只需在所指向的对象大小中增加一个指针，并且 safePtr 的大小等于一个原始指针加上一个链表指针。\n线程安全性\n这个类不是线程安全的。特别是，操作引用同一个底层对象的 safe_ptr 对象不能从多个线程安全地进行。然而，不相关的 safe_ptr 对象可以在多个线程中安全使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class RandomLifetimeObject : public eastl::safe_object { public: int A = 0; RandomLifetimeObject(int value) : A(value){} void Print() { cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } }; int main() { { Object* Object1 = new Object(1); eastl::safe_ptr\u0026lt;RandomLifetimeObject\u0026gt; pSafePtr(new RandomLifetimeObject(50)); pSafePtr-\u0026gt;Print(); eastl::safe_ptr\u0026lt;RandomLifetimeObject\u0026gt; pSafePtrCopy = pSafePtr; pSafePtrCopy-\u0026gt;Print(); pSafePtr-\u0026gt;Print(); delete pSafePtr; // 此时，pSafePtrCopy 评估为 NULL。 //get()返回false if (pSafePtrCopy.get()) { pSafePtrCopy-\u0026gt;Print(); } else { cout \u0026lt;\u0026lt; \u0026#34;pSafePtrCopy is null\\n\u0026#34;; } } while (true) { } } ","date":"1074-01-01T20:11:46+08:00","permalink":"https://akaklya.github.io/p/eastl/","title":"EASTL"},{"content":"模板专题\n构造 赋值 析构 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { String s1(); String s2(\u0026#34;Hello\u0026#34;); // 拷贝构造 String s3(s1); cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; // 拷贝赋值 s3 = s2; cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt;endl; } 不写这些函数，编译器自动写.\n构造 析构 String类，手动定义 构造、赋值、析构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 String::String(const char* cstr = 0) { if(cstr) { // 字符长度+1 的+1 是结尾符号\u0026#39;\\0\u0026#39; m_data = new char[strlen(cstr)+1]; strcpy(m_data,cstr); } else { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } } String::~String() { //清理动态分配的数组内存[] delete[] m_data; } { String s1(); String s2(\u0026#34;hello\u0026#34;); String* p = new String(\u0026#34;hello\u0026#34;); delete p; } // 离开作用域，s1 s2自动释放 析构，p要delete. 拷贝构造 b=a 浅拷贝， b的data指向a的data的区域，导致b原本的\u0026quot;World\\0\u0026quot;内存泄露， 当a的data修改后，b跟着受影响.\n深拷贝，空间创建出以后 把内容拷贝过去.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 String::String(const String\u0026amp; str) { m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); } { String s1(\u0026#34;hello\u0026#34;); 下面两行意思相同 String s2(s1); //String s2 = s1; 忽略上面一行，s2是新创建出的对象，调用构造函数 } 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）.按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。\n深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）\n拷贝赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String\u0026amp; String::operator=(const String\u0026amp; str) { // 必写 检测自我赋值 if(this == \u0026amp;str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data,str.m_data); return *this; } { String s1(\u0026#34;hello\u0026#34;); String s2(s1); s2 = s1; } 检测自我赋值，避免delete自杀\n流重载要写到类外\n1 2 3 4 5 6 7 8 9 10 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const string\u0026amp; str) { os \u0026lt;\u0026lt; str.get_c_str(); return os; } { String s1(\u0026#34;hello\u0026#34;); cout \u0026lt;\u0026lt; s1; } stack 栈 heap堆 stack是存在于某作用域的一块内存空间。调用函数时 函数本身会形成一个stack用来存放它接收的参数 和 返回地址在函数本体内声明的任何变量，其所使用的内存块都取自stack.heap 或 system heap ,是操作系统提供的一块 global内存空间，程序可动态分配从其中获得区块. new出来的东西必须手动delete\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Complex{...}; { Complex c1(1,2); Complex* p = new Complex(3); static Complex c3(1,2); //释放p，否则p离开作用域后就死亡了，会对内存失去控制，导致内存泄露，无法把内存还给系统 delete p; } //c1占用的空间来自stack. //Complex(3)是临时对象，占用的空间是以new自heap动态分配来的，并由p指向. //c1是stack object，生命在作用域结束的时候结束， //在作用域内的object 又称为 auto object，因为会被自动清理. //c3是static object,生命在作用域结束后仍然存在，直到整个程序结束. 1 2 3 4 5 6 7 8 9 10 class Complex{...}; Complex c4(1,2) int main() { } //C4是global object,生命在整个程序结束才结束。其作用域是 整个系统. new : 先分配内存，再调用构造 。 new内部调用malloc(n)\n1 2 3 4 5 6 Complex* pc = new Complex(1,2); //编译器转化为: void* mem = operator new( sizeof(Complex) ); pc = static_cast\u0026lt;Complex*\u0026gt;(mem); pc-\u0026gt;Complex::Complex(1,2); //实际是Complex::Complex(pc,1,2); delete:先调用析构， 再释放内存\n1 2 3 4 5 6 String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 1 2 3 4 5 6 7 8 9 10 class Complex { double A; double B; } class String { char* m_data; } VC内存 Complex、String被 new 出来之后的内存\n调试模式下的Complex的头尾都有 00000041 这一串数据，称为 cookie，这一个东西在delete时要用到. 末尾的1 表示内存以及分配出去，4表示其大小64，绿色块用来把内存大小从52填充为64Release模式下的Complex头尾有00000011,1表示大小为16. 当Complex被回收后，这一串数值会变成00000010，末尾的0表示已经被回收的内存.00000000 和 00000001 分别是0和16，只差一位，但十进制上差的是16，由于对象的内存大小必须是16的倍数，所以16以及16以下的数据 都是没有用到的，可以拿来做内存 分配出去 与 回收 的状态标记.\nnew Array的内存:\n8x3 ，一个Complex有2个double，2个double是8.32+4是debug的块, 4x2是头尾的51h， 4是用一个整数记录有3个Complex.String里面只有一个指针，所以图中有一个箭头去表示这个指针指向一个地方.\nArray 的new 与 delete delete要看内存头尾的cookie，cookie 记录了一整块的大小，如 图中的两个21h，delete根据它们可以把内存删掉. 此时 delete 和 delete[]不会造成内存泄露，使用delete[] 编译器才知道要删除的是数组，数组里有3个String，调用3次析构，再回收整块内存.不写delete[] 会造成内存泄露，但泄露的不是这一块内存，而是String里的指针，如图中右边的红色 ?! 块 是String里面指针指向的地方. 这里会发生内存泄露.\n1 2 3 4 5 6 7 8 9 10 11 class String { char* m_data; } String* ps = new String(\u0026#34;Hello\u0026#34;); ...... delete ps; //编译器转化为: String::~String(ps); operator delete(ps); //内部调用free(ps) 如果new的是Complex，里面只有double 没有指针， 即便是用 delete 也可以.\n用了array new 就必须搭配 delete[] 才可万无一失.\n阶段A 复习String.\nString使用char*指针，动态分配大小. 不使用数组 如果用数组，数组大小不确定 太大太小都不好.\nString里面有指针，要关注3个重要函数: 拷贝构造、拷贝赋值、析构.\n在这里不会修改来源端的数据，函数参数用const\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class String { public: // C - Style String(const char* cstr = 0); // 拷贝构造 String(const String\u0026amp; str); // 拷贝赋值 String\u0026amp; operator=(const String\u0026amp; str); //析构 ~String(); char* get_c_str() const {return m_data;} private: char* m_data; } static、cout 所有Account实例共用一份m_rate数据.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Account { public: static double m_rate; static void set_rate(const double\u0026amp; x){m_rate = x;} }; // 定义初始值 double Account::m_rate = 8.0; int main() { // 调用static函数的两个方式 Account::set_rate(5.0); Account a; a.set_rate(7.0); } Singleton ， 把构造函数放在private\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); static A a; } A::GetInstance.setup(); 有人调用GetInstance时，A才会出现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { public: static A\u0026amp; GetInstance(return a;); setup(){...} private: A(); A(const A\u0026amp; rhs); } A\u0026amp; A::GetInstance() { static A a; return a; } Cout为了打印出一些不同类型的数据 ， 做了一堆重载\n复合、继承、委托 复合 Adapter适配器设计模式\ndeque的功能很强，拿过来改造一下，只开放部分函数 成为queue.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template\u0026lt;class T\u0026gt; class queue { ... protected: deque\u0026lt;T\u0026gt; c; public: // 使用c的操作函数完成. bool empty() const {return c.empty();} size_type size() const {return c.size();} reference front() {return c.front();} reference back() {return c.back();} // void push(const value_type\u0026amp; x) {c.push_back(x);} void pop() {c.pop_front();} }; 构造由内而外，析构由外而内.\n构造： queue的构造函数首先调用deque的默认构造函数，然后才执行自己析构： queue的析构函数首先执行自己，然后才次调用deque的析构函数.\n委托 用指针指向实现功能的那个类，指针可以指向不同的实现类，右边的变动不影响左边.编译防火墙：左边不用再编译，要编译的是右边.\n继承 1 2 3 4 5 6 7 8 9 10 11 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; } template\u0026lt;typename _Tp\u0026gt; struct _List_node : public _List_node_base { _Tp _M_Data } 构造由内而外，析构由外而内\n子类的构造函数首先调用父类的默认构造函数，然后才执行自己析构首先执行自己，然后才调用父类的析构函数.\n继承搭配虚函数才是更强的.\nnon-virtual：不希望子类重新定义(override)virtual:希望子类重新定义，并且它已有默认定义pure virtual:希望子类一定要重新定义，它没有默认定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Shape { public: // pure virtual virtual void draw() const = 0; // impure virtual virtual void error(const std::string\u0026amp; msg); // non - virtual int objectID()const; } class Rectangle : public Shape { ... } 转换函数 分母默认为1，Fraction(3) 就是3/1 = 3；只需要一个参数够了，one-argument\nnon-explicit-one-argument\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); // 调用operator double将f转换为0.6 double d=4+f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; Fraction重载了+号，但是f+4时 4是int，不是Fraction类型，调用non-explicit ctor将4转换为Fraction(4,1)，然后调用operator+\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; //[Error] operator double() 可以把Fraction转为double， Fraction(int num,int den=1) 可以把4转为Fraction\n此时有两条路线可以走，编译器报错.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Fraction { public: explicit Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){} operator double() const { return (double)(m_numerator/m_denominator); } Fraction operator+(const Fraction\u0026amp; f) { return Fraction(...); } private: //分子 int m_numerator; //分母 int m_denominator; } Fraction f(3,5); Fraction d2 = f+4; 构造加上explicit，防止隐式转换，不可以把3变成3/1了，不能把3变成Fraction类型，\nf+4 , 4不会变成Fraction，而operator+(const Fraction\u0026amp; f) 要的参数是Fraction类型，所以4转不到Fraction,会转换失败.\nC++11 变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\nrange-based for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for(int i : {2,3,5,7,9,13,17,19}) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } vector\u0026lt;double\u0026gt; vec; // pass by value for(auto elem: vec) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt;endl; } // pass by reference for(auto\u0026amp; elem:vec) { elem *=3 ; } auto lambda 1 2 3 4 5 6 7 8 9 10 11 12 auto i = 42; double f(); auto d = f(); vector\u0026lt;string\u0026gt; v; ... auto pos = v.begin(); auto I = [](int x) -\u0026gt; bool { ...; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; } //call: []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }(); // print \u0026#34;hello lambda\u0026#34; auto I = []{ std::cout\u0026lt;\u0026lt;\u0026#34;hello lambda\u0026#34;\u0026lt;\u0026lt;std::endl; }; I(); // print \u0026#34;hello lambda\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 [...](...)-\u0026gt;returnType{...} ()参数 {}函数体 [=] 外部变量值传递 [\u0026amp;] 外部变量引用传递 int id = 0; //mutable []里的东西是可变的，不写 就不能++id auto f = [id]()mutable{ std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } { id = 42; f(); f(); f(); std::cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; } //输出 id:0; id:1; id:2; 42 //内部的id变了，外部的还是42. // class Functor { private: int id;//copy of outside id public: void operator() { std::cout\u0026lt;\u0026lt;\u0026#34;id:\u0026#34;\u0026lt;\u0026lt;id\u0026lt;\u0026lt;std::endl; ++id; } }; Functor f; Uniform Initialization 1 2 3 4 int values[] {1,2,3}; vector\u0026lt;int\u0026gt; v{2,3,5,7}; vector\u0026lt;string\u0026gt; cities{\u0026#34;New York\u0026#34;,\u0026#34;Berlin\u0026#34;}; complex\u0026lt;double\u0026gt; c{4.0,3.0}; 编译器在幕后做出一个 initializer_list 进行构造.\ninitializer_list 1 2 3 4 int i;\ti拥有未定义值 int j{}; j = 0 int* p; p未定义值 int* q{}; q = nullptr 1 2 3 4 5 6 7 8 void print(std::initializer_list\u0026lt;int\u0026gt; vals) { for(auto p=vals.bee();p!=vals.end;++p) { std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } print({12,3,5,7,11,13,17}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } P(initializer_list\u0026lt;int\u0026gt; initlist) { cout \u0026lt;\u0026lt; \u0026#34;P(initializer_list\u0026lt;int\u0026gt;) ,values =\u0026#34;; for(auto i : initlist) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\u0026#39;; } cout \u0026lt;\u0026lt; endl; } } P p(77,5); //P(int,int) a=77,b=5 P q{77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 P r{77,5,42}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 42 P s={77,5}; //P(initializer_list\u0026lt;int\u0026gt;) ,values = 77 5 1 2 3 4 5 6 7 8 9 10 11 12 13 class p { public: P(int a,int b) { cout \u0026lt;\u0026lt; \u0026#34;P(int,int),a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } } P p(77,5); P q{77,5}; P r{77,5,42}; P s={77,5}; 没有initializer_list构造时，编译器会把{}里面的一包内容拆解出来，q{77,5} 和 s={77,5} 有两个数，符合P(int,int)r里面有3个数，不符合P(int,int)，失败.\ninitializer_list背后是个array，编译器能够调用initializer_list的私有构造函数.编译器看到 {} 时就制造一个initializer_list，\n=default , =delete 如果自行定义了一个构造函数，那么编译器就不会再给你一个默认构造函数。如果强制加上 = default，就可以重新获得并使用默认构造函数。 =delete告诉编译器不要定义它。必须出现在声明式。适用于任何成员函数。也适用于构造函数，但后果自负。\n1 2 3 4 5 6 7 8 9 10 11 12 class Zoo { public: Zoo(int i1,inti2) : d1(i1),d2(i2){} Zoo(const Zoo\u0026amp;) = delete; Zoo(Zoo\u0026amp;\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;)=default; Zoo\u0026amp; operator=(const Zoo\u0026amp;\u0026amp;)=delete; virtual ~Zoo(){} private: int d1,d2; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A { public: // A user-defined // parameterized constructor A(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is a parameterized constructor\u0026#34;; } // Using the default specifier to instruct // the compiler to create the default // implementation of the constructor. A() = default; }; int main() { // executes using defaulted constructor A a; // uses parameterized constructor A x(1); return 0; } 在上述情况下，我们不必指定构造函数 A() 的主体，因为通过附加说明符 \u0026lsquo;=default\u0026rsquo;，编译器将创建此函数的默认实现。\n默认函数需要是特殊成员函数（默认构造函数、复制构造函数、析构函数等），或者没有默认参数。例如，以下代码说明非特殊成员函数不能为默认值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class B { public: // Error, func is not a special member function. int func() = default; // Error, constructor B(int, int) is not // a special member function. B(int, int) = default; // Error, constructor B(int=0) // has a default argument. B(int = 0) = default; }; // driver program int main() { return 0; } 禁用复制构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class A { public: A(int x): m(x) { } // Delete the copy constructor A(const A\u0026amp;) = delete; // Delete the copy assignment operator A\u0026amp; operator=(const A\u0026amp;) = delete; int m; }; int main() { A a1(1), a2(2), a3(3); // Error, the usage of the copy // assignment operator is disabled a1 = a2; // Error, the usage of the // copy constructor is disabled a3 = A(a2); return 0; } 禁用不需要的参数转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class A { public: A(int) {} // Declare the conversion constructor as a // deleted function. Without this step, // even though A(double) isn\u0026#39;t defined, // the A(int) would accept any double value // for it\u0026#39;s argumentand convert it to an int A(double) = delete; }; int main() { A A1(1); // Error, conversion from // double to class A is disabled. A A2(100.1); return 0; } 删除特殊成员函数提供了一种更清晰的方法来防止编译器生成我们不需要的特殊成员函数。\n删除普通成员函数或非成员函数可以防止有问题的类型提升导致意外调用函数(如“禁用不需要的参数转换”示例所示)。\nAlias Template 别名: 李白 字太白\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; using Vec = std::vector\u0026lt;T,MyAlloc\u0026lt;T\u0026gt;\u0026gt;; Vec\u0026lt;int\u0026gt; coll; std::vector\u0026lt;int,MyAlloc\u0026lt;int\u0026gt;\u0026gt; coll; //TODO::模板内容很多，不止这些\n右值与移动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //解决非必要的拷贝，右边是右值时，左边可以偷右边的资源 //而不需要执行allocation重新分配内存 //Lvalue:可以出现在operator=左侧者 //Rvalue:只能出现在operator=右侧者 //临时对象一定被当作右值 //————————————————————————————————————————————————————————————// int a = 9; int b = 4; a=b; //ok b=a;\t//ok a=a+b;\t//ok //a+b是右值 a+b=42 //Error , lvalue required as left operand of assignment //————————————————————————————————————————————————————————————// string s1(\u0026#34;hello\u0026#34;); string s2(\u0026#34;world\u0026#34;); s1 + s2 = s2; //通过编译 cout \u0026lt;\u0026lt; \u0026#34;s1:\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;s2:\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt;endl; string() = \u0026#34;world\u0026#34;; //对临时对象赋值？ //————————————————————————————————————————————————————————————// 1 2 3 4 5 int foo(){return 5;} int x = foo(); //ok int* p = \u0026amp;foo(); //Error，不能对右值取地址 foo() = 7\t//Error 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyString { private: char* _data; public: //copy ctor MyString(const MyString\u0026amp; str):initialization_list{...} //move ctor MyString(MyString\u0026amp;\u0026amp; str) noexcept : initialization_list{...} } //---------------- M c1(c); M c2(std::move(c1));//要确保后续不再使用c1. 完美转发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 template\u0026lt;typename T1,typename T2\u0026gt; void functionA(T1\u0026amp;\u0026amp;t1,T2\u0026amp;\u0026amp;t2) { functionB(std::forward\u0026lt;T1\u0026gt;(t1),std::forward\u0026lt;T2\u0026gt;(t2)); } //-------------------------------------// void _init_data(const char* s) { _data = new char[_len+1]; memcpy(_data,s,_len); _data[_len] = \u0026#39;\\0\u0026#39;; } // copy constructor MyString(const MyString\u0026amp; str) :_len(str.len) { _init_data(str._data); } // move constructor MyString(MyString\u0026amp;\u0026amp; str) noexcept :_data(str._data),_len(str._len) { str._len = 0; str._data=null; } //----------------------------------------------// //copy assignment MyString\u0026amp; operator=(const MyString\u0026amp; str) { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str.len; _init_data(str.data); // Copy } else { } return *this; } //move assignment MyString\u0026amp; operator=(MyString\u0026amp;\u0026amp; str) noexcept { if(this!=\u0026amp;str) { if(_data) delete _data; _len = str._len; //Move _data = str.data; //Move str._len = 0; //重要 str._data = null; //重要 } } //----------------------------------------------// virtual ~MyString() { if(_data) { delete _data; } } 模板 函数模板 模板函数Max，不管是什么样的类型 都可以调用这个模板，模板函数在使用时实例化，只有使用 Max(float,float) 时 才会生成对于float的Max函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; template \u0026lt;typename T\u0026gt; T Max(const T\u0026amp; T1, const T\u0026amp; T2) { return T1 \u0026gt; T2 ? T1 : T2; } class VNumber { public: float A; float B; std::string Name; VNumber(float InA , float InB,std::string InName) : A(InA),B(InB),Name(InName) {} bool operator\u0026lt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026lt; (Ohter.A + Ohter.B); } bool operator\u0026gt;(const VNumber\u0026amp; Ohter) const { return (A + B) \u0026gt; (Ohter.A + Ohter.B); } }; int main() { int A = Max(2,3); double B = Max(2.2,3.3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;float Max - A:{} B:{} \\n\u0026#34;,A,B); //float Max - A:3 B:3.3 VNumber V1(1,2,\u0026#34;V1\u0026#34;); VNumber V2(3,5,\u0026#34;V2\u0026#34;); auto MaxVNumber = Max(V1,V2); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber.Name,MaxVNumber.A,MaxVNumber.B); // MaxName:V2 A:3 B:5 VNumber V3(10,5,\u0026#34;V3\u0026#34;); auto MaxVNumber2 = Max(V2,V3); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;MaxName:{} A:{} B:{} \\n\u0026#34;,MaxVNumber2.Name,MaxVNumber2.A,MaxVNumber2.B); // MaxName:V3 A:10 B:5 } 自动推导返回值 C++14引入自动推导:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;typeinfo\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format; template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { return tv1 + tv2; } int main() { int a = 5; int b = 3; int c = Add(a, b); float d = 5.5f; float e = 3.3f; float f = Add(d, e); auto AplusD = Add(a, d); cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2}\u0026#34;, a, b, c) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2}\u0026#34;, d, e, f) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;{0} + {1} = {2} Type:{3}\u0026#34;, a, d, AplusD, typeid(AplusD).name()) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; 输出：\n1 2 3 5 + 3 = 8 5.5 + 3.3 = 8.8 5 + 5.5 = 10.5 Type:float 如果在C++11中使用自动推导，需要使用尾置返回类型（trailing return type）：\n1 2 3 4 5 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 函数重载 当调用 Add 函数时，编译器会优先选择最匹配的重载函数。\n如果没有匹配的重载函数，则调用模板函数。\n如果重载函数和模板函数同时存在，编译器会优先选择重载函数（如果匹配）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { return tv1 + tv2; } // 2. 重载函数：处理两个整数相加 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用整数相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } // 3. 重载函数：处理两个字符串相加 string Add(const string\u0026amp; str1, const string\u0026amp; str2) { cout \u0026lt;\u0026lt; \u0026#34;调用字符串相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return str1 + str2; } // 4. 重载函数：处理一个整数和一个字符串相加 string Add(int a, const string\u0026amp; str) { cout \u0026lt;\u0026lt; \u0026#34;调用整数和字符串相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return std::to_string(a) + str; } int main() { // 调用模板函数 cout \u0026lt;\u0026lt; Add(1.5, 2.3) \u0026lt;\u0026lt;endl; // 调用模板函数，返回 double 类型 // 调用整数相加的重载函数 cout \u0026lt;\u0026lt; Add(10, 20) \u0026lt;\u0026lt; endl; // 调用整数相加的重载函数 // 调用字符串相加的重载函数 cout \u0026lt;\u0026lt; Add(string(\u0026#34;Hello\u0026#34;), string(\u0026#34;World!\u0026#34;)) \u0026lt;\u0026lt; endl; // 调用字符串相加的重载函数 // 调用整数和字符串相加的重载函数 cout \u0026lt;\u0026lt; Add(42, string(\u0026#34; is the answer\u0026#34;)) \u0026lt;\u0026lt; endl; // 调用整数和字符串相加的重载函数 }; 1 2 3 4 5 6 7 8 调用模板函数 3.8 调用整数相加的重载函数 30 调用字符串相加的重载函数 HelloWorld! 调用整数和字符串相加的重载函数 42 is the answer 特化 Specialization 特化是指为模板的某些特定类型或条件提供特殊的实现\n针对Object类 ，调用Add时 只会把它们内部的Name变量加起来.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;format\u0026gt; using std::cout,std::format,std::string; template\u0026lt;typename T\u0026gt; void Add(T\u0026amp; T1, T\u0026amp; T2) { T1 += T2; } struct Object { Object(string InName) : Name(InName){} string Name; }; template\u0026lt;\u0026gt; void Add\u0026lt;Object\u0026gt;(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } int main() { int A = 5; int B = 6; Add(A,B); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,A,B); //A:11 B:6 Object Obj1(\u0026#34;Manba\u0026#34;); Object Obj2(\u0026#34;Out\u0026#34;); Add(Obj1,Obj2); cout\u0026lt;\u0026lt;format(\u0026#34;A:{} B:{} \\n\u0026#34;,Obj1.Name,Obj2.Name); //A:ManbaOut B:Out } 这个例子里的第二个Add 手动指定了两个参数的类型，而且模板函数也只有这两个参数，也就是把所有参数类型全部手动指定了，这就是全特化.\n以下两种写法都可以，有时候还是写明模板实参比较好，即第一种写法，在尖括号里指明特化类型.\n1 2 3 4 5 6 template\u0026lt;\u0026gt; void Add\u0026lt;Object\u0026gt;(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } 1 2 3 4 5 6 template\u0026lt;\u0026gt; void Add(Object\u0026amp; T1, Object\u0026amp; T2) { cout\u0026lt;\u0026lt; \u0026#34;Adding Objects\u0026#34; \u0026lt;\u0026lt; endl; T1.Name = T1.Name + T2.Name; } 全特化是指为模板的所有模板参数指定具体的类型或值，从而为这些特定类型提供一个完全独立的实现。\n偏特化是指为模板的部分模板参数指定具体的类型或条件，而不是全部参数。偏特化允许对模板参数进行部分约束，从而为某些特定情况提供特殊实现。\n实际上 函数模板只有全特化，没有偏特化，模板类有全特化和偏特化.\n模板类特化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u0026lt;typename T\u0026gt; void VarType(T T1) {} template \u0026lt;\u0026gt; void VarType\u0026lt;int\u0026gt;(int) { cout \u0026lt;\u0026lt; \u0026#34;VarType is int\\n\u0026#34;; } template \u0026lt;\u0026gt; void VarType\u0026lt;float\u0026gt;(float) { cout \u0026lt;\u0026lt; \u0026#34;VarType is float\\n\u0026#34;; } 函数重载与特化 （1）普通函数重载优先 普通函数重载的优先级最高。如果调用时的实参与某个普通函数重载完全匹配，编译器会直接选择该函数，而不会考虑模板函数或模板特化版本。\n（2）模板全特化版本次之 如果没有匹配的普通函数重载，编译器会检查是否存在模板全特化版本。如果调用时的实参与某个模板全特化版本完全匹配，编译器会选择该特化版本。\n（3）模板函数最后 如果既没有匹配的普通函数重载，也没有匹配的模板全特化版本，编译器会选择最匹配的模板函数，并实例化该模板。\n函数模板重载 普通函数重载：这是指在同一作用域内定义多个具有相同名称但参数列表不同的函数。\n1 2 3 4 5 // 普通函数重载 int Add(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;调用整数相加的重载函数\u0026#34; \u0026lt;\u0026lt; endl; return a + b; } 函数模板重载：这是指在同一作用域内定义多个具有相同名称但模板参数或参数列表不同的函数模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 通用函数模板 template \u0026lt;typename T, typename U\u0026gt; auto Add(T tv1, U tv2) { cout \u0026lt;\u0026lt; \u0026#34;调用模板函数: T, U\u0026#34; \u0026lt;\u0026lt; endl; return tv1 + tv2; } // 特定参数类型的函数模板重载 template\u0026lt;typename T\u0026gt; auto Add(float T1, T\u0026amp; T2) { cout \u0026lt;\u0026lt; \u0026#34;调用第二个Add\u0026#34; \u0026lt;\u0026lt; endl; return T1 + T2; } 缺省参数 缺省值\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T\u0026gt; auto Sub(T tv1, T tv2 = 1) { cout \u0026lt;\u0026lt; \u0026#34;调用模板函数: T\u0026#34; \u0026lt;\u0026lt; endl; return tv1 - tv2; } int main() { int A = 10; auto c = Sub(A); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 调用模板函数: T 9 缺省类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T = int,typename T2\u0026gt; auto Add(T2 tv2) { T tv1 = 1; return tv1 + tv2; } int main() { int A = 10; auto c = Add(A); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } 运行结果 C = 11\n非类型模板参数 非类型模板参数是具体的值或对象，它们可以在编译时确定，并且可以用于控制模板的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T,typename U,auto V = 100\u0026gt; auto Add(T a,T b) { return a + b + V; } int main() { int A = 10; int B = 20; auto c = Add\u0026lt;int,int\u0026gt;(A,B); //C = A + B + 100 //C = 130 cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; auto d = Add\u0026lt;int,int,2.2\u0026gt;(A,B); // d = A + B + 2.2 // d = 32.2 cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 运行结果 c=130，d=32.2\n非类型模板参数要在编译期确定，不能使用变量，除非是const、constexpr\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int V1 = 100; constexpr int V2 = 100; int V3 = 100; template\u0026lt;typename T,typename U,auto V = 100\u0026gt; auto Add(T a,T b) { return a + b + V; } int main() { int a = 10; int b = 20; auto c = Add\u0026lt;int,int,V1\u0026gt;(a,b); auto d = Add\u0026lt;int,int,V2\u0026gt;(a,b); auto e = Add\u0026lt;int,int,V3\u0026gt;(a,b); return 0; } 其中 e的V3是变量，编译时报错\n1 2 表达式的计算结果不是常数 非常量参数或对非常量符号的引用导致了故障 如果在代码中 没有使用到非类型模板参数，可以不写参数名，但在调用时 还是要用尖括号指明类型的，以下的写法是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T, int value\u0026gt; auto Add2() { return 100; } template \u0026lt;typename , int \u0026gt; auto Add2() { return 100; } //调用时指明尖括号 Add2\u0026lt;int,5\u0026gt;(); 可变参模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //终止条件 void print() { } template\u0026lt;typename T,typename... Types\u0026gt; void print(const T\u0026amp; firstArg,const Types\u0026amp;... args) { cout\u0026lt;\u0026lt;firstArg\u0026lt;\u0026lt;endl; print(args...); } print(7.5,\u0026#34;hello\u0026#34;,42); //输出: //7.5 //hello //42 把放进去的参数分为 一个 和 一包 (const T\u0026amp; firstArg 和 Type*\u0026hellip;args)，\ncout把第一个打印出来剩下的一包再传给自己，这一包又被分为 一个和一包42传进去时 是 一个 + 0个，cout把42打印出来 ,此时 0个再传进去就会失败 print只接收1个和1包，于是调用的是void print().\n折叠表达式极大地简化了可变参数模板的操作，使得编写递归模板函数来处理参数包变得不再必要，从而让代码更加简洁和易读\n折叠表达式主要用于对可变数量的模板参数进行操作，常见的应用场景包括：\n对所有参数应用一个二元运算符：例如求和、求积等。 构建复杂的类型列表或值列表：例如生成类型列表或初始化列表。 简化递归模板函数：通过折叠表达式可以避免手动编写递归模板函数来处理参数包。 求和 求积：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 使用折叠表达式计算参数包中所有整数的和 template\u0026lt;typename... Args\u0026gt; auto sum(Args... args) { return (args + ...); // 左折叠 } template\u0026lt;typename... Args\u0026gt; auto product(Args... args) { return (args * ...); // 左折叠 } template\u0026lt;typename... Args\u0026gt; std::string concat(Args... args) { return (... + std::string(args)); // 右折叠 } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Sum: \u0026#34; \u0026lt;\u0026lt; sum(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出: 15 std::cout \u0026lt;\u0026lt; \u0026#34;Product: \u0026#34; \u0026lt;\u0026lt; product(1, 2, 3, 4, 5) \u0026lt;\u0026lt; std::endl; // 输出: 120 // 输出: Hello World! cout \u0026lt;\u0026lt; \u0026#34;Concatenated:\u0026#34; \u0026lt;\u0026lt; concat(\u0026#34;Hello\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;!\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 左折叠 vs 右折叠\n左：参数从左侧开始计算 (((\u0026ldquo;Hello\u0026rdquo; + \u0026quot; \u0026ldquo;) + \u0026ldquo;World\u0026rdquo;) + \u0026ldquo;!\u0026rdquo;)右：参数从右侧开始计算 ((\u0026ldquo;Hello\u0026rdquo; + (\u0026rdquo; \u0026quot; + (\u0026ldquo;World\u0026rdquo; + \u0026ldquo;!\u0026rdquo;))))\n对于字符串连接操作 +，左折叠和右折叠的结果也是相同的，因为字符串连接也是结合律的。\n对于具有结合律的运算符（如 +, *），左折叠和右折叠的结果是相同的。但对于没有结合律的运算符（如 -, /），左折叠和右折叠的结果可能会不同。因此，在选择左折叠还是右折叠时，需要根据具体情况和运算符的特性进行选择。\n一元左折(unary left fold) 格式:(\u0026hellip; 运算符 一包参数) 计算方式:(((参数1 运算符 参数2) 运算符 参数3)\u0026hellip;.运算符 参数N)\n一元右折(unary right fold) 格式: (一包参数 运算符 \u0026hellip;) 计算方式:(参数1 运算符 ( \u0026hellip; (参数N-1 运算符 参数N)))\n二元左折(binary left fold) 格式:(init 运算符 \u0026hellip; 运算符 一包参数) 计算方式:(((init 运算符 参数1) 运算符 参数2) \u0026hellip; 运算符 参数N) init表示 一个初始的东西，它可能是一个值，也可能是个其他东西。\n二元右折(binary right fold) 格式:(一包参数 运算符 \u0026hellip; 运算符 init) 计算方式:(参数1 运算符 (\u0026hellip;（参数N 运算符 init )))\n多态 模板中的多态，并不需要用到父类以及继承的概念，子类也不需要虚函数(压根就不存在父类指针指向子类对象或者父类引用绑定子类对象这种概念)\n1 编译期间内，编译器会实例化出eatTmpl\u0026lt;A\u0026gt;和eatTmpl\u0026lt;B\u0026gt;这两个函数。 总结： 传统多态：也叫动态多态（运行时多态），因为要访问虚函数表指针，所以对执行期间的性能多少会有一些影响。 模板多态：也叫静态多态，编译期间就确定了具体调用谁，就不存在执行期间的性能问题 只要支持相同的语法，就允许不同类型的对象以同样的方式被操纵——都有eat成员函数，那么就允许调用该成员函数，因为这是在编译期间完成的多态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class A { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;A!\u0026#34; \u0026lt;\u0026lt; endl; } }; class B { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;B!\u0026#34; \u0026lt;\u0026lt; endl; } }; //函数模板 template\u0026lt;typename T\u0026gt; void eatTmpl(T\u0026amp; obj) { obj.eat(); } int main() { A ObjA; B ObjB; eatTmpl(ObjA); eatTmpl(ObjB); return 0; } 类模板 类模板可以做数据结构的容器什么的. 比如在一个模板类里面搞一个数组，在使用时 可以定义数组存放什么样的类型， 或者 搞个链表，放一串int / float / string 等等类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template\u0026lt;typename T\u0026gt; class SimpleContainer { public: SimpleContainer(T InContent) : Content(InContent){} T GetContent() { return Content; } void SetContent(T InContent) { Content = InContent; } private: T Content; }; int main() { SimpleContainer SC(5); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} ,type:{} \\n\u0026#34;,SC.GetContent(),typeid(SC.GetContent()).name()); //SC Content:5 ,type:int SC.SetContent(10); cout\u0026lt;\u0026lt;format(\u0026#34;SC Content:{} , Is String? : {}\\n\u0026#34;, SC.GetContent(), std::is_same\u0026lt;decltype(SC.GetContent()),string\u0026gt;::value); //SC Content:10 , Is String? : false SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); cout\u0026lt;\u0026lt;format(\u0026#34;SC1 Content:{}, Is String? : {} \\n\u0026#34;, SC1.GetContent(), std::is_same\u0026lt;decltype(SC1.GetContent()),string\u0026gt;::value); //SC1 Content:Manba out, Is String? : true } C++17 模板参数自动推导，下面两种写法是一样的\n1 2 SimpleContainer SC(string(\u0026#34;Fuck\u0026#34;)); SimpleContainer\u0026lt;string\u0026gt; SC1(\u0026#34;Manba out\u0026#34;); 推断指引 在 C++17 之前，如果你有一个模板类，比如 std::pair，你在实例化时必须显式指定模板参数：\n1 2 3 4 std::pair\u0026lt;int, double\u0026gt; p(42, 3.14); // 必须显式指定 \u0026lt;int, double\u0026gt; //C++17 引入了 类模板参数推导 std::pair p(42, 3.14); // 编译器自动推导为 std::pair\u0026lt;int, double\u0026gt; 但有些情况下，编译器无法根据构造函数参数正确推导模板参数，这时就需要 deduction guide 来明确推导规则。\nDeduction guide 的主要作用是在 不显式指定模板参数 的情况下，帮助编译器推导模板参数\n1 2 template \u0026lt;模板参数列表\u0026gt; 类名(构造函数参数列表) -\u0026gt; 推导出的模板参数; 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; class Box { public: T value; Box(T v) : value(v) { cout\u0026lt;\u0026lt;format(\u0026#34;Box created with value {}\\n\u0026#34;,value); } }; int main() { Box b(\u0026#34;hello\u0026#34;); return 0; } 当Box b构建完成，它的value是const char*类型，\n使用推断指引 指定value的类型，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename T\u0026gt; class Box { public: T value; Box(T v) : value(v) { cout\u0026lt;\u0026lt;format(\u0026#34;Box created with value {}\\n\u0026#34;,value); } }; // Deduction guide for const char* Box(const char*)-\u0026gt;Box\u0026lt;std::string\u0026gt;; int main() { Box b(\u0026#34;hello\u0026#34;); return 0; } 添加了推断指引后，value为string类型\n例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename T\u0026gt; class Wrapper { public: T value; Wrapper(int v) : value(v) { cout \u0026lt;\u0026lt; format(\u0026#34;Wrapper({}) created\\n\u0026#34;, value); } // 构造函数参数是 int，但 T 可能是其他类型 }; // Deduction guide for Wrapper Wrapper(int)-\u0026gt;Wrapper\u0026lt;int\u0026gt;; int main() { Wrapper w(42); return 0; } 如果不添加推导指引，编译器会报错，\n1 2 3 error C2641: 无法推导“Wrapper”的模板参数 error C2783: “Wrapper\u0026lt;T\u0026gt; Wrapper(int)”: 无法推导“T”的 模板 参数 error C2784: “Wrapper\u0026lt;T\u0026gt; Wrapper(Wrapper\u0026lt;T\u0026gt;)”: 无法从“int”推导出“Wrapper\u0026lt;T\u0026gt;”的 模板 参数 当不添加推导指引时，可以手动使用尖括号指定T的类型，不需要依赖 类模板参数推导（CTAD） 或 deduction guide。\n1 Wrapper\u0026lt;int\u0026gt; w(42); 例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template\u0026lt;typename T\u0026gt; struct B { T m_b; T m_b2; }; template\u0026lt;typename T\u0026gt; B(T) -\u0026gt; B\u0026lt;T\u0026gt;; template\u0026lt;typename T\u0026gt; B(T, T) -\u0026gt; B\u0026lt;T\u0026gt;; int main() { B\u0026lt;int\u0026gt; bobj1; //需要明确指定模板参数类型 B\u0026lt;int\u0026gt; bobj2{ 15 }; //可以用初始化列表的方式来定义对象bobj2,成员变量m_b=15。 B bobj3{ 15 }; //无法推导B的模板参数 B bobj4{ 15,20 }; return 0; } 在C++17版本，不添加推断指引，编译错误.\nC++20版本，即使不写推断指引，也能自动推导，编译成功.\n模板类特化 全特化 说人话就是 模板里的参数被手动指定了，例如指定为 int和double\n偏特化 模板里的参数 只指定了一个为int，另一个还是T\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 主模板 template \u0026lt;typename T, typename U\u0026gt; class MyClass { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;主模板\u0026#34; \u0026lt;\u0026lt; endl; } }; // 全特化：T = int, U = double template \u0026lt;\u0026gt; class MyClass\u0026lt;int, double\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;全特化版本：T = int, U = double\u0026#34; \u0026lt;\u0026lt; endl; } }; // 偏特化：T = int, U 任意 template \u0026lt;typename U\u0026gt; class MyClass\u0026lt;int, U\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化版本：T = int, U 任意\u0026#34; \u0026lt;\u0026lt; endl; } }; // 偏特化：T 任意, U = double template \u0026lt;typename T\u0026gt; class MyClass\u0026lt;T, double\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化版本：U = double, T 任意\u0026#34; \u0026lt;\u0026lt; endl; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void TemA() { MyClass\u0026lt;char, char\u0026gt; obj1; obj1.print(); // 调用主模板 MyClass\u0026lt;int, double\u0026gt; obj2; obj2.print(); // 调用全特化版本 return 0; } void TemB() { MyClass\u0026lt;char, char\u0026gt; obj1; obj1.print(); // 调用主模板 MyClass\u0026lt;int, char\u0026gt; obj2; obj2.print(); // 调用偏特化版本：T = int, U 任意 MyClass\u0026lt;char, double\u0026gt; obj3; obj3.print(); // 调用偏特化版本：U = double, T 任意 return 0; } 函数定义也可以写在类外\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 主模板 template \u0026lt;typename T, typename U\u0026gt; class MyClass { public: void print(); }; template \u0026lt;typename T, typename U\u0026gt; void MyClass\u0026lt;T,U\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;主模板\u0026#34; \u0026lt;\u0026lt; endl; } // 全特化：T = float, U = double template \u0026lt;\u0026gt; class MyClass\u0026lt;float, double\u0026gt; { public: void print(); }; void MyClass\u0026lt;float,double\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;全特化 float, double\u0026#34; \u0026lt;\u0026lt; endl; } // 偏特化：T = int, U 任意 template \u0026lt;typename U\u0026gt; class MyClass\u0026lt;int, U\u0026gt; { public: void print(); }; template \u0026lt;typename U\u0026gt; void MyClass\u0026lt;int, U\u0026gt;::print() { cout \u0026lt;\u0026lt; \u0026#34;偏特化：T = int, U 任意\u0026#34; \u0026lt;\u0026lt; endl; } int main() { MyClass\u0026lt;float, float\u0026gt; Mclass; Mclass.print(); MyClass\u0026lt;float,double\u0026gt; Mclass2; Mclass2.print(); MyClass\u0026lt;int,int\u0026gt; Mclass1; Mclass1.print(); return 0; } 输出：\n1 2 3 主模板 全特化 float, double 偏特化：T = int, U 任意 成员函数模板 类模板中的成员函数，只有源程序代码中出现调用这些成员函数的代码时，这些成员函数才会出现在一个实例化了的类模板中。\n类模板中的成员函数模板，只有源程序代码中出现调用这些成员函数模板的代码时，这些成员函数模板的具体实例才会出现在一个实例化了的类模板中。\n目前编译器并不支持虚成员函数模板，因为虚函数表vtbl的大小是固定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u0026lt;typename T1\u0026gt; class A { public: template \u0026lt;typename T2\u0026gt; A(T2 v1, T2 v2); //构造函数模板，引入了自己的模板参数T2，与类A的模板参数T1没有关系 template \u0026lt;typename T3\u0026gt; void myft(T3 tmpt) //普通成员函数模板 { cout \u0026lt;\u0026lt; tmpt \u0026lt;\u0026lt; endl; } }; template \u0026lt;typename T1\u0026gt; template \u0026lt;typename T2\u0026gt; A\u0026lt;T1\u0026gt;::A(T2 v1, T2 v2) { cout \u0026lt;\u0026lt; \u0026#34;A::A(T2,T2)执行了!\u0026#34; \u0026lt;\u0026lt; endl; } int main() { A\u0026lt;int\u0026gt; A1(1,2); A1.myft(3); return 0; } 继承关系 CRTP\nCRTP（Curiously Recurring Template Pattern，奇特递归模板模式）是一种C++编程技术，通过使用模板和继承来实现静态多态性。与传统的运行时多态（通过虚函数实现）不同，CRTP可以在编译时进行优化，从而提高性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename Derived\u0026gt; class Base { public: void interface() { // 调用派生类的实现 static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;implementation(); } }; class Derived : public Base\u0026lt;Derived\u0026gt; { public: void implementation() { // 实现细节 } }; CRTP实现策略模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 策略接口 template \u0026lt;typename Derived\u0026gt; class Strategy { public: void execute() { static_cast\u0026lt;Derived*\u0026gt;(this)-\u0026gt;doExecute(); } }; // 具体策略A class ConcreteStrategyA : public Strategy\u0026lt;ConcreteStrategyA\u0026gt; { public: void doExecute() { std::cout \u0026lt;\u0026lt; \u0026#34;Executing strategy A\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体策略B class ConcreteStrategyB : public Strategy\u0026lt;ConcreteStrategyB\u0026gt; { public: void doExecute() { std::cout \u0026lt;\u0026lt; \u0026#34;Executing strategy B\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { ConcreteStrategyA strategyA; ConcreteStrategyB strategyB; strategyA.execute(); // 输出: Executing strategy A strategyB.execute(); // 输出: Executing strategy B return 0; } 这里的关键点在于派生类Derived在定义时将自己作为模板参数传递给了基类Base。这样做的好处是可以让基类访问到派生类的成员，同时保持一定的抽象层次和代码复用。\n实现机制\n静态绑定：由于所有操作都在编译期确定，因此避免了虚函数调用带来的间接性和开销。CRTP允许基类调用派生类的方法或访问其数据成员，而不需要通过虚函数表（vtable）。 类型识别：在CRTP中，基类通过模板参数知道它是为哪个具体的派生类实例化的。这使得基类可以根据不同的派生类提供不同的行为，而这些行为在编译期就已经确定。 接口扩展与策略模式：除了实现静态多态外，CRTP还常用于接口扩展和策略模式的实现。例如，可以为一个类添加额外的功能而不修改其原始定义。 C++23\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Base { void name(this auto\u0026amp;\u0026amp; self) { self.impl(); } }; struct D1 : Base { void impl() { cout\u0026lt;\u0026lt;\u0026#34;D1::impl() \\n\u0026#34;; } }; struct D2 : Base { void impl() { cout\u0026lt;\u0026lt;\u0026#34;D2::impl() \\n\u0026#34;; } }; int main() { D1 d1; d1.name(); D2 d2; d2.name(); } 混入\n通过模板混入技巧，我们可以在不修改基类的情况下，动态地为类添加新的功能。这种方式比继承更加灵活，因为它允许我们在编译时选择性地组合功能，而不需要创建复杂的继承层次结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 基类 class Base { public: void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Base is doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 混入类：添加日志功能 template \u0026lt;typename T\u0026gt; class LoggingMixin : public T { public: void doSomethingWithLog() { std::cout \u0026lt;\u0026lt; \u0026#34;Logging: Before doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; T::doSomething(); // 调用基类的功能 std::cout \u0026lt;\u0026lt; \u0026#34;Logging: After doing something.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 使用混入类扩展 Base 的功能 LoggingMixin\u0026lt;Base\u0026gt; obj; // 调用扩展后的功能 obj.doSomethingWithLog(); return 0; } 结果\n1 2 3 Logging: Before doing something. Base is doing something. Logging: After doing something. 基类 Base：这是一个普通的类，有一个 doSomething 方法。\n混入类 LoggingMixin：这是一个模板类，继承自模板参数 T。它添加了一个新的方法 doSomethingWithLog，在调用基类的 doSomething 方法前后添加了日志输出。\n使用混入类：在 main 函数中，我们通过 LoggingMixin\u0026lt;Base\u0026gt; 创建了一个对象 obj。这个对象既拥有 Base 的功能，又拥有 LoggingMixin 添加的日志功能。\nMixin 模式非常适合以下场景：\n功能扩展：当你需要为现有类添加新功能而不修改其源代码时。 模块化设计：通过将不同功能分离到不同的 Mixin 类中，使代码更加模块化和易于维护。 代码复用：Mixin 类可以被多个不同的类复用，减少了重复代码。 灵活性：通过多重继承或模板组合，可以在不修改原始类的情况下灵活地组合多种功能。 然而，需要注意的是，过多的多重继承可能会导致复杂的继承层次结构，增加代码理解和维护的难度。因此，在使用 Mixin 时应权衡其优点和潜在的复杂性。结合 CRTP（Curiously Recurring Template Pattern）等技术，可以进一步增强 Mixin 的功能和控制力。\n变量模板 C++14，允许定义模板化的常量或变量。通过变量模板，可以在编译时生成不同类型的常量或变量实例，并且可以简化代码，提高可读性和维护性。\n例1：使用变量模板表示某个类型的最小值\n1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T\u0026gt; constexpr T min_value = std::numeric_limits\u0026lt;T\u0026gt;::min(); template\u0026lt;typename T\u0026gt; constexpr T max_value = std::numeric_limits\u0026lt;T\u0026gt;::max(); cout \u0026lt;\u0026lt; \u0026#34;Min value for unsigned short: \u0026#34; \u0026lt;\u0026lt; min_value\u0026lt;unsigned short\u0026gt; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Max value for unsigned short: \u0026#34; \u0026lt;\u0026lt; max_value\u0026lt;unsigned short\u0026gt; \u0026lt;\u0026lt; endl; cout\u0026lt;\u0026lt;format(\u0026#34;Min value for unsigned short: {}\\nMax value for unsigned short: {}\\n\u0026#34;, min_value\u0026lt;unsigned short\u0026gt;, max_value\u0026lt;unsigned short\u0026gt;); 例2：数字常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;typename T\u0026gt; constexpr T pi = T(3.1415926535897932385L); // 定义一个函数模板，计算圆的面积 template\u0026lt;typename T\u0026gt; T circle_area(T radius) { return pi\u0026lt;T\u0026gt; * radius * radius; } cout \u0026lt;\u0026lt; \u0026#34;Pi (double): \u0026#34; \u0026lt;\u0026lt; pi\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Pi (float): \u0026#34; \u0026lt;\u0026lt; pi\u0026lt;float\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Area of a circle with radius 5 (double): \u0026#34; \u0026lt;\u0026lt; circle_area(5.0) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Area of a circle with radius 5 (float): \u0026#34; \u0026lt;\u0026lt; circle_area(5.0f) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 例3：类型特性\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; constexpr bool is_integer = std::is_integral_v\u0026lt;T\u0026gt;; cout \u0026lt;\u0026lt; \u0026#34;Is int an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;int\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Is double an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;double\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Is char an integer type? \u0026#34; \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; is_integer\u0026lt;char\u0026gt; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;typename T\u0026gt; T Value{}; int main() { Value\u0026lt;int\u0026gt; = 10; cout \u0026lt;\u0026lt; format(\u0026#34;Value = {}\\n\u0026#34;, Value\u0026lt;int\u0026gt;); Value\u0026lt;string\u0026gt; = \u0026#34;Hello\u0026#34;; cout \u0026lt;\u0026lt; format(\u0026#34;Value = {}\\n\u0026#34;, Value\u0026lt;string\u0026gt;); cout \u0026lt;\u0026lt; format(\u0026#34;Value\u0026lt;int\u0026gt; = {} Value\u0026lt;string\u0026gt; = {}\\n\u0026#34;, Value\u0026lt;int\u0026gt;, Value\u0026lt;string\u0026gt;); return 0; } 进阶 模板模板参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 template\u0026lt;typename T,template\u0026lt;typename\u0026gt; typename Vec = std::vector\u0026gt; class Obj { public: Vec\u0026lt;T\u0026gt; vec; Obj() { cout \u0026lt;\u0026lt; format(\u0026#34;{}\u0026#34;,typeid(T).name()) \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; ++i) { vec.push_back(i); } } void print() { for (auto i : vec) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt; endl; } }; int main() { Obj\u0026lt;int\u0026gt; Ob; Ob.print(); return 0; } //输出： //int //0 1 2 3 4 5 6 7 8 9 使用模板模板参数 打印各种不同容器的元素\n1 2 3 4 5 6 7 8 9 template \u0026lt;template \u0026lt;typename, typename\u0026gt; class Container, typename T, typename Allocator\u0026gt; void printContainer(const Container\u0026lt;T, Allocator\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 打印vector 以及 模板实例化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::vector\u0026lt;int\u0026gt; vec = { 1, 2, 3, 4 }; printContainer(vec); // 模板实例化的代码 //template \u0026lt;typename, typename\u0026gt; class Container, typename T, typename Allocator // Container = std::vector // T = int // Allocator = Allocator\u0026lt;int\u0026gt; void printContainer(const std::vector\u0026lt;int, std::allocator\u0026lt;int\u0026gt;\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 打印list 以及 模板实例化\n1 2 3 4 5 6 7 8 9 10 11 std::list\u0026lt;double\u0026gt; lst = { 1.1, 2.2, 3.3 }; printContainer(lst); //模板实例化 void printContainer(const std::list\u0026lt;double, std::allocator\u0026lt;double\u0026gt;\u0026gt;\u0026amp; container) { for (const auto\u0026amp; elem : container) { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 模板参数推导： 编译器根据传入的容器类型（如 std::vector\u0026lt;int\u0026gt; 或 std::list\u0026lt;double\u0026gt;）推导出模板参数 Container、T 和 Allocator。 默认模板参数： std::vector 和 std::list 的第二个模板参数（分配器）是默认的 std::allocator\u0026lt;T\u0026gt;，因此不需要显式指定。 万能引用 万能引用（Universal Reference） 是 C++11 引入的一个概念，通常与 \u0026amp;\u0026amp; 和模板结合使用。它允许函数模板接受任意类型的参数（左值或右值），并根据传入的参数类型自动推导出正确的引用类型。万能引用的典型应用是实现完美转发（Perfect Forwarding）。\n右值与移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 函数模板，使用万能引用 template \u0026lt;typename T\u0026gt; void print(T\u0026amp;\u0026amp; value) { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { int x = 10; const std::string str = \u0026#34;Hello\u0026#34;; // 传递左值 print(x); // T 推导为 int\u0026amp; print(str); // T 推导为 const std::string\u0026amp; // 传递右值 print(42); // T 推导为 int print(std::string(\u0026#34;World\u0026#34;)); // T 推导为 std::string return 0; } 万能引用的语法： T\u0026amp;\u0026amp; 是万能引用的语法形式。 当 T 是一个模板参数时，T\u0026amp;\u0026amp; 可以根据传入的参数类型推导出左值引用或右值引用。 类型推导： 如果传入的是一个左值（如 x 或 str），T 会被推导为左值引用类型（如 int\u0026amp; 或 const std::string\u0026amp;）。 如果传入的是一个右值（如 42 或 std::string(\u0026quot;World\u0026quot;)），T 会被推导为值类型（如 int 或 std::string）。 输出结果： 无论传入左值还是右值，print 函数都能正确处理并输出。 完美转发\n将参数以原始类型（左值或右值）传递给另一个函数。以下是一个完美转发的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void process(int\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing lvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } void process(int\u0026amp;\u0026amp; x) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing rvalue: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } // 转发函数模板 template \u0026lt;typename T\u0026gt; void forwarder(T\u0026amp;\u0026amp; arg) { process(std::forward\u0026lt;T\u0026gt;(arg)); // 使用 std::forward 完美转发 } int main() { int x = 10; // 传递左值 forwarder(x); // 调用 process(int\u0026amp;) // 传递右值 forwarder(20); // 调用 process(int\u0026amp;\u0026amp;) return 0; } std::forward： std::forward\u0026lt;T\u0026gt;(arg) 用于保持参数的原始类型（左值或右值）。 如果 arg 是一个左值，std::forward 会将其转发为左值。 如果 arg 是一个右值，std::forward 会将其转发为右值。 完美转发的作用： 通过万能引用和 std::forward，forwarder 函数可以将参数以原始类型传递给 process 函数，确保调用正确的重载版本。 输出：\n1 2 Processing lvalue: 10 Processing rvalue: 20 总结\n万能引用（T\u0026amp;\u0026amp;）允许函数模板接受任意类型的参数（左值或右值）。 通过 std::forward，可以实现完美转发，保留参数的原始类型。 万能引用是 C++11 中实现通用代码和高效资源管理的重要工具。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // Person 类 class Person { public: // 构造函数，接受 std::string 参数 explicit Person(const string\u0026amp; name) : name_(name) { cout \u0026lt;\u0026lt; \u0026#34;Person 左值创建：: \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } explicit Person(string\u0026amp;\u0026amp; name) : name_(std::move(name)) { cout \u0026lt;\u0026lt; \u0026#34;Person 右值创建：: \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } void greet() const { cout \u0026lt;\u0026lt; \u0026#34;Hello, my name is \u0026#34; \u0026lt;\u0026lt; name_ \u0026lt;\u0026lt; endl; } private: string name_; }; using PersonPtr = std::unique_ptr\u0026lt;Person\u0026gt;; // 工厂函数模板，使用完美转发 template \u0026lt;typename T\u0026gt; PersonPtr createPerson(T\u0026amp;\u0026amp; name) { return std::make_unique\u0026lt;Person\u0026gt;(std::forward\u0026lt;T\u0026gt;(name)); } int main() { std::string lvalueName = \u0026#34;Alice\u0026#34;; // 使用左值创建 Person auto person1 = createPerson(lvalueName); // 调用 Person(const std::string\u0026amp;) // 使用右值创建 Person auto person2 = createPerson(\u0026#34;Bob\u0026#34;); // 调用 Person(std::string\u0026amp;\u0026amp;) // 使用右值（移动语义）创建 Person auto person3 = createPerson(std::move(lvalueName)); // 调用 Person(std::string\u0026amp;\u0026amp;) // 检查 lvalueName 是否被移动， 左值移动后 这个字符串应该为空 std::cout \u0026lt;\u0026lt; \u0026#34;lvalueName after move: \u0026#34; \u0026lt;\u0026lt; lvalueName \u0026lt;\u0026lt; endl; return 0; } 移动语义是一种优化技术，允许我们将资源（如动态内存、文件句柄等）从一个对象“转移”到另一个对象，而不是进行昂贵的拷贝操作。对于 std::string 来说，移动操作会将字符串的内部指针（指向字符数据的指针）从源对象转移到目标对象，同时将源对象置于有效但未定义的状态（通常是空字符串）。std::move 将 lvalueName 转换为右值，从而触发移动语义。移动后，lvalueName 的内容被转移到 Person 对象的构造函数中，而 lvalueName 本身会变为空字符串。如果输出是空值，说明 lvalueName 的内容已经被成功移动。\nSFINAE SFINAE C++模板编程中的一个重要概念，它的核心思想是：在模板推导过程中，如果某个替换失败了，编译器不会报错，而是简单地忽略这个候选，继续尝试其他可行的模板。SFINAE 通常用于在编译时根据类型特性选择不同的函数重载或模板特化。\nenable_if\nstd::enable_if 是C++模板编程中的一个工具，主要用于基于某些条件启用或禁用模板的实例化。它通常用来实现SFINAE原则，允许编译器根据表达式的有效性来选择不同的函数重载或类模板特化。\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; struct enable_if {}; // no member \u0026#34;type\u0026#34; when !_Test template \u0026lt;class _Ty\u0026gt; struct enable_if\u0026lt;true, _Ty\u0026gt; { // type is _Ty for _Test using type = _Ty; }; 当 _Test 为 true 时，std::enable_if\u0026lt;_Test,_Ty\u0026gt;::type 存在，并等于 T 类型。 当 _Test 为 false 时，std::enable_if\u0026lt;_Test,_Ty\u0026gt;::type 不存在，这会导致试图使用它的代码无法编译。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std::enable_if\u0026lt;true\u0026gt;::type; //可用作类型，其type是void类型. //等同于 using std::enable_if\u0026lt;true,void\u0026gt;::type = void std::enable_if\u0026lt;true\u0026gt;::type func() { cout \u0026lt;\u0026lt; \u0026#34;func\\n\u0026#34;; } //std::enable_if\u0026lt;true\u0026gt;::type func() // 二者相等 //void func() std::enable_if\u0026lt;false\u0026gt;::type; //类 \u0026#34;std::enable_if\u0026lt;false, void\u0026gt;\u0026#34; 没有成员 \u0026#34;type\u0026#34; 测试第一个模板参数bool _Test\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename T\u0026gt; enable_if\u0026lt;(sizeof(T)\u0026gt;2)\u0026gt;::type Func() { } int main() { Func\u0026lt;int\u0026gt;(); Func\u0026lt;char\u0026gt;(); return 0; } 第一个Func，int大于2，enable_if为true，true的特化版本有type成员，可以编译，函数匹配成功第二个Func，char小于2，enable_if为false，它没有type成员，忽略这个模板函数，寻找其它合适的函数，但没有合适的其它模板函数，函数匹配失败 所以报错\n1 2 error C2672: “Func”: 未找到匹配的重载函数 type Func(void)”的显式 模板 参数无效 enable_if_t简化版本，不用写::type\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; using enable_if_t = typename enable_if\u0026lt;_Test, _Ty\u0026gt;::type; template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;(sizeof(T)\u0026gt;2)\u0026gt; Func() { } 以上是第一个bool参数的实现，还有第二个参数_Ty\n1 2 3 4 5 6 7 8 _EXPORT_STD template \u0026lt;bool _Test, class _Ty = void\u0026gt; struct enable_if {}; // no member \u0026#34;type\u0026#34; when !_Test template \u0026lt;class _Ty\u0026gt; struct enable_if\u0026lt;true, _Ty\u0026gt; { // type is _Ty for _Test using type = _Ty; }; _Ty默认是void，也就是上面例子中void func 中的 void 的来历，\n1 2 3 4 5 6 7 8 9 10 11 12 enable_if_t\u0026lt;(sizeof(int) \u0026gt; 2),int\u0026gt; D = 3; //等同于using std::enable_if\u0026lt;true,int\u0026gt; = int int D = 3; template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;(sizeof(T)\u0026gt;2),T\u0026gt; Func() { } Func\u0026lt;int\u0026gt;(); //函数为: int Func\u0026lt;int\u0026gt;(); 例1:\n考虑需要根据类型的属性定义不同版本的函数。比如，你可能想要一个只适用于整数类型的加法函数和一个适用于浮点类型的加法函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 仅当 T 是整数类型时此函数才有效 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, T\u0026gt;::type add(T a, T b) { cout\u0026lt;\u0026lt; \u0026#34;Add integer \\n\u0026#34;; return a + b; } // 仅当 T 是浮点类型时此函数才有效 template\u0026lt;typename T\u0026gt; typename std::enable_if\u0026lt;std::is_floating_point\u0026lt;T\u0026gt;::value, T\u0026gt;::type add(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;Add float \\n\u0026#34;; return a + b; } int main() { add(3,2); add(3.0,2.0); return 0; } 输出\n1 2 Add integer Add float 简化写法 使用enable_if_t\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 仅当 T 是整数类型时此函数才有效 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, T\u0026gt; add(T a, T b) { cout\u0026lt;\u0026lt; \u0026#34;Add integer \\n\u0026#34;; return a + b; } // 仅当 T 是浮点类型时此函数才有效 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_floating_point\u0026lt;T\u0026gt;::value, T\u0026gt; add(T a, T b) { cout \u0026lt;\u0026lt; \u0026#34;Add float \\n\u0026#34;; return a + b; } 标准库 std::declval std::declval 是 C++ 标准库中的一个工具，通常用于在编译时生成某个类型的假想值，以便在不实际创建对象的情况下进行类型推导或表达式求值。它主要用于模板元编程和 SFINAE场景中。主要作用是在编译时模拟一个类型的对象，从而可以在不实际构造对象的情况下推导表达式的类型或检查表达式的合法性。std::declval 通常与 decltype 一起使用，用于推导表达式的类型。\n1 2 template \u0026lt;class T\u0026gt; typename std::add_rvalue_reference\u0026lt;T\u0026gt;::type declval() noexcept; 它声明了一个返回类型为 T 的右值引用的函数，但这个函数不应该被调用。其目的仅在于帮助编译器推导类型。 从 C++14 开始，可以使用 std::declval\u0026lt;T\u0026gt;() 更简洁地表示相同的意思，其中 std::declval_t\u0026lt;T\u0026gt; 直接给出了 T 类型的右值引用。 add_rvalue_reference：是C++标准库中的类模板，他的能力是给进来一个类型，他能够返回该类型的右值引用类型。比如： a)给进来一个int类型,返回的就是int \u0026amp;\u0026amp; b)给进来一个int \u0026amp;类型，返回的还是int \u0026amp;类型。这里用到了引用折叠。 c)给进来一个int \u0026amp;\u0026amp;类型，返回的还是int \u0026amp;\u0026amp;类型。这里依旧用到了引用折叠知识。\n示例：基本用法\n假设我们有一个类 MyClass，它有一个成员函数 int foo()。我们想要在不实际创建 MyClass 对象的情况下，推导 foo() 函数的返回类型。\n1 2 int a = 10; decltype(a) b = a; // b 的类型是 int，因为 a 的类型是 int declval + decltype:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyClass { public: MyClass() {cout \u0026lt;\u0026lt; \u0026#34;MyClass constructor called\u0026#34; \u0026lt;\u0026lt; endl;} int foo() { return 42; } }; int main() { // 使用 std::declval 来模拟一个 MyClass 对象，并推导 foo() 的返回类型 using FooReturnType = decltype(std::declval\u0026lt;MyClass\u0026gt;().foo()); // 检查推导的类型是否是 int static_assert(std::is_same\u0026lt;FooReturnType, int\u0026gt;::value, \u0026#34;Foo return type should be int\u0026#34;); return 0; } 在这个过程中MyClass的构造函数不会被调用\nstd::true_type std::true_type 和 std::false_type 是 C++ 标准库中的类型，分别表示编译时的布尔值 true 和 false。它们是类型特征（type traits）的基础，通常用于模板元编程和编译时逻辑判断。\nstd::true_type 和 std::false_type 是类型别名，分别表示 true 和 false 的编译时常量。\n它们的主要作用是在编译时进行逻辑判断，例如通过模板特化或 SFINAE来实现条件编译或类型检查。\nstd::true_type 和 std::false_type 通常与 std::is_same、std::enable_if 等类型特征一起使用。\n它们可以通过 value 成员访问其布尔值（true 或 false）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 _EXPORT_STD using true_type = bool_constant\u0026lt;true\u0026gt;; _EXPORT_STD using false_type = bool_constant\u0026lt;false\u0026gt;; //true_type 拥有成员value //true_type 和 false_type 都继承自bool_constant template \u0026lt;bool _Val\u0026gt; using bool_constant = integral_constant\u0026lt;bool, _Val\u0026gt;; //bool_constant继承自integral_constant template \u0026lt;class _Ty, _Ty _Val\u0026gt; struct integral_constant { static constexpr _Ty value = _Val; using value_type = _Ty; using type = integral_constant; constexpr operator value_type() const noexcept { return value; } _NODISCARD constexpr value_type operator()() const noexcept { return value; } }; 示例1：模板特化\n假设我们有一个模板函数，它需要根据类型是否为指针来决定如何处理该类型的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 模板函数的基础版本，处理非指针类型 template\u0026lt;typename T\u0026gt; void processData(T data, std::false_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing non-pointer data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } // 模板函数的特化版本，处理指针类型 template\u0026lt;typename T\u0026gt; void processData(T* data, std::true_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing pointer data: \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; std::endl; } int main() { int a = 42; int* b = \u0026amp;a; // 对于非指针类型，使用 std::false_type processData(a, std::is_pointer\u0026lt;decltype(a)\u0026gt;{}); // 对于指针类型，使用 std::true_type processData(b, std::is_pointer\u0026lt;decltype(b)\u0026gt;{}); return 0; } processData 函数有两个重载版本：一个用于处理非指针类型，另一个用于处理指针类型。 std::is_pointer\u0026lt;T\u0026gt;::type 返回 std::true_type 或 std::false_type，取决于 T 是否是指针类型。 在 main 函数中，通过 std::is_pointer\u0026lt;decltype(a)\u0026gt; 和 std::is_pointer\u0026lt;decltype(b)\u0026gt; 来区分 a 和 b 的类型，并选择合适的 processData 版本。 1 2 3 //输出结果 Processing non-pointer data: 42 Processing pointer data: 42 示例 2：自定义类型特征\n以下示例展示了如何自定义一个类型特征，用于检查类型是否为指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 主模板：默认情况下，T 不是指针 template \u0026lt;typename T\u0026gt; struct IsPointer : std::false_type {}; // 特化模板：如果 T 是指针，继承 std::true_type template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; : std::true_type {}; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Is int* a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int*\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) std::cout \u0026lt;\u0026lt; \u0026#34;Is int a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) return 0; } 示例 3: SFINAE 中的应用\n假设我们需要一个函数模板，仅当类型 T 是整数类型时才有效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 仅对整数类型有效的函数模板 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value, void\u0026gt; printIfIntegral(T value, std::true_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Integer value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 如果类型不是整数，则不会实例化此函数 template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;!std::is_integral\u0026lt;T\u0026gt;::value, void\u0026gt; printIfIntegral(T value, std::false_type) { std::cout \u0026lt;\u0026lt; \u0026#34;Non-integer value\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { int a = 10; double b = 3.14; printIfIntegral(a, std::is_integral\u0026lt;decltype(a)\u0026gt;{}); printIfIntegral(b, std::is_integral\u0026lt;decltype(b)\u0026gt;{}); return 0; } printIfIntegral 函数有两个模板版本，分别针对整数类型和非整数类型。 std::enable_if 结合 std::is_integral 来控制哪个版本会被实例化。 通过传递 std::is_integral\u0026lt;decltype(a)\u0026gt;{} 或 std::is_integral\u0026lt;decltype(b)\u0026gt;{} 来选择合适的函数版本。 输出\n1 2 Integer value: 10 Non-integer value 总结\nstd::true_type 和 std::false_type 提供了一种简洁的方式来进行编译时的条件判断，特别适用于模板元编程中的类型选择和函数重载。通过结合其他类型特征工具（如 std::is_integral），可以在编译期实现复杂的行为控制和优化。\nstd::function C++11 引入的一个通用函数包装器，用于存储、复制和调用任何可调用对象（如函数、Lambda 表达式、函数对象等）。它提供了一种类型安全的方式来处理各种可调用对象，使得代码更加灵活和通用。\n统一接口：std::function 可以包装任何可调用对象，提供一个统一的接口来调用它们。 类型安全：通过模板参数指定函数签名，确保调用时参数和返回值的类型正确。 灵活性：可以在运行时动态地绑定不同的可调用对象。 1 std::function\u0026lt;返回类型(函数参数....)\u0026gt; 示例 1：包装普通函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int add(int a, int b) { return a + b; } int main() { // 包装一个普通函数 std::function\u0026lt;int(int, int)\u0026gt; func = add; // 调用包装的函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(2, 3) \u0026lt;\u0026lt; std::endl; // 输出 5 return 0; } std::function\u0026lt;int(int, int)\u0026gt; 定义了一个函数包装器，可以存储任何接受两个 int 参数并返回 int 的可调用对象。 func(2, 3) 调用包装的函数。 示例 2：包装 Lambda 表达式\nLambda 表达式也是可调用对象，可以直接存储在 std::function 中。\n1 2 3 4 5 6 7 8 9 // 包装一个 Lambda 表达式 std::function\u0026lt;int(int, int)\u0026gt; func = [](int a, int b) { return a * b; }; // 调用包装的 Lambda 表达式 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(2, 3) \u0026lt;\u0026lt; std::endl; // 输出 6 示例 3: 包装成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyClass { public: int add(int a, int b) { return a + b; } }; int main() { MyClass obj; // 包装一个成员函数 std::function\u0026lt;int(MyClass\u0026amp;, int, int)\u0026gt; func = \u0026amp;MyClass::add; // 调用包装的成员函数 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; func(obj, 2, 3) \u0026lt;\u0026lt; std::endl; // 输出 5 return 0; } \u0026amp;MyClass::add 是成员函数的指针。 std::function\u0026lt;int(MyClass\u0026amp;, int, int)\u0026gt; 的第一个参数是对象实例（MyClass\u0026amp;），后面是成员函数的参数。 示例4：作为回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 模拟一个异步任务，完成后调用回调函数 void asyncTask(std::function\u0026lt;void(int)\u0026gt; callback) { int result = 42; // 模拟任务结果 callback(result); // 调用回调函数 } int main() { // 定义一个回调函数 std::function\u0026lt;void(int)\u0026gt; callback = [](int result) { std::cout \u0026lt;\u0026lt; \u0026#34;Task completed with result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; }; // 执行异步任务 asyncTask(callback); // 输出 \u0026#34;Task completed with result: 42\u0026#34; return 0; } asyncTask 接受一个 std::function\u0026lt;void(int)\u0026gt; 类型的回调函数。 在任务完成后，调用回调函数并传递结果。 std::remove_all_extents 是C++ 标准库中的一个类型特征（type trait），用于移除数组类型的所有维度，最终得到数组元素的类型。它的主要作用是简化对多维数组类型的处理。\n移除数组类型的所有维度：如果传入的类型是多维数组（例如 int[3][4]），它会递归地移除所有维度，最终得到数组元素的类型（例如 int）。 简化类型处理：在处理数组类型时，可以直接获取其底层元素类型，而不需要手动解析数组的维度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;typename T\u0026gt; struct remove_all_extents { using type = T; }; template \u0026lt;typename T\u0026gt; struct remove_all_extents\u0026lt;T[]\u0026gt; { using type = typename remove_all_extents\u0026lt;T\u0026gt;::type; }; template \u0026lt;typename T, std::size_t N\u0026gt; struct remove_all_extents\u0026lt;T[N]\u0026gt; { using type = typename remove_all_extents\u0026lt;T\u0026gt;::type; }; 主模板：如果 T 不是数组类型，则直接返回 T。 特化模板：如果 T 是数组类型（如 T[] 或 T[N]），则递归地移除维度，直到得到非数组类型。 示例 1：移除一维数组的维度\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; // 包含 std::remove_all_extents int main() { using ArrayType = int[10]; using ElementType = std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;ArrayType: \u0026#34; \u0026lt;\u0026lt; typeid(ArrayType).name() \u0026lt;\u0026lt; std::endl; // 输出 int [10] std::cout \u0026lt;\u0026lt; \u0026#34;ElementType: \u0026#34; \u0026lt;\u0026lt; typeid(ElementType).name() \u0026lt;\u0026lt; std::endl; // 输出 int return 0; } ArrayType 是 int[10]，表示一个包含 10 个 int 元素的数组。 std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type 移除数组维度，得到 int。 如果传入的类型不是数组类型，std::remove_all_extents 会直接返回该类型。 示例2：结合 std::is_same 进行类型检查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { using ArrayType = double[10][20]; using ElementType = std::remove_all_extents\u0026lt;ArrayType\u0026gt;::type; // 检查 ElementType 是否是 double if (std::is_same\u0026lt;ElementType, double\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;ElementType is double!\u0026#34; \u0026lt;\u0026lt; std::endl; // 输出 \u0026#34;ElementType is double!\u0026#34; } else { std::cout \u0026lt;\u0026lt; \u0026#34;ElementType is not double!\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 萃取 类型萃取：从复杂类型（如指针、引用、数组等）中提取基础类型。 参数包萃取：从可变参数模板中提取特定参数。 主要用途\n类型萃取：用于获取类型的基本信息，例如去除引用、指针、cv限定符（const和volatile），或者从数组类型中提取元素类型。 参数包萃取：用于处理可变参数模板，从中提取特定参数进行操作。 类型别名 示例：为不同类型定义不同的求和结果类型\n假设我们需要实现一个通用的求和功能，但不同的类型在求和时可能需要不同的结果类型。例如：\n对于 char 类型，求和结果应该是 int，因为 char 的范围较小，直接相加可能导致溢出。 对于 int 类型，求和结果可以是 int 本身。 对于 double 类型，求和结果可以是 double 本身。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 主模板：默认情况下，求和类型为 T 本身 template \u0026lt;typename T\u0026gt; struct SumTraits { using sumT = T; // 默认求和类型为 T }; // 特化模板：针对 char 类型，求和类型为 int template \u0026lt;\u0026gt; struct SumTraits\u0026lt;char\u0026gt; { using sumT = int; // char 的求和类型为 int }; // 特化模板：针对 int 类型，求和类型为 int template \u0026lt;\u0026gt; struct SumTraits\u0026lt;int\u0026gt; { using sumT = int; // int 的求和类型为 int }; // 特化模板：针对 double 类型，求和类型为 double template \u0026lt;\u0026gt; struct SumTraits\u0026lt;double\u0026gt; { using sumT = double; // double 的求和类型为 double }; //--------------------------------// // 通用的求和函数 template \u0026lt;typename T\u0026gt; typename SumTraits\u0026lt;T\u0026gt;::sumT sum(T a, T b) { return a + b; } int main() { // 测试 char 类型 char c1 = 100, c2 = 100; auto resultChar = sum(c1, c2); cout \u0026lt;\u0026lt; \u0026#34;char sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultChar).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;char sum result: \u0026#34; \u0026lt;\u0026lt; resultChar \u0026lt;\u0026lt; endl; // 输出 200 // 测试 int 类型 int i1 = 100, i2 = 200; auto resultInt = sum(i1, i2); cout \u0026lt;\u0026lt; \u0026#34;int sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultInt).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;int sum result: \u0026#34; \u0026lt;\u0026lt; resultInt \u0026lt;\u0026lt; endl; // 输出 300 // 测试 double 类型 double d1 = 100.5, d2 = 200.5; auto resultDouble = sum(d1, d2); cout \u0026lt;\u0026lt; \u0026#34;double sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultDouble).name() \u0026lt;\u0026lt; endl; // 输出 double cout \u0026lt;\u0026lt; \u0026#34;double sum result: \u0026#34; \u0026lt;\u0026lt; resultDouble \u0026lt;\u0026lt; endl; // 输出 301.0 return 0; } 分析：\n1 2 3 4 5 // 测试 char 类型 char c1 = 100, c2 = 100; auto resultChar = sum(c1, c2); cout \u0026lt;\u0026lt; \u0026#34;char sum result type: \u0026#34; \u0026lt;\u0026lt; typeid(resultChar).name() \u0026lt;\u0026lt; endl; // 输出 int cout \u0026lt;\u0026lt; \u0026#34;char sum result: \u0026#34; \u0026lt;\u0026lt; resultChar \u0026lt;\u0026lt; endl; // 输出 200 sum的返回类型是 SumTraits\u0026lt;T\u0026gt;::sumT, 根据特化模板，sum(char,char)的返回类型 即sumT ，将被推断为int，因此 针对char相加的情况， sum函数的返回类型是int, 所以变量resultChar的类型是int后面的两行cout，一个输出相加结果的类型名称，一个输出相加结果的值.\n总结\n类型别名（using）：通过 using 可以为类型定义别名，使代码更具可读性和灵活性。 模板特化：通过特化模板，可以为不同的类型定义不同的别名。 适用场景：当需要根据类型定制行为时（如返回值类型、参数类型等），可以使用 using 和模板特化。 优势：这种方式使代码更具通用性和可扩展性，能够轻松支持新的类型。 通过这个例子，我们可以看到 using 和模板特化的强大之处：它们能够根据类型的不同，自动选择合适的行为，从而实现高度灵活和可复用的代码。\n萃取元素类型-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 主模板：默认情况下，尝试通过 value_type 萃取元素类型 template \u0026lt;typename T\u0026gt; struct ElementType { using type = typename T::value_type; // 假设 T 有 value_type 成员 }; int main() { // 测试 std::vector using Vector = std::vector\u0026lt;int\u0026gt;; using VectorElement = ElementType\u0026lt;Vector\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;Element type of std::vector\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; typeid(VectorElement).name() \u0026lt;\u0026lt; std::endl; // 输出 int // 测试 std::list using List = std::list\u0026lt;double\u0026gt;; using ListElement = ElementType\u0026lt;List\u0026gt;::type; std::cout \u0026lt;\u0026lt; \u0026#34;Element type of std::list\u0026lt;double\u0026gt;: \u0026#34; \u0026lt;\u0026lt; typeid(ListElement).name() \u0026lt;\u0026lt; std::endl; // 输出 double return 0; } 萃取元素类型-2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template \u0026lt;typename T\u0026gt; struct GetEleType; //特化版本 template \u0026lt;typename T\u0026gt; struct GetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct GetEleType\u0026lt;std::list\u0026lt;T\u0026gt;\u0026gt; { using type = T; }; template \u0026lt;typename T, std::size_t Size\u0026gt; //这个特化版本增加了一个模板参数 struct GetEleType\u0026lt;T[Size]\u0026gt; //萃取出数组元素个数 { using type = T; static const std::size_t size = Size; }; int main() { using vectordouble = GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;vector\u0026lt;double\u0026gt;的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(vectordouble).name() \u0026lt;\u0026lt; endl; using listint = GetEleType\u0026lt;std::list\u0026lt;int\u0026gt; \u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;list\u0026lt;int\u0026gt;的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(listint).name() \u0026lt;\u0026lt; endl; using float45 = GetEleType\u0026lt; float[45] \u0026gt;::type; cout \u0026lt;\u0026lt; \u0026#34;float[45]的元素类型为：\u0026#34; \u0026lt;\u0026lt; typeid(float45).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float[45]的数组元素数量为：\u0026#34; \u0026lt;\u0026lt; GetEleType\u0026lt; float[45] \u0026gt;::size \u0026lt;\u0026lt; endl; return 0; } 模板参数匹配机制：第一个例子 using vectordouble = GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type;，看上去好像并没有把double传给GetEleType，double只是被传给了vector，但是它能够匹配到正确的GetEleType特化版本，\n实际上这是由 C++ 的 模板特化机制 和 模板参数推导规则 决定的，\nGetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; 的特化版本中有两个 T，分别是：\n模板参数 typename T：这是模板的通用参数，表示任意类型。 特化类型 std::vector\u0026lt;T\u0026gt;：这是特化版本的具体类型，表示 std::vector 的模板参数。 这两个 T 是同一个类型，因为它们是通过模板参数推导确定的。\n使用 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; 时，编译器会按照以下顺序确定 T 的具体类型：\n匹配特化版本： 编译器看到 std::vector\u0026lt;double\u0026gt;，发现它是一个 std::vector\u0026lt;T\u0026gt; 类型。 因此，编译器会尝试匹配特化版本 GetEleType\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;。 推导模板参数： 编译器将 std::vector\u0026lt;double\u0026gt; 与 std::vector\u0026lt;T\u0026gt; 进行比较。 由于 std::vector\u0026lt;double\u0026gt; 是 std::vector\u0026lt;T\u0026gt; 的一个实例化版本，编译器可以推导出 T = double。 实例化特化版本： 编译器将 T 替换为 double，实例化出 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;。 在特化版本中，using type = T; 被替换为 using type = double;。 提取类型： 通过 GetEleType\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt;::type，你可以得到 double 类型。 类型萃取 简单的示例：实现一个类型萃取工具 IsPointer，用于判断一个类型是否为指针类型。\n定义主模板：默认情况下，类型不是指针类型，value 为 false。 特化模板：针对指针类型（T*），特化模板并将 value 设为 true。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; // 用于对比标准库的实现 // 主模板：默认情况下，类型不是指针 template \u0026lt;typename T\u0026gt; struct IsPointer { static constexpr bool value = false; }; // 特化模板：针对指针类型 T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;T*\u0026gt; { static constexpr bool value = true; }; int main() { // 测试 int std::cout \u0026lt;\u0026lt; \u0026#34;Is int a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) // 测试 int* std::cout \u0026lt;\u0026lt; \u0026#34;Is int* a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int*\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) // 测试 int** std::cout \u0026lt;\u0026lt; \u0026#34;Is int** a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;int**\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 1 (true) // 测试 std::string std::cout \u0026lt;\u0026lt; \u0026#34;Is std::string a pointer? \u0026#34; \u0026lt;\u0026lt; IsPointer\u0026lt;std::string\u0026gt;::value \u0026lt;\u0026lt; std::endl; // 输出 0 (false) return 0; } 如果需要支持更多类型（如 const 指针、volatile 指针等），可以进一步扩展特化模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 特化模板：针对 const 指针类型 const T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;const T*\u0026gt; { static constexpr bool value = true; }; // 特化模板：针对 volatile 指针类型 volatile T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;volatile T*\u0026gt; { static constexpr bool value = true; }; // 特化模板：针对 const volatile 指针类型 const volatile T* template \u0026lt;typename T\u0026gt; struct IsPointer\u0026lt;const volatile T*\u0026gt; { static constexpr bool value = true; }; C++ 标准库中已经提供了类似的类型萃取工具 std::is_pointer，其实现原理与上述代码类似。\n引用类型的移除和增加 引用类型的移除\n应用场景：\n在编写模板函数时，我们可能需要处理传入参数的原始类型，而不关心它是否是引用类型。 在完美转发中，我们需要移除参数的引用类型，以便正确地转发参数。 在实现自定义容器时，我们可能需要确保存储的元素类型是非引用类型。RemoveReference 可以帮助我们移除引用，确保类型安全。 有时需要将某个类型转换为它的非引用版本，例如在某些模板元编程场景中。 可能需要从复杂的类型推导出基础类型，去除所有修饰符（如引用、指针、cv限定符等）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u0026lt;class T1, class T2\u0026gt; void print_is_same() { cout \u0026lt;\u0026lt; \u0026#34;T1类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T1).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T2类型为：\u0026#34; \u0026lt;\u0026lt; typeid(T2).name() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;T1类型和T2类型是否相等：\u0026#34; \u0026lt;\u0026lt; std::is_same\u0026lt;T1, T2\u0026gt;::value \u0026lt;\u0026lt; endl; } int main() { std::remove_reference_t\u0026lt;int\u0026gt; a; std::remove_reference_t\u0026lt;int\u0026amp;\u0026gt; b; std::remove_reference_t\u0026lt;int\u0026amp;\u0026amp;\u0026gt; c; print_is_same\u0026lt;decltype(a), decltype(b)\u0026gt;(); print_is_same\u0026lt;decltype(a), decltype(c)\u0026gt;(); return 0; } 手动实现RemoveReferrce\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //泛化版本 template \u0026lt;typename T\u0026gt; struct RemoveReference { using type = T; }; //特化版本 template \u0026lt;typename T\u0026gt; struct RemoveReference\u0026lt;T\u0026amp;\u0026gt; { using type = T; }; template \u0026lt;typename T\u0026gt; struct RemoveReference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { using type = T; }; //别名模板 template \u0026lt;typename T\u0026gt; using RemoveReference_t = typename RemoveReference\u0026lt;T\u0026gt;::type; int main() { int\u0026amp;\u0026amp; A = 12; RemoveReference_t\u0026lt;decltype(A)\u0026gt; RemoveA = 125; int B = 64; int\u0026amp; RefB = B; RemoveReference_t\u0026lt;decltype(RefB)\u0026gt; RemoveRefB = 500; cout\u0026lt;\u0026lt;format(\u0026#34;{} {} {} {} {}\u0026#34;,A, RemoveA,B,RefB,RemoveRefB) \u0026lt;\u0026lt; endl; return 0; } 运行结果：\n变量 值 类型 A 12 int \u0026amp;\u0026amp; RemoveA 125 int B 64 int RefB 64 int \u0026amp; RemoveRefB 500 int 引用类型的增加：根据给定的类型来创建一个左值或者右值引用 std::add_lvalue_reference：给进来一个类型，返回该类型对应的左值引用类型 std::add_rvalue_reference：给进来一个类型，返回该类型对应的右值引用类型 std::is_lvalue_reference和std::is_rvalue_reference类模板：判断某个类型是否是左值引用类型或者右值引用类型。\n应用场景：\n确保函数参数是左值引用：使用 std::add_lvalue_reference 确保返回类型是左值引用。 实现移动语义：使用 std::add_rvalue_reference 实现移动构造函数或移动赋值操作符。 完美转发：在模板函数中使用完美转发时，可能需要将类型转换为右值引用以保留其值类别。 模板元编程中的类型转换：与其他类型特征结合使用，根据条件动态地添加或移除引用限定符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { int a = 15; //using std::add_lvalue_reference\u0026lt;int\u0026gt;::type = int\u0026amp; std::add_lvalue_reference\u0026lt;decltype(a)\u0026gt;::type b = a; //b的类型为int \u0026amp; //using std::add_rvalue_reference\u0026lt;int\u0026gt;::type = int\u0026amp;\u0026amp; std::add_rvalue_reference\u0026lt;decltype(a)\u0026gt;::type c = 16; //c的类型为int \u0026amp;\u0026amp; using btype = std::add_lvalue_reference_t\u0026lt;int\u0026gt;; //_t是个别名模板 cout \u0026lt;\u0026lt; std::is_same\u0026lt;int\u0026amp;, btype\u0026gt;() \u0026lt;\u0026lt; endl; //1 using ctype = std::add_rvalue_reference_t\u0026lt;int\u0026gt;; cout \u0026lt;\u0026lt; std::is_lvalue_reference\u0026lt;btype\u0026gt;::value \u0026lt;\u0026lt; endl; //1 cout \u0026lt;\u0026lt; std::is_rvalue_reference\u0026lt;ctype\u0026gt;::value \u0026lt;\u0026lt; endl; //1 //cc1类型为int\u0026amp;，这里涉及到引用折叠，\u0026amp;和\u0026amp;\u0026amp; 折叠后得到 \u0026amp;, 后面专门解释一下 std::add_rvalue_reference_t\u0026lt;int\u0026amp;\u0026gt; cc1 = a; //cc2的类型为int \u0026amp;\u0026amp;，这里涉及到引用折叠，\u0026amp;\u0026amp;和\u0026amp;\u0026amp;折叠得到\u0026amp;\u0026amp;。 std::add_rvalue_reference_t\u0026lt;int\u0026amp;\u0026amp;\u0026gt; cc2 = 16; return 0; } 手动实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template\u0026lt;typename T\u0026gt; struct AddLValueReference { using type = T\u0026amp;; //int \u0026amp;\u0026amp; \u0026amp; ，引用折叠：有左值 引用，结果必然为左值 引用，所以type = int \u0026amp; }; template\u0026lt;typename T\u0026gt; using AddLValueReference_t = typename AddLValueReference\u0026lt;T\u0026gt;::type; //实际上可以直接简化为using AddLValueReference_t = T\u0026amp;;，这样就不用定义AddLValueReference了。 template\u0026lt;typename T\u0026gt; struct AddRValueReference { using type = T\u0026amp;\u0026amp;; }; template\u0026lt;typename T\u0026gt; using AddRValueReference_t = typename AddRValueReference\u0026lt;T\u0026gt;::type; //实际上可以直接简化为using AddRValueReference_t = T\u0026amp;\u0026amp;;，这样就不用定义AddRValueReference了。 移除const 去除类型的 const 限定符，返回一个非 const 版本的类型。\n1 2 3 const int x = 10; //using std:remove_const\u0026lt;const int\u0026gt;::type = int std::remove_const\u0026lt;decltype(x)\u0026gt;::type D = 10; 手动实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //泛化版本 template \u0026lt;typename T\u0026gt; struct RemoveConst { using type = T; }; //特化版本 template \u0026lt;typename T\u0026gt; struct RemoveConst\u0026lt;const T\u0026gt; { using type = T; }; //根据需要增加其他特化版本.... template \u0026lt;typename T\u0026gt; using RemoveConst_t = typename RemoveConst\u0026lt;T\u0026gt;::type; std::decay 退化 std::decay 是 C++ 标准库中的一个类型特征（type trait），位于 \u0026lt;type_traits\u0026gt; 头文件中。\n用于将给定的类型转换为适合存储在数组或传递给函数的形式\n移除引用：将 T\u0026amp; 或 T\u0026amp;\u0026amp; 转换为 T。 移除 const 和 volatile 限定符：将 const T 或 volatile T 转换为 T。 数组到指针的转换：将数组类型（如 int[10]）转换为指针类型（如 int*）。 函数到指针的转换：将函数类型（如 int(int)）转换为函数指针类型（如 int(*)(int)）。 示例：打印参数类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template \u0026lt;typename T\u0026gt; void printType(T\u0026amp;\u0026amp; value) { using DecayedType = typename std::decay\u0026lt;T\u0026gt;::type; // 使用 std::decay 转换为值类型 std::cout \u0026lt;\u0026lt; \u0026#34;Decayed type of value: \u0026#34; \u0026lt;\u0026lt; typeid(DecayedType).name() \u0026lt;\u0026lt; std::endl; } int main() { int x = 42; const int\u0026amp; y = x; int\u0026amp;\u0026amp; z = 100; printType(x); // 输出 int printType(y); // 输出 int printType(z); // 输出 int printType(200); // 输出 int return 0; } 输出\n1 2 3 4 Decayed type of value: int Decayed type of value: int Decayed type of value: int Decayed type of value: int 示例：数组和函数的类型转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename T\u0026gt; void printDecayedType() { using DecayedType = typename std::decay\u0026lt;T\u0026gt;::type; // 使用 std::decay 转换为值类型 std::cout \u0026lt;\u0026lt; \u0026#34;Decayed type: \u0026#34; \u0026lt;\u0026lt; typeid(DecayedType).name() \u0026lt;\u0026lt; std::endl; } int main() { // 数组类型 printDecayedType\u0026lt;int[10]\u0026gt;(); // 输出 int* // 函数类型 printDecayedType\u0026lt;int(int)\u0026gt;(); // 输出 int (*)(int) return 0; } 输出 Decayed type: int* Decayed type: int (*)(int) 示例：实现通用的类型比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;typename T1, typename T2\u0026gt; void compareTypes() { using DecayedT1 = typename std::decay\u0026lt;T1\u0026gt;::type; // 使用 std::decay 转换为值类型 using DecayedT2 = typename std::decay\u0026lt;T2\u0026gt;::type; // 使用 std::decay 转换为值类型 if (std::is_same\u0026lt;DecayedT1, DecayedT2\u0026gt;::value) { std::cout \u0026lt;\u0026lt; \u0026#34;Types are the same after decay.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Types are different after decay.\u0026#34; \u0026lt;\u0026lt; std::endl; } } int main() { compareTypes\u0026lt;int, const int\u0026amp;\u0026gt;(); // 输出 Types are the same after decay. compareTypes\u0026lt;int[10], int*\u0026gt;(); // 输出 Types are the same after decay. compareTypes\u0026lt;int(int), int(*)(int)\u0026gt;(); // 输出 Types are the same after decay. return 0; } 输出 Types are the same after decay. Types are the same after decay. Types are the same after decay. 值萃取 给进来一个类型，萃取出一个值.\nIsVoid\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; struct voidvaluetraits { static const bool value = false; }; template \u0026lt;\u0026gt; struct voidvaluetraits\u0026lt;void\u0026gt; { static const bool value = true; }; int main() { cout \u0026lt;\u0026lt; \u0026#34;int是void类型吗？\u0026#34; \u0026lt;\u0026lt; voidvaluetraits\u0026lt;int\u0026gt;::value \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; \u0026#34;void是void类型吗？\u0026#34; \u0026lt;\u0026lt; voidvaluetraits\u0026lt;void\u0026gt;::value \u0026lt;\u0026lt; endl; //1 return 0; } IsSame\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //泛化版本 template\u0026lt;typename T1, typename T2\u0026gt; struct IsSameType { static const bool value = false; }; //特化版本 template\u0026lt;typename T1\u0026gt; struct IsSameType\u0026lt;T1, T1\u0026gt; { static const bool value = true; }; //变量模板 template\u0026lt;typename T1, typename T2\u0026gt; const bool IsSame_v = IsSameType\u0026lt;T1, T2\u0026gt;::value; int main() { cout \u0026lt;\u0026lt; IsSameType\u0026lt;int, const int\u0026gt;::value \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; IsSameType\u0026lt;int, int\u0026gt;::value \u0026lt;\u0026lt; endl; //1 cout \u0026lt;\u0026lt; IsSame_v\u0026lt;int, const int\u0026gt; \u0026lt;\u0026lt; endl; //0 cout \u0026lt;\u0026lt; IsSame_v\u0026lt;int, int\u0026gt; \u0026lt;\u0026lt; endl; //1 return 0; } 因为std::true_type和std::false_type里面有value，所以也可以这样写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //泛化版本 template\u0026lt;typename T1, typename T2\u0026gt; struct IsSameType : std::false_type {\t}; //特化版本 template\u0026lt;typename T1\u0026gt; struct IsSameType\u0026lt;T1, T1\u0026gt;:std::true_type {\t}; //变量模板 template\u0026lt;typename T1, typename T2\u0026gt; const bool IsSame_v = IsSameType\u0026lt;T1, T2\u0026gt;::value; 元编程 将各种计算从运行期提前至编译期，往往会采用递归手段。\n泛型编程：“通用”，程序员不需要关心具体类型元编程：突出一种程序设计技巧达到常规编程难以达到的效果。前面章节：std::remove_all_extents类模板的实现。\n元函数 数值元函数\n1 2 3 4 5 6 7 8 9 10 11 constexpr int Add(int Value,int Value2) { return Value + Value2; } int main() { constexpr int V = Add(3,2); static_assert(V == 5, \u0026#34;std error\u0026#34;); //静态断言,编译期间断言 return 0; } V = 3+2，确实等于5， 如果把 V==5 改成其它值 断言就会失败.\n编译期计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //计算n的阶乘的泛化版本 template \u0026lt;int N\u0026gt; struct Factorial { static constexpr unsigned int value = N * Factorial\u0026lt;N - 1\u0026gt;::value; }; //计算n的阶乘的特化版本，用于做递归调用的出口 template \u0026lt;\u0026gt; struct Factorial\u0026lt;1\u0026gt; { static constexpr unsigned int value = 1; }; int main() { auto A = Factorial\u0026lt;5\u0026gt;::value; cout\u0026lt;\u0026lt;A\u0026lt;\u0026lt;endl; return 0; } 基本模板： template \u0026lt;unsigned int N\u0026gt; 这个模板类有一个静态成员变量 value，其值是 N * Factorial\u0026lt;N - 1\u0026gt;::value。这表示通过递归调用自身来计算阶乘。 特化模板： template \u0026lt;\u0026gt; struct Factorial\u0026lt;0\u0026gt; 这是递归的终止条件。当 N 为0时，阶乘的值应该是1。因此，我们特化了这个模板，并将 value 设置为1。 主函数： 在 main 函数中，我们使用 Factorial\u0026lt;5\u0026gt;::value 来获取5的阶乘，并将其打印出来。 循环求值\n1 2 3 4 5 6 7 8 9 constexpr int Factorial(int n_v) { int result = 1; for (int i = 1; i \u0026lt;= n_v; ++i) { result *= i; } return result; } 类型元函数\nremove_all_extents类模板所实现的元编程就是靠递归模板实例化来驱动的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; struct AddPoint //类型元函数 { using type = T*; }; //using AddPoint\u0026lt;int\u0026gt;::type = int * //a是 int* 类型 AddPoint\u0026lt;int\u0026gt;::type a; 或写为 template \u0026lt;typename T\u0026gt; using AddPoint = T*; //using AddPoint\u0026lt;int\u0026gt; =int * AddPoint\u0026lt;int\u0026gt; a; 混合元编程 混合元编程指的是 结合 编译期元编程 和 运行期编程 的技术。通过这种方式，可以利用编译期计算的优势来优化程序性能，并且在运行时根据具体需求动态地执行某些操作。\n编译期元编程：使用模板、constexpr 等机制在编译期进行计算和类型推导，以生成高效的代码。 运行期编程：在程序运行期间进行的常规计算和逻辑处理。 应用场景：\n优化计算：将一些可以在编译期完成的计算提前完成，减少运行时的开销。 类型安全：利用编译期检查确保类型安全，同时在运行时进行灵活的操作。 生成代码：根据编译期信息生成特定的代码片段或数据结构，提高灵活性和效率。 点积计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //泛化版本 template \u0026lt;typename T, int U\u0026gt;//T：元素类型，U：数组大小 struct DotProduct { static T result(const T* a, const T* b) { return (*a) * (*b) + DotProduct\u0026lt;T, U - 1\u0026gt;::result(a + 1, b + 1); } }; //特化版本，用于做递归调用的出口 template \u0026lt;typename T\u0026gt; struct DotProduct\u0026lt;T, 0\u0026gt; { static T result(const T* a, const T* b) { return T{}; } }; int a[] = { 1,2,3 }; int b[] = { 4,5,6 }; int result = DotProduct\u0026lt;int, 3\u0026gt;::result(a, b); 内存模型 类对象的占用空间 普通函数 1 2 3 4 class A { public: void func() {}; }; sizeof(A) 的结果是 1。 原因是：C++ 标准规定，一个类的实例至少占用 1 个字节，即使它是空的（没有非静态成员变量）。这是为了确保每个实例都有唯一的地址。 void func() 是否占用类的大小？\n不占用。成员函数（包括 void func()）不占用类的实例的大小。 成员函数是类的共享代码，存储在代码段（代码区）中，而不是每个实例中。 函数代码存储在哪里？\n成员函数的代码存储在程序的 代码段（Code Segment） 中。 代码段是内存中的一个区域，用于存储程序的执行代码（包括类的成员函数）。 所有实例共享同一份成员函数的代码。 不同实例调用 func() 时，函数地址是否相同？\n相同。对于 a1.func() 和 a2.func()，调用的函数地址是相同的。 成员函数是类的共享代码，所有实例调用的是同一份代码。 编译器在调用成员函数时，会隐式地传递一个指向当前实例的指针（即 this 指针），以区分不同实例的数据成员。 深入理解\n成员函数的调用机制\n当你调用 a1.func() 时，编译器实际上会将调用转换为类似以下的形式：\n1 func(\u0026amp;a1); // 隐式传递 this 指针 this 指针指向当前实例（a1 或 a2），这样函数可以访问当前实例的成员变量。 函数代码本身是共享的，只有 this 指针不同。 如果类中有成员变量\n如果类中有成员变量，sizeof(A) 就是这些成员变量的总大小（考虑内存对齐）。例如：\n1 2 3 4 5 class A { public: void func() {}; int x; }; sizeof(A) 将是 sizeof(int)，通常是 4（取决于平台）。 总结\nsizeof(A) 是 1，因为空的类至少占用 1 个字节。 成员函数 void func() 不占用类的大小，函数代码存储在代码段中。 不同实例调用 func() 时，函数地址相同，因为成员函数是共享的。 成员函数通过隐式传递 this 指针来区分不同实例的数据成员。 虚函数 1 2 3 4 5 6 7 class A { public: virtual void FuncA() {}; virtual void FuncB() {}; virtual void FuncC() {}; }; sizeof(A) = 8\n虚函数表（vtable） 当一个类包含虚函数时，编译器会为该类生成一个虚函数表（vtable），并且每个对象会有一个指向这个虚函数表的指针 (通常称为虚指针或 vptr), 虚指针通常位于对象的起始位置。每个类有一个唯一的vtable，而不是每个对象都有一个vtable。这个虚指针是存储在对象中的唯一额外数据成员。\n虚函数表调用私有函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; class A { public: int ca = 3; virtual void FuncA() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncA\u0026#34; \u0026lt;\u0026lt; std::endl; } private: virtual void FuncB() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncB\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void FuncC() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncC\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void FuncD() { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncD\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void FuncE(int F) { std::cout \u0026lt;\u0026lt; \u0026#34;A::FuncE \u0026#34; \u0026lt;\u0026lt; F \u0026lt;\u0026lt; std::endl; } int cd = 4; }; class B : public A { public: int a = 3; virtual void FuncA() override { std::cout \u0026lt;\u0026lt; \u0026#34;B::FuncA\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 宏定义获取虚函数表指针 #define GET_VTABLE(obj) (*reinterpret_cast\u0026lt;void***\u0026gt;(obj)) int main() { B* a = new B(); // 获取虚函数表指针 void** vtable = GET_VTABLE(a); // 打印虚函数表指针地址 std::cout \u0026lt;\u0026lt; \u0026#34;VTable pointer: \u0026#34; \u0026lt;\u0026lt; vtable \u0026lt;\u0026lt; std::endl; // FuncB using FuncBPtr = void(*)(A*); FuncBPtr funcB = reinterpret_cast\u0026lt;FuncBPtr\u0026gt;(vtable[1]); // FuncE using FuncEPtr = void(*)(A*, int); FuncEPtr funcE = reinterpret_cast\u0026lt;FuncEPtr\u0026gt;(vtable[4]); funcB(a); funcE(a,3); delete a; return 0; } ","date":"1073-01-13T14:39:23+08:00","permalink":"https://akaklya.github.io/p/%E6%88%90%E4%B8%BA%E5%96%9C%E5%8A%A0%E5%8A%A0%E9%AB%98%E6%89%8B/","title":"成为喜加加高手"}]