<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="简介 迭代器（Iterator）是一种用于遍历容器（如 std::vector, std::list, std::map 等）中元素的工具。它们提供了一种统一的方式来访问和操作容器中的数据，无论这些容器是如何实现的。迭代器的设计灵感来源于指针的概念，但它们提供了更抽象和灵活的操作接口。迭代器可以看作是“智能指针”，它们不仅能够指向容器中的某个位置，还能通过一系列标准操作进行移动、访问和修改容器中的元素。 STL 的六大组件通过 迭代器 作为粘合剂，将以下五个东西有机整合。 数据存储（容器） 数据操作（算法） 行为策略（仿函数） 接口改造（适配器） 内存管理（分配器） 这种设计使得代码高度模块化、可复用且高效，成为C++泛型编程的典范。容器库 算法库 容器类型 特点 时间复杂度（平均） 时间复杂度（最坏） 适用场景 std::vector 动态数组，支持随机访问 O(1) O(n) 需要频繁随机访问，且大多数操作集中在尾部 std::deque 双端队列，支持两端高效插入和删除 O(1) O(n) 需要在两端频繁插入和删除 std::list 双向链表，支持任意位置高效插入和删除 O(1) O(n) 需要频繁在任意位置插入和删除 std::forward_list 单向链表，支持高效插入和删除 O(1) O(n) 需要单向遍历和高效的插入/删除操作 std::set 有序集合，基于平衡二叉搜索树 O(log n) O(log n) 需要保持元素有序 std::multiset 有序多重集合，允许重复元素 O(log n) O(log n) 需要保持元素有序且允许重复元素 std::map 有序映射，基于平衡二叉搜索树 O(log n) O(log n) 需要保持键有序 std::multimap 有序多重映射，允许重复键 O(log n) O(log n) 需要保持键有序且允许重复键 std::unordered_set 无序集合，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multiset 无序多重集合，允许重复元素 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复元素 std::unordered_map 无序映射，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multimap 无序多重映射，允许重复键 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复键 std::stack LIFO 数据结构，基于其他容器实现 O(1) O(1) 需要栈操作 std::queue FIFO 数据结构，基于其他容器实现 O(1) O(1) 需要队列操作 std::priority_queue 优先队列，基于堆实现 O(log n) O(log n) 需要优先级管理的数据结构 设计哲学与优势">
<title>EASTL</title>

<link rel='canonical' href='http://localhost:1313/p/eastl/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="EASTL">
<meta property='og:description' content="简介 迭代器（Iterator）是一种用于遍历容器（如 std::vector, std::list, std::map 等）中元素的工具。它们提供了一种统一的方式来访问和操作容器中的数据，无论这些容器是如何实现的。迭代器的设计灵感来源于指针的概念，但它们提供了更抽象和灵活的操作接口。迭代器可以看作是“智能指针”，它们不仅能够指向容器中的某个位置，还能通过一系列标准操作进行移动、访问和修改容器中的元素。 STL 的六大组件通过 迭代器 作为粘合剂，将以下五个东西有机整合。 数据存储（容器） 数据操作（算法） 行为策略（仿函数） 接口改造（适配器） 内存管理（分配器） 这种设计使得代码高度模块化、可复用且高效，成为C++泛型编程的典范。容器库 算法库 容器类型 特点 时间复杂度（平均） 时间复杂度（最坏） 适用场景 std::vector 动态数组，支持随机访问 O(1) O(n) 需要频繁随机访问，且大多数操作集中在尾部 std::deque 双端队列，支持两端高效插入和删除 O(1) O(n) 需要在两端频繁插入和删除 std::list 双向链表，支持任意位置高效插入和删除 O(1) O(n) 需要频繁在任意位置插入和删除 std::forward_list 单向链表，支持高效插入和删除 O(1) O(n) 需要单向遍历和高效的插入/删除操作 std::set 有序集合，基于平衡二叉搜索树 O(log n) O(log n) 需要保持元素有序 std::multiset 有序多重集合，允许重复元素 O(log n) O(log n) 需要保持元素有序且允许重复元素 std::map 有序映射，基于平衡二叉搜索树 O(log n) O(log n) 需要保持键有序 std::multimap 有序多重映射，允许重复键 O(log n) O(log n) 需要保持键有序且允许重复键 std::unordered_set 无序集合，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multiset 无序多重集合，允许重复元素 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复元素 std::unordered_map 无序映射，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multimap 无序多重映射，允许重复键 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复键 std::stack LIFO 数据结构，基于其他容器实现 O(1) O(1) 需要栈操作 std::queue FIFO 数据结构，基于其他容器实现 O(1) O(1) 需要队列操作 std::priority_queue 优先队列，基于堆实现 O(log n) O(log n) 需要优先级管理的数据结构 设计哲学与优势">
<meta property='og:url' content='http://localhost:1313/p/eastl/'>
<meta property='og:site_name' content='AKaKLya'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='1074-01-01T20:11:46&#43;08:00'/><meta property='article:modified_time' content='1074-01-01T20:11:46&#43;08:00'/>
<meta name="twitter:title" content="EASTL">
<meta name="twitter:description" content="简介 迭代器（Iterator）是一种用于遍历容器（如 std::vector, std::list, std::map 等）中元素的工具。它们提供了一种统一的方式来访问和操作容器中的数据，无论这些容器是如何实现的。迭代器的设计灵感来源于指针的概念，但它们提供了更抽象和灵活的操作接口。迭代器可以看作是“智能指针”，它们不仅能够指向容器中的某个位置，还能通过一系列标准操作进行移动、访问和修改容器中的元素。 STL 的六大组件通过 迭代器 作为粘合剂，将以下五个东西有机整合。 数据存储（容器） 数据操作（算法） 行为策略（仿函数） 接口改造（适配器） 内存管理（分配器） 这种设计使得代码高度模块化、可复用且高效，成为C++泛型编程的典范。容器库 算法库 容器类型 特点 时间复杂度（平均） 时间复杂度（最坏） 适用场景 std::vector 动态数组，支持随机访问 O(1) O(n) 需要频繁随机访问，且大多数操作集中在尾部 std::deque 双端队列，支持两端高效插入和删除 O(1) O(n) 需要在两端频繁插入和删除 std::list 双向链表，支持任意位置高效插入和删除 O(1) O(n) 需要频繁在任意位置插入和删除 std::forward_list 单向链表，支持高效插入和删除 O(1) O(n) 需要单向遍历和高效的插入/删除操作 std::set 有序集合，基于平衡二叉搜索树 O(log n) O(log n) 需要保持元素有序 std::multiset 有序多重集合，允许重复元素 O(log n) O(log n) 需要保持元素有序且允许重复元素 std::map 有序映射，基于平衡二叉搜索树 O(log n) O(log n) 需要保持键有序 std::multimap 有序多重映射，允许重复键 O(log n) O(log n) 需要保持键有序且允许重复键 std::unordered_set 无序集合，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multiset 无序多重集合，允许重复元素 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复元素 std::unordered_map 无序映射，基于哈希表 O(1) O(n) 需要高效查找、插入和删除操作，且不需要有序 std::unordered_multimap 无序多重映射，允许重复键 O(1) O(n) 需要高效查找、插入和删除操作，且允许重复键 std::stack LIFO 数据结构，基于其他容器实现 O(1) O(1) 需要栈操作 std::queue FIFO 数据结构，基于其他容器实现 O(1) O(1) 需要队列操作 std::priority_queue 优先队列，基于堆实现 O(log n) O(log n) 需要优先级管理的数据结构 设计哲学与优势">
  


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/d_hu15622052934649275245.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">AKaKLya</a></h1>
            <h2 class="site-description">点击</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#简介">简介</a></li>
    <li><a href="#分配器">分配器</a></li>
    <li><a href="#eastl">EASTL</a>
      <ol>
        <li><a href="#开局">开局</a></li>
        <li><a href="#容器"><strong>容器</strong></a></li>
        <li><a href="#分配器-1"><strong>分配器</strong></a></li>
        <li><a href="#固定大小的容器"><strong>固定大小的容器</strong></a></li>
        <li><a href="#算法">算法</a></li>
        <li><a href="#智能指针">智能指针</a></li>
        <li><a href="#listsize-is-on">list::size is O(n)</a></li>
        <li><a href="#basic_string不使用写时复制">basic_string不使用写时复制</a></li>
        <li><a href="#配置">配置</a></li>
      </ol>
    </li>
    <li><a href="#容器-1">容器</a>
      <ol>
        <li><a href="#array">Array</a>
          <ol>
            <li><a href="#使用示例">使用示例</a></li>
            <li><a href="#类型别名">类型别名</a></li>
            <li><a href="#聚合初始化">聚合初始化</a></li>
            <li><a href="#成员函数">成员函数</a></li>
          </ol>
        </li>
        <li><a href="#vector">Vector</a>
          <ol>
            <li><a href="#使用示例-1">使用示例</a></li>
            <li><a href="#扩容机制">扩容机制</a></li>
          </ol>
        </li>
        <li><a href="#list">list</a></li>
        <li><a href="#string">string</a>
          <ol>
            <li><a href="#sso优化">SSO优化</a></li>
            <li><a href="#string-成员函数">string 成员函数</a></li>
          </ol>
        </li>
        <li><a href="#hashtable">HashTable</a></li>
        <li><a href="#hash_set">hash_set</a></li>
      </ol>
    </li>
    <li><a href="#智能指针-1">智能指针</a>
      <ol>
        <li><a href="#unique_ptr">unique_ptr</a>
          <ol>
            <li><a href="#使用示例-2">使用示例</a></li>
            <li><a href="#析构过程">析构过程</a></li>
          </ol>
        </li>
        <li><a href="#shared_ptr">shared_ptr</a>
          <ol>
            <li><a href="#引用计数">引用计数</a></li>
            <li><a href="#析构过程-1">析构过程</a></li>
            <li><a href="#使用示例-3"><strong>使用示例</strong></a></li>
          </ol>
        </li>
        <li><a href="#safe_ptr">safe_ptr</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/eastl/">EASTL</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jan 01, 1074</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 25 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="简介">简介
</h2><p><strong>迭代器</strong>（Iterator）是一种用于遍历容器（如 std::vector, std::list, std::map 等）中元素的工具。<br/>它们提供了一种统一的方式来访问和操作容器中的数据，无论这些容器是如何实现的。<br/>迭代器的设计灵感来源于指针的概念，但它们提供了更抽象和灵活的操作接口。<br/>迭代器可以看作是“智能指针”，它们不仅能够指向容器中的某个位置，还能通过一系列标准操作进行移动、访问和修改容器中的元素。</p>
<hr>
<p>STL 的六大组件通过 <strong>迭代器</strong> 作为粘合剂，将以下五个东西有机整合。</p>
<ul>
<li>数据存储（容器）</li>
<li>数据操作（算法）</li>
<li>行为策略（仿函数）</li>
<li>接口改造（适配器）</li>
<li>内存管理（分配器）</li>
</ul>
<p><br/>这种设计使得代码高度模块化、可复用且高效，成为C++泛型编程的典范。<br/><a class="link" href="https://zh.cppreference.com/w/cpp/container"  target="_blank" rel="noopener"
    >容器库</a> <a class="link" href="https://zh.cppreference.com/w/cpp/algorithm"  target="_blank" rel="noopener"
    >算法库</a></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>容器类型</th>
<th>特点</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::vector</code></td>
<td>动态数组，支持随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要频繁随机访问，且大多数操作集中在尾部</td>
</tr>
<tr>
<td><code>std::deque</code></td>
<td>双端队列，支持两端高效插入和删除</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要在两端频繁插入和删除</td>
</tr>
<tr>
<td><code>std::list</code></td>
<td>双向链表，支持任意位置高效插入和删除</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要频繁在任意位置插入和删除</td>
</tr>
<tr>
<td><code>std::forward_list</code></td>
<td>单向链表，支持高效插入和删除</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要单向遍历和高效的插入/删除操作</td>
</tr>
<tr>
<td><code>std::set</code></td>
<td>有序集合，基于平衡二叉搜索树</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>需要保持元素有序</td>
</tr>
<tr>
<td><code>std::multiset</code></td>
<td>有序多重集合，允许重复元素</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>需要保持元素有序且允许重复元素</td>
</tr>
<tr>
<td><code>std::map</code></td>
<td>有序映射，基于平衡二叉搜索树</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>需要保持键有序</td>
</tr>
<tr>
<td><code>std::multimap</code></td>
<td>有序多重映射，允许重复键</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>需要保持键有序且允许重复键</td>
</tr>
<tr>
<td><code>std::unordered_set</code></td>
<td>无序集合，基于哈希表</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要高效查找、插入和删除操作，且不需要有序</td>
</tr>
<tr>
<td><code>std::unordered_multiset</code></td>
<td>无序多重集合，允许重复元素</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要高效查找、插入和删除操作，且允许重复元素</td>
</tr>
<tr>
<td><code>std::unordered_map</code></td>
<td>无序映射，基于哈希表</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要高效查找、插入和删除操作，且不需要有序</td>
</tr>
<tr>
<td><code>std::unordered_multimap</code></td>
<td>无序多重映射，允许重复键</td>
<td>O(1)</td>
<td>O(n)</td>
<td>需要高效查找、插入和删除操作，且允许重复键</td>
</tr>
<tr>
<td><code>std::stack</code></td>
<td>LIFO 数据结构，基于其他容器实现</td>
<td>O(1)</td>
<td>O(1)</td>
<td>需要栈操作</td>
</tr>
<tr>
<td><code>std::queue</code></td>
<td>FIFO 数据结构，基于其他容器实现</td>
<td>O(1)</td>
<td>O(1)</td>
<td>需要队列操作</td>
</tr>
<tr>
<td><code>std::priority_queue</code></td>
<td>优先队列，基于堆实现</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>需要优先级管理的数据结构</td>
</tr>
</tbody>
</table></div>
<p><strong>设计哲学与优势</strong></p>
<ol>
<li><strong>解耦与复用</strong>：
<ul>
<li>算法与容器解耦，一个算法可作用于多种容器。</li>
<li>分配器与容器解耦，内存策略可灵活替换。</li>
</ul>
</li>
<li><strong>零开销抽象</strong>：
<ul>
<li>迭代器通过编译时多态（模板）实现，无运行时开销。</li>
<li>仿函数的内联优化比函数指针更高效。</li>
</ul>
</li>
<li><strong>扩展性</strong>：
<ul>
<li>用户可自定义容器（需提供迭代器）、算法（如支持新迭代器类型）、分配器等。</li>
</ul>
</li>
</ol>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">组件</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>容器</strong></td>
<td style="text-align:left">存储和管理数据（如 <code>vector</code>, <code>list</code>, <code>map</code>）</td>
</tr>
<tr>
<td style="text-align:left"><strong>算法</strong></td>
<td style="text-align:left">对数据进行操作（如 <code>sort</code>, <code>find</code>, <code>transform</code>）</td>
</tr>
<tr>
<td style="text-align:left"><strong>迭代器</strong></td>
<td style="text-align:left">连接容器和算法，提供统一的元素访问接口</td>
</tr>
<tr>
<td style="text-align:left"><strong>仿函数</strong></td>
<td style="text-align:left">封装可调用行为（如比较、运算），作为算法的策略参数</td>
</tr>
<tr>
<td style="text-align:left"><strong>适配器</strong></td>
<td style="text-align:left">改造组件接口（如 <code>stack</code> 适配 <code>deque</code>，<code>reverse_iterator</code> 反向遍历）</td>
</tr>
<tr>
<td style="text-align:left"><strong>分配器</strong></td>
<td style="text-align:left">管理容器的内存分配与释放（如自定义内存池）</td>
</tr>
</tbody>
</table></div>
<p>联动:</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">场景</th>
<th style="text-align:left">参与的组件</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">遍历容器</td>
<td style="text-align:left">容器、迭代器</td>
<td style="text-align:left"><code>for (auto it = vec.begin(); ...)</code></td>
</tr>
<tr>
<td style="text-align:left">排序算法</td>
<td style="text-align:left">算法、迭代器、仿函数</td>
<td style="text-align:left"><code>sort(vec.begin(), vec.end(), comp)</code></td>
</tr>
<tr>
<td style="text-align:left">容器适配栈</td>
<td style="text-align:left">容器、适配器</td>
<td style="text-align:left"><code>stack&lt;int, deque&lt;int&gt;&gt; s</code></td>
</tr>
<tr>
<td style="text-align:left">自定义内存管理</td>
<td style="text-align:left">容器、分配器</td>
<td style="text-align:left"><code>vector&lt;int, PoolAllocator&lt;int&gt;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">反向遍历</td>
<td style="text-align:left">容器、迭代器、迭代器适配器</td>
<td style="text-align:left"><code>reverse_iterator rbegin()</code></td>
</tr>
</tbody>
</table></div>
<p>例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">210</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">89</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">ia</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// Container - vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//vector&lt;int，allocator&lt;int&gt;&gt; vi(ia, ia + 5);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//统计小于30的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//Iterator - vi.begin(), vi.end()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//Algorithm - count_if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count_if</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;})</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//统计大于等于30的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//Function Adapter - not_fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count_if</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">not_fn</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;}))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="分配器">分配器
</h2><p><a class="link" href="https://zh.cppreference.com/w/cpp/memory/allocator"  target="_blank" rel="noopener"
    >分配器</a>（Allocator）是用于管理内存分配和释放的组件。<br/>它们主要用于标准库容器（如 std::vector, std::list, std::deque 等）中，以提供一致且高效的内存管理机制。</p>
<p><strong>主要职责：</strong></p>
<ol>
<li><strong>分配内存</strong>：为容器中的元素分配所需的内存。</li>
<li><strong>释放内存</strong>：当容器不再需要某些内存时，释放这些内存。</li>
<li><strong>构造和析构对象</strong>：在分配的内存上构造对象，并在需要时析构对象。</li>
</ol>
<h2 id="eastl">EASTL
</h2><h3 id="开局">开局
</h3><p><a class="link" href="https://github.com/electronicarts/EASTL"  target="_blank" rel="noopener"
    ><strong>EASTL</strong></a><strong>主要由容器、算法和迭代器组成。</strong></p>
<p><strong>容器的一个例子是链表，而算法的一个例子是排序函数；迭代器则是用于遍历容器和算法的实体。</strong></p>
<p><strong>EASTL包含相当多的容器和算法，每个都是一个非常干净、高效且经过单元测试的实现。</strong></p>
<p><strong>我们可以自信地说，你不太可能找到更好的实现（无论是商业还是其他），因为这些实现是多年智慧和勤奋工作的结果。</strong></p>
<p><strong>EAST 包含并扩展了标准 C++ STL 的功能，同时以各种对游戏开发有用的方式对其进行改进。</strong></p>
<p><strong>EASTL 的大部分设计与标准 STL 相同，因为 STL 的大部分设计都经过精心设计，可用于多种用途。</strong></p>
<p><strong>EASTL 与标准 STL 实现不同的主要方面基本上如下：</strong></p>
<ul>
<li><strong>具有简化且更灵活的自定义分配方案。</strong></li>
<li><strong>代码明显更易于阅读。</strong></li>
<li><strong>具有扩展容器和算法。</strong></li>
<li><strong>具有专为游戏开发而设计的优化。</strong></li>
</ul>
<p><strong>唯一与STL不兼容的差异是内存分配的情况。</strong></p>
<p><strong>为EASTL定义自定义分配器的方法与标准STL略有不同，尽管它们有90%的相似度。</strong></p>
<p><strong>然而，那10%的不同之处却使得EASTL在大多数情况下比标准STL更易于使用且功能更强大。</strong></p>
<p><strong>没有自定义分配器的容器在EASTL和标准STL之间的行为是相同的。</strong></p>
<ul>
<li><strong>某些 STL 实现（尤其是 Microsoft STL）的性能特征较差，因此不适合游戏开发。EASTL 比所有现有的 STL 实现都快。</strong></li>
<li><strong>STL 有时很难调试，因为大多数 STL 实现都使用晦涩难懂的变量名称和不寻常的数据结构。</strong></li>
<li><strong>STL 分配器有时使用起来很痛苦，因为它们有很多要求，并且一旦绑定到容器就无法修改。</strong></li>
<li><strong>STL 包含过多的功能，这些功能可能会导致代码大于预期。告诉程序员他们不应该使用该功能并不容易。</strong></li>
<li><strong>STL 是通过非常深入的函数调用实现的。这会导致在未优化构建中不可接受的性能，有时在优化构建中也是如此。</strong></li>
<li><strong>STL 不支持包含对象的对齐。</strong></li>
<li><strong>STL 容器不允许在未提供要从中复制的条目的情况下将条目插入容器。这可能效率低下。</strong></li>
<li><strong>在现有 STL 实现（如 STLPort）中找到的有用的 STL 扩展（例如 slist、hash_map shared_ptr）是不可移植的，因为它们在其他版本的 STL 中不存在，或者在 STL 版本之间不一致。</strong></li>
<li><strong>STL 缺乏游戏程序员认为有用的有用扩展（例如 intrusive_list），但在便携式 STL 环境中可以最好地优化这些扩展。</strong></li>
<li><strong>STL 的规范限制了我们有效使用它的能力。例如，STL 向量不能保证使用连续内存，因此不能安全地用作数组。</strong></li>
<li><strong>STL 强调正确性而不是性能，而有时您可以通过降低学术纯粹性来获得显着的性能提升。</strong></li>
<li><strong>STL 容器具有私有实现，不允许您以可移植的方式处理其数据，但有时这是一件重要的事情（例如节点池）。</strong></li>
<li><strong>所有现有版本的 STL 都至少在其某些容器的空版本中分配内存。这并不理想，并且会阻止优化，例如容器内存重置，在某些情况下可以大大提高性能。</strong></li>
<li><strong>STL 编译速度很慢，因为大多数现代 STL 实现都非常大。</strong></li>
<li><strong>存在一些法律问题，使我们很难自由地使用可移植的 STL 实现，例如 STLPort。</strong></li>
<li><strong>我们在 STL 的设计和实施中没有发言权，因此无法改变它以满足我们的需求。</strong></li>
</ul>
<p><strong>可读性是 EASTL 比许多其他模板化库（尤其是 Microsoft STL 和 STLPort）更好的实现。</strong></p>
<p><strong>我们尽一切努力使 EASTL 代码清晰明了。有时我们需要提供优化（特别是与 type_traits 和 iterator 类型相关）会导致代码不那么简单，但效率恰好是我们的首要任务，因此它凌驾于所有其他考虑因素之上。</strong></p>
<h3 id="容器"><strong>容器</strong>
</h3><ul>
<li><strong>原型容器</strong>：定义了所有非适配器容器都必须实现的基本功能。</li>
<li><strong>适配器容器</strong>：如栈、队列等，这些容器通常基于其他基础容器构建，并且其具体实现可能会有所不同。</li>
<li><strong>一致性</strong>：通过设定统一的标准，EASTL确保了不同容器之间的兼容性和易用性，减少了学习和使用成本。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">EASTLAllocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">container</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span>		<span class="n">this_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span>           <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span>			<span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span>	<span class="n">const_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span>	<span class="n">T</span><span class="o">&amp;</span>          <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span>    <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">ptrdiff_t</span>    <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">impl_defined</span>  <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">impl</span><span class="o">-</span><span class="n">defined</span>  <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">impl</span><span class="o">-</span><span class="n">defined</span>  <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>      <span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">reverse_const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">Allocator</span> <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">container</span><span class="p">(</span><span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">allocator</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">container</span><span class="p">(</span><span class="k">const</span> <span class="n">this_type</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">this_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">this_type</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">this_type</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">get_allocator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span>            <span class="nf">set_allocator</span><span class="p">(</span><span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">iterator</span>       <span class="nf">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">iterator</span>       <span class="nf">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">validate</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>  <span class="nf">validate_iterator</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">allocator_type</span> <span class="n">mAllocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">container</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>分配器不交换</strong>：当两个容器通过交换操作互换内容时，它们各自的分配器不会被交换，这意味着每个容器将继续使用其原来的分配策略。</li>
<li><strong>避免不必要的内存分配</strong>：EASTL的设计原则之一是尽量减少不必要的内存分配。新构造的空容器不会预先分配内存，这与某些其他容器库不同，后者可能会预先分配一个初始节点。</li>
<li><strong>空容器的状态</strong>：无论是新创建的还是已经存在的空容器，都不会包含任何已构造的对象，包括所谓的“结束”节点。只有在设计确实需要并且有文档说明的情况下，才会构造用户对象。</li>
<li><strong>reset函数的作用</strong>：reset函数用于快速重置容器到空状态，而无需释放容器内对象占用的内存。这对于临时使用的容器特别有用，因为它可以快速清理容器而不涉及复杂的内存管理。</li>
<li><strong>显式验证机制</strong>：为了平衡性能和安全性，EASTL提供了显式的验证功能（如validate和validate_iterator），允许用户在需要时手动检查容器和迭代器的有效性，而不是每次都自动进行这种可能耗费大量资源的检查。这种方法既保证了灵活性，也确保了性能。</li>
</ul>
<p>通过这些设计，EASTL旨在提高性能和易用性，同时为开发者提供更多的控制权和灵活性。</p>
<h3 id="分配器-1"><strong>分配器</strong>
</h3><p>STL分配器的问题：</p>
<ul>
<li>
<p><strong>类级别定义</strong>：STL容器的分配器是在类级别定义的，而不是在实例级别，这使得为每个容器实例定义不同的分配器变得复杂。</p>
</li>
<li>
<p><strong>代码膨胀</strong>：由于分配器模板需要针对每种类型重新绑定，这导致了代码膨胀。</p>
</li>
<li>
<p><strong>不可访问性</strong>：容器构造后，你无法再访问其分配器，这限制了对分配器的操作和管理。</p>
</li>
</ul>
<p>EASTL的改进：</p>
<ul>
<li><strong>单一分配器接口</strong>：EASTL采用了一个统一的分配器类接口，所有容器都使用这个接口，简化了内存分配的管理和使用。</li>
<li><strong>灵活的分配器操作</strong>：EASTL容器允许用户访问、查询、命名和更改分配器，提供了更大的灵活性和控制权。</li>
</ul>
<p>分配器在容器操作中的行为：</p>
<ul>
<li><strong>交换操作</strong>：当容器A与容器B交换内容时，两个容器都会保留其原始分配器，而不是交换分配器。</li>
<li><strong>赋值操作</strong>：将容器A赋值给容器B时，容器B会保留其原始分配器，而不是继承容器A的分配器。</li>
<li><strong>智能交换</strong>：如果两个容器的分配器相同，EASTL会执行智能交换（更高效的方式）。如果分配器不同，则执行暴力交换（逐元素复制）。</li>
</ul>
<p>通过这些改进，EASTL不仅解决了STL中分配器相关的一些痛点，还提高了内存管理的灵活性和效率，使开发者能够更好地控制容器的行为和性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// EASTL allocator  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">allocator</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>  
</span></span><span class="line"><span class="cl">    <span class="n">allocator</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">void</span>  <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">get_name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">void</span>        <span class="nf">set_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pName</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">allocator</span><span class="o">*</span> <span class="nf">GetDefaultAllocator</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="固定大小的容器"><strong>固定大小的容器</strong>
</h3><p>EASTL提供了诸如fixed_list这样的固定大小容器，它们通过固定大小的连续内存池来实现。</p>
<p>fixed_list具有以下特点：</p>
<ul>
<li><strong>没有额外的空间开销。</strong></li>
<li><strong>不会导致内存碎片化。</strong></li>
<li><strong>分配速度非常快。</strong></li>
</ul>
<p>实现方式：</p>
<ul>
<li>EASTL通过继承自常规容器的子类来实现固定容器，这些子类将其常规容器的分配器设置为指向自身。</li>
<li>这种设计使得fixed_list的实现非常简洁，主要包括构造函数和分配器函数。</li>
</ul>
<p>设计的优点：</p>
<ul>
<li><strong>减少代码膨胀</strong>：由于实现简单，避免了大量的重复代码。</li>
<li><strong>易于扩展</strong>：用户可以轻松地基于现有的实现进行扩展和修改。</li>
<li><strong>简化实现</strong>：保持了实现的简单性和清晰度。</li>
</ul>
<p>设计的小缺点：</p>
<ul>
<li>父类list中有一个指向自身的指针，占用了4个字节的空间。</li>
<li>如果采用不同的设计（例如策略模板参数），可以节省这4个字节，但会带来其他问题，如实现复杂化、用户扩展难度增加以及可能的代码膨胀。</li>
</ul>
<p>为什么不采用策略设计：</p>
<ul>
<li><strong>实现复杂化</strong>：策略设计会使容器的实现更加复杂。</li>
<li><strong>用户扩展难度增加</strong>：复杂的实现会使用户难以扩展和修改容器。</li>
<li><strong>潜在的代码膨胀</strong>：虽然可以节省每个容器实例中的4字节空间，但由于策略设计可能导致更多的代码膨胀，反而浪费了更多的内存。</li>
</ul>
<p>通过这种方式，EASTL在简化实现和提高灵活性的同时，权衡了一些小的性能损失，确保了整体的设计简洁性和易用性。</p>
<h3 id="算法">算法
</h3><p><strong>算法设计哲学</strong>：</p>
<ul>
<li>EASTL算法遵循标准C++算法的设计原则，强调使用迭代器而非容器。</li>
<li>通过使用迭代器，算法可以处理容器的任意子范围，并且可以应用于非容器的数据结构（如C数组）。</li>
</ul>
<p><strong>灵活性和通用性</strong>：</p>
<ul>
<li>这种设计使得算法更加灵活和通用，用户可以轻松指定要操作的数据范围，而不需要局限于特定类型的容器。</li>
<li>例如，find算法接受两个迭代器参数，允许在任意范围内查找元素。</li>
</ul>
<p><strong>性能优化</strong>：</p>
<ul>
<li>EASTL算法不仅与商业库中的最佳STL算法一样优化，而且在很多情况下表现更好。</li>
<li>EASTL算法利用类型特征和迭代器类型进行优化，以生成更高效的代码。例如，对于整数数组或POD类型的数据，EASTL会在适当的情况下使用memcpy来代替逐对象复制，从而提高性能。</li>
</ul>
<p><strong>复杂性和实现难度</strong>：</p>
<ul>
<li>EASTL算法和相关支持代码使用了一些高级的C++技巧，尽管代码本身易于阅读，但实现和维护这些优化需要深厚的C++知识和经验。</li>
<li>开发和维护EASTL相比简单的库需要更多的努力和专业知识，但由于其带来的性能提升，这种权衡被认为是值得的。</li>
</ul>
<p>总结来说，EASTL通过精心设计的算法和高级优化技术，在保持灵活性和通用性的同时，显著提升了性能。尽管这增加了开发和维护的复杂性，但最终的性能优势使其成为高性能应用的理想选择。</p>
<h3 id="智能指针">智能指针
</h3><p>EASTL实现了以下智能指针类型：</p>
<ul>
<li>shared_ptr</li>
<li>shared_array</li>
<li>weak_ptr</li>
<li>instrusive_ptr</li>
<li>scoped_ptr</li>
<li>scoped_array</li>
<li>linked_ptr</li>
<li>linked_array</li>
</ul>
<p>除了linked_ptr和linked_array之外，其他智能指针都是来自Boost库中广为人知的智能指针。</p>
<p>这些智能指针的行为与Boost中的非常相似，但有两个例外：</p>
<p><strong>分配器赋值</strong>：</p>
<ul>
<li>EASTL智能指针允许你为它们分配一个分配器。</li>
<li>这使得EASTL在内存分配和跟踪方面具有更多的控制权，因为Boost智能指针单方面使用全局operator new从全局堆中分配内存。</li>
</ul>
<p><strong>shared_ptr的删除机制</strong>：</p>
<ul>
<li>EASTL的shared_ptr通过模板参数实现删除，而不是通过动态分配的虚拟成员对象接口。</li>
<li><strong>优点</strong>: EASTL避免了堆分配、避免了虚拟函数调用，并减少了模板类的泛滥。</li>
<li><strong>缺点</strong>: 如果EASTL的shared_ptr容器持有void指针，则除非用户手动指定自定义删除器模板参数，否则无法调用其包含对象的析构函数。这种情况表明EASTL更高效但安全性较低。如果这个问题在未来成为一个问题，我们可以重新审视这个话题。</li>
</ul>
<h3 id="listsize-is-on">list::size is O(n)
</h3><p>链表类的设计决策</p>
<p><strong>当前设计</strong>：</p>
<ul>
<li>EASTL中的 <code>list</code>、<code>slist</code> 和 <code>intrusive_list</code> 类不缓存链表的大小。</li>
<li>获取链表大小的操作需要遍历整个链表并计数节点，因此是一个O(n)操作。</li>
</ul>
<p><strong>支持缓存大小的理由</strong>：</p>
<ul>
<li>符合C++标准：根据C++标准，std::list的size函数应为O(1)操作。</li>
<li>常见实现方式：许多C++标准库的实现都包含一个成员变量来缓存链表的大小。</li>
<li>性能优势：更新一个整数大小是非常快的，用户可以快速获取链表的大小。</li>
<li>用户期望：许多开发者期望size函数能够快速执行。</li>
</ul>
<p><strong>反对缓存大小的理由</strong>：</p>
<ul>
<li>增加内存开销：每个链表实例需要额外的4个字节来存储大小。</li>
<li>增加处理开销：每次插入或删除节点时，都需要更新大小变量，增加了少量的处理开销。</li>
<li>仅对size函数有益：缓存大小仅对size函数有效，对其他操作无明显改善。</li>
<li>intrusive_list的特殊性：对于intrusive_list，缓存大小可能会带来更多问题，因为它的节点管理机制不同。</li>
</ul>
<p><strong>最终决策与理由:</strong></p>
<ul>
<li><strong>性能优先</strong>：由于EASTL主要针对游戏开发，性能是最关键的因素。因此，EASTL选择不缓存链表的大小，以避免额外的内存和处理开销。</li>
<li><strong>灵活性</strong>：如果用户确实需要快速的size函数，他们可以自行实现大小缓存。这样既保持了库的轻量化，又满足了特定需求。</li>
</ul>
<h3 id="basic_string不使用写时复制">basic_string不使用写时复制
</h3><p>————以下内容只是介绍 <strong>写时复制</strong> 机制——与EASTL无关————</p>
<p>Copy-on-Write（写时复制，简称COW） 是一种优化技术，广泛应用于操作系统、数据库和编程语言中，用于提高资源管理的效率。</p>
<p>它通过延迟实际数据的复制操作，直到真正需要修改数据时才进行复制，从而节省内存和计算资源。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>共享数据</strong>：当一个对象或数据结构被复制时，初始阶段并不会创建一个新的副本。相反，原始对象和新对象会共享同一份数据。</li>
<li><strong>检测写操作</strong>：如果任何一个对象尝试修改共享的数据（即执行写操作），系统会检测到这一操作，并为该对象创建一份独立的数据副本。</li>
<li><strong>独立修改</strong>：在创建了新的副本之后，只有执行写操作的对象会使用这份新的副本，而其他对象仍然共享原始数据。</li>
<li><strong>避免不必要的复制</strong>：如果多个对象只是读取数据而不进行任何修改，它们可以继续共享同一份数据，无需进行额外的复制操作。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">str2</span> <span class="o">=</span> <span class="n">str1</span><span class="p">;</span> <span class="c1">// 此时 str1 和 str2 共享同一份数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">str2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;J&#39;</span><span class="p">;</span> <span class="c1">// 尝试将第一个字符改为 &#39;J&#39;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>写时复制机制会触发，系统会为 <code>str2</code> 创建一个新的副本，并在新副本上进行修改，而 <code>str1</code> 仍然指向原来的 <code>&quot;Hello&quot;</code>。</p>
<p>对于STL标准库来说，<code>std::string</code>在C++11后不再支持COW机制.</p>
<p>————以上内容只是介绍 <strong>写时复制</strong> 机制——与EASTL无关————</p>
<p>CoW机制可以在某些情况下提高效率，但其带来的额外复杂性和开销使其在许多应用场景中并不适用。</p>
<p>对于高性能需求的游戏开发环境，线程安全和内存管理的复杂性使得CoW字符串的实现面临诸多挑战。</p>
<p>因此，EASTL选择不在主要的basic_string实现中使用CoW机制，而是考虑为特定需求提供一个独立的cow_string类，以便在不影响整体性能的情况下满足特定需求。</p>
<p>CoW字符串的缺点包括：</p>
<ol>
<li><strong>引用计数</strong>：字符串需要有一个引用计数，这增加了字符串的内存使用。</li>
<li><strong>线程安全</strong>：在多线程环境下，原子操作和互斥锁非常昂贵，特别是在较弱的内存系统上，如游戏主机平台。</li>
<li><strong>非const访问器函数</strong>：所有非const字符串访问器函数都需要进行共享检查，并且第一次这样的检查需要分离字符串。类似地，所有字符串赋值也需要进行共享检查。如果你在赋值之前访问了字符串，那么赋值不会导致共享字符串，因为字符串已经被分离。</li>
<li><strong>字符串共享频率低</strong>：大多数情况下，字符串并不会被共享。在某些情况下，引用计数所需的总内存可能超过通过共享表示节省的内存。</li>
<li><strong>cow_string类的考虑</strong>：EASTL正在考虑添加一个<code>cow_string</code>类。有些系统的字符串使用模式可能会从CoW共享中受益。这种功能最好保存在一个单独的字符串实现中，这样其他字符串使用不会受到影响。</li>
</ol>
<h3 id="配置">配置
</h3><p>EASTL要求覆盖全局new</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="kr">__cdecl</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">debugFlags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="kr">__cdecl</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">alignment</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">pName</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">debugFlags</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="容器-1">容器
</h2><h3 id="array">Array
</h3><p><a class="link" href="https://github.com/electronicarts/EASTL/blob/master/include/EASTL/array.h"  target="_blank" rel="noopener"
    >Array</a></p>
<ul>
<li>实现了一个符合C++标准TR1的模板数组类。</li>
<li>这个类允许你像使用STL vector一样使用内置的C风格数组。</li>
<li>它不允许你改变其大小，因为它就像一个C内置数组一样。</li>
<li>我们的实现努力去除函数调用嵌套，因为这会使我们在调试构建中由于函数调用开销而难以进行性能分析。</li>
<li>注意，根据C++标准更新提案的要求，这里故意将其定义为一个具有公共数据的结构体（struct）。</li>
</ul>
<h4 id="使用示例">使用示例
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">eastl</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="类型别名">类型别名
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">array</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span>                                   <span class="n">this_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">T</span>                                             <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">value_type</span><span class="o">&amp;</span>                                   <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span>                             <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">value_type</span><span class="o">*</span>                                   <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span>                             <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">eastl</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">eastl</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span>       <span class="n">const_reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">typedef</span> <span class="n">eastl_size_t</span>                                  <span class="n">size_type</span><span class="p">;</span>        <span class="c1">// See config.h for the definition of eastl_size_t, which defaults to size_t.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">typedef</span> <span class="n">ptrdiff_t</span>                                     <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">ArrayTest</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">5</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// eastl::array&lt;int, 5&gt; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_this_type</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">this_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//BEGIN—— 类型别名 都来自于T ——BEGIN
</span></span></span><span class="line"><span class="cl"><span class="c1">// int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_value_type</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// int&amp; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_reference</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//const int&amp; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_const_reference</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_iterator</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// const int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_const_iterator</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// eastl::reverse_iterator&lt;int*&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_reverse_iterator</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// eastl::reverse_iterator&lt;const int*&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_const_reverse_iterator</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">const_reverse_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//END—— 类型别名 都来自于T ——END
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// unsigned long long 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_size_type</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// long long 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">Array_difference_type</span> <span class="o">=</span> <span class="n">ArrayTest</span><span class="o">::</span><span class="n">difference_type</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="聚合初始化">聚合初始化
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Note that the member data is intentionally public.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This allows for aggregate initialization of the
</span></span></span><span class="line"><span class="cl"><span class="c1">// object (e.g. array&lt;int, 5&gt; a = { 0, 3, 2, 4 }; )
</span></span></span><span class="line"><span class="cl"><span class="c1">// do not use this member directly (use data() instead).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">value_type</span> <span class="n">mValue</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>注意，成员数据有意是公开的。</li>
<li>这允许对对象进行聚合初始化（例如，array&lt;int, 5&gt; a = {0,3,2,4};）</li>
<li>不要直接使用这个成员（使用data（）代替）。</li>
</ul>
<p><code>eastl::array</code> <strong>维护了一个C风格数组.</strong></p>
<p>这个<code>eastl::array</code>类没有显式定义构造函数，是为了保持其作为<strong>聚合类型</strong>的特性，从而允许通过<strong>聚合初始化</strong>直接初始化其公有成员数组<code>mValue</code>。</p>
<p><strong>源码注释里: 故意不提供构造函数、析构函数或赋值操作符。</strong></p>
<p><strong>聚合类型的定义</strong>：C++规定，满足以下条件的类或结构体是聚合类型：</p>
<ol>
<li>没有用户提供的构造函数（包括默认构造函数）；</li>
<li>所有非静态成员都是公有的；</li>
<li>没有基类和虚函数。</li>
</ol>
<p><code>eastl::array</code>符合这些条件，因此它是一个聚合类型。</p>
<p><strong>支持聚合初始化</strong>：聚合类型允许通过花括号列表直接初始化成员，无需定义构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>  <span class="c1">// 直接初始化公有成员a和b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//-----------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_struct</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">Valueint</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">mValue</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">Valuefloat</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">my_struct</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{.</span><span class="n">mValue</span><span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">.</span><span class="n">Value</span><span class="o">=</span> <span class="mf">2.5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">my_struct</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span><span class="mf">7.2</span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">eastl::array&lt;int, 5&gt; arr {1, 2, 3, 4, 5};
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>聚合初始化的作用</strong>：初始化列表<code>{1, 2, 3, 4, 5}</code>会直接赋值给<code>mValue</code>数组的对应元素。</li>
<li><strong>底层实现</strong>：编译器将初始化列表中的值按顺序填充到<code>mValue</code>的每个位置，等同于：</li>
<li><code>value_type mValue[5] = {1, 2, 3, 4, 5};</code></li>
</ul>
<p>如果初始化列表元素少于<code>N</code>，剩余元素会默认初始化（如<code>int</code>类型初始化为0）；</p>
<p>若多于<code>N</code>，编译器会报错。</p>
<ul>
<li><code>**std::array**</code><strong>的设计一致性</strong>：C++标准库的<code>std::array</code>同样没有显式构造函数，依赖聚合初始化。<code>eastl::array</code>遵循这一设计，确保接口兼容性和性能优化。</li>
<li><strong>性能优势</strong>：避免构造函数的调用开销，编译器可直接生成高效的初始化代码。</li>
</ul>
<p>总结:</p>
<p><code>eastl::array</code>不定义构造函数，是为了保持聚合类型的特性，允许用户通过<strong>花括号初始化列表</strong>直接填充公有成员数组<code>mValue</code>。</p>
<p>这种设计简化了实现，提高了效率，并与标准库的<code>std::array</code>行为一致。</p>
<p>初始化时，编译器直接将列表值按顺序赋给<code>mValue</code>，无需构造函数介入。</p>
<h4 id="成员函数">成员函数
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">eastl</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 输出:size:5 maxsize:5 empty:false data[0]:7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;size:{} maxsize:{} empty:{} data[0]:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">arr</span><span class="p">.</span><span class="n">max_size</span><span class="p">(),</span><span class="n">arr</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span><span class="n">arr</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">arr</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 输出:data[0]:120
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;data[0]:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arr</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 输出:data[0]:64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;data[0]:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 输出:data[0]:32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;data[0]:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//输出 32 2 3 4 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">&#34;{} &#34;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 输出 front:32 back:5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;front:{} back:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arr</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span><span class="n">arr</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果:</p>
<ul>
<li>size:5 maxsize:5 empty:false data[0]:7</li>
<li>data[0]:120</li>
<li>data[0]:64</li>
<li>data[0]:32</li>
<li>32 2 3 4 5</li>
<li>front:32 back:5</li>
</ul>
<h3 id="vector">Vector
</h3><p><a class="link" href="https://github.com/electronicarts/EASTL/blob/master/include/EASTL/vector.h"  target="_blank" rel="noopener"
    >Vector</a></p>
<h4 id="使用示例-1">使用示例
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">355</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 输出 127 2 3 355
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// begin:127 end:355
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;begin:&#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;&lt;</span><span class="s">&#34; end:&#34;</span><span class="o">&lt;&lt;*</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//size:4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;size:{}  </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//capacity:4 rbegin:355 rend:127
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;capacity:{} rbegin:{} rend:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">capacity</span><span class="p">(),</span><span class="o">*</span><span class="n">vec</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="o">*</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">rend</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//size:4 capacity:10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;size:{} capacity:{}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">capacity</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//begin:127 end:355
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;begin:{} end:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="o">*</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="o">*</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 输出：
</span></span></span><span class="line"><span class="cl"><span class="c1">// 127 2 3 355
</span></span></span><span class="line"><span class="cl"><span class="c1">// begin:127 end:355
</span></span></span><span class="line"><span class="cl"><span class="c1">// size:4
</span></span></span><span class="line"><span class="cl"><span class="c1">// capacity:4 rbegin:355 rend:127
</span></span></span><span class="line"><span class="cl"><span class="c1">// size:4 capacity:10
</span></span></span><span class="line"><span class="cl"><span class="c1">// begin:127 end:355
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>size 当前元素个数</li>
<li>capacity 当前容量</li>
<li>vec容量为10，但只有3个元素，那么size = 3,capacity = 10</li>
</ul>
<h4 id="扩容机制">扩容机制
</h4><p>下图是stl::vector，但是算法和EASTL是一样的.可作为参考.</p>
<p><img src="/p/eastl/eastlvector.png"
	width="1710"
	height="836"
	srcset="/p/eastl/eastlvector_hu7474304239063827096.png 480w, /p/eastl/eastlvector_hu1655858860475924589.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="204"
		data-flex-basis="490px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">size_type</span><span class="p">)(</span><span class="n">mpEnd</span> <span class="o">-</span> <span class="n">mpBegin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">size_type</span><span class="p">)(</span><span class="n">internalCapacityPtr</span><span class="p">()</span> <span class="o">-</span> <span class="n">mpBegin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">eastl</span><span class="o">::</span><span class="n">compressed_pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*</span><span class="p">,</span> <span class="n">allocator_type</span><span class="o">&gt;</span>  <span class="n">mCapacityAllocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">*&amp;</span> <span class="n">internalCapacityPtr</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mCapacityAllocator</span><span class="p">.</span><span class="n">first</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">internalCapacityPtr</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mCapacityAllocator</span><span class="p">.</span><span class="n">first</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>size = end - begin.</p>
<p>例如:<code>vector</code>里面有5个元素: 1,2,3,4,5 . begin 指向1 ， end指向5的下一个位置.</p>
<p>Capacity = 整个空间 - begin. 即为<code>vector</code>的整个空间容量.</p>
<p><code>**internalCapacityPtr()**</code>：返回指向当前分配的内存块的容量结束位置的指针。</p>
<p><code>vector</code> 创建时size=0，capacity=0</p>
<p><code>vector</code> 有一个元素，触发扩容，size=1,capacity=1</p>
<p><code>vector</code> 当后续再插入元素 空间不够时，整个空间扩容2倍.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;size:{} capacity:{}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">capacity</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">18</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;AddValue:{} size:{} capacity:{}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">capacity</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;front:{} back:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="nl">size</span><span class="p">:</span><span class="mi">0</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">size</span><span class="p">:</span><span class="mi">1</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">1</span> <span class="nl">size</span><span class="p">:</span><span class="mi">2</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">2</span> <span class="nl">size</span><span class="p">:</span><span class="mi">3</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">3</span> <span class="nl">size</span><span class="p">:</span><span class="mi">4</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">4</span> <span class="nl">size</span><span class="p">:</span><span class="mi">5</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">5</span> <span class="nl">size</span><span class="p">:</span><span class="mi">6</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">6</span> <span class="nl">size</span><span class="p">:</span><span class="mi">7</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">7</span> <span class="nl">size</span><span class="p">:</span><span class="mi">8</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">8</span> <span class="nl">size</span><span class="p">:</span><span class="mi">9</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">9</span> <span class="nl">size</span><span class="p">:</span><span class="mi">10</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">10</span> <span class="nl">size</span><span class="p">:</span><span class="mi">11</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">11</span> <span class="nl">size</span><span class="p">:</span><span class="mi">12</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">12</span> <span class="nl">size</span><span class="p">:</span><span class="mi">13</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">13</span> <span class="nl">size</span><span class="p">:</span><span class="mi">14</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">14</span> <span class="nl">size</span><span class="p">:</span><span class="mi">15</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">15</span> <span class="nl">size</span><span class="p">:</span><span class="mi">16</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">16</span> <span class="nl">size</span><span class="p">:</span><span class="mi">17</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">32</span>
</span></span><span class="line"><span class="cl"><span class="nl">AddValue</span><span class="p">:</span><span class="mi">17</span> <span class="nl">size</span><span class="p">:</span><span class="mi">18</span> <span class="nl">capacity</span><span class="p">:</span><span class="mi">32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">front</span><span class="p">:</span><span class="mi">0</span> <span class="nl">back</span><span class="p">:</span><span class="mi">17</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>容量不够时 扩容2倍.</p>
<p><strong>插入与扩容</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">mpEnd</span> <span class="o">&lt;</span> <span class="n">internalCapacityPtr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="o">::</span><span class="k">new</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">mpEnd</span><span class="o">++</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">DoInsertValueEnd</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>**mpEnd**</code>：指向当前 <code>vector</code> 中最后一个已使用的元素之后的位置。</li>
<li><code>**internalCapacityPtr()**</code>：返回指向当前分配的内存块的容量结束位置的指针。</li>
</ul>
<p>该条件检查当前 <code>vector</code> 是否有足够的空间来容纳新元素。</p>
<p>如果 <code>mpEnd</code> 小于 <code>internalCapacityPtr()</code>，则表示当前容量足够，可以直接插入新元素。</p>
<p><code>::new((void*)mpEnd++) value_type(value);</code> 放置式 <code>new</code> 操作符，用于在指定地址上构造对象。这里使用的是 <code>mpEnd</code> 所指向的地址，并且在构造后将 <code>mpEnd</code> 向前移动一位。</p>
<p><code>DoInsertValueEnd(value);</code> 当前容量不足时，调用此函数处理插入操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">DoInsertValueEnd</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">size_type</span> <span class="n">nPrevSize</span> <span class="o">=</span> <span class="n">size_type</span><span class="p">(</span><span class="n">mpEnd</span> <span class="o">-</span> <span class="n">mpBegin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">size_type</span> <span class="n">nNewSize</span>  <span class="o">=</span> <span class="n">GetNewCapacity</span><span class="p">(</span><span class="n">nPrevSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pointer</span> <span class="k">const</span>   <span class="n">pNewData</span>  <span class="o">=</span> <span class="n">DoAllocate</span><span class="p">(</span><span class="n">nNewSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="n">pointer</span> <span class="n">pNewEnd</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">uninitialized_move</span><span class="p">(</span><span class="n">mpBegin</span><span class="p">,</span> <span class="n">mpEnd</span><span class="p">,</span> <span class="n">pNewData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="k">new</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pNewEnd</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNewEnd</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">destruct</span><span class="p">(</span><span class="n">mpBegin</span><span class="p">,</span> <span class="n">mpEnd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">DoFree</span><span class="p">(</span><span class="n">mpBegin</span><span class="p">,</span> <span class="p">(</span><span class="n">size_type</span><span class="p">)(</span><span class="n">internalCapacityPtr</span><span class="p">()</span> <span class="o">-</span> <span class="n">mpBegin</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mpBegin</span>    <span class="o">=</span> <span class="n">pNewData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mpEnd</span>      <span class="o">=</span> <span class="n">pNewEnd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">internalCapacityPtr</span><span class="p">()</span> <span class="o">=</span> <span class="n">pNewData</span> <span class="o">+</span> <span class="n">nNewSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">typename</span> <span class="n">VectorBase</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">size_type</span>
</span></span><span class="line"><span class="cl"><span class="n">VectorBase</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">GetNewCapacity</span><span class="p">(</span><span class="n">size_type</span> <span class="n">currentCapacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// This needs to return a value of at least currentCapacity and at least 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="p">(</span><span class="n">currentCapacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">currentCapacity</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>GetNewCapacity</code> 如果当前容量为0，则扩容为1，其它情况下都扩容2倍.</p>
<p><strong>1. 计算当前大小与新容量</strong></p>
<ul>
<li><strong>当前大小</strong>：通过 <code>mpEnd - mpBegin</code> 获取当前元素数量。</li>
<li><strong>新容量</strong>：调用 <code>GetNewCapacity(nPrevSize)</code> 确定扩容后的新容量（通常按固定策略，如翻倍）。</li>
</ul>
<p><strong>2. 分配新内存</strong></p>
<ul>
<li>使用 <code>DoAllocate(nNewSize)</code> 分配大小为 <code>nNewSize</code> 的新内存块 <code>pNewData</code>。</li>
</ul>
<p><strong>3. 迁移旧数据</strong></p>
<ul>
<li><strong>移动构造</strong>：通过 <code>eastl::uninitialized_move</code> 将旧数据移动到新内存。这一步调用元素的移动构造函数，转移资源所有权。</li>
<li><strong>构造新元素</strong>：在新内存末尾（<code>pNewEnd</code>）使用 placement new 和完美转发 <code>Args&amp;&amp;...</code> 直接构造新元素，避免额外拷贝。</li>
</ul>
<p><strong>4. 清理旧内存</strong></p>
<ul>
<li><strong>析构旧元素</strong>：调用 <code>eastl::destruct</code> 析构旧内存中的元素（移动后的源对象仍需析构，但资源已转移）。</li>
<li><strong>释放旧内存</strong>：通过 <code>DoFree</code> 释放原内存块，需传入原指针和容量（确保内存正确释放）。</li>
</ul>
<p><strong>5. 更新内部指针</strong></p>
<ul>
<li><code>**mpBegin**</code>：指向新内存起始位置。</li>
<li><code>**mpEnd**</code>：指向新内存的末尾（即最后一个元素的下一个位置）。</li>
<li><code>**internalCapacityPtr()**</code>：更新为新内存的容量终点（<code>pNewData + nNewSize</code>）。</li>
</ul>
<p><strong>右值版本 调用移动构造</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mpEnd</span> <span class="o">&lt;</span> <span class="n">internalCapacityPtr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="o">::</span><span class="k">new</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">mpEnd</span><span class="o">++</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">DoInsertValueEnd</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>右值引用</strong>：如果传递的是右值引用（rvalue reference），则会调用移动构造函数。</li>
<li><strong>左值引用</strong>：如果传递的是左值引用（lvalue reference），则会调用拷贝构造函数。</li>
</ol>
<h3 id="list">list
</h3><p>该链表与 <code>std::list</code> 的主要区别如下：</p>
<ul>
<li>
<p><strong>缺少部分不常用函数</strong>：</p>
</li>
<li>
<p>这个链表没有实现 <code>std::list</code> 中一些不太常用的函数。任何需要的函数可以在以后添加。</p>
</li>
<li>
<p><strong>扩展函数提升性能</strong>：</p>
</li>
<li>
<p>链表包含了一些扩展函数，可以提高性能。</p>
</li>
<li>
<p><strong>支持对象对齐要求</strong>：</p>
</li>
<li>
<p>链表可以包含具有对齐要求的对象，而 <code>std::list</code> 在不进行一些繁琐且非便携的操作时无法做到这一点。</p>
</li>
<li>
<p><strong>针对目标平台的优化</strong>：</p>
</li>
<li>
<p>链表包含了一些在标准库供应商提供的 STL 实现中不存在的优化。</p>
</li>
<li>
<p><strong>本地支持调试内存命名</strong>：</p>
</li>
<li>
<p>链表本地支持调试内存命名。</p>
</li>
<li>
<p><code>**size()**</code> <strong>函数的时间复杂度</strong>：</p>
</li>
<li>
<p>默认情况下，<code>list::size()</code> 不是一个常数时间函数（类似于某些标准实现如 STLPort 和 SGI STL 中的 <code>list::size</code>），但与 Dinkumware 和 Metrowerks 中的 <code>list</code> 不同。可以通过设置 <code>EASTL_LIST_SIZE_CACHE</code> 选项来改变这一行为。</p>
</li>
<li>
<p><strong>提供可移植节点定义</strong>：</p>
</li>
<li>
<p>链表提供了保证可移植的节点定义，允许用户编写自定义固定大小的节点分配器，并确保其可移植性。</p>
</li>
<li>
<p><strong>易读、调试和可视化</strong>：</p>
</li>
<li>
<p>链表更容易阅读、调试和可视化。</p>
</li>
<li>
<p><strong>适应无异常处理环境</strong>：</p>
</li>
<li>
<p>链表能够适应没有异常处理的环境，这在控制台或嵌入式环境中有时是必要的。</p>
</li>
<li>
<p><strong>减少深层嵌套函数调用</strong>：</p>
</li>
<li>
<p>链表减少了深层嵌套函数调用，并允许用户在调试构建中启用强制内联，以减少代码膨胀。</p>
</li>
<li>
<p><strong>不保留成员变量</strong> <code>**size**</code>：</p>
</li>
<li>
<p>链表不保留成员变量 <code>size</code>。这意味着链表比 <code>std::list</code> 更小（取决于 <code>std::list</code> 的实现），并且对于大多数操作来说更快。然而，<code>list::size</code> 函数的速度较慢。</p>
</li>
<li>
<p><code>**size_type**</code> <strong>定义为</strong> <code>**eastl_size_t**</code>：</p>
</li>
<li>
<p><code>list::size_type</code> 定义为 <code>eastl_size_t</code> 而不是 <code>size_t</code>，以节省内存并在 64 位系统上运行更快。</p>
</li>
</ul>
<h3 id="string">string
</h3><p><a class="link" href="https://github.com/electronicarts/EASTL/blob/master/include/EASTL/string.h"  target="_blank" rel="noopener"
    >string</a></p>
<p>实现了一个 <code>basic_string</code> 类，类似于 C++ 标准库中的 <code>std::basic_string</code>。<code>basic_string</code> 和 <code>std::basic_string</code> 的主要区别如下：</p>
<ul>
<li><strong>扩展函数</strong>：<code>basic_string</code> 包含一些扩展函数，可以提高性能。</li>
<li><strong>易用性</strong>：<code>basic_string</code> 包含一些扩展函数，使使用更加方便，例如成员 <code>sprintf</code> 函数和成员 <code>tolower</code>/<code>toupper</code> 函数。</li>
<li><strong>调试内存命名</strong>：<code>basic_string</code> 本地支持调试内存命名。</li>
<li><strong>可读性和调试</strong>：<code>basic_string</code> 更容易阅读、调试和可视化。</li>
<li><strong>内部手动扩展基本函数</strong>：如 <code>begin()</code>、<code>size()</code> 等，以改进调试性能和优化器的成功率。</li>
<li><strong>无异常处理环境适应性</strong>：<code>basic_string</code> 能够适应没有异常处理的环境，这在控制台或嵌入式环境中有时是必要的。</li>
<li><strong>减少深层嵌套函数调用</strong>：允许用户在调试构建中启用强制内联，以减少代码膨胀。</li>
<li><strong>不使用字符特性（char traits）</strong>：因此，EASTL 假设字符串将包含字符而不是像小部件这样的奇特事物。至少，<code>basic_string</code> 假设 <code>value_type</code> 是一个 POD（Plain Old Data）类型。</li>
<li><strong><code>basic_string::size_type</code></strong> <strong>定义为</strong> <code>**eastl_size_t**</code>：而不是 <code>size_t</code>，以节省内存并在 64 位系统上运行更快。</li>
<li><strong>数据保证连续</strong>：<code>basic_string</code> 数据保证是连续的。</li>
<li><strong>数据保证以零终止</strong>：<code>c_str()</code> 函数保证返回与 <code>data()</code> 相同的指针，该指针保证与 <code>&amp;string[0]</code> 的值相同。</li>
<li><strong><code>set_capacity()</code></strong> <strong>函数</strong>：释放多余的容量。在 <code>std::basic_string</code> 中唯一能做到这一点的方法是通过晦涩的技巧，例如使用 <code>basic_string&lt;char&gt;(x).swap(x);</code>。</li>
<li><strong><code>force_size()</code></strong> <strong>函数</strong>：单方面移动字符串结束位置（<code>mpEnd</code>）到给定位置。这对于用户通过外部方式（如 C 的 <code>strcpy</code> 或 <code>sprintf</code>）写入字符串时非常有用。</li>
<li>**<code>substr()</code> <strong>函数偏离标准</strong>：返回一个带有此 <code>get_allocator()</code> 复制的新字符串。</li>
</ul>
<p><a class="link" href="https://www.yuque.com/u28400626/kb/zyfgukt95u820r4n#x4PUt"  target="_blank" rel="noopener"
    >basic_string不使用写时复制</a></p>
<h4 id="sso优化">SSO优化
</h4><p>空结构体，用作标记类型，帮助区分不同的构造函数重载。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// CtorDoNotInitialize 存在的原因是我们可以创建一个仅分配内存但不进行初始化的构造函数，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 并且不会与其他任何构造函数声明发生冲突。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">CtorDoNotInitialize</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CtorSprintf 存在的原因是我们可以创建一个接受 printf 风格参数的构造函数，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 并且不会与其他任何构造函数声明发生冲突。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">CtorSprintf</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CtorConvert 存在的原因是我们可以有一个实现字符串编码转换的构造函数，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 例如在 UCS2 char16_t 和 UTF8 char8_t 之间进行转换。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">CtorConvert</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于确定我们是否处于 SSO（Short String Optimization，短字符串优化）或堆模式的掩码
</span></span></span><span class="line"><span class="cl"><span class="c1">// 小端序使用最高有效位（MSB）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 检测是否使用堆存储字符串。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">EA_CONSTEXPR_OR_CONST</span> <span class="n">size_type</span> <span class="n">kHeapMask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">size_type</span><span class="p">(</span><span class="o">~</span><span class="n">size_type</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 检测是否使用短字符串优化（SSO）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">EA_CONSTEXPR_OR_CONST</span> <span class="n">size_type</span> <span class="n">kSSOMask</span>  <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 当字符串数据从分配器获取时，内存视图的结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">HeapLayout</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">value_type</span><span class="o">*</span> <span class="n">mpBegin</span><span class="p">;</span>  <span class="c1">// 字符串的起始位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">size_type</span> <span class="n">mnSize</span><span class="p">;</span>     <span class="c1">// 字符串的大小。当前字符串中的字符数，不包括结尾的 &#39;0&#39;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">size_type</span> <span class="n">mnCapacity</span><span class="p">;</span> <span class="c1">// 字符串的容量。字符串可以容纳的字符数，不包括结尾的 &#39;0&#39;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>SSO优化</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 短字符优化
</span></span></span><span class="line"><span class="cl"><span class="c1">//SSO 是一种常见的优化技术，用于在小字符串的情况下避免动态内存分配。
</span></span></span><span class="line"><span class="cl"><span class="c1">//通常，字符串类会在对象内部预留一小块缓冲区（称为 SSO 缓冲区），用于存储短字符串。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CharT</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CharT</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SSOPadding</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//CharT：表示字符类型（如 char, wchar_t, char16_t, char32_t 等）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//size_t：默认为 sizeof(CharT)，用于区分不同的字符类型。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//padding数组用于填充，以确保结构体的大小与字符类型的大小对齐。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">padding</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CharT</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CharT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SSOPadding</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 模板特化以移除填充结构，避免零长度数组警告
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 同时，这也允许我们利用空基类优化（empty-base-class optimization）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 适用于 CharT 的大小为 1 字节的情况（例如 char 类型）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 当字符串数据能够在本地存储（无需堆分配）时的内存视图。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">SSOLayout</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// SSO_CAPACITY 计算公式：(HeapLayout 的大小 - 1 字节) / 字符类型的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">EA_CONSTEXPR_OR_CONST</span> <span class="n">size_type</span> <span class="n">SSO_CAPACITY</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HeapLayout</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// mnSize 必须对应于 HeapLayout.mnCapacity 的最后一个字节，因此我们不希望编译器在 mnSize 后插入填充（如果 sizeof(value_type) != 1）；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 同时确保两种布局具有相同的大小。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">SSOSize</span> <span class="o">:</span> <span class="n">SSOPadding</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">mnRemainingSize</span><span class="p">;</span> <span class="c1">// 剩余大小字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">value_type</span> <span class="n">mData</span><span class="p">[</span><span class="n">SSO_CAPACITY</span><span class="p">];</span> <span class="c1">// 用于存储字符串数据的本地缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SSOSize</span> <span class="n">mRemainingSizeField</span><span class="p">;</span>    <span class="c1">// 剩余大小字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>HeapLayout</code> 结构体</strong>：描述字符串在堆上的内存布局，包含字符串的起始位置、大小和容量。</p>
<p><strong><code>SSOLayout</code> 结构体</strong>：用于描述字符串在本地缓冲区中的内存布局，适用于短字符串优化（SSO）。它包含一个本地缓冲区 <code>mData</code> 和一个剩余大小字段 <code>mRemainingSizeField</code>。</p>
<p><strong><code>SSO_CAPACITY</code></strong>：计算本地缓冲区的容量，确保能够存储短字符串而不需动态内存分配。</p>
<p><strong>实际应用</strong>：通过 <code>SSOLayout</code> 结构体，可以有效地管理短字符串的内存布局，减少不必要的动态内存分配，提高性能和效率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// This view of memory is a utility structure for easy copying of the string data.
</span></span></span><span class="line"><span class="cl"><span class="c1">//这个内存视图是一个实用结构，便于复制字符串数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">RawLayout</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//大小是 sizeof(HeapLayout)，这意味着它可以容纳一个 HeapLayout 结构体的所有数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">mBuffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HeapLayout</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 当字符串数据从分配器获取时，内存视图的结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">HeapLayout</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">value_type</span><span class="o">*</span> <span class="n">mpBegin</span><span class="p">;</span>  <span class="c1">// 字符串的起始位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">size_type</span> <span class="n">mnSize</span><span class="p">;</span>     <span class="c1">// 字符串的大小。当前字符串中的字符数，不包括结尾的 &#39;0&#39;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">size_type</span> <span class="n">mnCapacity</span><span class="p">;</span> <span class="c1">// 字符串的容量。字符串可以容纳的字符数，不包括结尾的 &#39;0&#39;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 这实现了“短字符串优化”或 SSO。SSO 重用了字符串类现有的存储来保存足够短的字符串数据，从而避免了堆分配。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 存储在字符串 SSO 缓冲区中的字符数量是可变的，并且取决于字符串字符的宽度。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 此实现更倾向于保持一致的字符串大小，而不是增加字符串本地数据的大小以容纳一致数量的字符，尽管字符宽度不同。
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a class="link" href="https://github.com/electronicarts/EASTL/blob/master/include/EASTL/string.h#L388"  target="_blank" rel="noopener"
    >Layout</a></p>
<ol>
<li><strong>统一管理字符串存储</strong>：
<ul>
<li>使用联合体来管理不同类型的内存布局，使得字符串可以在堆上或本地缓冲区中存储，具体取决于字符串的长度。</li>
<li>通过 <code>IsHeap()</code> 和 <code>IsSSO()</code> 方法判断当前使用的是堆分配还是 SSO 缓冲区。</li>
</ul>
</li>
<li><strong>提供一致的接口</strong>：
<ul>
<li>提供了多种方法来获取和设置字符串的各种属性（如大小、容量、指针等），无论字符串是存储在堆上还是 SSO 缓冲区中，都能通过统一的接口进行操作。</li>
</ul>
</li>
<li><strong>支持拷贝和移动操作</strong>：
<ul>
<li>提供了拷贝构造函数、赋值运算符以及移动构造函数和赋值运算符，确保对象可以安全地进行拷贝和移动操作。</li>
<li>使用 <code>Copy</code> 和 <code>Move</code> 方法来处理不同情况下的数据复制和移动。</li>
</ul>
</li>
<li><strong>灵活的初始化和重置</strong>：
<ul>
<li>默认情况下，字符串以 SSO 模式初始化（<code>ResetToSSO</code> 方法）。</li>
<li>提供了 <code>Swap</code> 方法用于交换两个 <code>Layout</code> 对象的内容。</li>
</ul>
</li>
</ol>
<p><strong>Layout 成员函数:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">构造与赋值：</span>
</span></span><span class="line"><span class="cl"><span class="err">构造函数：默认构造函数将字符串初始化为</span> <span class="n">SSO</span> <span class="err">模式。拷贝构造函数和移动构造函数分别用于拷贝和移动对象。</span>
</span></span><span class="line"><span class="cl"><span class="err">赋值运算符：提供了拷贝赋值和移动赋值运算符。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">状态检查：</span>
</span></span><span class="line"><span class="cl"><span class="n">IsHeap</span><span class="p">()</span><span class="err">：检查当前是否使用堆分配。</span>
</span></span><span class="line"><span class="cl"><span class="n">IsSSO</span><span class="p">()</span><span class="err">：检查当前是否使用</span> <span class="n">SSO</span> <span class="err">缓冲区。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">获取指针：</span>
</span></span><span class="line"><span class="cl"><span class="n">SSOBufferPtr</span><span class="p">()</span><span class="err">：获取</span> <span class="n">SSO</span> <span class="err">缓冲区的指针。</span>
</span></span><span class="line"><span class="cl"><span class="n">HeapBeginPtr</span><span class="p">()</span><span class="err">：获取堆分配字符串的起始指针。</span>
</span></span><span class="line"><span class="cl"><span class="n">BeginPtr</span><span class="p">()</span><span class="err">：根据当前模式返回相应的起始指针。</span>
</span></span><span class="line"><span class="cl"><span class="n">EndPtr</span><span class="p">()</span><span class="err">：根据当前模式返回相应的结束指针（指向字符串末尾的空字符）。</span>
</span></span><span class="line"><span class="cl"><span class="n">CapacityPtr</span><span class="p">()</span><span class="err">：根据当前模式返回相应的容量指针（指向缓冲区末尾）。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">获取和设置大小与容量：</span>
</span></span><span class="line"><span class="cl"><span class="n">GetSSOSize</span><span class="p">()</span><span class="err">：获取</span> <span class="n">SSO</span> <span class="err">缓冲区中的字符串大小。</span>
</span></span><span class="line"><span class="cl"><span class="n">GetHeapSize</span><span class="p">()</span><span class="err">：获取堆分配字符串的大小。</span>
</span></span><span class="line"><span class="cl"><span class="n">GetSize</span><span class="p">()</span><span class="err">：根据当前模式返回相应的字符串大小。</span>
</span></span><span class="line"><span class="cl"><span class="n">SetSSOSize</span><span class="p">()</span><span class="err">：设置</span> <span class="n">SSO</span> <span class="err">缓冲区中的字符串大小。</span>
</span></span><span class="line"><span class="cl"><span class="n">SetHeapSize</span><span class="p">()</span><span class="err">：设置堆分配字符串的大小。</span>
</span></span><span class="line"><span class="cl"><span class="n">SetSize</span><span class="p">()</span><span class="err">：根据当前模式设置相应的字符串大小。</span>
</span></span><span class="line"><span class="cl"><span class="n">SetHeapCapacity</span><span class="p">()</span><span class="err">：设置堆分配字符串的容量。</span>
</span></span><span class="line"><span class="cl"><span class="n">GetHeapCapacity</span><span class="p">()</span><span class="err">：获取堆分配字符串的容量。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">拷贝与移动：</span>
</span></span><span class="line"><span class="cl"><span class="n">Copy</span><span class="p">()</span><span class="err">：实现深拷贝。</span>
</span></span><span class="line"><span class="cl"><span class="n">Move</span><span class="p">()</span><span class="err">：实现移动操作。</span>
</span></span><span class="line"><span class="cl"><span class="n">Swap</span><span class="p">()</span><span class="err">：交换两个</span> <span class="n">Layout</span> <span class="err">对象的内容。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">重置：</span>
</span></span><span class="line"><span class="cl"><span class="n">ResetToSSO</span><span class="p">()</span><span class="err">：将字符串重置为</span> <span class="n">SSO</span> <span class="err">模式，并将其内容清空。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>总结</strong></p>
<ul>
<li><strong><code>Layout</code> 结构体</strong>：通过联合体管理不同类型的内存布局（堆分配、SSO 缓冲区和原始数据视图），实现了短字符串优化（SSO）。</li>
<li><strong>主要功能</strong>：提供了一致的接口来获取和设置字符串的各种属性，支持拷贝和移动操作，并且可以根据需要在堆分配和 SSO 缓冲区之间切换。</li>
<li><strong>实际应用</strong>：通过这种设计，可以有效地减少不必要的动态内存分配，提高性能和效率，同时保持代码的简洁性和可靠性。</li>
</ul>
<p>在 <code>Layout</code> 结构体中，字符串可以存储在两个不同的地方：</p>
<ol>
<li><strong>SSO 缓冲区（Short String Optimization Buffer）</strong>：
<ul>
<li>当字符串长度较短时，字符串数据会被存储在 <code>SSOLayout</code> 中的本地缓冲区 <code>mData</code> 中。</li>
<li>这种情况下，字符串不会占用额外的堆内存。</li>
</ul>
</li>
<li><strong>堆分配（Heap Allocation）</strong>：
<ul>
<li>当字符串长度超过 SSO 缓冲区的容量时，字符串数据会被存储在堆上，具体通过 <code>HeapLayout</code> 结构体中的指针 <code>mpBegin</code> 来指向堆上的内存块。</li>
</ul>
</li>
</ol>
<p><strong>获取不同版本的指针</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">value_type</span><span class="o">*</span> <span class="nf">BeginPtr</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span>                    
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="n">IsHeap</span><span class="p">()</span> <span class="o">?</span> <span class="n">HeapBeginPtr</span><span class="p">()</span> <span class="o">:</span> <span class="n">SSOBeginPtr</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="nf">BeginPtr</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>        
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="n">IsHeap</span><span class="p">()</span> <span class="o">?</span> <span class="n">HeapBeginPtr</span><span class="p">()</span> <span class="o">:</span> <span class="n">SSOBeginPtr</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">value_type</span><span class="o">*</span> <span class="nf">HeapEndPtr</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span>                  
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="n">heap</span><span class="p">.</span><span class="n">mpBegin</span> <span class="o">+</span> <span class="n">heap</span><span class="p">.</span><span class="n">mnSize</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="nf">HeapEndPtr</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>      
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span> <span class="n">heap</span><span class="p">.</span><span class="n">mpBegin</span> <span class="o">+</span> <span class="n">heap</span><span class="p">.</span><span class="n">mnSize</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h4 id="string-成员函数">string 成员函数
</h4><p><a class="link" href="https://zh.cppreference.com/w/cpp/string/basic_string"  target="_blank" rel="noopener"
    >cppreference-string</a></p>
<p><strong>EASTL</strong>的很多函数都和<strong>STL</strong>中的相同.</p>
<p><code>basic_string</code> 类提供了多种构造函数，以支持不同场景下的字符串初始化。</p>
<ul>
<li><strong>默认构造</strong>：创建空字符串。</li>
<li><strong>带分配器的构造</strong>：允许指定分配器。</li>
<li><strong>部分复制构造</strong>：从现有字符串中复制部分内容。</li>
<li><strong>带长度和数据的构造</strong>：使用指定长度的数据初始化字符串。</li>
<li><strong>C 字符串构造</strong>：使用以空字符结尾的 C 字符串初始化。</li>
<li><strong>填充构造</strong>：创建包含多个相同字符的字符串。</li>
<li><strong>拷贝构造</strong>：创建现有字符串的副本。</li>
<li><strong>带分配器的拷贝构造</strong>：创建现有字符串的副本，并使用指定分配器。</li>
<li><strong>范围构造</strong>：使用指定范围的数据初始化字符串。</li>
<li><strong>不初始化构造</strong>：创建未初始化的字符串对象。</li>
<li><strong>格式化构造</strong>：使用格式化字符串初始化。</li>
<li><strong>初始化列表构造</strong>：使用初始化列表初始化。</li>
<li><strong>移动构造</strong>：使用右值引用移动构造。</li>
<li><strong>带分配器的移动构造</strong>：使用右值引用移动构造，并使用指定分配器。</li>
<li><strong>视图构造</strong>：使用字符串视图初始化。</li>
<li><strong>部分视图构造</strong>：使用字符串视图中的部分内容初始化。</li>
<li><strong>模板转换构造</strong>：支持不同字符类型的转换构造。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Implicit conversion operator
</span></span></span><span class="line"><span class="cl"><span class="c1">//这个隐式转换操作符允许将 basic_string 对象隐式转换为 basic_string_view&lt;T&gt; 类型的对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">operator</span> <span class="n">basic_string_view</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">printview</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sv</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;Hello World&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printview</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>void swap(this_type&amp; x)</strong></p>
<p>交换两个 <code>basic_string</code> 对象的内容。<br/>考虑了分配器的兼容性，以确保高效地交换内容，同时避免不必要的内存分配和拷贝。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">swap</span><span class="p">(</span><span class="n">this_type</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If allocators are equivalent...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">get_allocator</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">get_allocator</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">internalLayout</span><span class="p">().</span><span class="n">IsSSO</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">.</span><span class="n">internalLayout</span><span class="p">().</span><span class="n">IsSSO</span><span class="p">()))</span> 
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We leave mAllocator as-is.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">eastl</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">internalLayout</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">internalLayout</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="c1">// else swap the contents.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">const</span> <span class="n">this_type</span> <span class="nf">temp</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// Can&#39;t call eastl::swap because that would
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                   <span class="c1">// itself call this member swap function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">x</span>     <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>目的</strong>：交换两个 <code>basic_string</code> 对象的内容。</li>
<li><strong>实现方式</strong>
<ul>
<li>如果分配器相同或两者都使用 SSO 缓冲区，则直接交换内部布局。</li>
<li>如果分配器不同，则通过创建临时对象的方式进行交换。</li>
</ul>
</li>
<li><strong>优点</strong>
<ul>
<li>当分配器兼容时，交换操作非常高效，因为它只交换一些指针和状态信息，而不涉及实际数据的拷贝。</li>
<li>即使分配器不兼容，也能保证正确的交换行为。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>assign</strong></p>
<p>这个函数提供了一种方式来安全地将一个<code>basic_string</code>实例的内容复制到另一个实例中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">eastl</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">sv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">sv</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(size_type count, CharT ch)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;====&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="n">c</span><span class="p">(</span><span class="s">&#34;Exemplary&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(const basic_string&amp; str)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; == &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;Exemplary == Exemplary&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(const basic_string&amp; str, size_type pos, size_type count)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;Exemplar&#34;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(basic_string&amp;&amp; str)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;C++ by &#34;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;example&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;C++ by example&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(const CharT* s, size_type count)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="s">&#34;C-style string&#34;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;C-style&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(const CharT* s)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="s">&#34;C-style</span><span class="se">\0</span><span class="s">string&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;C-style&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">mutable_c_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;C-style string&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(InputIt first, InputIt last)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">mutable_c_str</span><span class="p">),</span> <span class="n">eastl</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">mutable_c_str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;C-style string&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// assign(::initializer_list&lt;CharT&gt; ilist)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">.</span><span class="n">assign</span><span class="p">({</span><span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &#34;C-style&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">====
</span></span><span class="line"><span class="cl">Exemplary == Exemplary
</span></span><span class="line"><span class="cl">Exemplar
</span></span><span class="line"><span class="cl">C++ by example
</span></span><span class="line"><span class="cl">C-style
</span></span><span class="line"><span class="cl">C-style
</span></span><span class="line"><span class="cl">C-style string
</span></span><span class="line"><span class="cl">C-style
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>append</strong></p>
<p><strong>追加多个字符或整个字符串</strong></p>
<p><strong>使用示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#34;ddd&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>源码</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">append</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">pBegin</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">pEnd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果pBegin和pEnd不同，则说明有字符需要追加。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">pBegin</span> <span class="o">!=</span> <span class="n">pEnd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//当前字符串的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_type</span> <span class="n">nOldSize</span>  <span class="o">=</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">GetSize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="c1">//要追加的字符数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_type</span> <span class="n">n</span>         <span class="o">=</span> <span class="p">(</span><span class="n">size_type</span><span class="p">)(</span><span class="n">pEnd</span> <span class="o">-</span> <span class="n">pBegin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="c1">//当前字符串的容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_type</span> <span class="n">nCapacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="c1">//追加后的新字符串大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_type</span> <span class="n">nNewSize</span> <span class="o">=</span> <span class="n">nOldSize</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//如果新的字符串大小超过当前容量，则需要重新分配内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">nNewSize</span> <span class="o">&gt;</span> <span class="n">nCapacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//计算新的容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">const</span> <span class="n">size_type</span> <span class="n">nLength</span> <span class="o">=</span> <span class="n">GetNewCapacity</span><span class="p">(</span><span class="n">nCapacity</span><span class="p">,</span> <span class="n">nNewSize</span> <span class="o">-</span> <span class="n">nCapacity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//分配新内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pointer</span> <span class="n">pNewBegin</span> <span class="o">=</span> <span class="n">DoAllocate</span><span class="p">(</span><span class="n">nLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				
</span></span><span class="line"><span class="cl">            <span class="c1">//将现有字符和要追加的字符复制到新分配的内存中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pointer</span> <span class="n">pNewEnd</span> <span class="o">=</span> <span class="n">CharStringUninitializedCopy</span><span class="p">(</span><span class="n">internalLayout</span><span class="p">().</span><span class="n">BeginPtr</span><span class="p">(),</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">EndPtr</span><span class="p">(),</span> <span class="n">pNewBegin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">pNewEnd</span>         <span class="o">=</span> <span class="n">CharStringUninitializedCopy</span><span class="p">(</span><span class="n">pBegin</span><span class="p">,</span>  <span class="n">pEnd</span><span class="p">,</span>  <span class="n">pNewEnd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">//标记字符串的结束位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">*</span><span class="n">pNewEnd</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">//设置新的开始指针、容量和大小，并释放旧的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">DeallocateSelf</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">internalLayout</span><span class="p">().</span><span class="n">SetHeapBeginPtr</span><span class="p">(</span><span class="n">pNewBegin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">internalLayout</span><span class="p">().</span><span class="n">SetHeapCapacity</span><span class="p">(</span><span class="n">nLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">internalLayout</span><span class="p">().</span><span class="n">SetHeapSize</span><span class="p">(</span><span class="n">nNewSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果新字符串大小不超过当前容量，则直接在现有内存中追加字符，并更新字符串大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pointer</span> <span class="n">pNewEnd</span> <span class="o">=</span> <span class="n">CharStringUninitializedCopy</span><span class="p">(</span><span class="n">pBegin</span><span class="p">,</span> <span class="n">pEnd</span><span class="p">,</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">EndPtr</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">//标记字符串的结束位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">*</span><span class="n">pNewEnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">internalLayout</span><span class="p">().</span><span class="n">SetSize</span><span class="p">(</span><span class="n">nNewSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>push_back</strong></p>
<p><strong>追加单个字符</strong></p>
<p><strong>使用示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hell&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;o&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>源码</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">(</span><span class="n">value_type</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用 append(size_type n, value_type c) 方法，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//其中 n 是要追加的字符数（在这里是1），c 是要追加的字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">append</span><span class="p">((</span><span class="n">size_type</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">append</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">value_type</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//检查是否需要追加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">size_type</span> <span class="n">nSize</span> <span class="o">=</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">GetSize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">size_type</span> <span class="n">nCapacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">        <span class="c1">//如果新的大小超过当前容量，则调用 reserve 方法重新分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">((</span><span class="n">nSize</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nCapacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">reserve</span><span class="p">(</span><span class="n">GetNewCapacity</span><span class="p">(</span><span class="n">nCapacity</span><span class="p">,</span> <span class="p">(</span><span class="n">nSize</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">nCapacity</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//填充新字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pointer</span> <span class="n">pNewEnd</span> <span class="o">=</span> <span class="n">CharStringUninitializedFillN</span><span class="p">(</span><span class="n">internalLayout</span><span class="p">().</span><span class="n">EndPtr</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">//标记字符串的结束位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">*</span><span class="n">pNewEnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">//更新字符串的实际大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">internalLayout</span><span class="p">().</span><span class="n">SetSize</span><span class="p">(</span><span class="n">nSize</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>find、replace</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hellohello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eastl</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">eastl_size_t</span> <span class="n">first</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&#34;HELLO&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">hellohelloworld</span>
</span></span><span class="line"><span class="cl"><span class="n">HELLOhelloworld</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>find</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">size_type</span>
</span></span><span class="line"><span class="cl">    <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">position</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">EASTL_LIKELY</span><span class="p">(((</span><span class="n">npos</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">position</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">GetSize</span><span class="p">()))</span> <span class="c1">// If the range is valid...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span> <span class="k">const</span> <span class="n">pTemp</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">search</span><span class="p">(</span><span class="n">internalLayout</span><span class="p">().</span><span class="n">BeginPtr</span><span class="p">()</span> <span class="o">+</span> <span class="n">position</span><span class="p">,</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">EndPtr</span><span class="p">(),</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">((</span><span class="n">pTemp</span> <span class="o">!=</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">EndPtr</span><span class="p">())</span> <span class="o">||</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="p">(</span><span class="n">size_type</span><span class="p">)(</span><span class="n">pTemp</span> <span class="o">-</span> <span class="n">internalLayout</span><span class="p">().</span><span class="n">BeginPtr</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">npos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>查找范围的有效性检查</strong>：
<ul>
<li>确保 <code>position</code> 和 <code>n</code> 的组合不会导致溢出，并且查找范围在当前字符串的有效范围内。</li>
</ul>
</li>
<li><strong>使用 <code>eastl::search</code> 进行查找</strong>：
<ul>
<li>在指定范围内查找子串，<code>eastl::search</code> 是一个标准算法，用于在一个范围内查找另一个范围的首次出现。</li>
</ul>
</li>
<li><strong>判断查找结果</strong>：
<ul>
<li>如果找到匹配的子串，计算并返回其起始位置。</li>
<li>如果查找空子串或未找到匹配的子串，返回 <code>npos</code>。</li>
</ul>
</li>
</ol>
<h3 id="hashtable">HashTable
</h3><p>哈希表(Hash Table)，也称为散列表，是一种数据结构，它通过哈希函数将键映射到表中的一个位置来加速查找操作。<br/>哈希表可以在平均情况下以常数时间复杂度 O(1）进行插入、删除和查找操作，这使得它们在许多应用场景中非常高效。</p>
<hr>
<p><strong>哈希表的基本概念</strong></p>
<ol>
<li><strong>哈希函数</strong>：用于将键转换为数组索引的函数。理想情况下，哈希函数应均匀分布键，以避免冲突。</li>
<li><strong>桶（Bucket）</strong>：哈希表中的每个位置通常称为桶，每个桶可以存储一个或多个键值对。</li>
<li><strong>冲突解决方法:</strong>
<ul>
<li><strong>链地址法（Separate Chaining）</strong>：每个桶是一个链表（或其他数据结构），用于存储具有相同哈希值的所有元素。</li>
<li><strong>开放寻址法（Open Addressing）</strong>：当发生冲突时，使用某种策略找到另一个空桶来存储元素。常见的策略包括线性探测、二次探测和双重哈希。</li>
</ul>
</li>
</ol>
<p><strong>哈希表的主要操作</strong></p>
<ol>
<li><strong>插入（Insert）</strong>：将一个新的键值对插入哈希表中。</li>
<li><strong>查找（Find/Search）</strong>：根据键查找对应的值。</li>
<li><strong>删除（Delete）</strong>：从哈希表中删除指定的键值对。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">插入操作</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.</span><span class="err">使用哈希函数计算键的哈希值。</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span><span class="err">将哈希值映射到哈希表的一个桶。</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.</span><span class="err">如果该桶为空，则直接插入键值对；如果该桶已占用，则使用冲突解决方法处理。</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="err">查找操作</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.</span><span class="err">使用哈希函数计算键的哈希值。</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span><span class="err">找到对应的桶，并在桶内查找是否存在该键。</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.</span><span class="err">如果存在，则返回对应的值；否则返回未找到的结果。</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="err">删除操作</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.</span><span class="err">使用哈希函数计算键的哈希值。</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span><span class="err">找到对应的桶，并在桶内查找并删除该键值对。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优点</strong></p>
<ul>
<li><strong>高效查找</strong>：在理想情况下，哈希表的查找、插入和删除操作的时间复杂度均为 O(1)。</li>
<li><strong>灵活性</strong>：支持多种数据类型的键值对。</li>
<li><strong>可扩展性</strong>：可以通过调整桶的数量和负载因子来优化性能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>冲突处理</strong>：尽管哈希函数设计得再好，也无法完全避免冲突。冲突处理会影响性能。</li>
<li><strong>空间开销</strong>：为了减少冲突，通常需要预留更多的空间，导致空间利用率较低。</li>
<li><strong>扩容问题</strong>：当哈希表接近满载时，需要进行扩容操作，这涉及重新计算所有元素的哈希值并重新分配位置，代价较高。</li>
</ul>
<p>哈希表广泛应用于各种算法和系统中，以下是几个典型的应用场景：</p>
<ol>
<li><strong>字典和集合</strong>：如 C++ STL 中的 <code>unordered_map</code> 和 <code>unordered_set</code>，Python 中的 <code>dict</code> 和 <code>set</code>。</li>
<li><strong>缓存机制</strong>：如 LRU 缓存（Least Recently Used Cache）。</li>
<li><strong>去重和计数</strong>：例如统计文档中单词出现的频率。</li>
<li><strong>数据库索引</strong>：提高查询效率。</li>
<li><strong>编译器符号表</strong>：管理变量名和函数名等符号信息。</li>
</ol>
<hr>
<h3 id="hash_set">hash_set
</h3><p>实现了一个 <code>hash_set</code>，这是一个哈希唯一项容器。查找操作的时间复杂度为 O(1)（即非常快），但容器不是排序的。</p>
<p>需要注意的是，查找操作只有在哈希表分布良好（没有冲突）时才是 O(1)。</p>
<p>当表变得越来越差时，查找操作的时间复杂度会接近 O(n)。</p>
<p>运用set,为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是  hash table,都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable  没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有。</p>
<p><strong>set_max_load_factor</strong></p>
<p>如果你想让哈希表永远不会增加其桶的使用量，可以调用 <code>set_max_load_factor</code> 并传入一个非常高的值，例如 <code>100000.f</code>。</p>
<p><strong>find_as</strong></p>
<p>为了支持能够在字符串哈希表中通过字符指针高效查找的功能（即不需要将字符指针转换为字符串对象），我们提供了 <code>find_as</code> 函数。这个函数允许你使用不同于哈希表键类型的键进行查找。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 示例 1：使用默认哈希和比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">hash_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hashSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hashSet</span><span class="p">.</span><span class="n">find_as</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span>    <span class="c1">// 使用默认哈希和比较函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 示例 2：显式指定哈希和比较函数（省略命名空间以简化）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">hash_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hashSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hashSet</span><span class="p">.</span><span class="n">find_as</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(),</span> <span class="n">equal_to</span><span class="o">&lt;&gt;</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="智能指针-1">智能指针
</h2><p>智能指针（Smart Pointer）是 C++ 中用于管理动态分配对象生命周期的一种工具。</p>
<p>通过封装原始指针，并利用 RAII 机制自动管理内存的分配和释放，从而避免常见的内存泄漏问题。</p>
<ol>
<li><strong>RAII 机制</strong></li>
</ol>
<ul>
<li><strong>资源获取即初始化</strong>：在对象创建时获取资源，在对象销毁时释放资源。</li>
<li><strong>作用域控制</strong>：智能指针在其作用域结束时自动释放所管理的对象，确保资源不会被遗忘或泄露。</li>
</ul>
<ol>
<li><strong>自动内存管理</strong></li>
</ol>
<ul>
<li><strong>自动释放</strong>：智能指针会在其生命周期结束时自动释放所管理的对象，减少手动管理内存的复杂性和出错的可能性。</li>
<li><strong>防止悬挂指针</strong>：智能指针能够检测到对象是否仍然被引用，从而防止悬挂指针的问题。</li>
</ul>
<ol>
<li><strong>引用计数</strong></li>
</ol>
<ul>
<li><strong>共享所有权</strong>：多个智能指针可以共享同一个对象的所有权，只有当最后一个指向该对象的智能指针被销毁时，才会释放该对象。</li>
<li><strong>线程安全</strong>：某些智能指针（如 <code>std::shared_ptr</code>）提供了线程安全的引用计数机制。</li>
</ul>
<ol>
<li><strong>独占所有权</strong></li>
</ol>
<ul>
<li><strong>单一所有权</strong>：某些智能指针（如 <code>std::unique_ptr</code>）确保只有一个指针拥有某个对象的所有权，防止多个指针同时管理同一对象。</li>
</ul>
<h3 id="unique_ptr">unique_ptr
</h3><ul>
<li><strong>独占所有权</strong>：一个 <code>std::unique_ptr</code> 对象只能指向一个对象，不能进行拷贝操作，但可以通过移动语义转移所有权。</li>
<li><strong>轻量级</strong>：相比于 <code>std::shared_ptr</code>，<code>std::unique_ptr</code> 更加轻量，因为它不涉及引用计数。</li>
</ul>
<p>更具体地说，<code>unique_ptr</code> 模板类存储一个指向动态分配对象的指针。该对象在 <code>unique_ptr</code> 的析构函数中自动删除，或者可以通过 <code>unique_ptr::reset</code> 函数手动删除。</p>
<h4 id="使用示例-2">使用示例
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Object</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Object</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;CreateObj &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Object</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;DestroyObj &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">ObjectPtr</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">Object</span><span class="o">*</span> <span class="n">obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPtr</span> <span class="n">objpt1</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPtr</span> <span class="n">objpt2</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;objpt1: {} objpt2:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">objpt1</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">,</span> <span class="n">objpt2</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1">// 交换 objpt1 和 objpt2 保存的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">objpt1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">objpt2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;----------objpt2.reset()--------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//reset - delete保存的指针.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//调用objpt2保存的Object对象的析构函数.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//然后，objpt2保存的指针是空指针.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">objpt2</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;----------Move Test--------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 把ptr1的指针交给ptr2，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ptr1指针为空，ptr2拥有原先ptr1的指针.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 也可以说 ptr2接管了ptr1的指针.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPtr</span> <span class="n">ptr1</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">400</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr1: {}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPtr</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;move ptr1 ---&gt; ptr2 </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr2: {}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr1object</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr1object</span><span class="o">-&gt;</span><span class="n">A</span> <span class="o">&lt;&lt;</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ptr1 is null</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;----------ptr2.reset(new Object(5000))--------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ptr2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;----------Main End--------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">CreateObj</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">CreateObj</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl"><span class="nl">objpt1</span><span class="p">:</span> <span class="mi">100</span> <span class="nl">objpt2</span><span class="p">:</span><span class="mi">200</span>
</span></span><span class="line"><span class="cl"><span class="o">----------</span><span class="n">objpt2</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="o">--------------</span>
</span></span><span class="line"><span class="cl"><span class="n">DestroyObj</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="o">----------</span><span class="n">Move</span> <span class="n">Test</span><span class="o">--------------</span>
</span></span><span class="line"><span class="cl"><span class="n">CreateObj</span> <span class="mi">400</span>
</span></span><span class="line"><span class="cl"><span class="nl">ptr1</span><span class="p">:</span> <span class="mi">400</span>
</span></span><span class="line"><span class="cl"><span class="n">move</span> <span class="n">ptr1</span> <span class="o">---&gt;</span> <span class="n">ptr2</span>
</span></span><span class="line"><span class="cl"><span class="nl">ptr2</span><span class="p">:</span> <span class="mi">400</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr1</span> <span class="n">is</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl"><span class="o">----------</span><span class="n">ptr2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">5000</span><span class="p">))</span><span class="o">--------------</span>
</span></span><span class="line"><span class="cl"><span class="n">CreateObj</span> <span class="mi">5000</span>
</span></span><span class="line"><span class="cl"><span class="n">DestroyObj</span> <span class="mi">400</span>
</span></span><span class="line"><span class="cl"><span class="o">----------</span><span class="n">Main</span> <span class="n">End</span><span class="o">--------------</span>
</span></span><span class="line"><span class="cl"><span class="n">DestroyObj</span> <span class="mi">5000</span>
</span></span><span class="line"><span class="cl"><span class="n">DestroyObj</span> <span class="mi">200</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>release() 取出指针</strong></p>
<p>unique_ptr返回指针，并且把自己保存的设为空.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">ObjectPtr</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Object</span><span class="o">*</span> <span class="n">Obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ObjectPtr</span> <span class="nf">ObjPtr</span><span class="p">(</span><span class="n">Obj1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;Smart ObjPtr.A = {}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ObjPtr</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Object</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ObjPtr</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr.A = {}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ObjPtr</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;objPtr.A = {}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ObjPtr</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ObjPtr is nullptr</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">CreateObj</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">Smart</span> <span class="n">ObjPtr</span><span class="p">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr</span><span class="p">.</span><span class="n">A</span> <span class="o">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">ObjPtr</span> <span class="n">is</span> <span class="k">nullptr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="析构过程">析构过程
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//销毁已拥有的指针。
</span></span></span><span class="line"><span class="cl"><span class="c1">//被拥有的指针引用的对象的析构函数将被调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">~</span><span class="n">unique_ptr</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//删除已拥有的指针，并获取传入指针的所有权。
</span></span></span><span class="line"><span class="cl"><span class="c1">//如果传入的指针与拥有的指针相同，则什么也不做。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 例如:
</span></span></span><span class="line"><span class="cl"><span class="c1">//    unique_ptr&lt;int&gt; ptr(new int(3));
</span></span></span><span class="line"><span class="cl"><span class="c1">//    ptr.reset(new int(4));  // deletes int(3)
</span></span></span><span class="line"><span class="cl"><span class="c1">//    ptr.reset(NULL);        // deletes int(4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="n">pointer</span> <span class="n">pValue</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">())</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">pValue</span> <span class="o">!=</span> <span class="n">mPair</span><span class="p">.</span><span class="n">first</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">mPair</span><span class="p">.</span><span class="n">first</span><span class="p">(),</span> <span class="n">pValue</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="n">get_deleter</span><span class="p">()(</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">deleter_type</span><span class="o">&amp;</span> <span class="n">get_deleter</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">mPair</span><span class="p">.</span><span class="n">second</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">static_assert</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">is_complete_type_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&#34;Attempting to call the destructor of an incomplete type&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>析构时调用reset函数，并且传入空指针.</p>
<p><code>eastl::exchange(mPair.first(), pValue)</code> 交换两个指针，</p>
<p>假设 <code>unique_ptr</code> 保存的有效指针 <code>unique_ptr -&gt; ptr</code> 为 <code>指针A</code>.</p>
<p>1.把 <code>unique_ptr</code> 里面保存的 <code>指针A</code> 与 nullptr 交换，此时 unique_ptr保存的是 nullptr.</p>
<p><code>unique_ptr -&gt; ptr = nullptr</code></p>
<p><code>first</code>= <code>指针A</code> ，</p>
<p>2.<code>get_deleter()</code> 取出删除器.</p>
<p>删除器有两种，<code>default_delete&lt;T&gt;</code> <code>default_delete&lt;T[]&gt;</code> 分别是删除普通对象 和 删除数组对象.</p>
<p>3.调用 <code>删除器</code> 的 <code>()运算符重载</code>，把 <code>first</code> 作为参数传递进去. 这个重载运算符将调用delete 删除 <code>first</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">default_delete</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">EA_CONSTEXPR</span> <span class="nf">default_delete</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>  <span class="c1">// Enable if T* can be constructed with U* (i.e. U* is convertible to T*).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">default_delete</span><span class="p">(</span><span class="k">const</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">typename</span> <span class="n">eastl</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">U</span><span class="o">*</span><span class="p">,</span> <span class="n">T</span><span class="o">*&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">EA_NOEXCEPT</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">static_assert</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">is_complete_type_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&#34;Attempting to call the destructor of an incomplete type&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//-------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="shared_ptr">shared_ptr
</h3><ul>
<li><strong>共享所有权</strong>：多个 <code>std::shared_ptr</code> 对象可以共享同一个对象的所有权，每个 <code>std::shared_ptr</code> 都持有对对象的引用计数。</li>
</ul>
<p>这个类实现了 C++11 标准库中的 <code>shared_ptr</code> 模板。</p>
<p><code>shared_ptr</code> 类似于 C++ 标准库中的 <code>unique_ptr</code>，但不同之处在于它允许通过引用计数在多个实例之间共享指针。</p>
<p><code>shared_ptr</code> 对象可以安全地进行拷贝，并且可以安全地用于 C++ 标准库容器中，如 <code>std::vector</code> 或 <code>std::list</code>。</p>
<p>这个类不是线程安全的，因为你不能同时从两个线程使用它的同一个实例，也不能同时使用拥有相同指针的两个独立实例。</p>
<p>使用标准的多线程互斥技术来解决前者的问题，并使用 <code>shared_ptr_mt</code> 来解决后者的问题。</p>
<p>请注意，这与 C++11 标准不一致。</p>
<ul>
<li>如果你使用原始指针构造一个 <code>shared_ptr</code>，你不能仅用那个原始指针再构造另一个 <code>shared_ptr</code>。相反，你需要用最初创建的 <code>shared_ptr</code> 来构造额外的 <code>shared_ptr</code>。否则会导致崩溃。</li>
<li>使用 <code>shared_ptr</code> 是线程安全的，但它指向的对象并不自动是线程安全的。多个引用同一个对象的 <code>shared_ptr</code> 可以被多个线程任意使用。</li>
<li>你可以将单个 <code>shared_ptr</code> 在多个线程之间以所有方式共享，除了赋值操作。以下操作不是线程安全的，需要通过互斥锁或 <code>shared_ptr</code> 的原子函数来保护：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">pFoo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 线程 1:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">pFoo2</span> <span class="o">=</span> <span class="n">pFoo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 线程 2:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pFoo</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>shared_ptr:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">shared_ptr</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...........
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">element_type</span><span class="o">*</span>  <span class="n">mpValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ref_count_sp</span><span class="o">*</span>  <span class="n">mpRefCount</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">//.........
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>两个成员变量分别是 <code>指针</code> 和 <code>引用计数块</code>.</p>
<p><code>引用计数块</code>以指针形式存储，原因就是它是 <code>new</code>创建的，本体在内存条里，可以用指针指向它.</p>
<p>这样就实现了 多个 <code>shared_ptr</code> 类拥有同一个<code>引用计数块</code>. 因为它们都可以获得 <code>引用计数块</code>的地址，并且用指针指向它.</p>
<h4 id="引用计数">引用计数
</h4><p><strong>ref_count_sp</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ref_count_sp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">mRefCount</span><span class="p">;</span>            <span class="c1">/// Reference count on the contained pointer. Starts as 1 by default.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">mWeakRefCount</span><span class="p">;</span>        <span class="c1">/// Reference count on contained pointer plus this ref_count_sp object itself. Starts as 1 by default.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ref_count_sp</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">refCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">weakRefCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">EA_NOEXCEPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ref_count_sp</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="nf">use_count</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">addref</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">weak_addref</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">weak_release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">ref_count_sp</span><span class="o">*</span> <span class="nf">lock</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">free_value</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// Release the contained object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">free_ref_count_sp</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Release this instance.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#if EASTL_RTTI_ENABLED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">get_deleter</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">)</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">get_deleter</span><span class="p">()</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>ref_count_sp</code> 拥有两个原子变量</p>
<ul>
<li><strong>强引用计数 (</strong><code>mRefCount</code><strong>)</strong>：跟踪有多少个 <code>shared_ptr</code> 实例指向同一个对象。</li>
<li><strong>弱引用计数 (</strong><code>mWeakRefCount)</code>：跟踪有多少个 <code>weak_ptr</code> 实例指向同一个对象。</li>
</ul>
<p><code>release()</code> 方法用于减少强引用计数，并在引用计数降为零时释放对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">ref_count_sp</span><span class="o">::</span><span class="n">release</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">EASTL_ASSERT</span><span class="p">((</span><span class="n">mRefCount</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">mRefCount</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">free_value</span><span class="p">();</span><span class="c1">//释放对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">weak_release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>fetch_sub</code>：原子操作，减少引用计数并返回旧值。</li>
<li><code>free_value()</code>：虚函数，在引用计数降为零时调用，实际执行的是派生类中的实现。</li>
</ul>
<p>派生类 <code>ref_count_sp_t</code> 实现了具体的删除逻辑:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Deleter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ref_count_sp_t</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ref_count_sp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">ref_count_sp_t</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&gt;</span> <span class="n">this_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">Allocator</span> <span class="n">allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">Deleter</span> <span class="n">deleter_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">value_type</span> <span class="n">mValue</span><span class="p">;</span> <span class="c1">// This is expected to be a pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">deleter_type</span> <span class="n">mDeleter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">allocator_type</span> <span class="n">mAllocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ref_count_sp_t</span><span class="p">(</span><span class="n">value_type</span> <span class="n">value</span><span class="p">,</span> <span class="n">deleter_type</span> <span class="n">deleter</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="n">allocator</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">ref_count_sp</span><span class="p">(),</span> <span class="n">mValue</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">mDeleter</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">deleter</span><span class="p">)),</span> <span class="n">mAllocator</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">allocator</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">free_value</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mDeleter</span><span class="p">(</span><span class="n">mValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mValue</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">free_ref_count_sp</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">allocator_type</span> <span class="n">allocator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">allocator</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>free_value()</code>：重写了基类的虚函数，使用 <code>mDeleter</code> 删除对象。</li>
<li><code>free_ref_count_sp()</code>：重写了基类的虚函数，释放 <code>ref_count_sp_t</code> 对象本身。</li>
</ul>
<p><code>shared_ptr</code> 类封装了上述引用计数管理机制，并提供了用户接口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">shared_ptr</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">typedef</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>                                    <span class="n">this_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">typedef</span> <span class="n">T</span>                                                <span class="n">element_type</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">		<span class="k">typedef</span> <span class="k">typename</span> <span class="n">shared_ptr_traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">reference_type</span>    <span class="n">reference_type</span><span class="p">;</span>   <span class="c1">// This defines what a reference to a T is. It&#39;s always simply T&amp;, except for the case where T is void, whereby the reference is also just void.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">typedef</span> <span class="n">EASTLAllocatorType</span>                               <span class="n">default_allocator_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">typedef</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>                                <span class="n">default_deleter_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">typedef</span> <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>                                      <span class="n">weak_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">element_type</span><span class="o">*</span>  <span class="n">mpValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">ref_count_sp</span><span class="o">*</span>  <span class="n">mpRefCount</span><span class="p">;</span>           <span class="c1">/// Base pointer to Reference count for owned pointer and the owned pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="析构过程-1">析构过程
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="o">~</span><span class="n">shared_ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mpRefCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mpRefCount</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>析构时调用 <code>mpRefCount-&gt;release()</code> 判断引用计数是否为0:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">ref_count_sp</span><span class="o">::</span><span class="n">release</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">EASTL_ASSERT</span><span class="p">((</span><span class="n">mRefCount</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">mRefCount</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">free_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">weak_release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果为0，调用 <code>free_value()</code> , <code>free_value()</code>调用删除器的 <code>()运算符重载</code></p>
<p>最终删除对象指针.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">free_value</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mDeleter</span><span class="p">(</span><span class="n">mValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mValue</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//----------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">deleter_type</span>   <span class="n">mDeleter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//mDeleter 实际上就是default_delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">default_delete</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cp">#if defined(EA_COMPILER_GNUC) &amp;&amp; (EA_COMPILER_VERSION &lt;= 4006) </span><span class="c1">// GCC prior to 4.7 has a bug with noexcept here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">EA_CONSTEXPR</span> <span class="nf">default_delete</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>		<span class="n">EA_CONSTEXPR</span> <span class="nf">default_delete</span><span class="p">()</span> <span class="n">EA_NOEXCEPT</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>  <span class="c1">// Enable if T* can be constructed with U* (i.e. U* is convertible to T*).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">default_delete</span><span class="p">(</span><span class="k">const</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">typename</span> <span class="n">eastl</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">U</span><span class="o">*</span><span class="p">,</span> <span class="n">T</span><span class="o">*&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">EA_NOEXCEPT</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="n">EA_NOEXCEPT</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">static_assert</span><span class="p">(</span><span class="n">eastl</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">is_complete_type_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&#34;Attempting to call the destructor of an incomplete type&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="使用示例-3"><strong>使用示例</strong>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Object</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Object</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;CreateObj &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Object</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;DestroyObj &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">ObjectPtr</span> <span class="o">=</span> <span class="n">eastl</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Object</span><span class="o">*</span> <span class="n">Object1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPtr</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">Object1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1">//仍然可以通过原始指针访问 Object1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//cout &lt;&lt; format(&#34;Object1 value: {}\n&#34;, Object1-&gt;A);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//---------------------------------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr1 count: {}  value:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">(),</span><span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//ptr1 count: 1  value:1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="n">ObjectPtr</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">A</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr1 count: {}  value:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">(),</span><span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//ptr1 count: 2  value:5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr2 count: {}  value:{} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">(),</span><span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//ptr2 count: 2  value:5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ObjectPtr</span> <span class="n">ptr3</span><span class="p">(</span><span class="n">ptr2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr1 count: {}  ptr2 count: {} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">(),</span><span class="n">ptr2</span><span class="p">.</span><span class="n">use_count</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//ptr1 count: 3  ptr2 count: 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="n">ObjectPtr</span> <span class="n">ptr4</span><span class="p">(</span><span class="n">ptr3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr3 count: {}  ptr4 count: {} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr3</span><span class="p">.</span><span class="n">use_count</span><span class="p">(),</span><span class="n">ptr4</span><span class="p">.</span><span class="n">use_count</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//ptr3 count: 4  ptr4 count: 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="n">ObjectPtr</span> <span class="n">ptr5</span><span class="p">(</span><span class="n">ptr4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">ObjectPtr</span> <span class="n">ptr6</span><span class="p">(</span><span class="n">ptr5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr5 count: {}  ptr6 count: {} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr5</span><span class="p">.</span><span class="n">use_count</span><span class="p">(),</span><span class="n">ptr6</span><span class="p">.</span><span class="n">use_count</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//ptr5 count: 6  ptr6 count: 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&#34;ptr1 count: {} </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//ptr1 count: 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;---------- End --------------</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//DestroyObj 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">CreateObj</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr1</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">1</span>  <span class="nl">value</span><span class="p">:</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr1</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">2</span>  <span class="nl">value</span><span class="p">:</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr2</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">2</span>  <span class="nl">value</span><span class="p">:</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr1</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">3</span>  <span class="n">ptr2</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr3</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">4</span>  <span class="n">ptr4</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr5</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">6</span>  <span class="n">ptr6</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="n">ptr1</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">----------</span> <span class="n">End</span> <span class="o">--------------</span>
</span></span><span class="line"><span class="cl"><span class="n">DestroyObj</span> <span class="mi">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="safe_ptr">safe_ptr
</h3><p><code>safe_ptr</code> 是一种自动且轻量的解决方案，用于解决悬空指针问题。</p>
<p><strong>类描述</strong></p>
<p>这个类是 <code>weak_ptr</code> 的一种替代方案，其主要优点是不需要分配额外的内存，但代价是稍微慢一些，并且不是线程安全的。</p>
<p>在正常使用情况下，<code>safe_ptr&lt;T&gt;</code> 的行为与 <code>T*</code> 完全相同。当 <code>safe_ptr</code> 引用的原始指针被删除时，所有指向该原始指针的 <code>SafePtrs</code> 都会被设置为 <code>NULL</code>。</p>
<p><strong>工作原理</strong></p>
<p>这一机制通过让原始对象继承自 <code>safe_object</code> 类来实现。<code>safe_object</code> 类维护一个指向它的 <code>SafePtrs</code> 的链表。当一个 <code>safe_object</code> 被销毁时 会遍历其链表，将每个 <code>SafePtr</code> 的对象引用设置为 <code>NULL</code>。</p>
<p>这种开销很小——只需在所指向的对象大小中增加一个指针，并且 <code>safePtr</code> 的大小等于一个原始指针加上一个链表指针。</p>
<p><strong>线程安全性</strong></p>
<p>这个类不是线程安全的。特别是，操作引用同一个底层对象的 <code>safe_ptr</code> 对象不能从多个线程安全地进行。然而，不相关的 <code>safe_ptr</code> 对象可以在多个线程中安全使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RandomLifetimeObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eastl</span><span class="o">::</span><span class="n">safe_object</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">RandomLifetimeObject</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">value</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">Print</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span> <span class="o">&lt;&lt;</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Object</span><span class="o">*</span> <span class="n">Object1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">eastl</span><span class="o">::</span><span class="n">safe_ptr</span><span class="o">&lt;</span><span class="n">RandomLifetimeObject</span><span class="o">&gt;</span> <span class="n">pSafePtr</span><span class="p">(</span><span class="k">new</span> <span class="n">RandomLifetimeObject</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">pSafePtr</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">eastl</span><span class="o">::</span><span class="n">safe_ptr</span><span class="o">&lt;</span><span class="n">RandomLifetimeObject</span><span class="o">&gt;</span> <span class="n">pSafePtrCopy</span> <span class="o">=</span> <span class="n">pSafePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pSafePtrCopy</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">pSafePtr</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">pSafePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 此时，pSafePtrCopy 评估为 NULL。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">//get()返回false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pSafePtrCopy</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">pSafePtrCopy</span><span class="o">-&gt;</span><span class="n">Print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pSafePtrCopy is null</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            国窖1573 - 
        
        2025 AKaKLya
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.0f4e44504cf40ab34cf124bb8fa71a5615b897b6d3841a1d2857b604319620c7.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
