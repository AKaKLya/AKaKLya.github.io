<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="简介 多线程 多线程是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。 多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。 关键概念 线程：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。 并发：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。 并行：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。 并发，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。 特性 并发（Concurrency） 并行（Parallelism） 定义 多个任务交替执行，看似同时运行。 多个任务真正同时执行。 硬件需求 单核 CPU 即可实现。 需要多核 CPU 或多个处理器。 目标 提高资源利用率，增强系统响应性。 提高计算性能，加快任务完成速度。 适用场景 I/O 密集型任务（如网络请求、文件读写）。 计算密集型任务（如科学计算、图像处理）。 实现方式 通过时间片轮转或事件循环实现。 通过多核 CPU 或分布式计算实现。 示例 单核 CPU 上运行多个线程。 多核 CPU 上同时运行多个线程。 并发示例： 一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。 一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。 并行示例： 使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。 使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。 多线程的作用 提高性能：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。 提高响应性：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。 简化设计：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。 异步处理：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。 实际应用场景 Web 服务器： 场景：处理大量并发请求。 实现：每个请求由一个独立线程处理，主线程继续接收新请求。 优势：提高并发处理能力，减少响应时间。 图形用户界面（GUI）应用程序： 场景：执行耗时任务（如文件处理、网络请求）时保持界面响应。 实现：耗时任务在后台线程执行，主线程负责更新界面。 优势：避免界面卡顿，提升用户体验。 数据处理与计算： 场景：大数据处理或复杂计算（如图像处理、科学计算）。 实现：将数据分块，每个线程处理一块。 优势：充分利用多核 CPU，加快处理速度。 游戏开发： 场景：同时处理图形渲染、物理模拟、AI 计算等任务。 实现：不同任务由不同线程处理，通过同步机制协调。 优势：提高游戏性能和流畅度。 实时系统： 场景：需要快速响应的系统（如自动驾驶、工业控制）。 实现：关键任务由独立线程处理，确保实时性。 优势：提高系统响应速度和可靠性。 多线程与进程 在操作系统中，进程和线程是两个核心概念，而主线程是进程中的一个特殊线程。">
<title>C&#43;&#43;多线程</title>

<link rel='canonical' href='http://localhost:1313/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="C++多线程">
<meta property='og:description' content="简介 多线程 多线程是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。 多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。 关键概念 线程：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。 并发：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。 并行：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。 并发，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。 特性 并发（Concurrency） 并行（Parallelism） 定义 多个任务交替执行，看似同时运行。 多个任务真正同时执行。 硬件需求 单核 CPU 即可实现。 需要多核 CPU 或多个处理器。 目标 提高资源利用率，增强系统响应性。 提高计算性能，加快任务完成速度。 适用场景 I/O 密集型任务（如网络请求、文件读写）。 计算密集型任务（如科学计算、图像处理）。 实现方式 通过时间片轮转或事件循环实现。 通过多核 CPU 或分布式计算实现。 示例 单核 CPU 上运行多个线程。 多核 CPU 上同时运行多个线程。 并发示例： 一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。 一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。 并行示例： 使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。 使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。 多线程的作用 提高性能：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。 提高响应性：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。 简化设计：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。 异步处理：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。 实际应用场景 Web 服务器： 场景：处理大量并发请求。 实现：每个请求由一个独立线程处理，主线程继续接收新请求。 优势：提高并发处理能力，减少响应时间。 图形用户界面（GUI）应用程序： 场景：执行耗时任务（如文件处理、网络请求）时保持界面响应。 实现：耗时任务在后台线程执行，主线程负责更新界面。 优势：避免界面卡顿，提升用户体验。 数据处理与计算： 场景：大数据处理或复杂计算（如图像处理、科学计算）。 实现：将数据分块，每个线程处理一块。 优势：充分利用多核 CPU，加快处理速度。 游戏开发： 场景：同时处理图形渲染、物理模拟、AI 计算等任务。 实现：不同任务由不同线程处理，通过同步机制协调。 优势：提高游戏性能和流畅度。 实时系统： 场景：需要快速响应的系统（如自动驾驶、工业控制）。 实现：关键任务由独立线程处理，确保实时性。 优势：提高系统响应速度和可靠性。 多线程与进程 在操作系统中，进程和线程是两个核心概念，而主线程是进程中的一个特殊线程。">
<meta property='og:url' content='http://localhost:1313/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B/'>
<meta property='og:site_name' content='AKaKLya'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='1574-01-01T13:05:38&#43;08:00'/><meta property='article:modified_time' content='1574-01-01T13:05:38&#43;08:00'/>
<meta name="twitter:title" content="C++多线程">
<meta name="twitter:description" content="简介 多线程 多线程是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。 多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。 关键概念 线程：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。 并发：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。 并行：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。 并发，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。 特性 并发（Concurrency） 并行（Parallelism） 定义 多个任务交替执行，看似同时运行。 多个任务真正同时执行。 硬件需求 单核 CPU 即可实现。 需要多核 CPU 或多个处理器。 目标 提高资源利用率，增强系统响应性。 提高计算性能，加快任务完成速度。 适用场景 I/O 密集型任务（如网络请求、文件读写）。 计算密集型任务（如科学计算、图像处理）。 实现方式 通过时间片轮转或事件循环实现。 通过多核 CPU 或分布式计算实现。 示例 单核 CPU 上运行多个线程。 多核 CPU 上同时运行多个线程。 并发示例： 一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。 一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。 并行示例： 使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。 使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。 多线程的作用 提高性能：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。 提高响应性：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。 简化设计：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。 异步处理：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。 实际应用场景 Web 服务器： 场景：处理大量并发请求。 实现：每个请求由一个独立线程处理，主线程继续接收新请求。 优势：提高并发处理能力，减少响应时间。 图形用户界面（GUI）应用程序： 场景：执行耗时任务（如文件处理、网络请求）时保持界面响应。 实现：耗时任务在后台线程执行，主线程负责更新界面。 优势：避免界面卡顿，提升用户体验。 数据处理与计算： 场景：大数据处理或复杂计算（如图像处理、科学计算）。 实现：将数据分块，每个线程处理一块。 优势：充分利用多核 CPU，加快处理速度。 游戏开发： 场景：同时处理图形渲染、物理模拟、AI 计算等任务。 实现：不同任务由不同线程处理，通过同步机制协调。 优势：提高游戏性能和流畅度。 实时系统： 场景：需要快速响应的系统（如自动驾驶、工业控制）。 实现：关键任务由独立线程处理，确保实时性。 优势：提高系统响应速度和可靠性。 多线程与进程 在操作系统中，进程和线程是两个核心概念，而主线程是进程中的一个特殊线程。">
  


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/d_hu15622052934649275245.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">AKaKLya</a></h1>
            <h2 class="site-description">点击</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#简介">简介</a>
      <ol>
        <li><a href="#多线程">多线程</a></li>
        <li><a href="#多线程与进程">多线程与进程</a></li>
      </ol>
    </li>
    <li><a href="#多线程-a">多线程-A</a>
      <ol>
        <li><a href="#线程创建">线程创建</a>
          <ol>
            <li><a href="#线程的多种创建方式"><strong>线程的多种创建方式</strong></a></li>
            <li><a href="#join-与-detach"><strong>join 与 detach</strong></a></li>
            <li><a href="#joinable"><strong>joinable()</strong></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#线程传参"><strong>线程传参</strong></a>
      <ol>
        <li><a href="#常量引用">常量引用</a>
          <ol>
            <li><a href="#线程id">线程ID</a></li>
            <li><a href="#线程传参-类对象">线程传参-类对象</a></li>
            <li><a href="#stdref"><strong>std::ref</strong></a></li>
          </ol>
        </li>
        <li><a href="#智能指针">智能指针</a></li>
      </ol>
    </li>
    <li><a href="#多线程-b">多线程-B</a>
      <ol>
        <li><a href="#数据共享">数据共享</a>
          <ol>
            <li><a href="#互斥量">互斥量</a></li>
            <li><a href="#lock_guard"><strong>lock_guard</strong></a></li>
            <li><a href="#死锁">死锁</a></li>
            <li><a href="#unique_lock">unique_lock</a></li>
            <li><a href="#线程安全的cout">线程安全的cout</a></li>
            <li><a href="#condition_variable">condition_variable</a></li>
          </ol>
        </li>
        <li><a href="#单例模式">单例模式</a>
          <ol>
            <li><a href="#call_once">call_once</a></li>
          </ol>
        </li>
        <li><a href="#异步">异步</a>
          <ol>
            <li><a href="#async--future">async &amp; future</a></li>
            <li><a href="#stdpackaged_task">std::packaged_task</a></li>
            <li><a href="#promise">promise</a></li>
            <li><a href="#shared_future">shared_future</a></li>
            <li><a href="#atomic">atomic</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#多线程-c">多线程-C</a>
      <ol>
        <li><a href="#线程池">线程池</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">C&#43;&#43;多线程</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jan 01, 1574</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 37 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="简介">简介
</h2><h3 id="多线程">多线程
</h3><p><strong>多线程</strong>是指在一个程序中同时运行多个线程，每个线程可以独立执行不同的任务。<br/>线程是操作系统调度的最小单位，多个线程共享进程的资源（如内存、文件句柄等），但每个线程有自己的栈和寄存器状态。</p>
<hr>
<p>多线程允许程序同时执行多个任务，从而提高效率和性能，特别是在多核处理器上。</p>
<p><strong>关键概念</strong></p>
<ol>
<li><strong>线程</strong>：线程是操作系统调度的最小单位，一个进程可以包含多个线程，共享进程的资源。</li>
<li><strong>并发</strong>：多个线程交替执行，通过时间片轮转实现“同时”运行的效果。</li>
<li><strong>并行</strong>：多个线程在多个 CPU 核心上真正同时执行,每个核心执行一个线程。</li>
</ol>
<p><strong>并发</strong>，多个任务在短时间内交替执行，反复横跳，给人一种“同时运行”的错觉，实际是单个 CPU 核心通过快速切换任务来实现并发。<br/></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>特性</strong></th>
<th style="text-align:left"><strong>并发（Concurrency）</strong></th>
<th style="text-align:left"><strong>并行（Parallelism）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义</strong></td>
<td style="text-align:left">多个任务交替执行，看似同时运行。</td>
<td style="text-align:left">多个任务真正同时执行。</td>
</tr>
<tr>
<td style="text-align:left"><strong>硬件需求</strong></td>
<td style="text-align:left">单核 CPU 即可实现。</td>
<td style="text-align:left">需要多核 CPU 或多个处理器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>目标</strong></td>
<td style="text-align:left">提高资源利用率，增强系统响应性。</td>
<td style="text-align:left">提高计算性能，加快任务完成速度。</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left">I/O 密集型任务（如网络请求、文件读写）。</td>
<td style="text-align:left">计算密集型任务（如科学计算、图像处理）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>实现方式</strong></td>
<td style="text-align:left">通过时间片轮转或事件循环实现。</td>
<td style="text-align:left">通过多核 CPU 或分布式计算实现。</td>
</tr>
<tr>
<td style="text-align:left"><strong>示例</strong></td>
<td style="text-align:left">单核 CPU 上运行多个线程。</td>
<td style="text-align:left">多核 CPU 上同时运行多个线程。</td>
</tr>
</tbody>
</table></div>
<p><strong>并发示例</strong>：</p>
<ul>
<li>一个 Web 服务器同时处理多个客户端请求。虽然只有一个 CPU 核心，但通过快速切换任务，服务器可以“同时”处理多个请求。</li>
<li>一个文本编辑器在用户输入时自动保存文件。输入和保存操作交替执行，但不会真正同时运行。</li>
</ul>
<p><strong>并行示例</strong>：</p>
<ul>
<li>使用多核 CPU 并行渲染视频。每个核心负责渲染视频的不同部分，最终合并结果。</li>
<li>使用 GPU 并行计算矩阵乘法。每个核心同时计算矩阵的一个元素。</li>
</ul>
<hr>
<p><strong>多线程的作用</strong></p>
<ol>
<li><strong>提高性能</strong>：在多核处理器上，多线程可以并行执行任务，充分利用 CPU 资源，加快程序运行速度。</li>
<li><strong>提高响应性</strong>：在图形用户界面（GUI）应用程序中，多线程可以避免主线程被长时间任务阻塞，保持界面响应。</li>
<li><strong>简化设计</strong>：多线程可以将复杂任务分解为多个独立线程，简化程序设计和维护。</li>
<li><strong>异步处理</strong>：多线程可以异步执行任务，如网络请求、文件读写等，避免阻塞主线程。</li>
</ol>
<p><strong>实际应用场景</strong></p>
<ol>
<li><strong>Web 服务器</strong>：
<ul>
<li><strong>场景</strong>：处理大量并发请求。</li>
<li><strong>实现</strong>：每个请求由一个独立线程处理，主线程继续接收新请求。</li>
<li><strong>优势</strong>：提高并发处理能力，减少响应时间。</li>
</ul>
</li>
<li><strong>图形用户界面（GUI）应用程序</strong>：
<ul>
<li><strong>场景</strong>：执行耗时任务（如文件处理、网络请求）时保持界面响应。</li>
<li><strong>实现</strong>：耗时任务在后台线程执行，主线程负责更新界面。</li>
<li><strong>优势</strong>：避免界面卡顿，提升用户体验。</li>
</ul>
</li>
<li><strong>数据处理与计算</strong>：
<ul>
<li><strong>场景</strong>：大数据处理或复杂计算（如图像处理、科学计算）。</li>
<li><strong>实现</strong>：将数据分块，每个线程处理一块。</li>
<li><strong>优势</strong>：充分利用多核 CPU，加快处理速度。</li>
</ul>
</li>
<li><strong>游戏开发</strong>：
<ul>
<li><strong>场景</strong>：同时处理图形渲染、物理模拟、AI 计算等任务。</li>
<li><strong>实现</strong>：不同任务由不同线程处理，通过同步机制协调。</li>
<li><strong>优势</strong>：提高游戏性能和流畅度。</li>
</ul>
</li>
<li><strong>实时系统</strong>：
<ul>
<li><strong>场景</strong>：需要快速响应的系统（如自动驾驶、工业控制）。</li>
<li><strong>实现</strong>：关键任务由独立线程处理，确保实时性。</li>
<li><strong>优势</strong>：提高系统响应速度和可靠性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="多线程与进程">多线程与进程
</h3><p>在操作系统中，<strong>进程</strong>和<strong>线程</strong>是两个核心概念，而<strong>主线程</strong>是进程中的一个特殊线程。</p>
<ul>
<li><strong>主线程是进程的一部分</strong>：进程是资源的容器，而主线程是进程内的执行单元。</li>
<li><strong>主线程的生命周期与进程紧密相关</strong>：
<ul>
<li>当主线程开始执行时，进程开始运行。</li>
<li>当主线程执行完毕（<code>main</code> 函数返回）且没有其他非守护线程运行时，进程结束。</li>
</ul>
</li>
<li><strong>主线程与其他线程的关系</strong>：
<ul>
<li>主线程可以创建和管理其他线程。</li>
<li>主线程和其他线程共享进程的资源（如内存、文件句柄等）。</li>
<li>主线程的结束不会立即终止其他线程，但如果主线程结束且没有其他非守护线程，进程会终止。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">worker</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Worker thread is running...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Worker thread finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread started.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个子线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 主线程继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread is running...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待子线程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">started</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Worker</span> <span class="kr">thread</span> <span class="n">is</span> <span class="n">running</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">is</span> <span class="n">running</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Worker</span> <span class="kr">thread</span> <span class="n">finished</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">finished</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程并不是越多越好，每个线程都需要一个独立的堆栈空间，线程之间的切换要保存很多中间状态<br/>切换线程会耗费本该属于程序运行的时间.</p>
<h2 id="多线程-a">多线程-A
</h2><h3 id="线程创建">线程创建
</h3><h4 id="线程的多种创建方式"><strong>线程的多种创建方式</strong>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Obj</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Obj</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Obj is created&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Obj is called...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Obj2</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Obj2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Obj2 is created&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Obj2 is called...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Obj3</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;Obj3::Func() &#34;</span><span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">worker</span><span class="p">(</span><span class="kt">int</span> <span class="n">Value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Worker thread is running...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">([](</span><span class="kt">int</span> <span class="n">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Worker thread is running...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">Func</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Worker thread is running...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">Func</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t4</span><span class="p">(</span><span class="n">Obj</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj2</span> <span class="n">obj2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t5</span><span class="p">(</span><span class="n">obj2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t5</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//------------------------//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj3</span> <span class="n">obj3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t6</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Obj3</span><span class="o">::</span><span class="n">Func</span><span class="p">,</span><span class="o">&amp;</span><span class="n">obj3</span><span class="p">,</span><span class="mi">233</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//或 std::thread t6(&amp;Obj3::Func,std::ref(obj3),233);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t6</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h4 id="join-与-detach"><strong>join 与 detach</strong>
</h4><div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>行为</strong></th>
<th style="text-align:left"><strong>使用 <code>join()</code></strong></th>
<th style="text-align:left"><strong>使用 <code>detach()</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>主线程是否等待</strong></td>
<td style="text-align:left">是</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left"><strong>子线程的生命周期</strong></td>
<td style="text-align:left">主线程等待子线程结束后才退出</td>
<td style="text-align:left">子线程在后台运行，主线程不等待</td>
</tr>
<tr>
<td style="text-align:left"><strong>资源管理</strong></td>
<td style="text-align:left">子线程资源在线程结束后自动释放</td>
<td style="text-align:left">子线程资源在线程结束后自动释放</td>
</tr>
<tr>
<td style="text-align:left"><strong>线程状态</strong></td>
<td style="text-align:left">主线程可以获取子线程的状态(如是否完成)。</td>
<td style="text-align:left">主线程无法获取子线程的状态。</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left">需要确保子线程完成任务后再继续执行</td>
<td style="text-align:left">子线程是独立任务，主线程无需等待</td>
</tr>
</tbody>
</table></div>
<p><strong><code>join()</code> 的适用场景</strong></p>
<ol>
<li><strong>任务依赖</strong>：
<ul>
<li>主线程需要子线程的计算结果。</li>
<li>例如：并行计算中，主线程等待所有子线程完成并汇总结果。</li>
</ul>
</li>
<li><strong>资源清理</strong>：
<ul>
<li>主线程在退出前必须确保所有子线程已完成。</li>
<li>例如：多线程下载工具，主线程等待所有下载线程完成后再退出。</li>
</ul>
</li>
</ol>
<p><strong><code>detach()</code> 的适用场景</strong></p>
<ol>
<li><strong>后台任务</strong>：
<ul>
<li>子线程是独立任务，主线程无需关心其何时完成。</li>
<li>例如：日志记录线程、监控线程。</li>
</ul>
</li>
<li><strong>异步处理</strong>：
<ul>
<li>子线程执行耗时操作，主线程继续响应用户输入。</li>
<li>例如：GUI 应用程序中，后台线程处理文件读写，主线程保持界面响应。</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li>如果需要确保子线程完成任务，使用 <code>join()</code>。</li>
<li>如果希望子线程在后台运行，使用 <code>detach()</code>。</li>
<li><strong>不要既不调用 <code>join()</code> 也不调用 <code>detach()</code></strong>，这会导致程序未定义行为。</li>
<li>被 <code>detach()</code> 的线程独立运行，主线程无法再控制或等待它。</li>
<li>子线程资源在线程结束后自动释放</li>
</ul>
<hr>
<p>当一个线程被 <strong><code>detach()</code></strong> 后，它变成了一个<strong>独立运行的线程</strong>，不再与创建它的线程（通常是主线程）关联。<br/>此时，线程的管理权交给了 <strong>C++ 运行时库</strong> 和 <strong>操作系统</strong>。</p>
<ul>
<li><strong>C++ 运行时库</strong>：C++ 运行时库会负责管理线程的资源（如栈空间、线程 ID 等）。</li>
<li><strong>操作系统</strong>：操作系统负责调度线程的执行，并在线程结束后回收其资源。</li>
</ul>
<p>一旦线程被 <code>detach()</code>，就无法再通过 <code>join()</code> 等待其结束，也无法再获取其状态。<br/></p>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">task</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>  <span class="c1">// 模拟耗时任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程任务 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 完成.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 场景 1：使用 join()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程t1创建，调用join...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 主线程等待 t1 完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程在t1结束后继续.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 场景 2：使用 detach()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程t2创建，调用detach...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>  <span class="c1">// 主线程不等待 t2，直接继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;t2已经分离，主线程继续运行...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 主线程等待一段时间，确保 t2 有机会运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程完成.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">主线程</span><span class="n">t1创建</span><span class="err">，调用</span><span class="n">join</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="err">线程任务</span> <span class="mi">1</span> <span class="err">完成</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程在</span><span class="n">t1结束后继续</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程</span><span class="n">t2创建</span><span class="err">，调用</span><span class="n">detach</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">t2已经分离</span><span class="err">，主线程继续运行</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="err">线程任务</span> <span class="mi">2</span> <span class="err">完成</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程完成</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程t1创建后 调用join()， t1在睡觉，主线程会卡住，2秒后 t1执行完毕 主线程才继续运行，<br/>线程t2创建后 调用detach()，此时 主线程不再等待t2，继续执行，与此同时t2在睡觉，2秒后睡醒 执行完毕.</p>
<h4 id="joinable"><strong>joinable()</strong>
</h4><p>用于检查一个线程对象是否可以被 <code>join()</code> 或 <code>detach()</code>。<br/>它的作用是判断线程对象是否关联了一个<strong>可执行的线程</strong>。<br/>管理线程生命周期的重要工具，尤其在多线程编程中需要确保资源正确释放时。</p>
<ul>
<li><strong>检查线程状态</strong>：
<ul>
<li>如果线程对象关联了一个可执行的线程（即线程正在运行或尚未启动），则 <code>joinable()</code> 返回 <code>true</code>。</li>
<li>如果线程对象没有关联可执行的线程（即线程已经结束、被 <code>join()</code> 或 <code>detach()</code>），则 <code>joinable()</code> 返回 <code>false</code>。</li>
<li>在程序退出前，检查所有线程是否已完成，避免资源泄漏。</li>
</ul>
</li>
<li><strong>防止错误操作</strong>：
<ul>
<li>在调用 <code>join()</code> 或 <code>detach()</code> 之前，可以使用 <code>joinable()</code> 检查线程对象的状态，避免重复调用或无效调用。</li>
<li>如果线程已经被 <code>join()</code> 或 <code>detach()</code>，再次调用会导致程序崩溃。</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>线程状态</strong></th>
<th style="text-align:left"><strong><code>joinable()</code> 返回值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">线程已创建但未启动</td>
<td style="text-align:left"><code>true</code></td>
</tr>
<tr>
<td style="text-align:left">线程正在运行</td>
<td style="text-align:left"><code>true</code></td>
</tr>
<tr>
<td style="text-align:left">线程已结束但未调用 <code>join()</code> 或 <code>detach()</code></td>
<td style="text-align:left"><code>true</code></td>
</tr>
<tr>
<td style="text-align:left">线程已被 <code>join()</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left">线程已被 <code>detach()</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left">默认构造的线程对象（未关联线程）</td>
<td style="text-align:left"><code>false</code></td>
</tr>
</tbody>
</table></div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">task</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>  <span class="c1">// 模拟耗时任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Task finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>  <span class="c1">// 创建线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查线程是否可 join
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is joinable.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 等待线程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 再次检查线程是否可 join
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is no longer joinable.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">is</span> <span class="n">joinable</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Task</span> <span class="n">finished</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">joinable</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="线程传参"><strong>线程传参</strong>
</h2><p>当一个线程被 <strong><code>detach()</code></strong> 后，它会独立运行，不再与创建它的线程（通常是主线程）关联。<br/>如果这个线程使用了 <strong>主线程或函数局部的资源</strong>（如局部变量、栈内存等），而主线程或函数结束后这些资源被销毁，会导致线程访问无效的内存，从而引发 <strong>未定义行为</strong></p>
<p><strong>访问已释放的内存</strong>：</p>
<ul>
<li>如果线程访问了已经被销毁的局部变量或栈内存，可能会导致程序崩溃（如段错误）。</li>
</ul>
<p><strong>数据损坏</strong>：</p>
<ul>
<li>如果线程尝试修改已释放的内存，可能会导致数据损坏或其他不可预知的行为。</li>
</ul>
<p><strong>未定义行为</strong>：</p>
<ul>
<li>由于访问无效内存，程序的行为是不可预测的，可能表现为崩溃、输出错误结果，或者看似正常运行但隐藏严重问题。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyString</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="o">:</span> <span class="n">str_</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;MyString 创建&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 显式定义拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">str_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">str_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;MyString 拷贝创建&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --------TaskA--------- //
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">TaskA</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TaskA: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">.</span><span class="n">str_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 访问局部资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run_taskA</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyString</span> <span class="n">local_message</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">TaskA</span><span class="p">,</span> <span class="n">local_message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;run_taskA finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// --------TaskA--------- //
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// --------TaskB--------- //
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">TaskB</span><span class="p">(</span><span class="n">MyString</span><span class="o">*</span> <span class="n">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TaskB: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">str_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 访问局部资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run_taskB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyString</span> <span class="n">local_message</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">TaskB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;run_taskB finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// --------TaskB--------- //
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">run_taskA</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">run_taskB</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>TaskA成功运行，TaskB会发生错误.</p>
<p>只调用TaskA的输出：发现有两个MyString创建了，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">MyString</span> <span class="err">创建</span>
</span></span><span class="line"><span class="cl"><span class="n">MyString</span> <span class="err">拷贝创建</span>
</span></span><span class="line"><span class="cl"><span class="n">run_taskA</span> <span class="n">finished</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nl">TaskA</span><span class="p">:</span> <span class="n">Hello</span><span class="p">,</span> <span class="n">World</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">finished</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>值传递</strong>：线程函数通过值传递的方式接收参数，线程内部会保存一份独立的拷贝，因此即使局部变量被销毁，线程仍然可以访问有效的数据。</li>
<li><strong>拷贝构造函数</strong>：如果没有显式定义拷贝构造函数，编译器会生成默认的拷贝构造函数，执行浅拷贝，且不会输出日志。</li>
<li><strong>生命周期</strong>：线程内部的拷贝对象的生命周期与线程绑定，在线程函数执行期间一直有效。</li>
</ul>
<hr>
<p><strong>修复TaskB</strong></p>
<p>把detach改为join，run_taskB函数 会等待线程运行完成才结束.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">TaskB</span><span class="p">(</span><span class="n">MyString</span><span class="o">*</span> <span class="n">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TaskB: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">str_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 访问局部资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run_taskB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyString</span> <span class="n">local_message</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">TaskB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;run_taskB finished.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">MyString</span> <span class="err">创建</span>
</span></span><span class="line"><span class="cl"><span class="nl">TaskB</span><span class="p">:</span> <span class="n">Hello</span><span class="p">,</span> <span class="n">World</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">run_taskB</span> <span class="n">finished</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">finished</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>在这个例子中，TaskA创建了2个MyString，明明是常量引用，但实际上是值传递<br/>TaskB使用指针传递，两个MyString是同一个对象，那么在run_taskB结束后，这个MyString访问就错误了.<br/><strong>detach子线程时 不能传递指针.</strong></p>
<hr>
<p>在多线程编程中，正确传递函数参数非常重要，尤其是在涉及局部资源时。如果传递方式不当，可能会导致线程访问无效的内存，从而引发未定义行为。<br/></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>传递方式</strong></th>
<th style="text-align:left"><strong>适用场景</strong></th>
<th style="text-align:left"><strong>注意事项</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>值传递</strong></td>
<td style="text-align:left">大多数场景，确保线程安全</td>
<td style="text-align:left">数据会被拷贝，可能有一定开销</td>
</tr>
<tr>
<td style="text-align:left"><strong>引用传递</strong></td>
<td style="text-align:left">需要修改原始数据的场景</td>
<td style="text-align:left">必须确保原始数据的生命周期长于线程</td>
</tr>
<tr>
<td style="text-align:left"><strong>指针传递</strong></td>
<td style="text-align:left">需要共享数据的场景</td>
<td style="text-align:left">使用智能指针（如 <code>std::shared_ptr</code>）管理资源，避免悬空指针</td>
</tr>
<tr>
<td style="text-align:left"><strong>移动语义</strong></td>
<td style="text-align:left">大数据或不可拷贝的对象</td>
<td style="text-align:left">转移所有权后，原始对象不再有效</td>
</tr>
<tr>
<td style="text-align:left"><strong>Lambda 捕获</strong></td>
<td style="text-align:left">一次性使用的场景，简洁直观</td>
<td style="text-align:left">通过值捕获或引用捕获传递参数</td>
</tr>
</tbody>
</table></div>
<hr>
<p><strong>参数传递</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>  <span class="c1">// 传递 C 风格字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>std::string</code> 的创建时机</strong>：</p>
<ul>
<li>当线程函数 <code>func</code> 开始执行时，会尝试从 <code>const char*</code> 创建 <code>std::string</code>。</li>
<li>如果此时 <code>c</code> 已经被销毁，<code>const char*</code> 指向无效的内存，导致未定义行为。</li>
</ul>
<p><strong>情况 1：<code>c</code> 未被销毁</strong></p>
<ul>
<li>如果线程在 <code>c</code> 被销毁之前完成了 <code>std::string</code> 的创建，程序会正常运行。</li>
</ul>
<p><strong>情况 2：<code>c</code> 被销毁</strong></p>
<ul>
<li>如果线程在 <code>c</code> 被销毁之后才开始执行，尝试从已销毁的 <code>c</code> 创建 <code>std::string</code>，会导致未定义行为。</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ul>
<li><code>  std::thread t(func, string(c))</code>显式地将 <code>char c[]</code> 转换为 <code>std::string</code>.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="kt">char</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>string会在此时构造，在 c销毁之前 创建string。</p>
<p><code> std::thread t(func, string(c))</code> 构造了第一个string，<br/>传递给<code>void func(const std::string&amp; str)</code>时，调用string的拷贝构造 又创建了第二个string.</p>
<hr>
<h3 id="常量引用">常量引用
</h3><p>在这个例子里，<code>void func(const std::string&amp; str)</code>已经用常量引用了，还构造了2个string<br/>如果不使用常量引用，<code>void func(std::string str)</code> 不得构造3个string吗？</p>
<p>不使用常量引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">321</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 默认构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">)</span> <span class="o">:</span> <span class="n">Value</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 初始化构造 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 拷贝构造 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;~A &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>拷贝构造在 传入的a的基础上，将Value值加1，以此区分不同的拷贝构造.</p>
<p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">A</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">A</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">A</span> <span class="mi">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>拷贝构造了2个A，  一共有3个A被创造了，</p>
<p>使用常量引用：</p>
<p>把Func的参数改为常量引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">A</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">A</span> <span class="mi">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="线程id">线程ID
</h4><p><strong>线程 ID</strong> 是操作系统或运行时库为每个线程分配的唯一标识符,它用于区分和识别不同的线程。<br/>在多线程编程中，线程 ID 是一个重要的概念，可以帮助开发者调试、监控和管理线程。<br/>线程 ID 是唯一的、不可预测的，并且在线程销毁后失效。</p>
<p>在 C++ 中，可以通过以下方式获取线程 ID：</p>
<p>（1）<strong>当前线程的 ID</strong></p>
<ul>
<li>使用 <code>std::this_thread::get_id()</code> 获取当前线程的 ID。</li>
</ul>
<p>（2）<strong>线程对象的 ID</strong></p>
<ul>
<li>使用 <code>std::thread::get_id()</code> 获取线程对象的 ID。如 t.get_id();</li>
</ul>
<p>使用线程ID 观察A类是在哪个线程里创建的，主线程还是子线程？</p>
<p>常量引用版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">321</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">)</span> <span class="o">:</span> <span class="n">Value</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 初始化构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 线程ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 拷贝构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 线程ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 析构&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 线程ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;func子线程ID: &#34;</span><span class="o">&lt;&lt;</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">主线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">2608</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">2608</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span><span class="mi">2</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">2608</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">2608</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">func子线程ID</span><span class="p">:</span> <span class="mi">19240</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">2</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">19240</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>主线程ID:2608，子线程ID: 19240<br/>2个A类的构造 都是在主线程完成的，但是第2个A类的析构却在子线程里.</p>
<ul>
<li>
<p><strong>构造过程</strong>：</p>
<ul>
<li>在主线程中创建临时对象 <code>A(c)</code>。</li>
<li>由于函数参数是常量引用，编译器可能会进行一次拷贝构造以传递给子线程的函数。</li>
<li>因此，两个构造操作都在主线程中完成。</li>
</ul>
</li>
<li>
<p><strong>析构过程</strong>：</p>
<ul>
<li>第一个对象在主线程中被析构。</li>
<li>第二个对象在子线程中被析构。</li>
</ul>
</li>
</ul>
<p>值传递版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;func子线程ID: &#34;</span><span class="o">&lt;&lt;</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">主线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">12340</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">12340</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span><span class="mi">2</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">12340</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">12340</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span><span class="mi">3</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">10368</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">func子线程ID</span><span class="p">:</span> <span class="mi">10368</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">3</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">10368</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">2</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">10368</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际运行中，主线程ID:12340，子线程ID:10368，<br/>3个A类中， 前2个在主线程构造，第3个在子线程构造<br/>后2个都在子线程中析构.</p>
<ul>
<li><strong>构造过程</strong>：
<ul>
<li>在主线程中创建临时对象 <code>A(c)</code>。</li>
<li>由于函数参数是按值传递，编译器会进行两次拷贝构造：<br/>一次是在主线程中创建临时对象，另一次是将该对象传递给子线程的函数。</li>
<li>因此，前两个构造操作在主线程中完成，第三个构造操作在子线程中完成。</li>
</ul>
</li>
<li><strong>析构过程</strong>：
<ul>
<li>第一个对象在主线程中被析构。</li>
<li>后两个对象在子线程中被析构。</li>
</ul>
</li>
</ul>
<hr>
<p>上面测试的函数为 <code>  std::thread t(func, A(c));</code>,<br/>如果是<code>std::thread t(func, c);</code> 会发生什么？</p>
<p>常量引用版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;func子线程ID: &#34;</span><span class="o">&lt;&lt;</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">主线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">14908</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">19900</span>
</span></span><span class="line"><span class="cl"><span class="nl">func子线程ID</span><span class="p">:</span> <span class="mi">19900</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">19900</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>构造过程</strong>：
<ul>
<li>由于直接传递整数 <code>c</code>，在子线程中通过构造函数 <code>A(int V)</code> 创建对象。</li>
<li>所有构造操作都在子线程中完成。</li>
</ul>
</li>
<li><strong>析构过程</strong>：
<ul>
<li>对象在子线程中被析构。</li>
</ul>
</li>
</ul>
<p>值传递版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;func子线程ID: &#34;</span><span class="o">&lt;&lt;</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">主线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">15064</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">4928</span>
</span></span><span class="line"><span class="cl"><span class="nl">func子线程ID</span><span class="p">:</span> <span class="mi">4928</span>
</span></span><span class="line"><span class="cl"><span class="n">Hello</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">1</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">4928</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>构造过程</strong>：
<ul>
<li>类似于常量引用版本，所有构造操作都在子线程中完成。</li>
</ul>
</li>
<li><strong>析构过程</strong>：
<ul>
<li>对象在子线程中被析构。</li>
</ul>
</li>
</ul>
<p>可以看到，不管是 常量引用 还是 值传递，A类都在子线程中构造，并且只构造一次，<br/>虽然比<code>std::thread t(func, A(c));</code>构造次数的少，但是暗藏危机.</p>
<p><strong>总结</strong></p>
<ul>
<li><strong>常量引用版本 (<code>std::thread t(func, A(c));</code>)</strong>:
<ul>
<li>构造操作主要在主线程中完成，但部分析构操作会在子线程中发生。</li>
</ul>
</li>
<li><strong>值传递版本 (<code>std::thread t(func, A(c));</code>)</strong>:
<ul>
<li>构造操作分布在主线程和子线程中，析构操作主要在子线程中完成。</li>
</ul>
</li>
<li><strong>使用 <code>std::thread t(func, c);</code></strong>:
<ul>
<li>不论是常量引用还是值传递，构造和析构操作都集中在子线程中完成。</li>
</ul>
</li>
</ul>
<p><strong>在detach()情况下，使用常量引用版本的<code>std::thread t(func, A(c));</code> 安全高效.</strong></p>
<h4 id="线程传参-类对象">线程传参-类对象
</h4><p>前面已经证实了，即便是常量引用，也会生成第二个类对象， <br/><strong>在常量引用的情况下</strong>，如果将类对象作为线程参数 在线程函数里面修改对象的数据，<br/>那么在主线程里面的那个 不会受到影响。</p>
<p>主线程中有一个 A类型的 MyA 变量，在传给线程函数时，会调用拷贝构造 创建第二个A类，因此线程函数不会影响到MyA的数据。</p>
<p>在线程中修改A对象 还有一个问题，因为是常量引用，所以<strong>无法修改</strong>，但是在变量前面添加<strong>mutable</strong>就能够修改.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">mutable</span> <span class="kt">int</span> <span class="n">Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">321</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">)</span> <span class="o">:</span> <span class="n">Value</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 初始化构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 拷贝构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 析构&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;子线程A的Value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">MyA</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">MyA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;主线程A的Value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">MyA</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">拷贝构造</span><span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="err">子线程</span><span class="n">A的Value</span> <span class="mi">123</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">123</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程</span><span class="n">A的Value</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然使用<strong>mutable</strong>让变量可修改，但是修改无效啊，并且如果要在线程中修改对象的内容，改的变量很多的话，那每个变量都要加<strong>mutable</strong>，这河里吗？</p>
<h4 id="stdref"><strong>std::ref</strong>
</h4><p>在上面的例子中，要修改const的对象，并且修改了还无效， 双重错误，那有没有更好的办法呢？我们说 有的</p>
<p><code>std::ref</code> 是 C++ 标准库中的一个工具，位于 <code>&lt;functional&gt;</code> 头文件中。<br/>它的主要作用是创建一个对象的引用包装器，使得函数参数可以按引用传递而不是按值传递。<br/>允许将引用传递给需要值传递的函数或对象<br/>这对于避免不必要的拷贝和确保对同一个对象进行操作非常有用，尤其是在使用标准库算法或线程时。<br/></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">321</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">)</span> <span class="o">:</span> <span class="n">Value</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 初始化构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 拷贝构造&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">A</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A 析构&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;子线程A的Value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">MyA</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">MyA</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;主线程A的Value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">MyA</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span> <span class="err">初始化构造</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="err">子线程</span><span class="n">A的Value</span> <span class="mi">123</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程</span><span class="n">A的Value</span> <span class="mi">123</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="err">析构</span><span class="mi">123</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>std::ref为什么那么神奇？为什么会这样？</p>
<p><code>std::reference_wrapper</code> 是一个模板类，其简化实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">reference_wrapper</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造函数，接受一个引用并保存其地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">reference_wrapper</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 隐式类型转换运算符，将 reference_wrapper 转换为 T&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">operator</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>  <span class="c1">// 保存引用的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>构造函数</strong>：
<ul>
<li><code>reference_wrapper(T&amp; ref)</code> 接受一个引用，并将其地址保存到成员变量 <code>ptr</code> 中。</li>
</ul>
</li>
<li><strong>隐式类型转换运算符</strong>：
<ul>
<li><code>operator T&amp;() const</code> 是一个类型转换运算符，它允许 <code>reference_wrapper&lt;T&gt;</code> 对象隐式转换为 <code>T&amp;</code> 类型。</li>
<li>当需要 <code>T&amp;</code> 类型时，编译器会自动调用这个运算符。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;子线程A的Value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">MyA</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">MyA</span><span class="p">));</span>  <span class="c1">// std::ref(MyA) 返回 reference_wrapper&lt;A&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>具体过程</strong>：</p>
<ol>
<li><strong>传递参数</strong>：
<ul>
<li><code>std::ref(MyA)</code> 返回一个 <code>std::reference_wrapper&lt;A&gt;</code> 对象。</li>
<li>这个对象被传递给 <code>std::thread</code> 的构造函数。</li>
</ul>
</li>
<li><strong>线程内部存储</strong>：
<ul>
<li><code>std::thread</code> 将 <code>std::reference_wrapper&lt;A&gt;</code> 对象拷贝到线程的内部存储中。</li>
</ul>
</li>
<li><strong>调用线程函数</strong>：
<ul>
<li>当线程启动时，<code>std::thread</code> 会调用线程函数 <code>func</code>，并将存储的参数传递给它。</li>
<li>由于 <code>func</code> 的参数类型是 <code>A&amp;</code>，而实际传递的是 <code>std::reference_wrapper&lt;A&gt;</code>，编译器会尝试将 <code>std::reference_wrapper&lt;A&gt;</code> 转换为 <code>A&amp;</code>。</li>
</ul>
</li>
<li><strong>隐式转换</strong>：
<ul>
<li><strong>编译器</strong>：编译器在调用线程函数时，发现参数类型不匹配（<code>std::reference_wrapper&lt;A&gt;</code> vs <code>A&amp;</code>），于是尝试查找合适的转换方式。</li>
<li><strong>隐式类型转换运算符</strong>：<code>std::reference_wrapper&lt;A&gt;</code> 中定义的 <code>operator A&amp;()</code> 提供了从 <code>std::reference_wrapper&lt;A&gt;</code> 到 <code>A&amp;</code> 的转换规则。</li>
<li><strong>自动调用</strong>：编译器根据规则自动调用 <code>operator A&amp;()</code>，完成类型转换。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>隐式转换的触发</strong>：当 <code>std::reference_wrapper&lt;A&gt;</code> 需要转换为 <code>A&amp;</code> 时，<br/>编译器会自动调用 <code>operator A&amp;()</code>。</li>
<li><strong>转换的实现</strong>：<code>std::reference_wrapper</code> 中定义的隐式类型转换运算符提供了转换规则。</li>
<li><strong>应用场景</strong>：<code>std::ref</code> 通过 <code>std::reference_wrapper</code> 实现引用传递，适用于需要值传递但希望避免拷贝的场景。</li>
</ul>
<hr>
<h3 id="智能指针">智能指针
</h3><p>在多线程编程中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）可以有效地管理资源的生命周期，并避免内存泄漏和其他资源管理问题。</p>
<p><strong><code>shared_ptr</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">  </span><span class="c1">// 包含智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;MyClass 创建: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;MyClass 销毁: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>  <span class="c1">// 模拟耗时操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>  <span class="c1">// 访问共享对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">value_</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建 shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建线程，传递 shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 主线程继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;主线程继续执行...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// 等待线程结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;主线程的Value:&#34;</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">value_</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">MyClass</span> <span class="err">创建</span><span class="o">:</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程继续执行</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nl">Value</span><span class="p">:</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="err">主线程的</span><span class="nl">Value</span><span class="p">:</span><span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">MyClass</span> <span class="err">销毁</span><span class="o">:</span> <span class="mi">100</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>std::make_shared&lt;MyClass&gt;(42)</code> 创建了一个 <code>MyClass</code> 对象，并由 <code>std::shared_ptr</code> 管理。</li>
<li><code>std::thread t(task, ptr)</code> 将 <code>ptr</code> 传递给线程函数 <code>task</code>。</li>
<li>线程函数 <code>task</code> 通过 <code>std::shared_ptr</code> 访问 <code>MyClass</code> 对象。</li>
<li>当线程和主线程都结束时，<code>std::shared_ptr</code> 的引用计数变为 0，<code>MyClass</code> 对象被自动销毁。</li>
</ol>
<p><strong><code>std::unique_ptr</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 创建 unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 创建线程，传递 unique_ptr（必须使用 std::move）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>std::make_unique&lt;MyClass&gt;(42)</code> 创建了一个 <code>MyClass</code> 对象，并由 <code>std::unique_ptr</code> 管理。</li>
<li><code>std::thread t(task, std::move(ptr))</code> 将 <code>ptr</code> 的所有权转移给线程函数 <code>task</code>。</li>
<li>线程函数 <code>task</code> 通过 <code>std::unique_ptr</code> 访问 <code>MyClass</code> 对象。</li>
<li>当线程结束时，<code>std::unique_ptr</code> 被销毁，<code>MyClass</code> 对象被自动销毁。</li>
</ol>
<hr>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>特性</strong></th>
<th style="text-align:left"><strong><code>std::shared_ptr</code></strong></th>
<th style="text-align:left"><strong><code>std::unique_ptr</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>所有权</strong></td>
<td style="text-align:left">共享所有权，多个指针可以指向同一个对象</td>
<td style="text-align:left">独占所有权，只能有一个指针指向对象</td>
</tr>
<tr>
<td style="text-align:left"><strong>拷贝</strong></td>
<td style="text-align:left">可以拷贝</td>
<td style="text-align:left">不能拷贝，只能移动</td>
</tr>
<tr>
<td style="text-align:left"><strong>性能</strong></td>
<td style="text-align:left">有引用计数的开销</td>
<td style="text-align:left">无额外开销</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left">需要共享所有权的场景</td>
<td style="text-align:left">需要独占所有权的场景</td>
</tr>
</tbody>
</table></div>
<ul>
<li><strong>线程安全</strong>：<code>std::shared_ptr</code> 的引用计数是线程安全的，但对象的访问需要额外的同步机制（如 <code>std::mutex</code>）。</li>
</ul>
<h2 id="多线程-b">多线程-B
</h2><p>CPU 瞎jb转，线程跟了瞎jb干</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MyPrint</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程开始，编号：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;线程结束，编号：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">MyPrint</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;main thread end&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">线程开始，编号：</span><span class="mi">0</span><span class="err">线程开始，编号：线程开始，编号：线程开始，编号：线程开始，编号：</span><span class="mi">6</span><span class="err">线程开始，编号：线程开始，编号：</span><span class="mi">9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span><span class="err">线程开始，编号：</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="err">线程开始，编号：</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="err">线程开始，编号：</span><span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">7</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">线程结束，编号：</span><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span> <span class="kr">thread</span> <span class="n">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>多个线程运行时确实会受到CPU时间片轮转（time-slicing）的影响。<br/>这是操作系统调度器用来管理多个线程或进程执行的一种机制。</p>
<p>时间片轮转 是操作系统用于管理多线程环境下的CPU时间分配的一种机制。<br>
它会影响多线程程序的执行顺序和性能，尤其是上下文切换带来的开销。<br>
为了优化多线程程序，应该尽量减少不必要的上下文切换，合理分配任务，并使用合适的同步机制。</p>
<hr>
<h3 id="数据共享">数据共享
</h3><p>多个线程读取同一个数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MyPrint</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//  cout &lt;&lt; &#34;线程开始，编号：&#34; &lt;&lt; i &lt;&lt; endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//  cout &lt;&lt; &#34;线程结束，编号：&#34; &lt;&lt; i &lt;&lt; endl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;线程ID: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">21108</span><span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">21224</span><span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">183921</span> <span class="mi">2</span> <span class="mi">31</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">211761</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="err">线程</span><span class="nl">ID</span><span class="p">:</span> <span class="mi">222561</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">25601</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">220161</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">233601</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">229761</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="mi">221361</span> <span class="mi">2</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span> <span class="kr">thread</span> <span class="n">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程执行顺序不可控，如果一堆线程对同一个数据 有读有写，比如 多个线程读，同时有多个线程写，会造成错误。</p>
<p>下面的代码会崩溃</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">InMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;InMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">OutMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MsgQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">Command</span> <span class="o">=</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">MsgQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is empty&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue end&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MsgQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">T_InMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">InMsgQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">T_OutMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">OutMsgQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">T_InMsg</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">T_OutMsg</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="互斥量">互斥量
</h4><p>互斥量（Mutex）是一种同步机制，用于在并发编程中保护共享资源，确保在同一时间只有一个线程可以访问该资源。<br/>互斥量的主要目的是防止多个线程同时访问和修改共享数据，从而避免竞态条件（race condition）和其他并发问题。</p>
<p>它的实现依赖于操作系统的底层同步机制，通常是对操作系统提供的原语（Windows 的 <code>CRITICAL_SECTION</code>）的封装。<br>锁的状态通过原子操作或内存屏障来保证线程安全。</p>
<ul>
<li><code>std::mutex</code> 内部维护一个等待队列，用于存储被阻塞的线程。</li>
<li>当线程尝试获取锁时，如果锁已被其他线程持有，当前线程会被阻塞，并放入等待队列。</li>
<li>等待队列通常由另一个互斥锁（如 <code>queue_mutex</code>）保护，以确保线程安全。</li>
<li>当锁被释放时，操作系统会从等待队列中唤醒一个线程，使其继续执行。</li>
<li>当线程无法获取锁时，会调用操作系统的阻塞原语（如 <code>futex</code> 或 <code>WaitForSingleObject</code>）将线程挂起。</li>
<li>当锁被释放时，会调用操作系统的唤醒原语（如 <code>futex_wake</code> 或 <code>WakeByAddressSingle</code>）唤醒一个等待线程。</li>
</ul>
<p><strong>互斥量的工作原理</strong></p>
<ol>
<li><strong>锁定（Lock）</strong>：当一个线程想要访问共享资源时，它首先尝试获取互斥量的锁。<br/>如果互斥量当前没有被其他线程持有，则该线程成功获取锁，并开始访问共享资源。</li>
<li><strong>解锁（Unlock）</strong>：当线程完成对共享资源的操作后，它会释放互斥量的锁，允许其他等待的线程获取锁并访问资源。</li>
<li><strong>阻塞（Block）</strong>：如果一个线程尝试获取已经被其他线程持有的互斥量锁，该线程会被阻塞，直到持有锁的线程释放锁为止。</li>
</ol>
<ul>
<li>
<p><strong>lock()</strong>：尝试获取互斥量的锁。如果锁已被其他线程持有，调用线程将被阻塞，直到锁可用。</p>
</li>
<li>
<p><strong>try_lock()</strong>：尝试获取互斥量的锁，但不会阻塞。如果锁不可用，函数立即返回失败状态。</p>
</li>
<li>
<p><strong>unlock()</strong>：释放互斥量的锁，允许其他线程获取锁并访问共享资源。</p>
</li>
<li>
<p><strong><code>std::mutex</code></strong> 是最基本的互斥量类型，适用于大多数场景。</p>
</li>
<li>
<p><strong><code>std::recursive_mutex</code></strong> 支持递归锁定，适用于需要在一个线程中多次锁定同一个互斥量的情况。</p>
</li>
<li>
<p><strong><code>std::timed_mutex</code></strong> 和 <strong><code>std::shared_timed_mutex</code></strong> 提供了带超时功能和共享锁的支持，适用于更复杂的同步需求。</p>
</li>
</ul>
<hr>
<p>使用mutex，运行稳定，每次只有一个线程访问资源，但是线程运行顺序不稳定..</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MsgQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">InMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;InMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">OutMsg</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">InCommand</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MsgQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">InCommand</span> <span class="o">=</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">OutMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">OutMsg</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is empty&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">             
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue end&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="lock_guard"><strong>lock_guard</strong>
</h4><p>主播主播🥰<br/>你的牢锁确～实很强👍 <br/>但还是太吃操作了😇 <br/>有没有更加简单又强势的英雄推荐一下吗🧐 <br/>有的兄弟（战术停顿）有的😋 <br/>这么强势的英雄当～然是不止一个了🤓 <br/>一共有九位，都是当～前版本t～0.5的超～标英雄👉 <br/>告诉主播，你想学习哪个😤</p>
<p>std::lock_guard 通过 RAII 机制自动管理互斥量的锁定和解锁操作，从而避免手动管理锁可能导致的错误，<br/>如忘记释放锁或在异常情况下未能正确解锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="kt">void</span> <span class="nf">InMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&#34;InMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="n">MsgQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="kt">bool</span> <span class="nf">OutMsg</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">InCommand</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MsgQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">     <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">InCommand</span> <span class="o">=</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="n">MsgQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>lock_guard 构造时就上锁，析构时解锁.</p>
<p>下面是lock_guard的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Mutex</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">_NODISCARD_LOCK</span> <span class="n">lock_guard</span> <span class="p">{</span> <span class="c1">// class with destructor that unlocks a mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">mutex_type</span> <span class="o">=</span> <span class="n">_Mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">lock_guard</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">)</span> <span class="o">:</span> <span class="n">_MyMutex</span><span class="p">(</span><span class="n">_Mtx</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// construct and lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_MyMutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">lock_guard</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">adopt_lock_t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// strengthened
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">:</span> <span class="n">_MyMutex</span><span class="p">(</span><span class="n">_Mtx</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// construct but don&#39;t lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">lock_guard</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_MyMutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">lock_guard</span><span class="p">(</span><span class="k">const</span> <span class="n">lock_guard</span><span class="o">&amp;</span><span class="p">)</span>            <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">lock_guard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_MyMutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另一个构造函数是什么？ 两个构造函数的区别在于 第二个参数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">lock_guard</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">adopt_lock_t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">// strengthened
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">:</span> <span class="n">_MyMutex</span><span class="p">(</span><span class="n">_Mtx</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// construct but don&#39;t lock
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当mutex已经上锁时，召唤lock_guard会再次对mutex上锁 就会错误， 因此有了这个版本的构造函数<br/>lock_guard构造时 不自动锁上mutex</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread_func</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 手动锁定互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 std::adopt_lock 告诉 lock_guard 互斥量已经被锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 访问共享资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is accessing shared resource.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 当离开作用域时，lock_guard 自动解锁互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="死锁">死锁
</h4><p>死锁（Deadlock）是并发编程中的一种常见问题，指的是两个或多个线程或进程在执行过程中，由于争夺资源而陷入无限等待的状态。<br/>每个线程都持有某些资源并等待获取其他线程持有的资源，导致所有这些线程都无法继续执行。</p>
<hr>
<p>有两个线程，都需要<strong>同时锁住两个互斥量</strong>，才可以进行某项操作，<br/>但它们分别都只锁住了一个互斥，都等着再给另一个互斥加锁。<br/>于是，双方毫无进展，因为它们同在苦苦等待对方解锁互斥，这种情形称为死锁。</p>
<p>有两个线程A和B，两个锁L1和L2，两个线程都需要锁住L1、L2才能继续执行<br/>线程A执行时 先锁了L1，A正准备锁L2时 发生了上下文切换，<br/>此时，线程B开始执行，B锁住了L2，然后去锁L1， 此时 两个锁在两个不同的线程中锁住，发生死锁。</p>
<p>这种情形下，没有任何一个线程能够同时拥有两个锁，没有任何一个线程能继续运行。</p>
<p>因此，只要保证锁的顺序一致，就可避免死锁， 如:线程AB都先锁L1 再锁L2。</p>
<hr>
<p><strong>std::lock</strong></p>
<p><code>std::lock</code> 是 C++ 标准库提供的一个函数，用于原子化地锁定多个互斥量（mutex）。<br/>它的主要作用是避免在锁定多个互斥量时发生死锁。<br/>通过 <code>std::lock</code>，可以确保所有互斥量要么全部成功锁定，要么全部不锁定，从而避免了潜在的死锁问题。</p>
<p>如果任何一个互斥量无法锁定，它会自动解锁之前已经锁定的所有互斥量，并重新尝试锁定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFuncA</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span> <span class="n">mtx2</span><span class="p">);</span> <span class="c1">// 原子化锁定两个互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// 采用已锁定的互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// 采用已锁定的互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread A acquired both mutexes.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFuncB</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span> <span class="n">mtx2</span><span class="p">);</span> <span class="c1">// 原子化锁定两个互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// 采用已锁定的互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// 采用已锁定的互斥量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread B acquired both mutexes.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">threadFuncA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">threadFuncB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="unique_lock">unique_lock
</h4><p><code>std::unique_lock</code> 是 C++ 标准库提供的一个通用的互斥量管理类，比 <code>std::lock_guard</code> 更加灵活。<br/>它提供了更丰富的功能来管理互斥量的锁定和解锁操作，适用于更复杂的并发场景。</p>
<ol>
<li><strong>灵活性</strong>：与 <code>std::lock_guard</code> 不同，<code>std::unique_lock</code> 允许延迟锁定、尝试锁定和递归锁定等高级操作。</li>
<li><strong>可移动但不可复制</strong>：<code>std::unique_lock</code> 可以通过移动语义进行转移，但不能被复制。</li>
<li><strong>支持多种锁定策略</strong>：除了基本的锁定和解锁操作外，还支持尝试锁定（try_lock）、超时锁定（try_lock_for/try_lock_until）等功能。</li>
<li><strong>手动管理锁状态</strong>：允许显式地锁定和解锁互斥量，这在某些需要更精细控制锁状态的场景中非常有用。</li>
</ol>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::unique_lock</code></th>
<th><code>std::lock_guard</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁定时机</strong></td>
<td>可以延迟锁定</td>
<td>总是在构造时锁定</td>
</tr>
<tr>
<td><strong>解锁时机</strong></td>
<td>可以手动解锁</td>
<td>总是在析构时解锁</td>
</tr>
<tr>
<td><strong>锁定策略</strong></td>
<td>支持多种锁定策略</td>
<td>仅支持锁定和解锁</td>
</tr>
<tr>
<td><strong>可移动性</strong></td>
<td>可移动</td>
<td>不可移动</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>复杂的同步需求</td>
<td>简单的同步需求</td>
</tr>
</tbody>
</table></div>
<hr>
<p>使用方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span> <span class="c1">// 创建并锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is accessing shared resource.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当离开作用域时，lock 自动解锁 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>unique_lock的构造函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">explicit</span> <span class="nf">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">)</span> <span class="c1">// 构造并且锁住
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">adopt_lock_t</span><span class="p">)</span> <span class="c1">// 加强版 构造，假设已经锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">defer_lock_t</span><span class="p">)</span> <span class="c1">// 构造但不锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">try_to_lock_t</span><span class="p">)</span> <span class="c1">// 构造，尝试锁住
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Rep</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Period</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">_Rep</span><span class="p">,</span> <span class="n">_Period</span><span class="o">&gt;&amp;</span> <span class="n">_Rel_time</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 构造 超时锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Clock</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Duration</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="k">const</span> <span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">_Clock</span><span class="p">,</span> <span class="n">_Duration</span><span class="o">&gt;&amp;</span> <span class="n">_Abs_time</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 构造 超时锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl"><span class="o">~</span><span class="n">unique_lock</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">     <span class="p">{</span> <span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span> <span class="p">}}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>构造函数</strong></th>
<th style="text-align:left"><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">explicit unique_lock(_Mutex&amp; _Mtx)</td>
<td style="text-align:left">构造时立即锁定互斥锁。</td>
</tr>
<tr>
<td style="text-align:left">unique_lock(_Mutex&amp; _Mtx, adopt_lock_t)</td>
<td style="text-align:left">接管已经锁定的互斥锁。</td>
</tr>
<tr>
<td style="text-align:left">unique_lock(_Mutex&amp; _Mtx, defer_lock_t)</td>
<td style="text-align:left">构造时不锁定互斥锁，后续手动锁定。</td>
</tr>
<tr>
<td style="text-align:left">unique_lock(_Mutex&amp; _Mtx, try_to_lock_t)</td>
<td style="text-align:left">构造时尝试锁定互斥锁，失败不阻塞。</td>
</tr>
<tr>
<td style="text-align:left">unique_lock(_Mutex&amp; _Mtx, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)</td>
<td style="text-align:left">构造时尝试在指定相对时间内锁定互斥锁，超时失败。</td>
</tr>
<tr>
<td style="text-align:left">unique_lock(_Mutex&amp; _Mtx, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)</td>
<td style="text-align:left">构造时尝试在指定绝对时间点前锁定互斥锁，超时失败。</td>
</tr>
</tbody>
</table></div>
<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//unique_lock(_Mutex&amp; _Mtx)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span> <span class="c1">// 创建并锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is accessing shared resource.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当离开作用域时，lock 自动解锁 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//unique_lock(_Mutex&amp; _Mtx, adopt_lock_t)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// 手动锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span> <span class="c1">// 假设 mtx 已经被锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is accessing shared resource.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当离开作用域时，lock 自动解锁 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//unique_lock(_Mutex&amp; _Mtx, defer_lock_t)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span> <span class="c1">// 创建但不锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 模拟一些工作负载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// 显式锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is accessing shared resource.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当离开作用域时，lock 自动解锁 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//unique_lock(_Mutex&amp; _Mtx, try_to_lock_t)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">try_to_lock</span><span class="p">);</span> <span class="c1">// 尝试锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">owns_lock</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread successfully locked the mutex.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread failed to lock the mutex.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//unique_lock(_Mutex&amp; _Mtx, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// 尝试在2秒内锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">owns_lock</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread successfully locked the mutex within 2 seconds.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread failed to lock the mutex within 2 seconds.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//unique_lock(_Mutex&amp; _Mtx, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 设置超时时间为当前时间加上2秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span> <span class="c1">// 尝试在指定时间点前锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">owns_lock</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread successfully locked the mutex before the timeout.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread failed to lock the mutex before the timeout.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其它函数</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#lock"  target="_blank" rel="noopener"
    >lock</a></td>
<td style="text-align:left">阻止调用线程，直到线程获取关联的 <code>mutex</code> 的所有权。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#mutex"  target="_blank" rel="noopener"
    >mutex</a></td>
<td style="text-align:left">检索指向关联的 <code>mutex</code> 的存储指针。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#owns_lock"  target="_blank" rel="noopener"
    >owns_lock</a></td>
<td style="text-align:left">指定调用线程是否拥有关联的 <code>mutex</code>。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#release"  target="_blank" rel="noopener"
    >release</a></td>
<td style="text-align:left">解除 <code>unique_lock</code> 对象与关联的 <code>mutex</code> 对象的关联。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#swap"  target="_blank" rel="noopener"
    >swap</a></td>
<td style="text-align:left">将关联的 <code>mutex</code> 和所有权状态与指定对象的互换。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#try_lock"  target="_blank" rel="noopener"
    >try_lock</a></td>
<td style="text-align:left">在不阻止的情况下尝试获取关联 <code>mutex</code> 的所有权。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#try_lock_for"  target="_blank" rel="noopener"
    >try_lock_for</a></td>
<td style="text-align:left">在不阻止的情况下尝试获取关联 <code>mutex</code> 的所有权。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#try_lock_until"  target="_blank" rel="noopener"
    >try_lock_until</a></td>
<td style="text-align:left">在不阻止的情况下尝试获取关联 <code>mutex</code> 的所有权。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#unlock"  target="_blank" rel="noopener"
    >unlock</a></td>
<td style="text-align:left">释放关联的 <code>mutex</code> 的所有权。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unique-lock-class?view=msvc-170#op_eq"  target="_blank" rel="noopener"
    >operator=</a></td>
<td style="text-align:left">从指定对象复制存储的 <code>mutex</code> 指针和关联的所有权状态。</td>
</tr>
</tbody>
</table></div>
<p>所有权转移：</p>
<p>unique_lock重载运算符，接收一个右值unique_lock</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="n">unique_lock</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_lock</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="cm">/* strengthened */</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="n">_STD</span> <span class="n">addressof</span><span class="p">(</span><span class="n">_Other</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="n">_Pmtx</span>        <span class="o">=</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">_Owns</span>        <span class="o">=</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutexA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">ulA</span><span class="p">(</span><span class="n">mutexA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">ulB</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">mutexA</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从函数返回局部unique_lock</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">get_unlocked_lock</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span> <span class="c1">// 创建但不锁定 mtx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">// 返回未锁定的 unique_lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">get_unlocked_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// 显式锁定 mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread is accessing shared resource.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// 显式解锁 mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="线程安全的cout">线程安全的cout
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#pragma once
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个全局互斥锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">coutMutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个线程安全的输出类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SafeCout</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SafeCout</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重载 &lt;&lt; 运算符，支持各种基本类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SafeCout</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">coutMutex</span><span class="p">);</span> <span class="c1">// 自动管理锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">// 返回当前对象，以便链式调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 全局实例化 SafeCout 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SafeCout</span> <span class="n">cout_f</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="condition_variable">condition_variable
</h4><p><code>std::condition_variable</code> 是 C++11 标准库中提供的一个同步原语，用于线程间的通信。<br/>它允许一个线程等待某个条件变为真，而另一个线程在条件满足时通知等待的线程继续执行。<br/><code>std::condition_variable</code> 通常与 <code>std::mutex</code> 一起使用，以确保对共享资源的安全访问。</p>
<p><strong>基本概念</strong></p>
<ul>
<li><strong><code>std::condition_variable</code></strong>：这是一个类模板，提供了等待和通知机制。它允许一个或多个线程等待某个条件变量被通知。</li>
<li><strong><code>std::mutex</code></strong>：互斥锁，用于保护共享资源，防止多个线程同时访问导致数据竞争。</li>
<li><strong><code>std::unique_lock&lt;std::mutex&gt;</code></strong>：与 <code>std::mutex</code> 配合使用，提供更灵活的锁定机制，并且可以与 <code>std::condition_variable</code> 结合使用。</li>
</ul>
<p><strong>主要方法</strong></p>
<p><code>std::condition_variable</code> 提供了以下主要方法：</p>
<ul>
<li><strong><code>wait()</code></strong>：使当前线程阻塞，直到条件变量被通知。通常与 <code>std::unique_lock</code> 一起使用。</li>
<li><strong><code>notify_one()</code></strong>：唤醒一个等待该条件变量的线程（如果有）。</li>
<li><strong><code>notify_all()</code></strong>：唤醒所有等待该条件变量的线程。</li>
</ul>
<hr>
<p>wait函数： _Pred是谓词</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait</span><span class="p">(</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">_Lck</span><span class="p">)</span> <span class="k">noexcept</span> <span class="cm">/* strengthened */</span> <span class="p">{</span> <span class="c1">// wait for signal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="c1">// Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">_Cnd_wait</span><span class="p">(</span><span class="n">_Mycnd</span><span class="p">(),</span> <span class="n">_Lck</span><span class="p">.</span><span class="n">mutex</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">_Mymtx</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Predicate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">wait</span><span class="p">(</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">_Lck</span><span class="p">,</span> <span class="n">_Predicate</span> <span class="n">_Pred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">_Pred</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">wait</span><span class="p">(</span><span class="n">_Lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>谓词返回 <code>true</code></strong>：
<ul>
<li>初始检查时 <code>_Pred()</code> 返回 <code>true</code>，因此不会进入 <code>while</code> 循环，也不会调用 <code>wait(_Lck)</code>。</li>
<li>锁 <code>_Lck</code> 保持锁定状态，没有释放也没有重新获取。</li>
</ul>
</li>
<li><strong>谓词返回 <code>false</code></strong>：
<ul>
<li>初始检查时 <code>_Pred()</code> 返回 <code>false</code>，进入 <code>while</code> 循环并调用 <code>wait(_Lck)</code>。</li>
<li><code>wait(_Lck)</code> 会释放互斥锁 <code>_Lck</code>，使当前线程进入等待状态，直到被其他线程通过 <code>notify_one()</code> 或 <code>notify_all()</code> 唤醒。</li>
<li>被唤醒后，线程会重新获取互斥锁 <code>_Lck</code> 并再次检查谓词，直到谓词返回 <code>true</code>。</li>
</ul>
</li>
</ul>
<p>如果调用了没有谓词的wait版本，也就是第一个，那么相当于 谓词 返回了false. 解锁互斥量.</p>
<hr>
<p><strong>使用场景</strong></p>
<p><code>std::condition_variable</code> 适用于以下几种常见场景：</p>
<ol>
<li><strong>生产者-消费者问题</strong>：生产者生成数据并放入队列，消费者从队列中取出数据进行处理。当队列为空时，消费者等待；当队列中有数据时，生产者通知消费者。</li>
<li><strong>任务调度</strong>：主线程等待子线程完成任务后继续执行。</li>
<li><strong>事件驱动系统</strong>：一个线程等待某个事件发生，另一个线程在事件发生时通知等待的线程。</li>
</ol>
<hr>
<p>问题代码：不停的判断list是否为空，占用资源，<br/>有没有一种方法 当队列为空时，取队列的方法应该等待，有数据时 才进行读取，而不是不断的判空？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MsgQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">InMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;InMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">OutMsg</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">InCommand</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MsgQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">InCommand</span> <span class="o">=</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">OutMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">OutMsg</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is empty&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue end&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用condition_variable</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MsgQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">InMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;InMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  list size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>    <span class="c1">//把wait的线程唤醒,OutMsgQueue()里面的wait被唤醒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//...其它处理代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">OutMsgQueue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//返回false 解锁互斥量，堵塞在这里，直到其它线程调用notify_one()或notify_all()为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//返回true 锁上，往下执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span><span class="k">return</span> <span class="o">!</span><span class="n">MsgQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">();});</span>
</span></span><span class="line"><span class="cl">            <span class="n">command</span> <span class="o">=</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">MsgQueue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;OutMsgQueue &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">command</span> <span class="o">&lt;&lt;</span><span class="s">&#34; ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  list size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">MsgQueue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程执行是反复横跳的，这一段运行起来的效果是，InMsgQueue已经给List插入了N个元素后，OutMsgQueue才执行，<br/>例如：InMsgQueue执行了2秒，然后才执行OutMsgQueue.<br/>notify_one也不会每次都生效，例如OutMsgQueue已经被唤醒了，正在执行wait之后的操作，没有卡在wait()，<br>那么notify_one就不会唤醒OutMsgQueue，因为没有东西可以唤醒。</p>
<hr>
<p>有2个OutMsgQueue线程函数，线程A堵塞在wait，线程B已经被唤醒且正在执行一些被唤醒后的操作</p>
<p><strong><code>notify_one()</code> 的行为</strong></p>
<p><strong>等待状态</strong>：</p>
<ul>
<li>只有当线程处于等待状态（即调用了 <code>wait()</code> 方法并且尚未返回）时，它才能被 <code>notify_one()</code> 唤醒。</li>
<li>如果一个线程已经从 <code>wait()</code> 返回并重新获得了互斥锁，则它不再是等待状态，不会被 <code>notify_one()</code> 唤醒</li>
</ul>
<p><strong>唤醒机制：</strong></p>
<ul>
<li><code>notify_one()</code> 只会发出一次通知信号，尝试唤醒一个等待的线程。</li>
<li>操作系统会选择一个等待的线程来唤醒（如果有多个等待的线程，选择哪个线程是未定义的行为）。</li>
<li>如果没有等待的线程或被唤醒的线程没有实际开始运行（例如因为它已经被唤醒），则通知信号将被忽略。</li>
</ul>
<p>谁决定了 <code>notify_one()</code> 唤醒哪一个线程？这是由操作系统级别的条件变量机制决定的：</p>
<ul>
<li><strong>等待队列</strong>：所有等待在条件变量上的线程会被放入一个等待队列中。</li>
<li><strong>选择机制</strong>：当 <code>notify_one()</code> 被调用时，操作系统会从等待队列中选择一个线程来唤醒。<br/>具体选择哪个线程是未定义的行为，通常取决于操作系统的调度策略。</li>
</ul>
<p><strong><code>notify_all()</code> 的行为</strong></p>
<ul>
<li><strong>调用 <code>notify_all()</code></strong>：所有等待的线程（如线程 A）会被唤醒，并尝试重新获取互斥锁。线程 B 不受影响，因为它不在等待状态。</li>
<li><strong>竞争互斥锁</strong>：被唤醒的线程会竞争互斥锁，只有一个线程能够成功获取锁并继续执行，其他线程将继续等待。</li>
<li>可以确保所有等待的线程都有机会被唤醒并处理新的消息或任务。</li>
</ul>
<h3 id="单例模式">单例模式
</h3><p><strong>Magic Static</strong></p>
<p>C++11 引入了局部静态变量的线程安全初始化特性，即所谓的“Magic Static”。<br/>当一个函数内的局部静态变量被首次访问时，编译器会确保其初始化是线程安全的，并且只执行一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取单例对象的静态方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">getInstance</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="n">instance</span><span class="p">(</span><span class="k">new</span> <span class="n">Singleton</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 示例方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Singleton is doing something!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 私有构造函数和析构函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Singleton</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Singleton created!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Singleton</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Singleton destroyed!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 禁用拷贝构造函数和赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Singleton</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singleton</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>双重检查锁定（DCLP）</strong></p>
<p>双重检查锁定是一种优化的懒加载单例模式实现方式，通过减少锁的竞争来提高性能。<br/>它的核心思想是先检查指针是否为空，如果不是空则直接返回实例；如果是空，则进入临界区再次检查并创建实例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="c1">// 第一次检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="c1">// 第二次检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 私有构造函数防止外部实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">mutex_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>在并发编程和计算机体系结构中，&ldquo;reorder&rdquo;（重排序）指的是编译器或处理器对指令执行顺序进行调整的过程。<br/>这种重排序旨在优化程序性能，但如果不加以适当控制，可能会导致多线程程序中的数据竞争和不一致问题。</p>
<p><strong>编译器重排序（Compiler Reordering）</strong></p>
<p>编译器为了优化代码的执行效率，可能会改变源代码中指令的实际执行顺序。<br/>这种优化通常基于静态分析，目的是减少指令依赖、提高流水线利用率等。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 操作1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 操作2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器可能将 <code>b = 2</code> 放在 <code>a = 1</code> 之前执行，因为这两个操作是独立的，不会互相影响。<br/>然而，在多线程环境中，这样的重排序可能会导致不可预期的行为。</p>
<p><strong>处理器重排序（Processor Reordering）</strong></p>
<p>现代处理器为了提高指令吞吐量和执行效率，也会对指令执行顺序进行重排。<br/>处理器重排序通常发生在以下几种情况下：</p>
<ul>
<li><strong>指令级并行</strong>：处理器可以同时执行多个独立的指令。</li>
<li><strong>内存访问重排序</strong>：处理器可以重新安排读写内存的操作顺序，以减少缓存未命中和等待时间。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 线程1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果没有适当的同步机制，处理器可能会先执行 <code>flag = true</code>，然后再执行 <code>a = 1</code>，这会导致线程2在检查 <code>flag</code> 时看到 <code>true</code>，但在读取 <code>a</code> 时仍然看到旧值 <code>0</code>，从而导致断言失败。</p>
<p><strong>内存模型（Memory Model）</strong></p>
<p>为了处理这些重排序问题，C++ 标准引入了内存模型的概念。内存模型定义了多线程程序中可见性和顺序的规则。<br/>C++11 及之后的标准提供了多种内存顺序（memory order），用于显式地控制指令的执行顺序和可见性。</p>
<ul>
<li><code>std::memory_order_relaxed</code>：最宽松的内存顺序，仅保证原子操作本身的原子性，不提供任何同步或顺序保证。</li>
<li><code>std::memory_order_consume</code>：消费操作，依赖于其他线程的写操作，并确保这些写操作在当前线程中可见。</li>
<li>**<code>std::memory_order_acquire</code>：获取操作，保证在此操作之后的所有读写操作都不会被重排到此操作之前。</li>
<li><code>std::memory_order_release</code>：释放操作，保证在此操作之前的所有读写操作都不会被重排到此操作之后。</li>
<li><code>std::memory_order_acq_rel</code>：结合获取和释放操作，适用于读-修改-写操作。</li>
<li><code>std::memory_order_seq_cst</code>：最严格的内存顺序，提供全局顺序一致性，但可能会带来较大的性能开销。</li>
</ul>
<hr>
<p>volatile 关键字告诉编译器不要对该变量进行重排序和优化。<br/>然而，C++ 中的 volatile 并不能解决所有重排序问题，尤其是处理器级别的重排序问题。</p>
<p>这种方法并不推荐，因为它无法解决所有重排序问题，特别是处理器级别的重排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 第一次检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 第二次检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">volatile</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">instance</span><span class="p">;</span> <span class="c1">// 使用 volatile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>更推荐的方法是使用 <code>std::atomic</code> 和适当的内存顺序来显式地控制指令的执行顺序和可见性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Singleton</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 私有构造函数防止外部实例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">*&gt;</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">mutex_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>std::memory_order_relaxed</code></strong>：用于初步检查 <code>instance</code> 是否为 <code>nullptr</code>，因为此时只需要保证原子性，不需要严格的同步保证。</li>
<li><strong><code>std::atomic_thread_fence(std::memory_order_acquire)</code></strong>：在进入临界区之前使用获取内存屏障，确保读取到的 <code>instance</code> 值是最新的。</li>
<li><strong><code>std::atomic_thread_fence(std::memory_order_release)</code></strong>：在存储 <code>instance</code> 之后使用释放内存屏障，确保所有写操作已经完成，其他线程可以看到最新的值。</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>特性</th>
<th>Magic Static</th>
<th>双重检查锁定 (DCLP)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实现复杂度</strong></td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>线程安全性</strong></td>
<td>内置线程安全</td>
<td>需要显式加锁</td>
</tr>
<tr>
<td><strong>懒加载</strong></td>
<td>支持，但不可控</td>
<td>完全可控</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高（无锁）</td>
<td>中等（较少锁竞争）</td>
</tr>
<tr>
<td><strong>资源管理</strong></td>
<td>自动管理生命周期</td>
<td>需要手动管理</td>
</tr>
<tr>
<td><strong>依赖环境</strong></td>
<td>需要 C++11 及以上标准</td>
<td>标准 C++，但需注意内存顺序问题</td>
</tr>
</tbody>
</table></div>
<h4 id="call_once">call_once
</h4><p><code>std::call_once</code> 是 C++11 标准库提供的一个工具，用于确保某个函数或可调用对象在多线程环境中仅被调用一次。<br/>它通常与 <code>std::once_flag</code> 一起使用，以实现线程安全的单次初始化。</p>
<ul>
<li><strong><code>std::call_once</code></strong>：这是一个函数模板，接受一个 <code>std::once_flag</code> 对象和一个可调用对象（如函数、lambda 表达式或函数对象）。<br/>它保证传入的可调用对象只会被执行一次，即使在多线程环境下多个线程同时尝试调用。</li>
<li><strong><code>std::once_flag</code></strong>：这是一个特殊的标记对象，用来标识某个操作是否已经执行过。<br/>每个需要保证只执行一次的操作都需要一个独立的 <code>std::once_flag</code> 实例。</li>
<li><strong><code>std::once_flag</code></strong> 必须是全局或静态变量：每个需要保证只执行一次的操作都需要一个独立的 std::once_flag 实例，并且该实例必须具有持久的生命周期（即不能是局部变量）。</li>
</ul>
<hr>
<p><code>std::call_once</code> 和 <code>std::once_flag</code> 主要用于以下场景：</p>
<ol>
<li><strong>单例模式</strong>：确保单例对象的初始化只发生一次。</li>
<li><strong>全局变量初始化</strong>：确保某些全局资源或配置只初始化一次。</li>
<li><strong>其他一次性操作</strong>：任何需要确保只执行一次的操作都可以使用 <code>std::call_once</code>。</li>
</ol>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">onceFlag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">initializedValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">initialize</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">onceFlag</span><span class="p">,</span> <span class="p">[]()</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">initializedValue</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Initialization complete.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">threadId</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">initialize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">threadId</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: initializedValue = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">initializedValue</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Initialization</span> <span class="n">complete</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span><span class="o">:</span> <span class="n">initializedValue</span> <span class="o">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">2</span><span class="o">:</span> <span class="n">initializedValue</span> <span class="o">=</span> <span class="mi">42</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>单例使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">getInstance</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">initFlag</span><span class="p">,</span> <span class="p">[]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Singleton</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Singleton instance created.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Singleton instance doing something.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singleton</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Singleton constructor called.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Singleton</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 禁止拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Singleton</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 禁止赋值操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">initFlag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 初始化静态成员变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">initFlag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">singleton</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">singleton</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">([]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">singleton</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">singleton</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="异步">异步
</h3><h4 id="async--future">async &amp; future
</h4><p><code>std::async</code> 是 C++11 标准引入的一个函数模板，用于启动异步任务。<br/>它允许你以一种简便的方式创建和管理异步任务，并且可以获取这些任务的返回值。<br/><code>std::async</code> 返回一个 <code>std::future</code> 对象，该对象可以在稍后用来获取任务的结果。</p>
<p><code>std::future</code> 是 C++11 标准库中的一部分，用于处理异步操作的结果。<br/>它提供了一种机制来获取异步任务的返回值或异常，并允许你等待任务完成。</p>
<hr>
<p><strong>创建future</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//带有_Policy的构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Function</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_ArgTypes</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">future</span><span class="o">&lt;</span><span class="n">_Invoke_result_t</span><span class="o">&lt;</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">decay_t</span><span class="o">&lt;</span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">async</span><span class="p">(</span><span class="n">launch</span> <span class="n">_Policy</span><span class="p">,</span> <span class="n">Function</span><span class="o">&amp;&amp;</span> <span class="n">_Fnarg</span><span class="p">,</span> <span class="n">_ArgTypes</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">_Args</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//不指定_Policy 就会调用这个版本的构造，此版本将会调用带有_Policy的构造，
</span></span></span><span class="line"><span class="cl"><span class="c1">//并且_Policy策略是launch::async+launch::deferred
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Function</span><span class="p">,</span> <span class="k">class</span><span class="err">... </span><span class="nc">_ArgTypes</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">future</span><span class="o">&lt;</span><span class="n">_Invoke_result_t</span><span class="o">&lt;</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">decay_t</span><span class="o">&lt;</span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">async</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;&amp;</span> <span class="n">_Fnarg</span><span class="p">,</span> <span class="n">_ArgTypes</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">_Args</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nf">async</span><span class="p">(</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span> <span class="o">|</span> <span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">forward</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Fnarg</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">forward</span><span class="o">&lt;</span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>_Policy</strong>：指定任务的执行策略，可以是 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>，<br/>或者两者的组合（默认情况下是 <code>std::launch::async | std::launch::deferred</code>）。</li>
<li><strong>_Fnarg</strong>：要异步执行的函数或可调用对象。</li>
<li><strong>_Args</strong>：传递给函数 <code>f</code> 的参数。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">STD</span> <span class="k">enum</span> <span class="k">class</span> <span class="nc">launch</span> <span class="p">{</span> <span class="c1">// names for launch options passed to async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">async</span>    <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">deferred</span> <span class="o">=</span> <span class="mh">0x2</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>如果选择了 <code>std::launch::async</code>，则立即在一个新线程中启动任务。</p>
</li>
<li>
<p>如果选择了 <code>std::launch::deferred</code>，则延迟执行任务，直到调用 <code>get()</code> 或 <code>wait()</code> 方法。</p>
</li>
<li>
<p>调用 <code>std::future::get()</code> 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。</p>
<p>如果任务已经完成，则直接返回结果。</p>
</li>
</ul>
<p><strong>future的函数</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170#get"  target="_blank" rel="noopener"
    >get</a></td>
<td style="text-align:left">检索存储在关联异步状态中的结果。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170#share"  target="_blank" rel="noopener"
    >share</a></td>
<td style="text-align:left">将对象转换为 <code>shared_future</code>。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170#valid"  target="_blank" rel="noopener"
    >valid</a></td>
<td style="text-align:left">指定对象是否不为空。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170#wait"  target="_blank" rel="noopener"
    >wait</a></td>
<td style="text-align:left">阻止当前线程，直到关联异步状态为准备就绪。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170#wait_for"  target="_blank" rel="noopener"
    >wait_for</a></td>
<td style="text-align:left">进行阻止，直到关联异步状态为准备就绪或已过指定时间。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170#wait_until"  target="_blank" rel="noopener"
    >wait_until</a></td>
<td style="text-align:left">进行阻止，直到关联异步状态为准备就绪或直到指定时间点。</td>
</tr>
</tbody>
</table></div>
<hr>
<ul>
<li><strong>阻塞行为</strong>：当调用 <code>get()</code> 方法时，如果异步任务尚未完成，当前线程会被阻塞，直到任务完成并返回结果。</li>
<li><strong>异常处理</strong>：如果异步任务抛出异常，<code>get()</code> 方法会重新抛出该异常，并且当前线程会被阻塞直到异常被抛出。</li>
<li><strong>延迟执行</strong>：如果使用 <code>std::launch::deferred</code> 策略，<code>get()</code> 方法不仅会阻塞，还会触发任务的实际执行。</li>
<li><strong>超时等待</strong>：可以使用 <code>wait_for</code> 或 <code>wait_until</code> 方法设置超时时间，避免无限期等待。</li>
</ul>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">loop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;add&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">loop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 启动异步任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 主线程继续做其他事情
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread is doing something else.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">loop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取异步任务的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread Get Result.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">is</span> <span class="n">doing</span> <span class="n">something</span> <span class="k">else</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">.....................................</span>
</span></span><span class="line"><span class="cl"><span class="p">....................................</span>
</span></span><span class="line"><span class="cl"><span class="p">.....................................</span>
</span></span><span class="line"><span class="cl"><span class="p">.........................................</span>
</span></span><span class="line"><span class="cl"><span class="p">..........................................</span>
</span></span><span class="line"><span class="cl"><span class="p">.....................................</span><span class="n">add</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="n">Main</span> <span class="kr">thread</span> <span class="n">Get</span> <span class="n">Result</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nl">Result</span><span class="p">:</span> <span class="mi">8</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>异步不会卡主线程，主线程一直在打印&hellip;. 直到子线程执行完毕，</p>
<p>假如调用异步任务的结果时，异步线程还没有执行完成，主线程会堵塞 直到异步线程执行完毕。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;add&#34;</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 启动异步任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 主线程继续做其他事情
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread is doing something else.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取异步任务的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Main thread Get Result.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="c1">//卡在这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">is</span> <span class="n">doing</span> <span class="n">something</span> <span class="k">else</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="n">Get</span> <span class="n">Result</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="c1">//在这里卡住，等待异步结果出来 才继续执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">add</span>
</span></span><span class="line"><span class="cl"><span class="nl">Result</span><span class="p">:</span> <span class="mi">8</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 成员函数，接受两个整数并返回它们的和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">computeSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// 模拟耗时操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// 创建类的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 std::async 启动异步任务，调用成员函数 computeSum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">computeSum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Doing some work in the main thread.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取异步任务的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>std::launch</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">STD</span> <span class="k">enum</span> <span class="k">class</span> <span class="nc">launch</span> <span class="p">{</span> <span class="c1">// names for launch options passed to async
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">async</span>    <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">deferred</span> <span class="o">=</span> <span class="mh">0x2</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>如果选择了 <code>std::launch::async</code>，则立即在一个新线程中启动任务。</p>
</li>
<li>
<p>如果选择了 <code>std::launch::deferred</code>，则延迟执行任务，直到调用 <code>get()</code> 或 <code>wait()</code> 方法。</p>
</li>
<li>
<p>调用 <code>std::future::get()</code> 方法时，如果任务尚未完成，则当前线程会被阻塞，直到任务完成并返回结果。</p>
<p>如果任务已经完成，则直接返回结果。</p>
</li>
</ul>
<p>如果将上面创建future的函数改为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">computeSum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么future的函数将会在主线程中执行，因为没有用launch::async.</p>
<p>下面的两种方式都会在新线程中执行，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//新线程延迟到get()时执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">computeSum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//新线程立即执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">computeSum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>async vs thread</strong></p>
<p>使用std::thread，如果系统资源紧张，线程创建会失败，执行std::thread可能导致程序崩溃.<br/>std::async是创建异步任务，使用launch::deferred时不创建新线程，</p>
<p>async构造函数 默认使用了 launch::async | launch::deferred，</p>
<ul>
<li>如果系统资源充足，可能会选择 <code>std::launch::async</code> 并创建一个新线程来立即执行任务。</li>
<li>如果系统资源紧张或任务数量较多，可能会选择 <code>std::launch::deferred</code>，延迟任务的执行，直到你请求其结果时才执行。</li>
</ul>
<p><strong>判断是否创建线程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="kr">thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">deferred</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="c1">//线程被延迟执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>wait_for</strong></p>
<p><code>wait_for</code> 方法，允许你在指定的时间内等待异步任务完成。<br/>如果在指定时间内任务完成了，<code>wait_for</code> 会返回一个指示任务状态的枚举值；如果超时，则返回一个表示超时的状态。</p>
<ul>
<li><strong>应用场景</strong>：当你希望避免无限期等待异步任务完成时，可以使用 <code>wait_for</code> 方法设置超时时间，并根据任务状态采取不同的操作。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Rep</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Period</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">future_status</span> <span class="n">wait_for</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Rep</span><span class="p">,</span><span class="n">Period</span><span class="o">&gt;&amp;</span> <span class="n">timeout_duration</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>参数</strong>：<code>timeout_duration</code> 是一个时间间隔，指定了你愿意等待的最大时间。</li>
<li>返回值：返回枚举值，表示当前任务的状态：
<ul>
<li><code>std::future_status::ready</code>：任务已经完成。</li>
<li><code>std::future_status::timeout</code>：任务未完成，并且达到了超时时间。</li>
<li><code>std::future_status::deferred</code>：任务被延迟执行<br/>（仅适用于使用 <code>std::launch::deferred</code> 启动的任务）。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">longComputation</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// 模拟长时间计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 std::async 启动异步任务，并获取 std::future 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">longComputation</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Waiting for the result with timeout...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置超时时间为1秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;End Wait...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="nl">ready</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result is ready: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="nl">timeout</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Timeout occurred before the result was ready.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="nl">deferred</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The task has been deferred and will be executed on call to get().&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出： 函数执行需要3秒，但是只等待了1秒，超时。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Waiting</span> <span class="k">for</span> <span class="n">the</span> <span class="n">result</span> <span class="n">with</span> <span class="n">timeout</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">End</span> <span class="n">Wait</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">Timeout</span> <span class="n">occurred</span> <span class="n">before</span> <span class="n">the</span> <span class="n">result</span> <span class="n">was</span> <span class="n">ready</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdpackaged_task">std::packaged_task
</h4><p><code>std::packaged_task</code> 是 C++11 标准库中的一个类模板，用于封装可调用对象（如函数、lambda 表达式或函数对象），并允许你异步执行这些对象。<br/>它与 <code>std::future</code> 配合使用，可以获取任务的执行结果。</p>
<p><strong>主要用途</strong></p>
<ul>
<li><strong>封装可调用对象</strong>：将可调用对象（如函数、lambda 表达式或函数对象）封装到 <code>std::packaged_task</code> 中。</li>
<li><strong>异步执行</strong>：可以在不同的线程中执行封装的任务，并通过 <code>std::future</code> 获取结果。</li>
<li><strong>异常处理</strong>：如果任务抛出异常，可以通过 <code>std::future::get()</code> 捕获并重新抛出该异常。</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/packaged-task-class?view=msvc-170#get_future"  target="_blank" rel="noopener"
    >get_future</a></td>
<td style="text-align:left">返回具有相同关联异步状态的 <a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170"  target="_blank" rel="noopener"
    >future</a> 对象。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/packaged-task-class?view=msvc-170#make_ready_at_thread_exit"  target="_blank" rel="noopener"
    >make_ready_at_thread_exit</a></td>
<td style="text-align:left">调用存储在关联异步状态中的可调用的对象，并以原子方式存储返回值。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/packaged-task-class?view=msvc-170#reset"  target="_blank" rel="noopener"
    >reset</a></td>
<td style="text-align:left">替换关联异步状态。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/packaged-task-class?view=msvc-170#swap"  target="_blank" rel="noopener"
    >swap</a></td>
<td style="text-align:left">将关联异步状态与指定对象交换。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/packaged-task-class?view=msvc-170#valid"  target="_blank" rel="noopener"
    >valid</a></td>
<td style="text-align:left">指定对象是否具有关联异步状态。</td>
</tr>
</tbody>
</table></div>
<hr>
<p><strong>简单使用：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个 packaged_task，包装 add 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">add</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取与任务关联的 future
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在另一个线程中执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//move(task) 或 ref(task)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取任务结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Result: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="promise">promise
</h4><p><code>std::promise</code> 是 C++11 标准库中的一个类模板，用于在不同的线程之间设置异步结果或异常。<br/>它通常与 <code>std::future</code> 配合使用，以便在一个线程中设置值或异常，并在另一个线程中获取这些值或异常。</p>
<p><strong>主要用途</strong></p>
<ul>
<li><strong>设置异步结果</strong>：在一个线程中通过 <code>std::promise</code> 设置某个值。</li>
<li><strong>获取异步结果</strong>：在另一个线程中通过关联的 <code>std::future</code> 获取该值。</li>
<li><strong>异常处理</strong>：如果任务抛出异常，可以通过 <code>std::promise</code> 将异常传递给 <code>std::future</code>。</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/promise-class?view=msvc-170#get_future"  target="_blank" rel="noopener"
    >get_future</a></td>
<td style="text-align:left">返回与此 promise 关联的 <a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/future-class?view=msvc-170"  target="_blank" rel="noopener"
    >future</a>。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/promise-class?view=msvc-170#set_exception"  target="_blank" rel="noopener"
    >set_exception</a></td>
<td style="text-align:left">以原子方式设置此 promise 的结果以指示异常。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/promise-class?view=msvc-170#set_exception_at_thread_exit"  target="_blank" rel="noopener"
    >set_exception_at_thread_exit</a></td>
<td style="text-align:left">以原子方式设置此 promise 的结果以指示异常，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/promise-class?view=msvc-170#set_value"  target="_blank" rel="noopener"
    >set_value</a></td>
<td style="text-align:left">以原子方式设置此 promise 的结果以指示值。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/promise-class?view=msvc-170#set_value_at_thread_exit"  target="_blank" rel="noopener"
    >set_value_at_thread_exit</a></td>
<td style="text-align:left">以原子方式设置此 promise 的结果以指示值，并且仅在销毁当前线程中的所有线程本地对象后（通常在线程退出时）发出通知。</td>
</tr>
<tr>
<td style="text-align:left"><a class="link" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/promise-class?view=msvc-170#swap"  target="_blank" rel="noopener"
    >swap</a></td>
<td style="text-align:left">用指定的 promise 对象的<em>关联的异步状态</em>交换此 promise 的关联的异步状态。</td>
</tr>
</tbody>
</table></div>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">computeSum</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">prom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prom</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span> <span class="c1">// 设置结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">computeSum</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">prom</span><span class="p">),</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">prom</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sum = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>多个线程之间传值</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">step1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prom</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 模拟耗时操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prom</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Step 1 completed,Value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">step2</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prom</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 模拟耗时操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">input</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prom</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Step 2 completed,Value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">step3</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prom</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 模拟耗时操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">input</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prom</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Step 3 completed,Value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">p3</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动第一个步骤，并将结果存储在p1中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">step1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动第二个步骤，并等待第一个步骤的结果，将结果存储在p2中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">step2</span><span class="p">,</span> <span class="n">f1</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动第三个步骤，并等待第二个步骤的结果，将结果存储在p3中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">step3</span><span class="p">,</span> <span class="n">f2</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取最终结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">final_result</span> <span class="o">=</span> <span class="n">f3</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// 如果任务未完成，这里会阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final result: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">final_result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Step</span> <span class="mi">1</span> <span class="n">completed</span><span class="p">,</span><span class="nl">Value</span><span class="p">:</span><span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">Step</span> <span class="mi">2</span> <span class="n">completed</span><span class="p">,</span><span class="nl">Value</span><span class="p">:</span><span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="n">Step</span> <span class="mi">3</span> <span class="n">completed</span><span class="p">,</span><span class="nl">Value</span><span class="p">:</span><span class="mi">25</span>
</span></span><span class="line"><span class="cl"><span class="n">Final</span> <span class="nl">result</span><span class="p">:</span> <span class="mi">25</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="shared_future">shared_future
</h4><p><code>std::shared_future</code> 是 C++11 标准库中的一个类模板，它是 <code>std::future</code> 的扩展版本，允许多个线程共享同一个异步结果。<br/>与 <code>std::future</code> 不同的是，<code>std::shared_future</code> 可以被多次拷贝，并且每个拷贝都可以独立地获取异步任务的结果或异常。</p>
<p><code>std::shared_future</code> 通常通过 <code>std::future</code> 的 <code>share()</code> 方法获得。一旦你有了 <code>std::shared_future</code> 对象，就可以在多个线程中使用它来获取异步结果。</p>
<p><strong>主要用途</strong></p>
<ul>
<li><strong>共享异步结果</strong>：允许多个线程共享同一个异步结果。</li>
<li><strong>多次获取结果</strong>：可以在多个地方调用 <code>get()</code> 方法来获取同一个异步任务的结果，而不会导致阻塞或重复执行任务。</li>
<li><strong>异常处理</strong>：如果任务抛出异常，可以通过 <code>std::shared_future::get()</code> 捕获并重新抛出该异常。</li>
</ul>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Tool.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">computeSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 模拟耗时操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">printResult</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">fut</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Result:%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="c1">// 获取异步任务的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用 std::async 启动异步任务，并获取 std::future 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">computeSum</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 std::future 转换为 std::shared_future
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sharedFut</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="n">share</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在多个线程中获取异步任务的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">printResult</span><span class="p">,</span> <span class="n">sharedFut</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">printResult</span><span class="p">,</span> <span class="n">sharedFut</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Main thread value:%d&#34;</span><span class="p">,</span> <span class="n">sharedFut</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nl">Result</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nl">Result</span><span class="p">:</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="n">Main</span> <span class="kr">thread</span> <span class="nl">value</span><span class="p">:</span><span class="mi">8</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="atomic">atomic
</h4><p><code>std::atomic</code> 是 C++11 标准库中的一个模板类，用于提供原子操作的支持。<br/>原子操作是指不可分割的操作，在多线程环境中可以保证对共享数据的访问是安全的，不会出现竞态条件（race condition）。</p>
<p>原语：操作系统或编程语言提供的基本构建块或不可再分的操作单元。<br/>要么完全执行，要么完全不执行<br/>
原子：指那些不可分割的操作或数据结构，在并发环境中保持一致性。<br/>
原子化：将一系列操作视为一个不可分割的整体，确保这些操作要么全部成功，要么全部失败。<br/>
原子操作：在执行过程中不会被中断的操作，通常用于确保并发环境下的线程安全性。<br/></p>
<p><strong>主要用途</strong></p>
<ul>
<li><strong>线程安全</strong>：确保对共享变量的操作在多线程环境中是线程安全的。</li>
<li><strong>无锁编程</strong>：通过原子操作实现高效的无锁编程。</li>
<li><strong>内存顺序控制</strong>：允许你控制内存顺序，以优化性能或确保特定的内存可见性。</li>
</ul>
<p><strong>基本概念</strong></p>
<ul>
<li>
<p><strong>原子类型</strong>：<code>std::atomic&lt;T&gt;</code> 是一个模板类，其中 <code>T</code> 是你要进行原子操作的数据类型。</p>
</li>
<li>
<p><strong>原子操作</strong>：包括读取、写入、交换、比较并交换等操作，这些操作都是原子性的，即它们不会被其他线程中断。</p>
</li>
<li>
<p><strong>函数：</strong></p>
</li>
<li>
<p><strong>load()</strong>：获取当前值（原子读取）。</p>
</li>
<li>
<p><strong>store(value)</strong>：设置新值（原子写入）。</p>
</li>
<li>
<p><strong>fetch_add(arg)</strong> 和 <strong>fetch_sub(arg)</strong>：增加或减少当前值，并返回旧值。</p>
</li>
<li>
<p><strong>fetch_and(arg)</strong>, <strong>fetch_or(arg)</strong>, <strong>fetch_xor(arg)</strong>：按位与、或、异或操作，并返回旧值。</p>
</li>
</ul>
<hr>
<p><strong>compare_exchange_weak(expected, desired)</strong></p>
<ul>
<li><strong>如果 atomic 的当前值 (currentValue) 等于 expected</strong>：
<ul>
<li>将 <code>atomicPoint</code> 更新为 <code>desired</code>。</li>
<li>返回 <code>true</code>。更新成功。</li>
</ul>
</li>
<li><strong>如果 atomic 的当前值 (currentValue) 不等于 expected</strong>：
<ul>
<li>更新 <code>expected</code> 为 <code>atomicPoint</code> 的当前值 (<code>currentValue</code>)。</li>
<li>返回 <code>false</code>。更新失败。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>compare_exchange_strong(expected, desired)</strong></p>
<p>与 <code>compare_exchange_weak</code> 类似，但没有伪失败的情况。</p>
<hr>
<p><strong>基础操作</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atomicInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 定义一个原子整型变量，并初始化为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Initial value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">atomicInt</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">atomicInt</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// 设置值为42
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Updated value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">atomicInt</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>写数值</strong></p>
<p>每个线程让Value+10000, 5个线程的执行结果应该为：50000，但是每次运行的Value结果是随机的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">incrementCounter</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建多个线程，每个线程都增加计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">incrementCounter</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有线程完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final counter value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>使用atomic</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atomicCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">incrementCounter</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">atomicCounter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 原子增加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Thread %d done </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建多个线程，每个线程都增加计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">incrementCounter</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有线程完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final counter value: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">atomicCounter</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">2</span> <span class="n">done</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">5</span> <span class="n">done</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">4</span> <span class="n">done</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">1</span> <span class="n">done</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="mi">3</span> <span class="n">done</span>
</span></span><span class="line"><span class="cl"><span class="n">Final</span> <span class="n">counter</span> <span class="nl">value</span><span class="p">:</span> <span class="mi">50000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">atm</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//原子操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">atm</span> <span class="o">=</span> <span class="n">atm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//不是原子操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//读atm是原子操作，但这一行不是原子操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">atm</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//使用load原子读值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">atm2</span><span class="p">(</span><span class="n">atm</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">atm3</span><span class="p">(</span><span class="n">atm</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">//store原子写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">atm2</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>自定义类型的原子操作</strong></p>
<p>虽然 <code>std::atomic</code> 支持大多数基本数据类型，但对于自定义类型，需要满足一些条件才能使用原子操作：</p>
<ul>
<li>类型必须是可平凡复制的（Trivially Copyable）。</li>
<li>类型必须有一个公共的默认构造函数。</li>
</ul>
<p>如果你需要对自定义类型进行原子操作，可以通过封装和手动实现 CAS 操作来实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x_</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">atomicPoint</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">updatePoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">oldVal</span><span class="p">,</span> <span class="n">newVal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">oldVal</span> <span class="o">=</span> <span class="n">atomicPoint</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">newVal</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">oldVal</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">oldVal</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atomicPoint</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldVal</span><span class="p">,</span> <span class="n">newVal</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建多个线程，每个线程都更新点的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">updatePoint</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有线程完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">finalValue</span> <span class="o">=</span> <span class="n">atomicPoint</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Final point position: (&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">finalValue</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">finalValue</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>有一个全局的原子变量 <code>atomicPoint</code>，它是一个 <code>Point</code> 结构体类型的对象。<br/>多个线程可能会同时尝试修改这个变量。<br/>为了确保这些修改是安全且没有冲突的，需要使用原子操作来实现这一点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">atomicPoint</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">updatePoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">oldVal</span><span class="p">,</span> <span class="n">newVal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">oldVal</span> <span class="o">=</span> <span class="n">atomicPoint</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">newVal</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">oldVal</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">oldVal</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atomicPoint</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldVal</span><span class="p">,</span> <span class="n">newVal</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">oldVal</span> <span class="o">=</span> <span class="n">atomicPoint</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">newVal</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">oldVal</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">oldVal</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>load()</code></strong>：这是一个原子操作，用来读取 <code>atomicPoint</code> 当前的值，并将其存储在 <code>oldVal</code> 中，以便在此基础上计算新的值</p>
<p><strong><code>newVal</code></strong>：基于 <code>oldVal</code> 和增量值 <code>dx</code> 和 <code>dy</code> 计算出的新 <code>Point</code> 对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">oldVal</span> <span class="o">=</span> <span class="n">atomicPoint</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">newVal</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">oldVal</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">oldVal</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atomicPoint</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldVal</span><span class="p">,</span> <span class="n">newVal</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong><code>compare_exchange_weak(oldVal, newVal)</code></strong>：这是一个关键的原子操作，用于比较并交换（CAS，Compare-And-Swap）。</p>
<ul>
<li><strong>比较部分</strong>：首先检查 <code>atomicPoint</code> 当前的值是否与 <code>oldVal</code> 相等。</li>
<li><strong>交换部分</strong>：如果相等，则将 <code>atomicPoint</code> 更新为 <code>newVal</code>，返回true；<br/>如果不相等，则不会更新 <code>atomicPoint</code>，而是更新 <code>oldVal</code> 为 <code>atomicPoint</code> 的当前值，返回false。</li>
</ul>
</li>
<li>
<p><strong>循环机制</strong>：</p>
<ul>
<li>如果 <code>compare_exchange_weak</code> 返回 <code>false</code>，说明在我们读取 <code>oldVal</code> 和尝试更新之间，有其他线程已经修改了 <code>atomicPoint</code> 的值。</li>
<li>此时，我们需要重新加载最新的 <code>oldVal</code>，重新计算 <code>newVal</code>，然后再次尝试更新。</li>
<li>如果在尝试更新时发现 atomicPoint 已经被其他线程修改，则重新加载最新值并重新计算新值，直到成功为止。</li>
</ul>
</li>
</ul>
<p>检查 atomicPoint 和 刚才读取的 atomicPoint (oldVal) 的值是否相同，如果值不一样，那就说明atomicPoint被其它线程篡改了。<br/>相等 ， 说明没有线程修改atomicPoint，可以把newVal给它，函数返回true<br/>不相等，说明有线程修改了atomicPoint ，此时就要把oldval给它，返回false，重新进入循环体计算newVal的值。</p>
<h2 id="多线程-c">多线程-C
</h2><h3 id="线程池">线程池
</h3><p>服务器 &mdash;&gt; 客户端， 每来一个客户端 就创建一个新线程给客户服务.<br/>网络游戏 2万个玩家，不可能给每个玩家创建一个线程，<br/>创建线程可能会因为资源不够而失败，也有线程切换造成的消耗，</p>
<p><strong>线程池</strong>是一种设计模式，用于管理和复用一组工作线程，以提高应用程序的性能和资源利用率。<br/>它通过预先创建一组线程，并将这些线程放入一个“池”中，以便在需要执行任务时可以快速分配和重用这些线程，而不需要频繁地创建和销毁线程。</p>
<p>通过复用一组工作线程来处理多个任务，减少了线程创建和销毁的开销，提高了系统的响应速度和资源利用率。</p>
<p>线程数量过多，因为线程切换时 需要切换上下文，所以性能效率下降，</p>
<p><strong>线程池的主要优点</strong></p>
<ol>
<li><strong>减少线程创建和销毁的开销</strong>：
<ul>
<li>创建和销毁线程是一个相对昂贵的操作，涉及内存分配、上下文切换等。使用线程池可以避免频繁创建和销毁线程，从而提高性能。</li>
</ul>
</li>
<li><strong>提高响应速度</strong>：
<ul>
<li>当有新的任务到达时，线程池中的空闲线程可以立即开始处理任务，而不是等待新线程的创建。这使得应用程序能够更快地响应请求。</li>
</ul>
</li>
<li><strong>控制并发线程数量</strong>：
<ul>
<li>线程池允许你设定最大并发线程数，防止系统因为创建过多线程而导致资源耗尽或系统崩溃。</li>
</ul>
</li>
<li><strong>资源管理</strong>：
<ul>
<li>线程池可以更好地管理系统资源，确保不会因为过度创建线程而导致内存或其他资源的耗尽。</li>
</ul>
</li>
</ol>
<p><strong>线程池的基本组成</strong></p>
<p>一个典型的线程池通常包含以下几个部分：</p>
<ol>
<li><strong>任务队列（Task Queue）</strong>：
<ul>
<li>存储待执行的任务。当有新的任务提交到线程池时，任务会被加入到这个队列中。</li>
</ul>
</li>
<li><strong>工作线程（Worker Threads）</strong>：
<ul>
<li>预先创建的一组线程，负责从任务队列中取出任务并执行。</li>
</ul>
</li>
<li><strong>线程池管理器（Pool Manager）</strong>：
<ul>
<li>负责管理线程池的状态，包括创建和销毁线程、监控线程状态、处理任务队列等。</li>
</ul>
</li>
<li><strong>任务调度机制</strong>：
<ul>
<li>决定如何从任务队列中取出任务并分配给空闲的工作线程。</li>
</ul>
</li>
</ol>
<p><strong>线程池的工作流程</strong></p>
<ol>
<li><strong>初始化线程池</strong>：
<ul>
<li>在程序启动时，线程池会根据配置预先创建一组工作线程，并将它们放入池中。</li>
</ul>
</li>
<li><strong>提交任务</strong>：
<ul>
<li>当有新的任务需要执行时，任务会被提交到线程池的任务队列中。</li>
</ul>
</li>
<li><strong>任务分配</strong>：
<ul>
<li>空闲的工作线程会从任务队列中取出任务并开始执行。</li>
<li>如果所有线程都在忙于执行任务，则新任务会被暂时存储在任务队列中，直到有线程空闲下来。</li>
</ul>
</li>
<li><strong>任务完成</strong>：
<ul>
<li>工作线程完成任务后，会返回线程池中继续等待下一个任务。</li>
</ul>
</li>
<li><strong>关闭线程池</strong>：
<ul>
<li>当不再需要线程池时，可以通过调用相应的 API 来关闭线程池，释放所有资源。</li>
</ul>
</li>
</ol>
<p><strong>线程池的应用场景</strong></p>
<ol>
<li><strong>Web服务器</strong>：
<ul>
<li>处理客户端请求时，每个请求都可以作为一个独立的任务交给线程池中的线程处理。</li>
</ul>
</li>
<li><strong>数据库查询</strong>：
<ul>
<li>数据库查询操作通常比较耗时，可以将查询请求提交到线程池中异步执行，避免阻塞主线程。</li>
</ul>
</li>
<li><strong>图像处理</strong>：
<ul>
<li>对大量图像进行处理时，可以将每张图像的处理任务提交到线程池中并发执行。</li>
</ul>
</li>
<li><strong>批量数据处理</strong>：
<ul>
<li>批量处理大量数据时，可以将每个数据块的处理任务提交到线程池中并行执行。</li>
</ul>
</li>
</ol>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            国窖1573 - 
        
        2025 AKaKLya
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.0f4e44504cf40ab34cf124bb8fa71a5615b897b6d3841a1d2857b604319620c7.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
