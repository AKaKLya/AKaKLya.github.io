<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="C++ STL 库中使用的设计模式 C++ 标准模板库（STL）的设计以泛型编程为核心，但其中也巧妙融入了多种经典设计模式的思想。以下是 STL 中一些典型设计模式的应用及示例： 1. 迭代器模式 (Iterator Pattern) 目的：提供一种统一的方式遍历容器元素，无需暴露容器内部结构。 STL 实现： 所有容器（如 vector, list, map）均提供 begin() 和 end() 方法返回迭代器。 算法（如 for_each, copy）通过迭代器操作容器，与具体容器类型解耦。 1 2 3 4 5 std::vector&lt;int&gt; vec = {1, 2, 3}; // 使用迭代器遍历 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; &#34; &#34;; } 2. 适配器模式 (Adapter Pattern) 目的：转换接口以兼容不同组件。 STL 实现： 容器适配器：stack, queue, priority_queue 基于底层容器（如 deque）适配接口。 迭代器适配器：reverse_iterator 反向遍历容器，back_insert_iterator 用于尾部插入。 1 2 3 4 // 基于 deque 实现栈 std::stack&lt;int, std::deque&lt;int&gt;&gt; stk; stk.">
<title>C&#43;&#43; 软件设计</title>

<link rel='canonical' href='http://localhost:1313/p/c-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="C++ 软件设计">
<meta property='og:description' content="C++ STL 库中使用的设计模式 C++ 标准模板库（STL）的设计以泛型编程为核心，但其中也巧妙融入了多种经典设计模式的思想。以下是 STL 中一些典型设计模式的应用及示例： 1. 迭代器模式 (Iterator Pattern) 目的：提供一种统一的方式遍历容器元素，无需暴露容器内部结构。 STL 实现： 所有容器（如 vector, list, map）均提供 begin() 和 end() 方法返回迭代器。 算法（如 for_each, copy）通过迭代器操作容器，与具体容器类型解耦。 1 2 3 4 5 std::vector&lt;int&gt; vec = {1, 2, 3}; // 使用迭代器遍历 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; &#34; &#34;; } 2. 适配器模式 (Adapter Pattern) 目的：转换接口以兼容不同组件。 STL 实现： 容器适配器：stack, queue, priority_queue 基于底层容器（如 deque）适配接口。 迭代器适配器：reverse_iterator 反向遍历容器，back_insert_iterator 用于尾部插入。 1 2 3 4 // 基于 deque 实现栈 std::stack&lt;int, std::deque&lt;int&gt;&gt; stk; stk.">
<meta property='og:url' content='http://localhost:1313/p/c-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/'>
<meta property='og:site_name' content='AKaKLya'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='1074-01-04T12:57:17&#43;08:00'/><meta property='article:modified_time' content='1074-01-04T12:57:17&#43;08:00'/>
<meta name="twitter:title" content="C++ 软件设计">
<meta name="twitter:description" content="C++ STL 库中使用的设计模式 C++ 标准模板库（STL）的设计以泛型编程为核心，但其中也巧妙融入了多种经典设计模式的思想。以下是 STL 中一些典型设计模式的应用及示例： 1. 迭代器模式 (Iterator Pattern) 目的：提供一种统一的方式遍历容器元素，无需暴露容器内部结构。 STL 实现： 所有容器（如 vector, list, map）均提供 begin() 和 end() 方法返回迭代器。 算法（如 for_each, copy）通过迭代器操作容器，与具体容器类型解耦。 1 2 3 4 5 std::vector&lt;int&gt; vec = {1, 2, 3}; // 使用迭代器遍历 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; &#34; &#34;; } 2. 适配器模式 (Adapter Pattern) 目的：转换接口以兼容不同组件。 STL 实现： 容器适配器：stack, queue, priority_queue 基于底层容器（如 deque）适配接口。 迭代器适配器：reverse_iterator 反向遍历容器，back_insert_iterator 用于尾部插入。 1 2 3 4 // 基于 deque 实现栈 std::stack&lt;int, std::deque&lt;int&gt;&gt; stk; stk.">
  


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/d_hu15622052934649275245.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">AKaKLya</a></h1>
            <h2 class="site-description">点击</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#c-stl-库中使用的设计模式">C++ STL 库中使用的设计模式</a></li>
    <li><a href="#现代c设计模式">现代C++设计模式</a>
      <ol>
        <li><a href="#一创建型模式5种">一、创建型模式（5种）</a></li>
        <li><a href="#二结构型模式7种">二、结构型模式（7种）</a></li>
        <li><a href="#三行为型模式11种">三、行为型模式（11种）</a></li>
        <li><a href="#四现代c关键优化技术">四、现代C++关键优化技术</a></li>
        <li><a href="#五模式选择建议表">五、模式选择建议表</a></li>
      </ol>
    </li>
    <li><a href="#关于本书">关于本书</a></li>
    <li><a href="#第一章-软件设计的艺术">第一章 软件设计的艺术</a>
      <ol>
        <li><a href="#准则1理解软件设计的重要性">准则1：理解软件设计的重要性</a></li>
        <li><a href="#准则2为变化而设计">准则2：为变化而设计</a></li>
        <li><a href="#准则3分离接口以避免人为耦合">准则3：分离接口以避免人为耦合</a></li>
        <li><a href="#准则4为可测试性而设计">准则4：为可测试性而设计</a></li>
        <li><a href="#准则5为扩展而设计">准则5：为扩展而设计</a></li>
      </ol>
    </li>
    <li><a href="#第二章-建立抽象的艺术">第二章 建立抽象的艺术</a>
      <ol>
        <li><a href="#准则6遵循抽象的预期行为">准则6：遵循抽象的预期行为</a></li>
        <li><a href="#准则7理解基类与概念的深层共性">准则7：理解基类与概念的深层共性</a></li>
        <li><a href="#准则8理解重载集合的语义要求">准则8：理解重载集合的语义要求</a></li>
        <li><a href="#准则9关注抽象的所有权归属">准则9：关注抽象的所有权归属</a></li>
        <li><a href="#准则10建议创建架构设计文档">准则10：建议创建架构设计文档</a></li>
      </ol>
    </li>
    <li><a href="#第三章-设计模式的核心价值">第三章 设计模式的核心价值</a>
      <ol>
        <li><a href="#准则-11理解设计模式的核心价值">准则 11：理解设计模式的核心价值</a></li>
        <li><a href="#准则12警惕设计模式的误解">准则12：警惕设计模式的误解</a></li>
        <li><a href="#准则13设计模式无处不在">准则13：设计模式无处不在</a></li>
        <li><a href="#准则14使用设计模式的名称来传达意图">准则14：使用设计模式的名称来传达意图</a></li>
      </ol>
    </li>
    <li><a href="#第四章-访问者设计模式">第四章 访问者设计模式</a>
      <ol>
        <li><a href="#准则15为添加类型或操作进行设计">准则15：为添加类型或操作进行设计</a></li>
        <li><a href="#准则16使用访问者模式扩展操作">准则16：使用访问者模式扩展操作</a></li>
        <li><a href="#准则17考虑使用-stdvariant-实现访问者">准则17：考虑使用 std::variant 实现访问者</a></li>
        <li><a href="#准则18警惕无环访问者的性能">准则18：警惕无环访问者的性能</a></li>
      </ol>
    </li>
    <li><a href="#第五章-策略和命令设计模式">第五章 策略和命令设计模式</a>
      <ol>
        <li><a href="#准则19使用策略隔离事物的实现方式">准则19：使用策略隔离事物的实现方式</a></li>
        <li><a href="#准则20优先使用组合而非继承">准则20：优先使用组合而非继承</a></li>
        <li><a href="#准则21使用命令模式隔离操作内容">准则21：使用命令模式隔离操作内容</a></li>
        <li><a href="#准则22优先使用值语义而非引用语义">准则22：优先使用值语义而非引用语义</a></li>
        <li><a href="#准则23优先使用基于值的策略和命令实现">准则23：优先使用基于值的策略和命令实现</a></li>
      </ol>
    </li>
    <li><a href="#第六章-适配器观察者和crtp设计模式">第六章 适配器、观察者和CRTP设计模式</a>
      <ol>
        <li><a href="#准则24使用适配器标准化接口">准则24：使用适配器标准化接口</a></li>
        <li><a href="#准则25应用观察者作为抽象通知机制">准则25：应用观察者作为抽象通知机制</a></li>
        <li><a href="#准则26使用crtp引入静态类型类别"><strong>准则26：使用CRTP引入静态类型类别</strong></a></li>
        <li><a href="#准则27使用-crtp-实现静态混入类">准则27：使用 CRTP 实现静态混入类</a></li>
      </ol>
    </li>
    <li><a href="#第七章-桥接原型和外部多态设计模式">第七章 桥接、原型和外部多态设计模式</a>
      <ol>
        <li><a href="#准则-28构建桥梁以消除物理依赖">准则 28：构建桥梁以消除物理依赖</a></li>
        <li><a href="#准则-29注意桥接的性能增益与损失">准则 29：注意桥接的性能增益与损失</a></li>
        <li><a href="#准则-30应用原型模式进行抽象复制操作">准则 30：应用原型模式进行抽象复制操作</a></li>
        <li><a href="#准则-31使用外部多态实现非侵入式运行时多态">准则 31：使用外部多态实现非侵入式运行时多态</a></li>
      </ol>
    </li>
    <li><a href="#第八章-类型擦除设计模式">第八章 类型擦除设计模式</a>
      <ol>
        <li><a href="#准则32考虑用类型擦除替代继承层次结构">准则32：考虑用类型擦除替代继承层次结构</a></li>
        <li><a href="#准则33了解类型擦除的优化潜力">准则33：了解类型擦除的优化潜力</a></li>
        <li><a href="#准则34注意拥有类型擦除包装器的设置成本">准则34：注意拥有类型擦除包装器的设置成本</a></li>
      </ol>
    </li>
    <li><a href="#第九章-装饰器设计模式">第九章 装饰器设计模式</a>
      <ol>
        <li><a href="#准则35使用装饰器层次化地添加定制">准则35：使用装饰器层次化地添加定制</a></li>
        <li><a href="#准则36理解运行时与编译时抽象之间的权衡">准则36：理解运行时与编译时抽象之间的权衡</a></li>
      </ol>
    </li>
    <li><a href="#第十章-单例模式">第十章 单例模式</a>
      <ol>
        <li><a href="#准则37将单例视为实现模式而非设计模式">准则37：将单例视为实现模式而非设计模式</a></li>
        <li><a href="#准则38为变化和可测试性设计单例">准则38：为变化和可测试性设计单例</a></li>
      </ol>
    </li>
    <li><a href="#第十一章-最后的准则">第十一章 最后的准则</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/c-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">C&#43;&#43; 软件设计</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jan 04, 1074</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 121 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="c-stl-库中使用的设计模式">C++ STL 库中使用的设计模式
</h2><p>C++ 标准模板库（STL）的设计以<strong>泛型编程</strong>为核心，但其中也巧妙融入了多种经典设计模式的思想。以下是 STL 中一些典型设计模式的应用及示例：</p>
<hr>
<p><strong>1. 迭代器模式 (Iterator Pattern)</strong></p>
<ul>
<li><strong>目的</strong>：提供一种统一的方式遍历容器元素，无需暴露容器内部结构。</li>
<li><strong>STL 实现</strong>：
<ul>
<li>所有容器（如 <code>vector</code>, <code>list</code>, <code>map</code>）均提供 <code>begin()</code> 和 <code>end()</code> 方法返回迭代器。</li>
<li>算法（如 <code>for_each</code>, <code>copy</code>）通过迭代器操作容器，与具体容器类型解耦。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用迭代器遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>2. 适配器模式 (Adapter Pattern)</strong></p>
<ul>
<li><strong>目的</strong>：转换接口以兼容不同组件。</li>
<li><strong>STL 实现</strong>：
<ul>
<li><strong>容器适配器</strong>：<code>stack</code>, <code>queue</code>, <code>priority_queue</code> 基于底层容器（如 <code>deque</code>）适配接口。</li>
<li><strong>迭代器适配器</strong>：<code>reverse_iterator</code> 反向遍历容器，<code>back_insert_iterator</code> 用于尾部插入。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 基于 deque 实现栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">stk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>3. 策略模式 (Strategy Pattern)</strong></p>
<ul>
<li><strong>目的</strong>：动态切换算法或策略。</li>
<li><strong>STL 实现</strong>：
<ul>
<li>算法（如 <code>sort</code>, <code>transform</code>）通过函数对象（Functor）或 Lambda 接受自定义策略。</li>
<li>分配器（Allocator）允许自定义内存管理策略。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 自定义排序策略：降序排列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ol start="4">
<li><strong>工厂方法模式 (Factory Method Pattern)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：将对象创建逻辑封装到子类。</li>
<li><strong>STL 实现</strong>：
<ul>
<li>容器通过 <code>emplace()</code> 或 <code>insert()</code> 方法内部构造对象。</li>
<li>分配器（Allocator）的 <code>allocate()</code> 和 <code>construct()</code> 方法封装内存分配与对象构造。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 分配内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>       <span class="c1">// 构造对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ol start="5">
<li><strong>模板方法模式 (Template Method Pattern)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：定义算法骨架，子类实现具体步骤。</li>
<li><strong>STL 实现</strong>：
<ul>
<li>流库（<code>&lt;iomanip&gt;</code>）通过虚函数（如 <code>std::streambuf::overflow()</code>）定义流程，子类重写具体行为。</li>
<li>分配器提供统一接口，用户可自定义内存管理细节。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CustomAllocator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 自定义内存分配逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<ol start="6">
<li><strong>享元模式 (Flyweight Pattern)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：共享细粒度对象以减少内存开销。</li>
<li><strong>STL 实现</strong>：
<ul>
<li><code>std::string</code> 的短字符串优化（SSO）：小字符串直接存储在对象内部，大字符串使用堆内存。</li>
<li><code>std::function</code> 通过类型擦除（Type Erasure）共享调用逻辑。</li>
</ul>
</li>
</ul>
<hr>
<ol start="7">
<li><strong>代理模式 (Proxy Pattern)</strong></li>
</ol>
<ul>
<li><strong>目的</strong>：通过代理对象控制对原对象的访问。</li>
<li><strong>STL 实现</strong>：
<ul>
<li><code>std::vector&lt;bool&gt;</code> 的特化版本使用代理类压缩存储（每个 <code>bool</code> 占 1 bit）。</li>
<li><code>std::reference_wrapper</code> 提供引用的代理，用于在容器中存储引用。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">refs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">refs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">refs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 代理引用，避免拷贝
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>总结</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left"><strong>设计模式</strong></th>
<th style="text-align:left"><strong>STL 应用场景</strong></th>
<th style="text-align:left"><strong>关键技术</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">迭代器模式</td>
<td style="text-align:left">容器遍历 (<code>vector</code>, <code>map</code>)</td>
<td style="text-align:left">迭代器接口 (<code>begin()</code>, <code>end()</code>)</td>
</tr>
<tr>
<td style="text-align:left">适配器模式</td>
<td style="text-align:left"><code>stack</code>, <code>queue</code>, 反向迭代器</td>
<td style="text-align:left">组合 + 接口转换</td>
</tr>
<tr>
<td style="text-align:left">策略模式</td>
<td style="text-align:left">算法自定义行为 (<code>sort</code>, <code>transform</code>)</td>
<td style="text-align:left">函数对象 + Lambda</td>
</tr>
<tr>
<td style="text-align:left">工厂方法模式</td>
<td style="text-align:left">对象构造 (<code>allocator</code>, <code>emplace()</code>)</td>
<td style="text-align:left">模板 + 分配器</td>
</tr>
<tr>
<td style="text-align:left">模板方法模式</td>
<td style="text-align:left">流缓冲区 (<code>streambuf</code>)</td>
<td style="text-align:left">虚函数 + 继承</td>
</tr>
<tr>
<td style="text-align:left">享元模式</td>
<td style="text-align:left"><code>std::string</code> 优化</td>
<td style="text-align:left">短字符串优化 (SSO)</td>
</tr>
<tr>
<td style="text-align:left">代理模式</td>
<td style="text-align:left"><code>vector&lt;bool&gt;</code>, <code>reference_wrapper</code></td>
<td style="text-align:left">特化模板 + 类型代理</td>
</tr>
</tbody>
</table></div>
<hr>
<p><strong>关键点</strong></p>
<ul>
<li><strong>泛型编程优先</strong>：STL 通过模板和编译时多态实现灵活性，而非传统面向对象的多态。</li>
<li><strong>模式隐式应用</strong>：许多模式以泛型方式实现（如策略模式通过模板参数传递函数对象）。</li>
<li><strong>性能至上</strong>：STL 设计避免虚函数开销，强调零成本抽象（Zero-overhead Abstraction）。</li>
</ul>
<p>理解这些模式在 STL 中的应用，能帮助你更高效地使用标准库，并在自定义组件时借鉴其设计思想。</p>
<h2 id="现代c设计模式">现代C++设计模式
</h2><h3 id="一创建型模式5种">一、创建型模式（5种）
</h3><p><strong>1. 工厂方法模式 (Factory Method)</strong></p>
<p><strong>核心思想</strong>：延迟对象创建到子类<br/>
<strong>解决问题</strong>：避免代码与具体类耦合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Creator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WidgetFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Creator</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConcreteWidget</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// 使用智能指针管理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>2. 抽象工厂模式 (Abstract Factory)</strong></p>
<p><strong>核心思想</strong>：创建相关对象家族<br/>
<strong>解决问题</strong>：跨平台UI组件生成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GUIFactory</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Button</span><span class="o">&gt;</span> <span class="n">createButton</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Menu</span><span class="o">&gt;</span> <span class="n">createMenu</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WinFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GUIFactory</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Button</span><span class="o">&gt;</span> <span class="n">createButton</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">WinButton</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...其他方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>3. 单例模式 (Singleton)</strong></p>
<p><strong>核心思想</strong>：全局唯一实例<br/>
<strong>解决问题</strong>：配置管理、日志系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Logger</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Logger</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">Logger</span> <span class="n">logger</span><span class="p">;</span> <span class="c1">// Meyer&#39;s单例 (线程安全)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 删除拷贝构造函数和赋值操作符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Logger</span><span class="p">(</span><span class="k">const</span> <span class="n">Logger</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Logger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Logger</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Logger</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>4. 建造者模式 (Builder)</strong></p>
<p><strong>核心思想</strong>：分步构建复杂对象<br/>
<strong>解决问题</strong>：简化多参数对象构造</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Pizza</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Builder</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">setSize</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">addTopping</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">topping</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Pizza</span> <span class="nf">build</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Pizza</span><span class="p">{</span><span class="o">*</span><span class="k">this</span><span class="p">};</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pizza</span><span class="p">(</span><span class="k">const</span> <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">builder</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 初始化逻辑 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Pizza</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">::</span><span class="n">Builder</span><span class="p">().</span><span class="n">setSize</span><span class="p">(</span><span class="mi">12</span><span class="p">).</span><span class="n">addTopping</span><span class="p">(</span><span class="s">&#34;Cheese&#34;</span><span class="p">).</span><span class="n">build</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>5. 原型模式 (Prototype)</strong></p>
<p><strong>核心思想</strong>：通过克隆创建对象<br/>
<strong>解决问题</strong>：避免重复初始化开销</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="c1">// 利用拷贝构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="二结构型模式7种">二、结构型模式（7种）
</h3><p><strong>6. 适配器模式 (Adapter)</strong></p>
<p><strong>核心思想</strong>：转换接口兼容性<br/>
<strong>解决问题</strong>：整合旧版API</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LegacyPrinter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">printDocument</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PrinterAdapter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">legacy_</span><span class="p">.</span><span class="n">printDocument</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">LegacyPrinter</span> <span class="n">legacy_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>7. 桥接模式 (Bridge)</strong></p>
<p><strong>核心思想</strong>：分离抽象与实现<br/>
<strong>解决问题</strong>：多维度扩展问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Renderer</span> <span class="p">{</span> <span class="c1">// 实现部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">drawCircle</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span> <span class="c1">// 抽象部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">Renderer</span><span class="o">&amp;</span> <span class="n">renderer</span><span class="p">)</span> <span class="o">:</span> <span class="n">renderer_</span><span class="p">(</span><span class="n">renderer</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Renderer</span><span class="o">&amp;</span> <span class="n">renderer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>8. 组合模式 (Composite)</strong></p>
<p><strong>核心思想</strong>：统一处理树形结构<br/>
<strong>解决问题</strong>：文件系统管理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FileSystemComponent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">list</span><span class="p">(</span><span class="kt">int</span> <span class="n">indent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Directory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FileSystemComponent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FileSystemComponent</span><span class="o">&gt;</span> <span class="n">comp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">children_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">comp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">list</span><span class="p">(</span><span class="kt">int</span> <span class="n">indent</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">children_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">child</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FileSystemComponent</span><span class="o">&gt;&gt;</span> <span class="n">children_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>9. 装饰器模式 (Decorator)</strong></p>
<p><strong>核心思想</strong>：动态添加职责<br/>
<strong>解决问题</strong>：流处理增强</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DataStream</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CompressedStream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DataStream</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">CompressedStream</span><span class="p">(</span><span class="n">DataStream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">)</span> <span class="o">:</span> <span class="n">stream_</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">compressed</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">stream_</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">compressed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">DataStream</span><span class="o">&amp;</span> <span class="n">stream_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>10. 外观模式 (Facade)</strong></p>
<p><strong>核心思想</strong>：简化复杂子系统接口<br/>
<strong>解决问题</strong>：简化数据库操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DatabaseFacade</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">executeQuery</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">sql</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection_</span><span class="p">.</span><span class="n">connect</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">parser_</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sql</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">executor_</span><span class="p">.</span><span class="n">execute</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection_</span><span class="p">.</span><span class="n">disconnect</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConnectionManager</span> <span class="n">connection_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">QueryParser</span> <span class="n">parser_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">QueryExecutor</span> <span class="n">executor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>11. 享元模式 (Flyweight)</strong></p>
<p><strong>核心思想</strong>：共享细粒度对象<br/>
<strong>解决问题</strong>：大量重复对象的内存优化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Font</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Font</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...字体属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FontFactory</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Font</span><span class="o">&amp;</span> <span class="n">getFont</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">fonts_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">fonts_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">it</span> <span class="o">=</span> <span class="n">fonts_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Font</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">)).</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Font</span><span class="o">&gt;&gt;</span> <span class="n">fonts_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>12. 代理模式 (Proxy)</strong></p>
<p><strong>核心思想</strong>：控制对象访问<br/>
<strong>解决问题</strong>：延迟加载、权限控制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Image</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RealImage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Image</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">RealImage</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span> <span class="n">loadFromDisk</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* 显示图片 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ProxyImage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Image</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ProxyImage</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span> <span class="o">:</span> <span class="n">filename_</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">realImage_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">realImage_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RealImage</span><span class="o">&gt;</span><span class="p">(</span><span class="n">filename_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">realImage_</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RealImage</span><span class="o">&gt;</span> <span class="n">realImage_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="三行为型模式11种">三、行为型模式（11种）
</h3><p>（以下为部分实现示例）</p>
<p><strong>13. 策略模式 (Strategy)</strong></p>
<p><strong>核心思想</strong>：封装可互换算法<br/>
<strong>解决问题</strong>：支付方式切换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">PaymentStrategy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PaymentProcessor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">setStrategy</span><span class="p">(</span><span class="n">PaymentStrategy</span> <span class="n">strategy</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">strategy_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">strategy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">processPayment</span><span class="p">(</span><span class="kt">double</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">strategy_</span><span class="p">(</span><span class="n">amount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">PaymentStrategy</span> <span class="n">strategy_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">PaymentProcessor</span> <span class="n">processor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">processor</span><span class="p">.</span><span class="n">setStrategy</span><span class="p">([](</span><span class="kt">double</span> <span class="n">amt</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 信用卡逻辑 */</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">processor</span><span class="p">.</span><span class="n">processPayment</span><span class="p">(</span><span class="mf">100.0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>14. 观察者模式 (Observer)</strong></p>
<p><strong>核心思想</strong>：状态变更通知<br/>
<strong>解决问题</strong>：事件处理系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">subscribe</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">observer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">observers_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">observer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">notify</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">obs</span> <span class="p">:</span> <span class="n">observers_</span><span class="p">)</span> <span class="n">obs</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">observers_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用示例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Observable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span><span class="p">.</span><span class="n">subscribe</span><span class="p">([](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value changed: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span><span class="p">.</span><span class="n">notify</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>15. 命令模式 (Command)</strong></p>
<p><strong>核心思想</strong>：将请求封装为对象<br/>
<strong>解决问题</strong>：撤销/重做功能</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">EditorCommand</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">undo</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InsertCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EditorCommand</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">InsertCommand</span><span class="p">(</span><span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">doc_</span><span class="p">(</span><span class="n">doc</span><span class="p">),</span> <span class="n">pos_</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">c_</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">execute</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">doc_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos_</span><span class="p">,</span> <span class="n">c_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">undo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">doc_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">pos_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">pos_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>16. 模板方法模式 (Template Method)</strong></p>
<p><strong>核心思想</strong>：定义算法骨架<br/>
<strong>解决问题</strong>：流程标准化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DataExporter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">exportData</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">openConnection</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">fetchData</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">formatData</span><span class="p">();</span> <span class="c1">// 虚函数钩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">closeConnection</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">formatData</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...其他步骤实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CSVExporter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DataExporter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">formatData</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* CSV格式处理 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>17. 状态模式 (State)</strong></p>
<p><strong>核心思想</strong>：封装状态行为<br/>
<strong>解决问题</strong>：订单状态流转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OrderState</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">OrderContext</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OrderContext</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">transitionTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">OrderState</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">process</span><span class="p">()</span> <span class="p">{</span> <span class="n">state_</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">OrderState</span><span class="o">&gt;</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="四现代c关键优化技术">四、现代C++关键优化技术
</h3><ol>
<li><strong>智能指针管理资源</strong>
<code>std::unique_ptr</code>/<code>std::shared_ptr</code>替代原始指针</li>
<li><strong>Lambda表达式</strong>
替代小型策略类和命令对象</li>
<li><strong>移动语义</strong>
优化对象传递效率</li>
<li><strong>类型推导 (auto)</strong>
简化模板代码</li>
<li><strong>可变参数模板</strong>
支持任意参数的工厂方法</li>
<li><strong>std::function</strong>
统一回调接口</li>
</ol>
<hr>
<h3 id="五模式选择建议表">五、模式选择建议表
</h3><div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">问题场景</th>
<th style="text-align:left">推荐模式</th>
<th style="text-align:left">现代C++特性应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">需要运行时算法切换</td>
<td style="text-align:left">策略模式</td>
<td style="text-align:left"><code>std::function</code> + lambda</td>
</tr>
<tr>
<td style="text-align:left">需要撤销/重做功能</td>
<td style="text-align:left">命令模式</td>
<td style="text-align:left">智能指针管理命令历史</td>
</tr>
<tr>
<td style="text-align:left">处理复杂对象创建流程</td>
<td style="text-align:left">建造者模式</td>
<td style="text-align:left">Fluent接口链式调用</td>
</tr>
<tr>
<td style="text-align:left">需要优化大量相似对象</td>
<td style="text-align:left">享元模式</td>
<td style="text-align:left"><code>unordered_map</code>缓存管理</td>
</tr>
<tr>
<td style="text-align:left">跨平台UI组件生成</td>
<td style="text-align:left">抽象工厂模式</td>
<td style="text-align:left">模板特化不同平台实现</td>
</tr>
</tbody>
</table></div>
<hr>
<p>通过结合现代C++特性，传统设计模式可以实现更简洁、更高效、更安全的代码结构。每个模式的核心价值在于<strong>解耦变化方向</strong>，而现代语言特性则提供了更优雅的实现手段。</p>
<h2 id="关于本书">关于本书
</h2><p><strong>关于作者</strong></p>
<p>克劳斯·伊格伯尔（Klaus Iglberger）是一名自由C++培训师和顾问。他在2010年完成了计算机科学博士学位，随后专注于大规模C++软件设计。他通过在全球范围内教授受欢迎的C++课程分享他的专业知识。他还是Blaze C++数学库的创建者和首席设计师，慕尼黑C++用户组（MUC++）的组织者之一，以及CppCon会议中“回归基础”和“软件设计”主题的（联合）组织者。</p>
<p><strong>封面故事</strong></p>
<p>《C++软件开发》封面上的动物是普通鹤（Grus grus，或称为“鹤鹤”）。这种鹤也被称为欧亚鹤，主要分布在古北区，包括北欧、北亚和北非，尽管有孤立群体远至爱尔兰东部和日本西部。每年最大的普通鹤繁殖种群可以在俄罗斯和斯堪的纳维亚半岛找到。</p>
<p>普通鹤是一种大型优雅的鸟类，在鹤类中属于中等体型，体长39-51英寸，翼展71-94英寸，平均体重10-12磅。它的身体呈板岩灰色，脸部黑色，颈部黑白相间，头顶红色。大约每两年一次，这种候鸟会完全换羽，在新羽毛生长期间无法飞行约六周。在迁徙过程中，有时会有四百只以上的群体一起飞行。这些群体被观察到可以飞到高达33,000英尺的高度，这是所有鸟类中的第二高记录。</p>
<p>像所有鹤类一样，普通鹤是杂食性动物，食用植物物质以及昆虫、两栖动物、啮齿动物和其他小型动物。它们通常成小群在陆地上或浅水中觅食，用喙探查食物。</p>
<p>自古代以来，鹤类就在人类的艺术和象征中占有重要地位，出现在伊索寓言中，启发了如韩国自646年开始表演的传统舞蹈，并与古代南阿拉伯和希腊的神祇相关联。几种武术风格，尤其是功夫，从鹤类优雅的动作中获得灵感，这在1984年的热门电影《空手道小子》中得到了普及。</p>
<p>截至2014年，全球普通鹤的数量约为六十万只，国际自然保护联盟（IUCN）将其列为无危物种，使其成为仅有的四种不被认为受到威胁或依赖保护的鹤类之一。许多奥莱利封面动物都是濒危物种；所有的动物对世界都很重要。</p>
<p>封面插图由凯伦·蒙哥马利（Karen Montgomery）根据英国鸟类的一幅古线雕版画绘制。封面字体为Gilroy Semibold和Guardian Sans。正文字体为Adobe Minion Pro；标题字体为Adobe Myriad Condensed；代码字体为Dalton Maag的Ubuntu Mono。</p>
<h2 id="第一章-软件设计的艺术">第一章 软件设计的艺术
</h2><p><strong>什么是软件设计？为什么你应该关心它？</strong></p>
<p>在这一章中，我将为本书关于软件设计的内容奠定基础。我会解释什么是软件设计，帮助你理解为什么它是项目成功的关键因素，并且为什么它是你必须做对的一件事。<br/>同时，你会看到软件设计是非常复杂的，事实上，它是软件开发中最复杂的部分。<br/>因此，我还会介绍几种软件设计原则，帮助你在正确的道路上前行。</p>
<p><strong>准则1：理解软件设计的重要性</strong></p>
<p>在“准则1：理解软件设计的重要性”中，我会聚焦于大局观并解释软件预期会经历变化。因此，软件应该能够应对这些变化。<br/>然而，说起来容易做起来难，因为在现实中，耦合和依赖关系使得开发者的工作变得复杂得多。这些问题可以通过软件设计来解决。<br/>我将介绍软件设计作为管理依赖关系和抽象的艺术——这是软件工程的一个重要组成部分。</p>
<p><strong>准则2：为变化而设计</strong></p>
<p>在“准则2：为变化而设计”中，我将明确讨论耦合和依赖关系，并帮助你理解如何设计以适应变化，使软件更具适应性。为此，我将介绍单一职责原则（SRP）和不要重复自己（DRY）原则，这两个原则可以帮助你实现这一目标。</p>
<ul>
<li><strong>单一职责原则 (SRP)</strong>：每个模块或类应只有一个改变的理由，即只负责一个功能。</li>
<li><strong>不要重复自己 (DRY)</strong>：避免代码重复，确保逻辑只在一个地方实现。</li>
</ul>
<p><strong>准则3：分离接口以避免人为耦合</strong></p>
<p>在“准则3：分离接口以避免人为耦合”中，我会进一步讨论耦合问题，特别是通过接口产生的耦合。<br/>我还会介绍接口隔离原则（ISP），这是一种减少由接口引起的人为耦合的方法。</p>
<ul>
<li><strong>接口隔离原则 (ISP)</strong>：客户端不应被迫依赖于它们不使用的接口。<br/>这意味着接口应该尽量小而具体，而不是大而泛。</li>
</ul>
<p><strong>准则4：为可测试性设计</strong></p>
<p>在“准则4：为可测试性设计”中，我会关注由于人为耦合导致的可测试性问题。<br/>特别是，我会提出如何测试私有成员函数的问题，并演示分离关注点的应用是唯一的解决方案。</p>
<ul>
<li><strong>分离关注点</strong>：将不同功能分离到不同的模块或类中，以便更容易进行单元测试和集成测试。</li>
</ul>
<p><strong>准则5：为扩展性设计</strong></p>
<p>在“准则5：为扩展性设计”中，我会讨论一种重要的变化类型：扩展。就像代码应该易于更改一样，它也应该易于扩展。我会给你一些实现这一目标的想法，并展示开闭原则（OCP）的价值。</p>
<ul>
<li><strong>开闭原则 (OCP)</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着你可以通过添加新功能来扩展系统，而不需要修改现有的代码。</li>
</ul>
<hr>
<h3 id="准则1理解软件设计的重要性">准则1：理解软件设计的重要性
</h3><p>如果我问你哪些代码属性对你来说最重要，经过一些思考后，你可能会说诸如可读性、可测试性、可维护性、可扩展性、可复用性和可扩展性之类的东西。我完全同意。<br/>但是，如果我现在问你如何实现这些目标，很有可能你会开始列举一些C++特性：RAII、算法、lambda表达式、模块等等。</p>
<p><strong>特性不是软件设计</strong></p>
<p>是的，C++ 提供了很多特性。非常多！大约一半的近2000页印刷版C++标准都用于解释语言机制和特性。<br/>自C++11发布以来，有一个明确的承诺：每三年，C++标准化委员会都会给我们带来一个新的C++标准，其中包含额外的全新特性。<br/>鉴于此，C++社区非常强调特性和语言机制并不令人意外。大多数书籍、讲座和博客都集中在特性、新库和语言细节上。</p>
<p>几乎感觉像是特性是用C++编程中最重要的东西，并且对C++项目的成功至关重要。但说实话，它们并不是。<br/>无论是对所有特性的了解还是C++标准的选择，都不是项目成功的关键因素,你不应该指望特性来拯救你的项目。<br/>相反，一个项目即使使用较旧的C++标准，甚至只使用可用特性的一小部分，也可以非常成功。<br/>撇开软件开发中的人为因素不谈，对于项目成败更重要的问题是软件的整体结构。</p>
<p>最终，正是这种结构决定了可维护性：修改代码、扩展代码和测试代码有多容易？如果没有轻松修改代码、添加新功能并对其正确性有信心的能力，项目将走到生命周期的尽头。<br/>结构还决定了项目的可扩展性：项目在崩溃之前能增长到多大？在大家开始互相干扰之前，有多少人可以参与实现项目的愿景？</p>
<p>整体结构就是项目的<strong>设计</strong>,设计在项目成功中的作用远比任何特性都要重要得多。<br/>好的软件不仅仅在于正确使用某个特性,而是关于坚实的架构和设计。<br/>良好的软件设计可以容忍一些糟糕的实现决策，但糟糕的软件设计不能仅靠英雄式的使用（旧或新的）特性来挽救。</p>
<p><strong>软件设计：管理依赖关系和抽象的艺术</strong></p>
<p><strong>为什么软件设计对项目的质量如此重要？</strong></p>
<p>假设目前一切运行良好，只要软件没有变化且不需要添加新功能，你就可以高枕无忧。</p>
<p>然而，这种状态通常不会持续很久，可以合理预期，某些事情将会发生变化，毕竟，在软件开发中唯一不变的就是变化，它是所有问题及解决方案背后的驱动力。</p>
<p>这就是为什么软件被称为“软”件：因为它相对硬件来说是柔软且可塑的。尽管我们期望软件能轻松适应变化，但现实往往并非如此。</p>
<p>为了说明这一点，假设你从问题跟踪系统中选择了一个评估为2的任务，无论2代表什么，它听起来都不是大任务，所以你有信心可以很快完成。</p>
<p>怀着良好的愿望，你先理解预期要求，然后开始在一个实体A上进行修改。<br/>由于测试反馈（你很幸运有测试！），你很快意识到还需解决实体B的问题，这令人惊讶，因为你没预料到B会涉及其中。</p>
<p>尽管如此，你还是继续调整B，然而，夜间构建显示这导致了C和D停止工作。<br/>深入调查后，你发现问题的根源遍布代码库的很大一部分。<br/>这个看似简单的任务已演变成大规模且高风险的代码修改。你解决问题的信心消失，本周的工作计划也被打乱。</p>
<p><strong>也许这个故事听起来很熟悉</strong></p>
<p>也许这个故事对你来说很熟悉，也许你甚至可以贡献一些你自己经历的“战争故事”。<br/>事实上，大多数开发者都有类似的经历。<br/>而这些经历的问题通常都源自同一个根源：依赖关系。正如Kent Beck在他的测试驱动开发一书中所表达的：</p>
<p><strong>依赖关系是所有规模软件开发中的关键问题。</strong></p>
<p>依赖关系是每个软件开发者存在的祸根 “但是当然会有依赖关系，” 你可能会争辩道，“总是会有依赖关系，否则不同的代码片段如何协同工作呢？” 当然，你是对的。<br/>不同的代码片段需要协同工作，这种交互总会产生某种形式的耦合。<br/>然而，虽然存在必要且不可避免的依赖关系，但也存在我们因缺乏对问题的理解、没有清晰的整体视角或只是不够注意而无意引入的人为依赖关系。<br/>不用说，这些人造依赖关系会带来麻烦，它们使得理解我们的软件、修改软件、添加新功能和编写测试变得更加困难。<br/>因此，作为软件开发者的主要任务之一（如果不是最重要的任务），就是尽量减少人为依赖关系。</p>
<p>这种依赖关系的最小化是软件架构和设计的目标。用Robert C. Martin的话来说：</p>
<p><strong>软件架构的目标是将构建和维护所需系统所需的人力资源最小化。</strong></p>
<p>架构和设计是减少任何项目工作量所需的工具。它们处理依赖关系并通过抽象来降低复杂性。用我自己的话来说：</p>
<p><strong>软件设计是管理软件组件之间相互依赖的艺术。它旨在最小化人为（技术）依赖，并引入必要的抽象和妥协。</strong></p>
<p>是的，软件设计是一门艺术，它不是一门科学，也没有一套简单而明确的答案。<br/>很多时候，设计的整体图景会让我们难以捉摸，我们会被软件实体之间复杂的相互依赖所压倒，但我们试图应对这种复杂性，并通过引入适当的抽象来减少它。<br/>这样，我们将细节的层次保持在一个合理的水平。然而，很多时候团队中的个别开发者可能对架构和设计有不同的想法。我们可能无法实现自己对设计的愿景，并被迫做出妥协以继续前进。</p>
<p>在前面的引用中，架构和设计这两个词可以互换使用，因为它们非常相似且目标相同。<br/>然而，它们并不是完全一样的，如果你看一下软件开发的三个层次，相似性和差异性就会变得清晰起来。</p>
<p><strong>软件开发的三个层次</strong></p>
<p>软件架构和软件设计是软件开发三个层次中的两个，第三个层次是实现细节。<br/>为了让你更直观地理解这三个层次，我们以建筑领域为例，类比架构、设计和实现细节的关系。假设你是一名建筑设计师（是的，不是坐在电脑前喝着咖啡的软件架构师，而是在工地现场的房屋建筑师）。你的职责包括：</p>
<ul>
<li>确保房屋与周围环境协调；</li>
<li>保证结构稳固性；</li>
<li>规划房间布局、管道系统等；</li>
<li>兼顾美观与功能性（例如宽敞的客厅、厨房与餐厅的便捷动线）。</li>
</ul>
<p>这些工作属于<strong>架构</strong>和<strong>设计</strong>层面。两者的界限往往是模糊的——架构关注全局且难以后期更改的决策，而设计处理更细粒度的部分（如门窗位置）。但无论是架构还是设计，你都不会操心冰箱、电视的摆放或装饰细节——这些属于<strong>实现细节</strong>，对应软件开发中的具体编码实现。</p>
<p><strong>实现细节：最具体的层次</strong></p>
<p>在软件中，实现细节是<strong>如何解决问题</strong>的层面，涉及：</p>
<ul>
<li>选择C++标准或语言特性（如<code>std::make_unique</code>工厂函数、<code>std::enable_if</code>实现SFINAE）；</li>
<li>处理内存管理、异常安全和性能优化；</li>
<li>应用惯用法（如“复制-交换”惯用法、RAII）。</li>
</ul>
<p><strong>关键点</strong>：实现细节通常不引入抽象或解耦，而是通过<strong>封装</strong>（如RAII将资源管理与业务逻辑隔离）提升代码健壮性。</p>
<p><strong>软件设计：关注交互与可维护性</strong></p>
<p>软件设计聚焦于：</p>
<ul>
<li><strong>可维护性、可扩展性、可测试性</strong>；</li>
<li>软件实体（类、函数）的<strong>物理与逻辑依赖关系</strong>；</li>
<li>应用设计模式（如访问者模式、策略模式、装饰模式）解耦复杂系统。</li>
</ul>
<p><strong>关键点</strong>：设计模式通常是语言无关的，帮助将复杂逻辑分解为可管理的模块。</p>
<p><strong>软件架构：模糊但关键的“大决策”</strong></p>
<p>软件架构是三个层次中最难定义的，但核心在于：</p>
<ul>
<li>制定<strong>难以后期更改的重大决策</strong>（如选择微服务架构或客户端-服务器架构）；</li>
<li>确保系统各部分变更时互不影响；</li>
<li>使用架构模式（如微服务、事件驱动）定义模块或组件间的结构与依赖。</li>
</ul>
<p><strong>关键洞见</strong>：</p>
<blockquote>
<p>“架构是你希望能在项目初期就正确决策，但实际未必比其他决策更容易正确。”
——Ralph Johnson</p>
</blockquote>
<p><strong>挑战</strong>：随着微服务等技术的普及，“大”与“小”的界限变得模糊，架构常由项目中的核心开发者凭经验界定。</p>
<p><strong>惯用法：跨越层次的模式</strong></p>
<p>惯用法（Idiom）是语言特定的常见解决方案，可能属于设计或实现细节。例如：</p>
<ul>
<li><strong>实现细节惯用法</strong>：RAII、复制-交换；</li>
<li><strong>设计惯用法</strong>：非虚接口（NVI，基于模板方法模式）、Pimpl（基于桥接模式）。</li>
</ul>
<p><strong>核心区别</strong>：</p>
<ul>
<li><strong>抽象</strong>（设计层）通过隐藏细节简化交互；</li>
<li><strong>封装</strong>（实现层）通过集中管理逻辑提升安全性</li>
</ul>
<hr>
<p><strong>对语言特性的过度关注</strong></p>
<p>如果软件架构和软件设计如此重要，为何C++社区却如此痴迷于语言特性？为何我们总营造一种错觉，认为C++标准、语言机制和特性能决定项目的成败？我认为有三个主要原因：</p>
<p><strong>第一，特性的复杂性与惯性塑造</strong>
C++语言特性数量庞大且细节复杂，社区需要大量时间讨论如何正确使用它们，建立对“良好实践”和“不良实践”的共识。我们需要共同塑造<strong>符合C++惯用法</strong>的编程文化。</p>
<p><strong>第二，对特性的错误期望</strong>
以C++20模块（Modules）为例——它无疑是自C++诞生以来最重大的技术革新之一，可能终结头文件包含的繁琐模式。但许多人误以为模块能修复代码的结构性问题，甚至拯救项目。然而，模块的作用是<strong>反映现有结构</strong>，而非改进设计。它无法掩盖设计缺陷，反而可能暴露问题。</p>
<p><strong>第三，软件设计的复杂性远超语言特性</strong>
相比软件设计中解耦实体、管理依赖的复杂性，语言特性的规则（无论有多少例外情况）更容易解释。关于特性的问题通常有明确答案，而软件设计的答案往往是 <strong>“视情况而定”</strong>。如何让代码更可维护、可扩展、可测试，高度依赖项目具体情境。正如那句名言：</p>
<blockquote>
<p>“设计与编程是人类活动；忘记这一点，一切将失去意义。”</p>
</blockquote>
<hr>
<p><strong>为何我们仍需关注特性？</strong></p>
<p>这三个原因共同导致了社区对特性的过度关注。但请注意，<strong>特性本身并非不重要</strong>。正确理解和使用它们至关重要，但仅凭特性无法拯救项目。</p>
<hr>
<p><strong>回归软件设计与原则的核心</strong></p>
<p>特性固然重要，但软件设计才是项目成功的基石。本书将聚焦于：</p>
<ul>
<li><strong>软件设计决策背后的逻辑</strong>；</li>
<li><strong>设计原则</strong>（如SOLID、DRY）；</li>
<li><strong>依赖管理</strong>与<strong>抽象设计</strong>；</li>
<li><strong>现代C++代码的合理应用</strong>（如C++20概念），而非盲目追求<code>noexcept</code>或滥用<code>constexpr</code>。</li>
</ul>
<p><strong>关键结论</strong></p>
<p>优秀的软件开发者必须深入理解软件设计。因为：</p>
<ul>
<li><strong>优秀软件成本低廉</strong>，糟糕软件代价高昂；</li>
<li>语言特性是工具，设计能力才是核心竞争力；</li>
<li>真正的挑战在于<strong>平衡特性使用与设计决策</strong>，构建可持续演进的系统。</li>
</ul>
<p><strong>本节总结</strong></p>
<ul>
<li>将软件设计视为编写软件的一个重要部分。</li>
<li>减少对C++语言细节的关注，更多地关注软件设计。</li>
<li>避免不必要的耦合和依赖，使软件更能适应频繁的变化。</li>
<li>理解软件设计是管理依赖关系和抽象的艺术。认识到软件设计与软件架构之间的界限是流动的。</li>
</ul>
<h3 id="准则2为变化而设计">准则2：为变化而设计
</h3><p>优秀软件的核心特征之一是<strong>易变更性</strong>。这一特性甚至隐含在&quot;软件&quot;（<em>software</em>）一词中——与硬件（<em>hardware</em>）不同，软件应能轻松适应需求变化（参见准则 1：理解软件设计的重要性）。然而，实际开发中我们常发现：看似简单的代码变更，往往需要耗费数天甚至数周。</p>
<hr>
<p><strong>分离关注点</strong></p>
<p>降低人为耦合、简化变更的最佳实践是<strong>分离关注点</strong>。其核心思想是：</p>
<blockquote>
<p>将功能拆分为<strong>高内聚、低耦合</strong>的独立模块，每个模块专注单一职责。
——《程序员修炼之道》</p>
</blockquote>
<p>这种思想通过不同术语被反复强调：</p>
<ul>
<li><strong>正交性</strong>（Orthogonality）：分离软件中正交的维度</li>
<li><strong>内聚性</strong>（Cohesion）：模块内部元素的关联强度（高内聚模块应作为整体处理）</li>
<li><strong>单一职责原则</strong>（SRP）：一个类只有一个变更理由</li>
</ul>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>将<strong>因不同原因而变化</strong>的部分分离</li>
<li>仅将真正相关的内容聚合</li>
<li>减少人为耦合，使变更只需修改一处</li>
</ul>
<p><strong>人为耦合的代码示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="c1">//#include &lt;some_json_library.h&gt;  // Potential physical dependency 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span> <span class="n">ByteStream</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>看似合理的设计</strong>：</p>
<ul>
<li>基类提供<code>exportToJSON()</code>和<code>serialize()</code>等通用功能</li>
<li>派生类（如PDF、Word文档）实现具体逻辑</li>
<li>用户无需了解具体文档类型即可操作</li>
</ul>
<p><strong>实际隐藏的三大耦合问题</strong>：</p>
<hr>
<p><strong>1. 第三方库的强制绑定</strong></p>
<ul>
<li>
<p><strong>JSON导出的陷阱</strong>：
每个派生类必须实现<code>exportToJSON()</code>，导致强制依赖某个JSON库（如<code>rapidjson</code>或<code>simdjson</code>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PDFDocument</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">exportToJSON</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">rapidjson</span><span class="o">::</span><span class="n">Document</span> <span class="n">json</span><span class="p">;</span>  <span class="c1">// 直接依赖特定JSON库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 实现细节...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>后果</strong>：
<ul>
<li>所有文档类型被同一JSON库绑定</li>
<li>更换库需修改所有派生类</li>
<li>系统变得臃肿，复用性降低</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. 接口签名泄漏实现细节</strong></p>
<ul>
<li>
<p><strong>隐式耦合示例</strong>：
假设<code>exportToJSON()</code>参数设计受限于当前JSON库：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="n">rapidjson</span><span class="o">::</span><span class="n">PrettyWriter</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>后果</strong>：
<ul>
<li>更换JSON库时，接口签名被迫修改</li>
<li>所有调用方代码需同步调整</li>
<li>变更影响范围超出预期</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>3. 序列化与文档类型的全局耦合</strong></p>
<ul>
<li>
<p><strong>枚举导致的连锁反应</strong>：
序列化需要标识文档类型，引入全局枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">DocumentType</span> <span class="p">{</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>派生类实现序列化时依赖此枚举：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PDFDocument</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stream</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">DocumentType</span><span class="o">::</span><span class="n">pdf</span><span class="p">));</span>  <span class="c1">// 所有文档类知晓其他类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其他序列化逻辑...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>后果</strong>：
<ul>
<li>添加新文档类型需修改全局枚举</li>
<li>所有现有文档类的序列化逻辑被影响</li>
<li>违反开闭原则（对扩展开放，对修改关闭）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>设计缺陷总结</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">问题类型</th>
<th style="text-align:left">引发原因</th>
<th style="text-align:left">维护代价</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>第三方库绑定</strong></td>
<td style="text-align:left">派生类直接实现具体库逻辑</td>
<td style="text-align:left">更换技术栈需全量重写</td>
</tr>
<tr>
<td style="text-align:left"><strong>接口泄漏实现细节</strong></td>
<td style="text-align:left">接口参数与特定库强关联</td>
<td style="text-align:left">调用方代码随实现库变更而修改</td>
</tr>
<tr>
<td style="text-align:left"><strong>全局类型耦合</strong></td>
<td style="text-align:left">序列化依赖共享枚举</td>
<td style="text-align:left">新增类型导致连锁代码修改</td>
</tr>
</tbody>
</table></div>
<p><strong>优化方向：解耦设计</strong></p>
<ol>
<li>
<p><strong>分离数据与操作</strong></p>
<ul>
<li>将JSON导出、序列化等能力拆分为独立组件</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">JSONExporter</span> <span class="p">{</span>  <span class="c1">// 独立JSON处理类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">export</span><span class="p">(</span><span class="k">const</span> <span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PDFDocument</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Document</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>  <span class="c1">// 不再实现JSON逻辑
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>依赖注入取代继承</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DocumentProcessor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">DocumentProcessor</span><span class="p">(</span><span class="n">JSONExporter</span><span class="o">&amp;</span> <span class="n">exporter</span><span class="p">,</span> <span class="n">Serializer</span><span class="o">&amp;</span> <span class="n">serializer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">exporter_</span><span class="p">(</span><span class="n">exporter</span><span class="p">),</span> <span class="n">serializer_</span><span class="p">(</span><span class="n">serializer</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="k">const</span> <span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">exporter_</span><span class="p">.</span><span class="k">export</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">serializer_</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">JSONExporter</span><span class="o">&amp;</span> <span class="n">exporter_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Serializer</span><span class="o">&amp;</span> <span class="n">serializer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>使用适配器模式隔离第三方库</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RapidJSONAdapter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">JSONExporter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">export</span><span class="p">(</span><span class="k">const</span> <span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">rapidjson</span><span class="o">::</span><span class="n">Document</span> <span class="n">json</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 转换逻辑封装在此
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<hr>
<p><strong>关键启示</strong></p>
<ul>
<li><strong>警惕&quot;全能基类&quot;</strong>：继承不是代码复用的唯一手段</li>
<li><strong>延迟技术决策</strong>：通过抽象层隔离具体实现细节</li>
<li><strong>正交性设计</strong>：确保不同功能维度相互独立，变更互不影响</li>
</ul>
<blockquote>
<p>&ldquo;好的系统设计不是避免变更，而是让变更发生在正确的地方。&rdquo;
——《领域驱动设计》</p>
</blockquote>
<p>我应该明确指出，<code>Document</code> 类对选定 JSON 库存在潜在的物理依赖。</p>
<p>如果 <code>&lt;Document.h&gt;</code> 头文件包含了所选 JSON 库中的任何头文件（如“人工耦合的例子”代码片段所示），</p>
<p>例如因为 <code>exportToJSON()</code> 函数期望基于该库的一些参数，那么就存在对该库的明确依赖。</p>
<p>然而，如果接口能够正确抽象这些细节，并且 <code>&lt;Document.h&gt;</code> 头文件不包含来自 JSON 库的任何内容，那么这种物理依赖可能会被避免。</p>
<p>因此，这取决于依赖关系能否被（以及如何被）良好地抽象。</p>
<p>“高层次、低层次——我现在有点糊涂了，”你抱怨道。是的，我知道这两个术语通常会让人感到困惑。在我们继续之前，先让我们明确这两个术语的定义。</p>
<p>这两个术语的起源与我们用统一建模语言（UML）绘制图表的方式有关：我们认为稳定的功能出现在顶部（高层次），而更常变化、具有可变性或可塑性的功能出现在底部（低层次）。</p>
<p>遗憾的是，当我们绘制架构图时，通常会试图展示各部分如何相互构建，因此最稳定的部分会出现在架构的底部。这自然会引起一些混淆。</p>
<p>不论如何绘制，请记住这两个术语：高层次指的是架构中稳定的部分，低层次指的是更常变化或更可能变化的方面。</p>
<p>回到问题本身：单一职责原则（SRP）建议我们分离关注点和那些不属于同一职责的部分，即缺乏内聚性的部分。换句话说，它建议我们将因不同原因而变化的部分分离为变化点。</p>
<p>根据这一建议，Document类被重构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 不再有&#39;exportToJSON()&#39;和&#39;serialize()&#39;函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 仅保留不会导致强耦合的最基本文档操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>JSON和序列化方面不再属于Document类的核心功能。</p>
<p>Document类应仅代表不同类型文档的最基本操作，所有正交关注点都应被分离，这将使修改更加容易。</p>
<p>例如，通过将JSON方面隔离为一个独立的变化点和新JSON组件，更换JSON库只会影响该组件。</p>
<p>修改可以集中在一个地方进行，与其他正交关注点完全隔离。</p>
<p>同时，使用多个JSON库支持JSON格式也会更简单。</p>
<p>此外，任何关于文档序列化的修改只会影响代码中的一个组件：新的序列化组件。序列化组件将作为变化点，实现隔离且简单的修改。这是最理想的情况。</p>
<p>虽然你对Document示例最初感到失望，但现在似乎又有了信心，也许你脸上还带着&quot;我早该想到！&ldquo;的微笑。</p>
<p>但你仍未完全满意：&ldquo;是的，我认同分离关注点的总体思路，但如何在软件结构中实现这种分离？具体该怎么做？&ldquo;这是一个极好的问题，但答案众多，我将在后续章节中逐一解答，最关键的第一步是识别变化点，即代码中预期会发生变化的部分。这些变化点应被提取、隔离和封装，消除对这些变化的依赖。这将最终使修改更容易。</p>
<p>&ldquo;但这仍只是表面建议！&ldquo;你说得对，遗憾的是，没有唯一或简单的答案，具体情况具体分析，但我承诺在后续章节中给出许多具体方案（毕竟这是一本关于软件设计——管理依赖关系的书）。</p>
<p>作为预告，第3章将介绍解决这一问题的通用实用方法：设计模式。通过访问者模式、策略模式、外部多态等模式，我将展示如何分离关注点。这些模式各有优缺点，但共同点是通过引入抽象来减少依赖。此外，我将详细探讨如何在现代C++中实现这些模式。</p>
<hr>
<p><strong>不要重复自己（DRY原则）</strong></p>
<p>可修改性还有第二个重要方面。为说明这一点，我将引入另一个示例：物品类层次结构。</p>
<p>层次结构的顶端是Item基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Money.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Money</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="n">Money</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="n">Money</span> <span class="n">money</span><span class="p">,</span> <span class="kt">double</span> <span class="n">factor</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">Money</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">Money</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Money</span> <span class="n">rhs</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Item.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Item</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Item</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Item基类代表具有价格标签（由Money类表示）的各类物品的抽象。</p>
<p>通过price()函数可以查询价格。虽然实际可能有多种物品，但为简化说明，我们仅以CppBook和ConferenceTicket为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;CppBook.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CppBook</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Item</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">CppBook</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">title_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">author_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">author</span><span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">priceWithTax_</span><span class="p">(</span> <span class="n">price</span> <span class="o">*</span> <span class="mf">1.15</span> <span class="p">)</span>  <span class="c1">// 15%税率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">title_</span><span class="p">;</span> <span class="p">}</span>      
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">author</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">author_</span><span class="p">;</span> <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">priceWithTax_</span><span class="p">;</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">author_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">priceWithTax_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>CppBook类的构造函数接收书名、作者（字符串形式）和价格（Money形式）。它通过title()、author()和price()函数提供访问接口。特别的是price()函数：由于书籍需缴税，原始价格需按15%税率调整。</p>
<p>ConferenceTicket类是第二个Item示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;ConferenceTicket.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConferenceTicket</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Item</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">ConferenceTicket</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span> <span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">priceWithTax_</span><span class="p">(</span> <span class="n">price</span> <span class="o">*</span> <span class="mf">1.15</span> <span class="p">)</span>  <span class="c1">// 15%税率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">priceWithTax_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">priceWithTax_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>ConferenceTicket与CppBook类似，但构造函数只需会议名称和价格。同样，会议门票价格也按15%税率调整。</p>
<p>通过这个设计，我们可以在main()函数中创建多个物品并计算总价：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CppBook.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ConferenceTicket.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;</span> <span class="n">items</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CppBook</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;Effective C++&#34;</span><span class="p">,</span> <span class="mf">19.99</span><span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CppBook</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;C++ Templates&#34;</span><span class="p">,</span> <span class="mf">49.99</span><span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConferenceTicket</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;CppCon&#34;</span><span class="p">,</span> <span class="mf">999.0</span><span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConferenceTicket</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;Meeting C++&#34;</span><span class="p">,</span> <span class="mf">699.0</span><span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConferenceTicket</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;C++ on Sea&#34;</span><span class="p">,</span> <span class="mf">499.0</span><span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="k">const</span> <span class="n">total_price</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">items</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">items</span><span class="p">),</span> <span class="n">Money</span><span class="p">{},</span> 
</span></span><span class="line"><span class="cl">            <span class="p">[](</span> <span class="n">Money</span> <span class="n">accu</span><span class="p">,</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">accu</span> <span class="o">+</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在main()中创建了两个书籍和三个会议门票，并计算含税总价。这看似良好的设计实现了关注点分离，每个物品类独立处理价格计算，符合SRP原则并隔离了变化点。然而，该设计存在重大缺陷：税率变更将影响所有派生类。例如，若税率从15%调整为12%或16%，需要修改每个类的计算逻辑，导致改动遍布代码库。</p>
<p>正如SRP建议分离变化点，我们还应避免在代码库中重复信息。每个职责应在系统中仅存在一次，这就是&quot;不要重复自己&rdquo;（DRY）原则。理想情况下，税率应仅在一处表示，便于统一修改。SRP与DRY通常相辅相成，但有时需要额外步骤来实现两者。我将在后续章节（参见&quot;准则35：使用装饰器实现层次化定制&rdquo;）详细探讨该问题的解决方案。</p>
<hr>
<p><strong>避免过早的分离关注点</strong></p>
<p>在这一点上，我希望已经说服你遵守 SRP（单一职责原则）和 DRY（不要重复自己）是一个非常合理的想法。</p>
<p>你甚至可能会如此坚定地计划将所有类和函数分离成最小的功能单元，毕竟，这就是目标，对吧？如果你现在正在这么想，请停下来！深呼吸一下。再来一次。然后请仔细聆听 Katerina Trajchevska 的智慧：</p>
<p><strong>“不要试图实现 SOLID，而是用 SOLID 来实现可维护性。”</strong></p>
<p>SRP 和 DRY 都是你实现更好可维护性和简化变更的工具，而不是你的目标，虽然从长远来看这两者都非常重要，但在没有明确了解哪些变化会影响你的情况下分离实体可能会适得其反。</p>
<p>为变化而设计通常有利于某一种特定的变化，但不幸的是，这可能会使其他种类的变化变得更加困难。<br/>这种理念是众所周知的 YAGNI 原则（You Aren’t Gonna Need It，你不会需要它）的一部分，该原则警告你避免过度设计（参见“指导原则 5：为扩展而设计”）。</p>
<p>如果你有一个明确的计划，并且知道预期的变化类型，那么应用 SRP 和 DRY 来简化那种变化。<br/>然而，如果你不知道会有什么样的变化，请不要猜测——只需等待，等到你清楚地知道预期的变化类型，然后再进行重构以使变化尽可能简单。</p>
<p>总之，软件中的变化是预期的，因此为变化而设计是至关重要的。分离关注点并最小化重复，以便你可以轻松地进行更改，而不必担心会破坏其他正交的方面。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>预期软件中的变化。</li>
<li>为易于更改而设计，使软件更具适应性。</li>
<li>避免将不相关的正交方面组合在一起，以防止耦合。</li>
<li>理解耦合增加了变更的可能性，并使变更更加困难。</li>
<li>遵循单一职责原则（SRP）来分离关注点。</li>
<li>遵守不要重复自己（DRY）原则以最小化重复。</li>
<li>如果你不确定下一次变更，避免过早抽象。</li>
</ul>
<h3 id="准则3分离接口以避免人为耦合">准则3：分离接口以避免人为耦合
</h3><p><strong>接口隔离：解耦正交功能</strong></p>
<p>让我们重新审视准则2：为变更而设计中的<code>Document</code>类案例。尽管已拆分JSON导出和序列化功能，但接口设计仍存在更深层的耦合问题。</p>
<hr>
<p><strong>问题：全能接口引发的连锁反应</strong></p>
<p>原<code>Document</code>接口强制派生类实现所有方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// JSON导出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 序列化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... 其他方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>缺陷示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exportDocument</span><span class="p">(</span><span class="k">const</span> <span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">doc</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>  <span class="c1">// 仅需JSON导出功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>隐性依赖</strong>：
<ul>
<li><code>exportDocument()</code>函数被迫依赖<code>Document</code>的所有接口（包括无关的<code>serialize()</code>）</li>
<li>修改<code>ByteStream</code>类或<code>serialize()</code>签名会导致所有<code>Document</code>用户重新编译</li>
<li>新增接口（如XML导出）会波及所有客户端代码</li>
</ul>
</li>
</ul>
<hr>
<p><strong>解决方案：接口隔离原则（ISP）</strong></p>
<p><strong>核心思想</strong>：</p>
<blockquote>
<p>客户端不应被迫依赖其不使用的方法。</p>
</blockquote>
<p><strong>重构步骤</strong>：</p>
<ol>
<li><strong>拆分正交接口</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// JSON导出能力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">JSONExportable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">JSONExportable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 序列化能力
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Serializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Serializable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 组合式Document接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Document</span> <span class="o">:</span> <span class="k">public</span> <span class="n">JSONExportable</span><span class="p">,</span> <span class="k">public</span> <span class="n">Serializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 其他基础功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>客户端按需依赖</strong></li>
</ol>
<p>cpp</p>
<p>复制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exportDocument</span><span class="p">(</span><span class="k">const</span> <span class="n">JSONExportable</span><span class="o">&amp;</span> <span class="n">exportable</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">exportable</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>  <span class="c1">// 仅依赖所需接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优势</strong>：</p>
<ul>
<li><strong>解耦编译依赖</strong>：修改<code>Serializable</code>不影响仅使用<code>JSONExportable</code>的客户端</li>
<li><strong>接口扩展安全</strong>：新增接口（如<code>XMLExportable</code>）不会导致现有客户端被迫适配</li>
<li><strong>符合SRP</strong>：每个接口专注单一能力维度</li>
</ul>
<hr>
<p><strong>ISP与SRP的关系</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">原则</th>
<th style="text-align:left">关注点</th>
<th style="text-align:left">应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>SRP</strong></td>
<td style="text-align:left">类/模块的职责单一性</td>
<td style="text-align:left">整体架构设计</td>
</tr>
<tr>
<td style="text-align:left"><strong>ISP</strong></td>
<td style="text-align:left">接口方法的正交性</td>
<td style="text-align:left">接口抽象层设计</td>
</tr>
</tbody>
</table></div>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>ISP是SRP在接口设计中的特例</li>
<li>违反ISP必然违反SRP，但反之不成立</li>
<li>接口聚合的诱惑普遍存在（如&quot;全能基类&rdquo;），需通过设计评审提前规避</li>
</ul>
<hr>
<p><strong>模板设计中的ISP思想</strong></p>
<p>ISP不仅适用于面向对象设计，也影响模板编程。以<code>std::copy</code>为例：</p>
<p><strong>不良设计：过度约束迭代器类型</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ForwardIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">copy</span><span class="p">(</span><span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">d_first</span><span class="p">);</span>  <span class="c1">// 要求前向迭代器
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>问题</strong>：无法适配输入流迭代器（仅支持单向遍历）</li>
</ul>
<p><strong>优化设计：最小化模板约束</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OutputIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">copy</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">d_first</span><span class="p">);</span>  <span class="c1">// 仅要求输入/输出迭代器
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>C++20概念增强</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span> <span class="n">InputIt</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">output_iterator</span> <span class="n">OutputIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">OutputIt</span> <span class="n">copy</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">d_first</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>设计启示</strong>：</p>
<ul>
<li><strong>精准表达需求</strong>：模板参数仅声明必要操作（如<code>input_iterator</code>只需<code>++</code>和<code>*</code>）</li>
<li><strong>提升泛用性</strong>：支持更广泛的适配器（如文件流、网络流迭代器）</li>
<li><strong>减少隐式依赖</strong>：避免强制用户实现无关接口</li>
</ul>
<hr>
<p><strong>最佳实践清单</strong></p>
<ol>
<li><strong>接口设计时</strong>：
<ul>
<li>为每个正交功能维度定义独立接口</li>
<li>通过多重继承组合复杂能力（而非单一庞大接口）</li>
</ul>
</li>
<li><strong>客户端编码时</strong>：
<ul>
<li>依赖最具体的接口类型（如<code>JSONExportable</code>而非<code>Document</code>）</li>
</ul>
</li>
<li><strong>模板设计时</strong>：
<ul>
<li>使用C++概念精准约束模板参数</li>
<li>优先选择最宽松的迭代器类别（输入/输出迭代器 &gt; 前向迭代器）</li>
</ul>
</li>
<li><strong>重构策略</strong>：
<ul>
<li>识别被强制实现的&quot;空方法&rdquo;（如抛出异常），提示接口需拆分</li>
<li>使用适配器模式包装遗留接口，逐步迁移</li>
</ul>
</li>
</ol>
<blockquote>
<p>&ldquo;良好的接口设计如同精确的手术刀——只切开必要的部分，保持其他组织的完整。&rdquo;
——《C++软件设计》</p>
</blockquote>
<p><strong>本节总结</strong></p>
<ul>
<li>注意耦合也会影响接口。</li>
<li>遵守接口隔离原则（ISP）以分离接口中的关注点。</li>
<li>将 ISP 视为单一职责原则（SRP）的一个特例。</li>
<li>理解 ISP 既适用于继承层次结构，也适用于模板。</li>
</ul>
<h3 id="准则4为可测试性而设计">准则4：为可测试性而设计
</h3><p>正如准则1：理解软件设计的重要性所述，软件必然面临变更。但每次修改都可能意外破坏现有功能——尽管我们尽力避免，风险始终存在。作为开发者，我们依赖<strong>测试</strong>作为安全网：</p>
<blockquote>
<p>测试是软件变更的保护层，是确保功能完整性的救生衣。</p>
</blockquote>
<p>然而，编写测试的前提是<strong>软件必须可测试</strong>。本准则将揭示如何通过设计提升可测试性。</p>
<hr>
<p><strong>挑战：如何测试私有成员函数？</strong></p>
<p>考虑以下<code>Widget</code>类，其私有方法<code>updateCollection()</code>需要测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">updateCollection</span><span class="p">(</span><span class="cm">/*参数*/</span><span class="p">);</span>  <span class="c1">// 需测试的私有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">blobs_</span><span class="p">;</span>         <span class="c1">// 数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... 其他可能的数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>常见错误方案</strong>：</p>
<ol>
<li>
<p><strong>白盒测试</strong>：通过公有方法间接测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">addBlob</span><span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&amp;</span> <span class="n">blob</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">updateCollection</span><span class="p">();</span>  <span class="c1">// 内部调用私有方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>问题</strong>：测试依赖实现细节，实现变更会导致测试失效。</p>
</li>
<li>
<p><strong>友元类</strong>：授予测试类特殊权限</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">TestWidget</span><span class="p">;</span>  <span class="c1">// 声明测试类为友元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">updateCollection</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>问题</strong>：生产代码反向依赖测试代码，形成循环依赖。</p>
</li>
<li>
<p><strong>继承暴露</strong>：将方法改为<code>protected</code>并派生测试类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestWidget</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Widget</span> <span class="p">{</span>  <span class="c1">// 通过继承访问protected方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">testUpdate</span><span class="p">()</span> <span class="p">{</span> <span class="n">updateCollection</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>问题</strong>：滥用继承机制，破坏封装性。</p>
</li>
</ol>
<hr>
<p><strong>终极方案：关注点分离</strong></p>
<p><strong>核心思想</strong>：将需测试的功能从类中解耦，使其独立可测。</p>
<p><strong>方案1：提取为自由函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 将更新逻辑提取为独立函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">updateCollection</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;&amp;</span> <span class="n">blobs</span><span class="p">,</span> <span class="cm">/*参数*/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 实现原私有方法逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">blobs_</span><span class="p">;</span>  <span class="c1">// 数据成员仍封装在类内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 调用方式：updateCollection(blobs_, ...);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优势</strong>：</p>
<ul>
<li><strong>直接测试</strong>：无需依赖<code>Widget</code>类即可测试<code>updateCollection</code></li>
<li><strong>增强封装</strong>：自由函数仅能通过公有接口访问数据，减少对私有成员的暴露</li>
</ul>
<p><strong>方案2：封装为独立类</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">widget_details</span> <span class="p">{</span>  <span class="c1">// 细节命名空间隔离实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BlobCollection</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">updateCollection</span><span class="p">(</span><span class="cm">/*参数*/</span><span class="p">);</span>  <span class="c1">// 公开可测试方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">blobs_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace widget_details
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">widget_details</span><span class="o">::</span><span class="n">BlobCollection</span> <span class="n">blobs_</span><span class="p">;</span>  <span class="c1">// 组合代替继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优势</strong>：</p>
<ul>
<li><strong>职责清晰</strong>：<code>BlobCollection</code>专注集合管理，符合SRP</li>
<li><strong>测试友好</strong>：可直接实例化<code>BlobCollection</code>进行单元测试</li>
</ul>
<hr>
<p><strong>设计原则的协同效应</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">原则</th>
<th style="text-align:left">应用场景</th>
<th style="text-align:left">收益</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>SRP</strong></td>
<td style="text-align:left">分离集合管理与Widget核心逻辑</td>
<td style="text-align:left">功能变更互不影响</td>
</tr>
<tr>
<td style="text-align:left"><strong>封装性</strong></td>
<td style="text-align:left">限制自由函数/类对私有数据的访问</td>
<td style="text-align:left">降低意外修改风险</td>
</tr>
<tr>
<td style="text-align:left"><strong>组合优于继承</strong></td>
<td style="text-align:left">使用BlobCollection组合</td>
<td style="text-align:left">避免继承链的脆弱性</td>
</tr>
</tbody>
</table></div>
<hr>
<p><strong>关键实践建议</strong></p>
<ol>
<li><strong>警惕&quot;测试后门&rdquo;</strong>：
<ul>
<li>避免使用友元、继承或预处理宏破坏封装</li>
<li>优先通过设计而非权限突破实现可测试性</li>
</ul>
</li>
<li><strong>函数提取标准</strong>：
<ul>
<li>当私有方法逻辑复杂到需要独立测试时，即应解耦</li>
<li>虚函数需特殊处理（后续章节讨论）</li>
</ul>
</li>
<li><strong>测试驱动设计(TDD)</strong>：
<ul>
<li>编写测试前思考：如何最小化被测单元的外部依赖？</li>
<li>通过测试用例反推模块边界是否合理</li>
</ul>
</li>
</ol>
<blockquote>
<p>&ldquo;可测试性不是事后补救，而是优秀设计的自然结果。&rdquo;
——《修改代码的艺术》</p>
</blockquote>
<hr>
<p><strong>从封装性看函数提取</strong></p>
<p>Scott Meyers在《Effective C++》中指出：</p>
<blockquote>
<p><strong>优先选择非成员非友元函数</strong></p>
<ul>
<li>成员函数可访问所有私有成员，削弱封装</li>
<li>自由函数仅通过公有接口交互，增强封装</li>
</ul>
</blockquote>
<p><strong>示例对比</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 方案A：成员函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">WidgetA</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* 直接访问blobs_ */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">blobs_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 方案B：自由函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">WidgetB</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;&amp;</span> <span class="n">getBlobs</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">blobs_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Blob</span><span class="o">&gt;</span> <span class="n">blobs_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">WidgetB</span><span class="o">&amp;</span> <span class="n">widget</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 通过getBlobs()访问 */</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>方案B</strong>中，<code>update</code>函数无法直接访问<code>blobs_</code>，必须通过公有接口，封装性更优。</li>
</ul>
<hr>
<p><strong>本节总结</strong></p>
<ul>
<li><strong>测试即设计指标</strong>：难以测试的代码往往暗示设计缺陷</li>
<li><strong>解耦为王</strong>：通过分离关注点使组件独立可测</li>
<li><strong>平衡之道</strong>：在封装性与可测试性间寻找最优解</li>
<li><strong>工具辅助</strong>：利用依赖注入、策略模式等提升可测试性（后续章节详解）</li>
</ul>
<p>通过本准则，我们学会将可测试性融入设计DNA，让变更更安全、系统更健壮。</p>
<h3 id="准则5为扩展而设计">准则5：为扩展而设计
</h3><p>关于软件变更，还有一个重要方面尚未强调：可扩展性。可扩展性应成为设计的首要目标。因为坦率地说，若代码无法添加新功能，就意味着其生命周期的终结。因此，添加新功能——扩展代码库——具有根本重要性。正因如此，可扩展性理应成为优秀软件设计的核心目标与驱动力。</p>
<hr>
<p><strong>开放-封闭原则（OCP）</strong></p>
<p>可扩展性不会凭空实现，而是需要在设计时显式考虑。回顾&quot;准则2：为变化而设计&quot;中的文档序列化示例，我们曾使用带有纯虚函数<code>serialize()</code>的<code>Document</code>基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span> <span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>派生类（如<code>PDF</code>）需实现<code>serialize()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PDF</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">serialize</span><span class="p">(</span> <span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关键问题在于如何实现序列化。为实现反序列化，需在字节流开头存储文档类型标识。我们曾使用枚举类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">DocumentType</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">pdf</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">word</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多文档类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但此设计导致所有文档类（PDF、Word等）耦合于同一枚举。当新增XML文档类型时，必须修改枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">DocumentType</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">pdf</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">word</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">xml</span><span class="p">,</span>  <span class="c1">// 新增类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这会导致所有现有文档类重新编译，且限制了外部扩展能力（无法修改枚举则无法添加新类型）。<br/>这显然违反了<strong>开放-封闭原则（OCP）</strong>——软件实体应对扩展开放，对修改关闭。</p>
<hr>
<p><strong>解决方案：分离关注点</strong></p>
<p>通过将序列化逻辑提取为独立组件（如图1-6所示），我们解除了文档类型间的耦合：</p>
<p>序列化组件依赖所有文档类型，但文档类型彼此独立。新增<code>XML</code>类时，仅需在序列化组件中处理新类型，无需修改现有文档类。这种自下而上的依赖符合架构层级原则——低层组件可依赖高层组件，反之则不然。</p>
<hr>
<p><strong>编译期扩展性</strong></p>
<p>扩展性设计同样适用于编译期多态。C++标准库通过以下方式实现扩展性：</p>
<p><strong>函数重载</strong>
<code>std::swap</code>允许为自定义类型特化交换逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">custom</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CustomType</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">CustomType</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">CustomType</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 定制实现 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用方式：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// 启用ADL查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>      <span class="c1">// 优先调用定制版本
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>模板与概念</strong>
标准算法（如<code>std::find</code>）通过模板参数接受自定义迭代器和谓词：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">InputIt</span> <span class="n">find</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryPredicate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">InputIt</span> <span class="n">find_if</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryPredicate</span> <span class="n">p</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>模板特化</strong>
<code>std::hash</code>允许为自定义类型特化哈希计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">CustomType</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">CustomType</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="cm">/* 定制哈希计算 */</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>避免过度设计</strong></p>
<p>尽管可扩展性至关重要，但需警惕<strong>过早抽象</strong>。遵循YAGNI（You Ain&rsquo;t Gonna Need It）原则：若不确定未来需求，优先保持简单。过度设计可能导致：</p>
<ul>
<li>不必要的复杂性</li>
<li>限制未来扩展方向（如偏重类型扩展却阻碍操作扩展）</li>
</ul>
<p><strong>平衡策略：</strong></p>
<ul>
<li>明确预期扩展点时，预先设计扩展接口</li>
<li>不确定时，通过重构逐步引入扩展机制</li>
</ul>
<hr>
<p><strong>准则5要点</strong></p>
<p>✅ <strong>提倡</strong></p>
<ul>
<li>采用开放-封闭原则（OCP），通过基类、模板、重载或特化支持扩展</li>
<li>识别预期扩展点并设计易扩展结构</li>
</ul>
<p>❌ <strong>避免</strong></p>
<ul>
<li>修改现有代码实现扩展（违反OCP）</li>
<li>不确定需求时的过度抽象</li>
</ul>
<p><strong>核心提示</strong>：
可扩展性是可持续软件的关键。通过分离关注点、合理使用多态与模板机制，构建适应演进的系统架构。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>优先设计便于扩展代码。</li>
<li>遵守开放封闭原则（OCP），使代码对扩展开放，但对修改关闭。</li>
<li>通过基类、模板、函数重载或模板特化来设计以支持代码添加。</li>
<li>如果你不确定下一个添加是什么，请避免过早抽象。</li>
</ul>
<h2 id="第二章-建立抽象的艺术">第二章 建立抽象的艺术
</h2><p><strong>抽象在软件设计与架构中的核心地位</strong></p>
<p>抽象是软件设计与架构的基石。优秀的抽象是管理复杂性的关键，没有它们，良好的设计与合理的架构将无从谈起。然而，构建并正确运用抽象绝非易事——这更像是一门艺术而非精确科学，充满了精妙权衡。本章将深入探讨抽象的本质及其构建之道。</p>
<hr>
<p><strong>准则6：遵循抽象的预期行为</strong></p>
<p>抽象的本质在于表达一组<strong>需求与契约</strong>。每个抽象背后都隐含了特定的行为承诺，遵循这些预期是维护系统一致性的关键。本准则将引入 <strong>里氏替换原则(LSP)</strong>，阐释为何子类必须完全遵循基类的行为契约。</p>
<p><strong>准则7：理解基类与概念的共性</strong></p>
<p>作为最常用的两种抽象机制，<strong>基类（继承)</strong> 与  <strong>概念(模板约束)</strong> 在语义层面具有深层相似性。二者都能定义行为规范，但实现方式迥异。本准则将对比二者的共性与差异，揭示抽象表达的普适规律。</p>
<p><strong>准则8：把握重载集合的语义契约</strong></p>
<p>函数重载构成第三种抽象形式。每个重载函数都需遵循<strong>重载集合的语义契约</strong>，其行为必须满足调用方的统一预期。本准则将扩展LSP原则，探讨重载机制中的行为一致性要求。</p>
<p><strong>准则9：关注抽象的所有权归属</strong></p>
<p>从架构视角看，抽象的<strong>所有权归属</strong>直接影响系统结构。本准则引入<strong>依赖倒置原则（DIP）</strong>，阐明如何通过抽象实现层级解耦。仅引入抽象并不足够——必须确保高层模块拥有抽象定义，低层实现依赖高层接口。</p>
<p><strong>准则10：构建架构设计文档</strong></p>
<p>架构设计文档是抽象体系的蓝图。本准则将探讨文档化的价值：明确抽象边界、记录设计决策、促进团队共识。即使采用轻量级形式，架构文档也能显著提升系统的可维护性与演进能力。</p>
<hr>
<p>抽象构建的艺术在于平衡表达力与约束力。通过这五大准则，我们将逐步掌握定义精确契约、管理依赖方向、实现可持续演进的实践方法。每一层精心设计的抽象，都是对抗软件熵增的坚实屏障。</p>
<hr>
<h3 id="准则6遵循抽象的预期行为">准则6：遵循抽象的预期行为
</h3><p>解耦软件的核心在于引入抽象，而构建良好的抽象却充满挑战。本节通过经典示例揭示抽象行为预期的重要性，并阐释 <strong>里氏替换原则(LSP)</strong> 的核心要义。</p>
<hr>
<p><strong>违反行为预期的典型案例</strong></p>
<p>考虑一个<code>Rectangle</code>基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Rectangle</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">getWidth</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">getHeight</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setWidth</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setHeight</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">getArea</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>作为基类，提供虚析构函数确保多态正确性</li>
<li>包含宽高属性和对应的访问/修改方法</li>
<li><code>setWidth</code>与<code>setHeight</code>可独立修改维度</li>
<li><code>getArea</code>返回宽高乘积</li>
</ul>
<p>派生类<code>Square</code>继承<code>Rectangle</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">setHeight</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">getArea</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>数学上正方形是矩形特例，但代码实现需保持宽高相等</li>
<li>重写<code>setWidth</code>和<code>setHeight</code>同步修改另一维度</li>
</ul>
<p><strong>问题爆发点</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">transform</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">&amp;</span> <span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rect</span><span class="p">.</span><span class="n">setWidth</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">    <span class="n">rect</span><span class="p">.</span><span class="n">setHeight</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">==</span> <span class="mi">28</span><span class="p">);</span> <span class="c1">// 断言失败！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Square</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">setWidth</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">transform</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// 传入正方形实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>transform</code>函数预期独立修改宽高后面积为28</li>
<li>传入<code>Square</code>时，两次set调用强制同步宽高，导致面积计算错误</li>
</ul>
<hr>
<p><strong>里氏替换原则（LSP）详解</strong></p>
<p>LSP要求子类必须完全遵守基类的<strong>行为契约</strong>，具体体现为：</p>
<ol>
<li>
<p><strong>前置条件不可强化</strong>
子类方法不能施加比基类更严格的输入约束</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 基类接受i&gt;0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">virtual</span> <span class="kt">void</span> <span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 错误：子类要求i&gt;10，违反LSP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Derived</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>后置条件不可弱化</strong>
子类方法需满足基类承诺的输出保证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 基类保证返回正值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">virtual</span> <span class="kt">int</span> <span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="n">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 错误：子类可能返回任意值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">Derived</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">...</span> <span class="cm">/* 无约束 */</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>返回类型协变(Covariant)</strong>
子类方法可返回 基类返回类型 的派生类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="n">Base</span><span class="o">*</span> <span class="n">Base</span><span class="o">::</span><span class="n">create</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Derived</span><span class="o">*</span> <span class="n">Derived</span><span class="o">::</span><span class="n">create</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 合法协变
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>参数类型逆变(Contravariant)</strong>
子类方法应接受基类参数的超类型（C++语法不支持）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="n">Base</span><span class="o">::</span><span class="n">process</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 理想情况：参数可为Base*，但C++不允许
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Derived</span><span class="o">::</span><span class="n">process</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>保持不变量(Invariants)</strong>
子类必须维护基类定义的状态约束</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span> <span class="c1">// 不变量：1 &lt;= value_ &lt;= 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="n">value_</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 破坏不变量！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<hr>
<p><strong>对LSP的常见误解与误用</strong></p>
<ul>
<li>
<p><strong>数学IS-A ≠ 编程IS-A</strong>
尽管几何学中正方形属于矩形，但代码中的行为契约破坏使继承关系失效</p>
</li>
<li>
<p><strong>动态类型检查是设计异味</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 特殊处理Derived类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 常规处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种针对具体子类的特殊处理，暴露抽象泄露，应视为严重设计缺陷</p>
</li>
</ul>
<hr>
<p><strong>构建可靠抽象的关键</strong></p>
<ol>
<li><strong>明确契约</strong>
通过代码注释、断言或契约编程框架（如C++20 Contracts）显式定义前置/后置条件</li>
<li><strong>封装不变性</strong>
避免protected数据成员，通过接口强制约束状态有效性（遵循核心准则C.133）</li>
<li><strong>谨慎使用继承</strong>
优先组合优于继承，仅在严格满足LSP时建立继承层次</li>
<li><strong>文档化预期</strong>
参考C++标准库对迭代器概念的规范，清晰描述抽象的行为要求</li>
</ol>
<p><strong>准则6要点</strong>
✅ <strong>遵循</strong></p>
<ul>
<li>将抽象视为行为契约集合</li>
<li>通过LSP确保子类无缝替换基类</li>
<li>显式定义并验证前置/后置条件</li>
</ul>
<p>❌ <strong>避免</strong></p>
<ul>
<li>基于数学直觉盲目建立继承</li>
<li>在子类中弱化后置条件或强化前置条件</li>
<li>通过运行时类型检查规避LSP</li>
</ul>
<p><strong>设计启示</strong>：
抽象是软件工程的基石，而LSP是确保抽象可靠性的核心机制。每一次继承决策都应伴随对行为契约的严格验证，唯有如此，才能构建出经得起演进的软件系统。</p>
<h3 id="准则7理解基类与概念的深层共性">准则7：理解基类与概念的深层共性
</h3><p>在准则6中，我们聚焦于继承体系的行为契约，但里氏替换原则（LSP）的适用范围远不止于此。</p>
<p>本节将揭示 <strong>动态多态(基类)</strong>  与  <strong>静态多态(概念)</strong> 在抽象语义上的本质统一。</p>
<hr>
<p><strong>动态与静态抽象的语义对等性</strong></p>
<p>对比两个代码片段：</p>
<p><strong>片段1：基于继承的动态多态</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">useDocument</span><span class="p">(</span><span class="k">const</span> <span class="n">Document</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">doc</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">();</span>  <span class="c1">// 依赖基类接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>片段2：基于概念的静态多态</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">Document</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">ByteStream</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">Document</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">useDocument</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">doc</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">();</span>  <span class="c1">// 依赖概念约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>关键洞察</strong>：
两段代码均要求<code>doc</code>对象满足<code>exportToJSON</code>和<code>serialize</code>的行为契约。无论通过虚函数还是模板概念，抽象的核心在于<strong>定义预期行为集合</strong>。基类与概念在此层面实现语义等价。</p>
<hr>
<p><strong>C++概念的LSP实践</strong></p>
<p>以标准库<code>std::copy</code>算法为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OutputIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">OutputIt</span> <span class="n">copy</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">d_first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">d_first</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">d_first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>InputIt</code>与<code>OutputIt</code>虽非C++20概念，但通过命名模板参数隐含行为契约：
<ul>
<li><code>InputIt</code>需支持递增、解引用及终止条件判断</li>
<li><code>OutputIt</code>需支持解引用赋值与递增</li>
</ul>
</li>
<li>任何不满足这些隐式契约的迭代器类型将导致算法失效，构成对LSP的违反</li>
</ul>
<p><strong>C++20概念的演进</strong>：
标准库通过分层概念精确定义迭代器要求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">input_or_output_iterator</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">input_iterator</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">    <span class="n">input_or_output_iterator</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="cm">/* 细化要求 */</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">forward_iterator</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">    <span class="n">input_iterator</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="cm">/* 新增前向迭代特性 */</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种分层设计践行接口隔离原则（ISP），允许按需组合抽象约束。</p>
<hr>
<p><strong>概念作为静态抽象的语义载体</strong></p>
<p>尽管C++20概念无法在语法层面强制语义，但仍通过以下方式表达预期行为：</p>
<ol>
<li><strong>操作可行性</strong>：通过<code>requires</code>子句规定必须存在的成员函数/操作符</li>
<li><strong>行为约定</strong>：依赖命名约定（如<code>InputIt</code>暗示输入迭代器语义）</li>
<li><strong>文档化契约</strong>：标准规范明确概念的行为预期（如迭代器有效性保证）</li>
</ol>
<p><strong>示例：自定义概念</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">Renderable</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">RenderTarget</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">obj</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 语法约束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 隐含语义：render()应将对象绘制到target且无副作用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用方代码可安全假定所有<code>Renderable</code>类型遵循此契约。</p>
<hr>
<p><strong>设计启示</strong></p>
<ol>
<li><strong>统一设计原则</strong>
LSP适用于所有抽象形式，无论动态（虚函数）还是静态（模板/概念）。子类或模板参数必须完全遵守抽象层的行为约定。</li>
<li><strong>概念即契约</strong>
将C++20概念及传统命名模板参数视为编译期接口规范。设计时应：
<ul>
<li>明确概念的最小化约束集合</li>
<li>通过分层组合构建复杂抽象（如迭代器体系）</li>
<li>在文档中详述语义预期</li>
</ul>
</li>
<li><strong>静态多态的优势</strong>
相比继承体系，概念提供：
<ul>
<li>零运行时开销</li>
<li>更强的类型安全性</li>
<li>对值语义的原生支持</li>
</ul>
</li>
</ol>
<p><strong>准则7要点</strong>
✅ <strong>实践建议</strong></p>
<ul>
<li>将LSP原则同步应用于动态与静态多态设计</li>
<li>使用C++20概念或命名模板参数定义编译期抽象</li>
<li>为每个概念编写清晰的行为契约文档</li>
</ul>
<p>❌ <strong>规避陷阱</strong></p>
<ul>
<li>在模板代码中忽略语义约束（如假定<code>operator++</code>必然前进）</li>
<li>创建&quot;巨无霸&quot;概念（违反接口隔离原则）</li>
</ul>
<p><strong>核心思维</strong>：
抽象的本质是行为契约的具象化。无论是运行时通过虚函数分发，还是编译期通过概念约束，对契约的忠诚度决定系统的健壮性。领悟这一共性，方能游刃于多范式设计之间。</p>
<h3 id="准则8理解重载集合的语义要求">准则8：理解重载集合的语义要求
</h3><p>在准则6中，我们强调抽象层的行为契约重要性。</p>
<p>本节将揭示<strong>函数重载</strong>这一编译时抽象机制如何承载语义要求，以及违反这些要求可能引发的设计风险。</p>
<hr>
<p><strong>自由函数的抽象力量</strong></p>
<p>以标准库的<code>begin()</code>/<code>end()</code>为例，<strong>非成员函数重载</strong>展现出独特的优势：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Range</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">traverseRange</span><span class="p">(</span><span class="k">const</span> <span class="n">Range</span><span class="o">&amp;</span> <span class="n">range</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span>  <span class="c1">// 启用ADL的参数依赖查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">range</span><span class="p">);</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">range</span><span class="p">);</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>非侵入式扩展</strong>：无需修改容器类即可为内置数组添加迭代支持</li>
<li><strong>开放封闭原则</strong>：通过新增自由函数扩展功能，无需改动现有代码</li>
<li><strong>通用性提升</strong>：支持所有提供<code>begin</code>/<code>end</code>重载的类型（包括第三方库）</li>
</ul>
<p><strong>对比成员函数局限</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 传统成员函数实现（仅支持特定容器）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">traverseMember</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>无法处理内置数组或自定义容器类型</li>
<li>违反开放封闭原则，新增容器需修改遍历逻辑</li>
</ul>
<hr>
<p><strong>重载集合的隐式契约</strong></p>
<p>以<code>swap</code>函数为例，不当实现将引发灾难：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 错误：仅交换部分成员变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// 忽略j的交换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用方代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="n">x</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">22</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 预期：x=(2,22), y=(1,11)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 实际：x=(2,11), y=(1,22) → 违反行为契约！
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>语义预期</strong>：<code>swap</code>应交换对象<strong>全部可观察状态</strong></li>
<li><strong>违反后果</strong>：调用方无法正确推理程序行为，导致隐蔽缺陷</li>
</ul>
<hr>
<p><strong>重载命名的核心准则</strong></p>
<ol>
<li>
<p><strong>语义一致性原则</strong></p>
<ul>
<li>
<p><strong>C.162</strong>：对语义等价的操作进行重载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 正确：提供多种构造方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">File</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">File</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">File</span><span class="p">(</span><span class="n">FILE</span><span class="o">*</span> <span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>C.163</strong>：避免对语义不同的操作使用相同名称</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 错误：find可能暗示线性搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Range</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">binary_find</span><span class="p">(</span><span class="n">Range</span><span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>  <span class="c1">// 应命名为binary_search
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p><strong>标准库命名约定</strong></p>
<ul>
<li><code>begin()</code>/<code>end()</code>必须返回可遍历的迭代器对</li>
<li><code>size()</code>应返回元素数量，而非字节大小</li>
<li><code>find()</code>默认表示线性查找，有序查找需使用<code>lower_bound</code>等</li>
</ul>
</li>
</ol>
<hr>
<p><strong>重载设计的实践要点</strong></p>
<p>✅ <strong>正确实践</strong></p>
<ul>
<li>遵守现有重载集合的语义约定（如<code>std::swap</code>的全状态交换）</li>
<li>通过ADL实现非侵入式扩展</li>
<li>为自定义类型提供标准接口重载（如<code>begin</code>/<code>end</code>支持范围for循环）</li>
</ul>
<p>❌ <strong>规避陷阱</strong></p>
<ul>
<li>在重载函数中实现与命名不符的行为（如<code>sort</code>不保证稳定性）</li>
<li>忽略参数依赖查找（ADL）导致自定义类型无法被通用算法识别</li>
<li>滥用重载导致接口语义模糊（如<code>process()</code>既处理数据又管理资源）</li>
</ul>
<hr>
<p><strong>本节总结</strong></p>
<ul>
<li>函数重载是编译时多态的重要形式，承载隐式行为契约</li>
<li>重载命名必须传递准确语义，遵循既有约定</li>
<li>任何对重载集合的扩展都需严格遵循LSP原则</li>
<li>自由函数重载是实现开放封闭原则的利器，但需谨慎维护语义一致性</li>
</ul>
<h3 id="准则9关注抽象的所有权归属">准则9：关注抽象的所有权归属
</h3><p>在软件架构中，抽象的<strong>所有权归属</strong>直接影响系统依赖方向。本节通过经典案例揭示 <strong>依赖倒置原则(DIP)</strong> 的核心实践：通过高层掌控抽象定义，实现架构级解耦。</p>
<hr>
<p><strong>依赖倒置原则（DIP）精要</strong></p>
<p><strong>核心主张</strong>：</p>
<ol>
<li><strong>高层模块不应依赖低层模块</strong>，两者都应依赖抽象</li>
<li><strong>抽象不应依赖细节</strong>，细节应依赖抽象</li>
</ol>
<p><strong>ATM系统反例剖析</strong>：</p>
<ul>
<li><strong>问题</strong>：存款、取款、转账等交易类直接调用<code>UI</code>类的具体方法（如<code>requestDepositAmount()</code>）</li>
<li><strong>后果</strong>：新增VIP快速转账功能需修改<code>UI</code>类，导致所有交易类重新编译，违反开放封闭原则</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ol>
<li>为每个交易定义专属接口（如<code>DepositUI</code>）</li>
<li>将接口声明置于<strong>高层模块</strong>（交易逻辑层）</li>
<li>具体<code>UI</code>实现继承高层接口，形成自下而上的依赖</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;高层/DepositUI.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">DepositUI</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">requestAmount</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">confirm</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;低层/ConsoleUI.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;高层/DepositUI.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">ConsoleDepositUI</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DepositUI</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">requestAmount</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* 控制台输入逻辑 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">confirm</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* 确认提示 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>插件架构的正向设计</strong></p>
<p><strong>错误模式</strong>：</p>
<ul>
<li>编辑器<code>Editor</code>直接引用<code>VimModePlugin</code>类</li>
<li><strong>缺陷</strong>：每新增插件需修改编辑器代码，无法扩展</li>
</ul>
<p><strong>正确实践</strong>：</p>
<p><strong>高层定义插件接口</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;编辑器/Plugin.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Plugin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">activate</span><span class="p">(</span><span class="n">Editor</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">deactivate</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>低层实现具体插件</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;第三方/VimModePlugin.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;编辑器/Plugin.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">VimModePlugin</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Plugin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">activate</span><span class="p">(</span><span class="n">Editor</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* Vim模式激活逻辑 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">deactivate</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* 清理资源 */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>编辑器仅依赖抽象接口</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;编辑器/Editor.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Plugin.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Editor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Plugin</span><span class="o">*&gt;</span> <span class="n">plugins</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">addPlugin</span><span class="p">(</span><span class="n">Plugin</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">plugins</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><strong>模板与重载的依赖倒置</strong></p>
<p><strong>STL算法范例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OutputIt</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">copy</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">OutputIt</span> <span class="n">d_first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="o">*</span><span class="n">d_first</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>倒置逻辑</strong>：算法定义<code>InputIt</code>/<code>OutputIt</code>概念（高层约束），容器迭代器（低层）需满足这些概念</li>
<li><strong>依赖方向</strong>：容器实现依赖STL算法定义的标准，而非反之</li>
</ul>
<p><strong>swap重载实现</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="n">T</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Widget</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">);</span> <span class="c1">// 依赖类型T的swap实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>契约传递</strong>：<code>Widget</code>的swap行为依赖<code>T</code>类型的swap实现，所有相关方遵循同一套交换语义</li>
</ul>
<hr>
<p><strong>设计启示</strong></p>
<p>✅ <strong>正确实践</strong></p>
<ul>
<li>将关键抽象接口置于架构高层（如核心业务模块）</li>
<li>低层模块通过实现高层接口建立依赖</li>
<li>使用模板约束时，在高层定义概念要求</li>
</ul>
<p>❌ <strong>规避陷阱</strong></p>
<ul>
<li>让具体实现模块定义抽象接口（导致反向依赖）</li>
<li>在低层模块间共享抽象接口（引发横向耦合）</li>
</ul>
<p><strong>核心公式</strong>：
<strong>抽象所有权 == 架构控制权</strong>
掌握抽象定义权，方能掌控依赖方向，构建可持续演进的系统架构。</p>
<h3 id="准则10建议创建架构设计文档">准则10：建议创建架构设计文档
</h3><p>让我们聊聊你的软件架构。</p>
<p>先问一个简单的问题：<strong>你是否有架构设计文档</strong>？这份文档是否清晰描述了系统核心模块、架构层级及依赖关系？</p>
<p>如果你的回答是肯定的，请跳过本准则。</p>
<p>若答案是否定的，请继续思考以下问题：你是否建立了持续集成（CI）环境？是否使用自动化测试？是否应用静态代码分析工具？如果这些都已实现，说明你的工程基础良好，但为何独缺架构文档？</p>
<p>&ldquo;何必小题大做？没有架构文档天又不会塌！我们采用敏捷开发，随时可以调整！&quot;——若这是你的心声，请容我指出一个常见的认知误区，敏捷方法的本质是快速获取反馈 <strong>，而非纵容无序修改。持续集成、测试驱动开发等技术实践确实能快速暴露问题，但架构质量决定了修改的难易程度</strong> 。</p>
<p>优秀的架构设计如同精密的城市管网系统，能让变更如同更换路灯般从容，而非动辄&quot;开膛破肚&rdquo;。</p>
<p><strong>架构文档的核心价值</strong></p>
<p>软件大师Ralph Johnson的洞见揭示了架构的本质：</p>
<blockquote>
<p>成功的软件项目中，核心开发者对系统设计有着共同认知，这种共识即架构。</p>
</blockquote>
<p>试想这样的场景：</p>
<ul>
<li>团队新成员是否准确理解现有架构？</li>
<li>资深工程师离职是否导致架构智慧流失？</li>
<li>各模块负责人是否对系统演进方向达成共识？</li>
</ul>
<p>没有书面化的架构文档，这些问题的答案往往令人不安，就像建筑工地没有设计蓝图，不同工种的工人对&quot;左侧车库&quot;的理解可能南辕北辙。</p>
<p>架构文档正是团队的&quot;认知锚点&quot;，确保所有人朝着同一目标前进。</p>
<p><strong>架构文档的实践智慧</strong></p>
<p><strong>破除两大迷思</strong>：</p>
<ol>
<li><strong>文档必然过时</strong>
聚焦宏观设计而非实现细节：记录模块划分、通信机制、关键技术选型等稳定要素，避免陷入API参数之类的易变细节。就像城市地图无需标注每间商铺，但必须清晰展现主干道和功能区。</li>
<li><strong>编写成本高昂</strong>
采用渐进式构建：
<ul>
<li><strong>初始阶段</strong>：用1页图文描述核心模块与数据流向</li>
<li><strong>迭代过程</strong>：通过架构评审会议逐步补充设计决策</li>
<li><strong>维护策略</strong>：每双周由技术负责人同步更新关键变更</li>
</ul>
</li>
</ol>
<p><strong>示例：微服务架构文档框架</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl"># 系统架构概览
</span></span><span class="line"><span class="cl">## 核心服务
</span></span><span class="line"><span class="cl">- 订单服务：处理交易生命周期（领域驱动设计）
</span></span><span class="line"><span class="cl">- 库存服务：采用事件溯源模式管理库存
</span></span><span class="line"><span class="cl">- 支付服务：通过适配器模式集成第三方支付网关
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">## 通信机制
</span></span><span class="line"><span class="cl">![架构拓扑图]
</span></span><span class="line"><span class="cl">- 服务间通信：gRPC（proto3协议）
</span></span><span class="line"><span class="cl">- 事件总线：Kafka集群（分区策略：订单ID哈希）
</span></span><span class="line"><span class="cl">- 缓存层：Redis哨兵模式（缓存穿透防护策略）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">## 关键技术决策
</span></span><span class="line"><span class="cl">- 数据库选型：
</span></span><span class="line"><span class="cl">  - 订单服务：PostgreSQL（ACID事务需求）
</span></span><span class="line"><span class="cl">  - 商品服务：MongoDB（灵活Schema支持）
</span></span><span class="line"><span class="cl">- 部署架构：
</span></span><span class="line"><span class="cl">  - K8s多可用区部署
</span></span><span class="line"><span class="cl">  - 服务网格使用Istio实现金丝雀发布
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>文档即资产</strong></p>
<p>优秀架构文档如同保险箱中的地契：</p>
<ul>
<li><strong>知识传承</strong>：新成员通过文档快速建立系统全景认知</li>
<li><strong>决策溯源</strong>：记录技术选型的权衡过程（如选择REST而非GraphQL的原因）</li>
<li><strong>质量护栏</strong>：结合ArchUnit等工具自动化验证架构约束</li>
</ul>
<p><strong>实施建议</strong>：</p>
<ol>
<li><strong>可视化工具</strong>：使用C4模型或UML绘制架构图</li>
<li><strong>版本化管理</strong>：将文档纳入代码仓库，与实现同步演进</li>
<li><strong>活文档机制</strong>：在关键模块添加架构守护测试</li>
</ol>
<hr>
<p><strong>准则10要点</strong>
✅ <strong>价值认知</strong></p>
<ul>
<li>架构文档是团队的技术宪法，维护认知一致性</li>
<li>避免&quot;口口相传&quot;导致的知识衰减</li>
<li>为系统演进提供可靠基线</li>
</ul>
<p>❌ <strong>规避误区</strong></p>
<ul>
<li>将架构文档等同于API文档</li>
<li>因追求完美而延迟文档化</li>
<li>允许文档与实现长期偏离</li>
</ul>
<p><strong>终极启示</strong>：
架构文档不是敏捷的对立面，而是工程专业性的体现。它如同航海图，让团队在快速迭代的惊涛骇浪中保持航向，让每次架构演进都成为精心策划的升级，而非慌不择路的逃亡。</p>
<h2 id="第三章-设计模式的核心价值">第三章 设计模式的核心价值
</h2><p>访问者（Visitor）、策略（Strategy）、装饰器（Decorator）——这些设计模式将在后续章节深入探讨。但在逐一解析之前，我们需先理解设计模式的本质意义。本章将揭示设计模式的核心特征、应用价值及其普遍存在性。</p>
<hr>
<p><strong>准则11：理解设计模式的根本目的</strong></p>
<p>在&quot;准则1：认识软件设计的重要性&quot;中，我们已提及设计模式的作用层级。设计模式的本质在于：</p>
<ol>
<li><strong>模式命名表达意图</strong>：如&quot;工厂模式&quot;直指对象创建逻辑的封装</li>
<li><strong>引入解耦抽象层</strong>：通过中间层隔离变化，降低模块间耦合</li>
<li><strong>久经考验的解决方案</strong>：经多年实践验证的通用问题应对策略</li>
</ol>
<p>例如，观察者模式（Observer）通过解耦发布者与订阅者，实现事件驱动的松耦合架构。</p>
<hr>
<p><strong>准则12：警惕设计模式认知误区</strong></p>
<p>破除常见误解：</p>
<ul>
<li>
<p>❌ <strong>非实现细节</strong>：设计模式是架构层面的蓝图，而非具体代码模板</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 错误认知：策略模式必须用虚函数实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Strategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 正确实践：策略可以是函数指针、模板参数等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Strategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Context</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Strategy</span> <span class="n">strategy_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span> <span class="n">strategy_</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>❌ <strong>不限于OOP</strong>：函数式编程中同样存在模式（如闭包实现状态模式）</p>
</li>
<li>
<p>❌ <strong>非语言特性</strong>：模式解决的是通用设计问题，与语言语法无关</p>
</li>
</ul>
<hr>
<p><strong>准则13：设计模式无处不在</strong></p>
<p>C++标准库中的模式应用实例：</p>
<ol>
<li>
<p><strong>迭代器模式（Iterator）</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>适配器模式（Adapter）</strong>
<code>std::stack</code>基于<code>deque/list</code>实现栈接口</p>
</li>
<li>
<p><strong>组合模式（Composite）</strong>
<code>std::filesystem::path</code>统一处理文件与目录路径</p>
</li>
</ol>
<hr>
<p><strong>准则14：以模式名称传递设计意图</strong></p>
<p>在代码中显式使用模式命名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 明确声明使用工厂模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">WidgetFactory</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过类型名传达访问者模式应用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">ElementVisitor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">ConcreteElement</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>优势：</p>
<ul>
<li>提升代码自解释性</li>
<li>促进团队设计共识</li>
<li>方便架构评审与重构</li>
</ul>
<hr>
<p><strong>设计模式的终极价值</strong></p>
<p>设计模式是软件工程的经验结晶，其核心价值在于：</p>
<ul>
<li><strong>提供设计词汇表</strong>：如&quot;采用观察者模式处理事件通知&quot;</li>
<li><strong>封装变化维度</strong>：将易变部分隔离在模式抽象层后</li>
<li><strong>促进架构演进</strong>：通过模式组合应对需求变化</li>
</ul>
<p>理解模式本质，方能超越形式模仿，实现灵活优雅的架构设计。接下来的章节将深入解析各模式在现代C++中的实践应用。</p>
<h3 id="准则-11理解设计模式的核心价值">准则 11：理解设计模式的核心价值
</h3><p>有很大可能您之前听说过设计模式，并且在您的编程职业生涯中很有可能使用过其中的一些。</p>
<p>设计模式并不是新事物：它们至少自“四人组”（Gang of Four，简称GoF）在1994年发布他们的设计模式书籍以来就存在了。</p>
<p>尽管一直有批评者，但设计模式的特殊价值在整个软件行业中得到了广泛认可。</p>
<p>然而，尽管设计模式已经存在很长时间并且非常重要，尽管积累了大量的知识和智慧，在C++社区中仍然存在许多关于设计模式的误解。</p>
<p>要有效地使用设计模式，第一步需要理解什么是设计模式。设计模式具有以下特征：</p>
<ul>
<li><strong>有一个名称</strong>：每个设计模式都有一个明确的名称，这有助于开发人员快速识别和讨论该模式。</li>
<li><strong>带有意图</strong>：设计模式不仅仅是解决某个问题的技术手段，它还传达了一个特定的设计意图或目标。<br/>例如，单例模式的意图是确保一个类只有一个实例，并提供一个全局访问点。</li>
<li><strong>引入一个抽象</strong>：设计模式通过定义接口、基类或其他形式的抽象来解决问题。<br/>这种抽象使得代码更加灵活和可扩展，能够适应未来的变化。</li>
<li><strong>经过验证</strong>：设计模式不是凭空想象出来的，而是基于实际项目中的经验和最佳实践发展而来的。<br/>它们已经被证明在多种场景下有效，并且可以在不同的项目中复用。</li>
</ul>
<p><strong>设计模式有一个名称</strong></p>
<p>首先，设计模式有一个名称。虽然这听起来非常显而易见且必要，但确实是设计模式的一个基本属性。</p>
<p>假设我们两个人在一个项目上合作，并被分配解决一个问题。</p>
<p>想象一下，如果我对您说：“我会用一个Visitor来解决这个问题。” 这不仅告诉了您我理解的实际问题是什么，还给您提供了一个关于我提出的解决方案的精确概念。</p>
<p>设计模式的名称使我们能够在非常高的层次上进行沟通，并用极少的词汇传达大量信息：</p>
<p><strong>我</strong>：我会用一个Visitor来解决这个问题。<br/>
<strong>你</strong>：我不确定。我考虑使用一个Strategy。<br/>
<strong>我</strong>：是的，您可能有道理。但是由于我们需要频繁扩展操作，我们可能还需要考虑使用一个Decorator。</p>
<p>通过仅仅使用Visitor、Strategy和Decorator这些名称，我们就讨论了代码库的演变，并描述了我们期望在未来几年内如何扩展和变化。</p>
<p>如果没有这些名称，我们将很难表达我们的想法：</p>
<p><strong>我</strong>：我认为我们应该创建一个系统，允许我们在不反复修改现有类型的情况下扩展操作。<br/>
<strong>你</strong>：我不确定。与其增加新的操作，我预计会频繁添加新的类型。<br/>因此，我更倾向于一种允许我轻松添加类型的解决方案，为了减少与实现细节的耦合（这是可以预期的），我建议引入一个变体点来提取现有类型的实现细节。<br/>
<strong>我</strong>：是的，您可能有道理。但是由于我们需要频繁扩展操作，我们可能需要设计系统，以便能够轻松构建和重用给定的实现。<br/></p>
<p>看到区别了吗？感觉到区别了吗？没有名称，我们必须明确地讨论更多的细节。</p>
<p>显然，这种精确的沟通只有在我们对设计模式有相同的理解时才可能实现。<br/>这就是为什么了解设计模式并讨论它们如此重要的原因。</p>
<p><strong>设计模式带有意图</strong></p>
<p>通过使用设计模式的名称，您可以简洁地表达您的意图，并限制可能的误解。</p>
<p>这引出了设计模式的第二个属性：意图。设计模式的名称传达了它的意图。</p>
<p>如果您使用设计模式的名称，您隐含地表达了您认为的问题以及您所看到的解决方案，</p>
<p>希望您已经意识到，在我们简短的对话中，我们并没有讨论任何具体的实现，我们没有谈论实现细节、任何特性或任何特定的C++标准，我们甚至没有讨论任何特定的编程语言，请不要假设通过给您一个设计模式的名称，我就隐含地告诉了您如何实现解决方案，这不是设计模式的目的。</p>
<p>相反，名称应该告诉您我提议的结构、我计划如何管理依赖关系以及我对系统演化的期望，这就是意图。</p>
<p>实际上，许多设计模式具有类似的结构，在GoF（四人组）的书中，许多设计模式看起来非常相似，这当然会引起很多困惑和问题。</p>
<p>例如，从结构上看，Strategy（策略）、Command（命令）和Bridge（桥接）设计模式几乎没有什么区别。</p>
<p>然而，它们的意图非常不同，因此您会用它们来解决不同的问题。</p>
<p>正如您将在接下来的章节中的各种示例中看到的那样，几乎总是有多种不同的实现可以选择。</p>
<p><strong>设计模式引入抽象</strong></p>
<p>设计模式总是通过引入某种形式的抽象来减少依赖，这意味着设计模式始终关注于管理软件实体之间的交互和解耦软件的不同部分。</p>
<p>例如，考虑GoF（四人组）最初的设计模式之一 <strong>策略设计模式 （Strategy）</strong></p>
<p>不深入细节，策略设计模式通过引入一个名为“Strategy”的基类来提供抽象。<br/>这个基类将策略用户（架构高层中的Context类）与具体策略的实现细节（架构低层中的ConcreteStrategyA和ConcreteStrategyB）解耦。</p>
<p>因此，策略模式符合设计模式的特性。</p>
<p>另一个类似的例子是 <strong>工厂方法设计模式</strong>，工厂方法的意图是解耦对象创建的具体产品。</p>
<p>为此，它引入了两个抽象：Product和Creator基类，这些基类在架构的高层中存在，具体的实现细节由<strong>ConcreteProduct</strong> 和 <strong>ConcreteCreator</strong>类提供，它们位于架构的低层。</p>
<p>通过这种架构结构，工厂方法也符合设计模式的标准：它有一个名称、解耦的意图，并且引入了抽象。</p>
<p>需要注意的是，设计模式引入的抽象并不一定是通过基类实现的，正如我在接下来的部分和章节中会展示的那样，抽象可以通过多种方式引入，例如通过模板或简单的函数重载。</p>
<p>再次强调，设计模式并不暗示任何特定的实现。</p>
<p>作为反例，让我们考虑一下<code>std::make_unique()</code>函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在C++社区中，我们经常谈论<code>std::make_unique()</code>函数作为一个工厂函数，重要的是要注意，尽管术语“工厂函数”给人一种<code>std::make_unique()</code>是工厂方法设计模式的一个例子的印象，但这种印象是错误的。</p>
<p>设计模式通过引入抽象来帮助您解耦，这允许您自定义并推迟实现细节。</p>
<p>特别是，工厂方法设计模式的意图是为对象实例化引入一个自定义点，<br/><code>std::make_unique()</code>并没有提供这样的自定义点，如果您使用<code>std::make_unique()</code>，你知道你会得到一个指向你请求类型的<code>std::unique_ptr</code>，并且实例将通过<code>new</code>生成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 这将通过调用 &#39;new&#39; 创建一个 &#39;Widget&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span> <span class="cm">/* 一些 Widget 参数 */</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于<code>std::make_unique()</code>没有为您提供任何自定义行为的方式，它无法帮助减少实体之间的耦合，因此不能满足设计模式的目的。</p>
<p>然而，<code>std::make_unique()</code>是针对特定问题的一种常见解决方案，换句话说，它是一种模式，但它不是设计模式，而是实现模式。</p>
<p>它是封装实现细节（在这种情况下，生成一个Widget实例）的流行解决方案，但它并未从您获得的内容或如何创建它进行抽象。</p>
<p>因此，它属于实现细节级别，而不是软件设计级别。</p>
<p>抽象的引入是解耦软件实体、设计变更和扩展的关键，<br/><code>std::make_unique()</code>函数模板中没有任何抽象，因此您无法扩展其功能（甚至无法正确地重载或特化）。</p>
<p>相比之下，工厂方法设计模式确实提供了关于创建什么以及如何创建（包括实例化前后的行为）的抽象。<br/>由于这种抽象，你可以在以后编写新的工厂，而无需更改现有代码。</p>
<p>因此，设计模式帮助你解耦和扩展你的软件，而<code>std::make_unique()</code>只是一个实现模式。</p>
<p><strong>设计模式已被证明有效</strong></p>
<p>最后但同样重要的是，设计模式经过多年验证，四人组（Gang of Four）并没有收集所有可能的解决方案，</p>
<p>只有那些在不同代码库中常用以解决相同问题的方案（尽管实现可能有所不同），</p>
<p>因此，一个解决方案必须多次证明其价值，才能被视为一种模式。</p>
<p><strong>总结一下</strong>：设计模式是一种经过验证、有名称的解决方案，它表达了一个非常具体的意图。</p>
<p>它引入某种形式的抽象，有助于解耦软件实体，从而帮助管理这些实体之间的交互，正如我们应该使用“设计”一词来表示管理和解耦依赖关系的艺术（参见“准则1：理解软件设计的重要性”），我们也应该准确且有目的地使用“设计模式”这一术语。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>理解设计模式是经过验证的、有名称的解决方案，其意图是解耦。</li>
<li>认识到设计模式引入某种形式的抽象。</li>
<li>记住设计模式的目标是软件设计，即帮助管理依赖关系。</li>
<li>注意区分设计模式和实现模式。</li>
</ul>
<h3 id="准则12警惕设计模式的误解">准则12：警惕设计模式的误解
</h3><p>上一节重点解释了设计模式的目的：名称、意图和某种形式的抽象相结合，以解耦软件实体。然而，正如理解什么是设计模式很重要一样，理解什么不是设计模式也同样重要。不幸的是，关于设计模式存在一些常见的误解：</p>
<ul>
<li>有些人认为设计模式是一种目标，并且是实现良好软件质量的保证。</li>
<li>有些人认为设计模式基于特定的实现，因此是特定语言的习惯用法。</li>
<li>有些人说设计模式仅限于面向对象编程和动态多态性。</li>
<li>有些人认为设计模式已经过时甚至被淘汰。</li>
</ul>
<p>这些误解并不令人惊讶，因为我们很少谈论设计，而是更多地关注功能和语言机制（参见“准则1：理解软件设计的重要性”）。因此，在本准则中，我将澄清前三种误解，并在下一节中处理第四种误解。</p>
<p><strong>设计模式不是目标</strong></p>
<p>一些开发者非常喜欢设计模式，他们对设计模式如此着迷，以至于试图通过设计模式解决所有问题，无论是否合理。</p>
<p>当然，这种思维方式可能会增加代码的复杂性并降低其可理解性，这最终可能适得其反。</p>
<p>因此，过度使用设计模式可能导致其他开发者的挫败感，损害设计模式的整体声誉，甚至导致对模式概念的拒绝。</p>
<p>明确地说：设计模式不是目标，它们是实现目标的手段，它们可能是解决方案的一部分，但它们不是目标。</p>
<p>正如Venkat Subramaniam所说：如果你早上起床时想着 “今天我会用哪种设计模式？”，那么这是一个明显的信号，表明你误解了设计模式的目的，没有奖励或奖章是因为使用尽可能多的设计模式。</p>
<p>设计模式的使用不应该增加复杂性，而应该相反，减少复杂性，代码应该变得更简单、更易理解，并且更容易更改和维护，因为设计模式应该帮助解决依赖关系并创建更好的结构。</p>
<p>如果使用设计模式导致更高的复杂性并给其他开发者带来问题，那显然不是正确的解决方案。</p>
<p>为了澄清：我不是告诉你不要使用设计模式，我只是告诉你不要过度使用它们，就像我也会告诉你不要过度使用任何其他工具一样。</p>
<p>这总是取决于具体的问题，例如，锤子是一个很好的工具，只要你的问题是钉子，一旦你的问题变成了螺丝，锤子就变成了一种不太优雅的工具，要正确使用设计模式，了解何时使用它们以及何时不使用它们，掌握它们的意图和结构特性，并明智地应用它们是非常重要的。</p>
<p><strong>设计模式不关乎实现细节</strong></p>
<p>关于设计模式最常见的误解之一是它们基于特定的实现，这包括认为设计模式或多或少是特定语言的习惯用法。</p>
<p>这种误解是可以理解的，因为许多设计模式，特别是四人组（GoF）模式，通常在面向对象的环境中呈现，并通过面向对象的例子进行解释。</p>
<p>在这种背景下，很容易将实现细节误认为是特定模式，并假设两者是相同的。</p>
<p>幸运的是，也很容易证明设计模式并不关乎实现细节、任何特定的语言特性或任何C++标准。</p>
<p>让我们看看同一个设计模式的不同实现，是的，我们将从经典、面向对象的版本开始。</p>
<p>考虑以下场景：我们想要绘制一个给定的形状。代码片段通过一个圆来演示这一点，当然它也可以是任何其他形状，如正方形或三角形。为了绘制，Circle类提供了draw()成员函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">);</span>  <span class="c1">// 使用某种图形库实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在似乎很明显你需要实现<code>draw()</code>函数。未经进一步思考，你可能会通过常见的图形库（如OpenGL、Metal、Vulkan或其他图形库）来实现。</p>
<p>然而，如果<code>Circle</code>类自己实现了<code>draw()</code>功能，那将是一个大的设计缺陷：直接实现<code>draw()</code>函数会引入对所选图形库的强耦合。这会带来一些缺点：</p>
<ul>
<li>对于<code>Circle</code>的每一个可能应用，你总是需要图形库可用，即使你可能只对几何图元感兴趣而不是图形。</li>
<li>图形库的每一次更改都可能影响到<code>Circle</code>类，导致必要的修改、重新测试和重新部署等。</li>
<li>未来切换到另一个库将意味着一切都不再顺利。</li>
</ul>
<p>这些问题都有一个共同的根源：在<code>Circle</code>类中直接实现<code>draw()</code>函数违反了单一职责原则（SRP；参见“准则2：为变更而设计”），该类不再因单一原因而改变，并且强烈依赖于那个设计决策。</p>
<p>这个问题的经典面向对象解决方案是提取如何绘制圆的决策，并通过基类引入抽象，引入这样的变化点是策略设计模式的效果。</p>
<p><strong>应用于绘制圆的策略设计模式</strong></p>
<p>策略设计模式的意图是定义一组算法并将每个算法封装起来，从而使它们可以互换。</p>
<p>策略使算法独立于使用它的客户端而变化，通过引入<code>DrawStrategy</code>基类，使得轻松改变给定<code>Circle</code>的<code>draw()</code>实现成为可能。</p>
<p>这也使得每个人，而不仅仅是你自己，无需修改现有代码就能实现新的绘制行为，并从外部注入到<code>Circle</code>中。</p>
<p>这就是我们常说的依赖注入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;OpenGLStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建所需的圆的绘制策略。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">strategy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OpenGLStrategy</span><span class="o">&gt;</span><span class="p">(</span> <span class="cm">/* OpenGL 特定参数 */</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 将策略注入到圆中；圆不需要知道具体的策略类型，但可以通过 &#39;DrawStrategy&#39; 抽象愉快地使用它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Circle</span> <span class="n">circle</span><span class="p">(</span><span class="mf">4.2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">strategy</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">    <span class="n">circle</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种方法大大提高了不同绘制行为的灵活性：它分离了对特定库和其他实现细节的所有依赖，从而使代码更易于更改和扩展。</p>
<p>例如，现在很容易提供一个专门用于测试目的的实现（即<code>TestStrategy</code>）。</p>
<p>这表明改进的灵活性对设计的可测试性有非常积极的影响。</p>
<p>策略设计模式是经典的GoF设计模式之一。因此，它常被称为面向对象设计模式，并且通常被认为需要一个基类。</p>
<p>然而，策略的意图不限于面向对象编程。就像可以使用基类进行抽象一样，同样可以依赖模板参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DrawStrategy</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种形式下，决定如何绘制圆是在编译时发生的：不是编写一个基类<code>DrawStrategy</code>并在运行时传递一个指向<code>DrawStrategy</code>的指针，而是通过<code>DrawStrategy</code>模板参数提供绘制的实现细节。</p>
<p>请注意，虽然模板参数允许你从外部注入实现细节，但<code>Circle</code>仍然不依赖于任何实现细节。</p>
<p>因此，你仍然将<code>Circle</code>类与使用的图形库解耦，然而，与运行时方法相比，每次<code>DrawStrategy</code>更改时都需要重新编译。</p>
<p>虽然基于模板的解决方案从根本上改变了示例的属性<br/>（即没有基类和虚函数，没有运行时决策，没有单一的<code>Circle</code>类，而是每个具体的<code>DrawStrategy</code>都有一个<code>Circle</code>类型），但它仍然完美地实现了策略设计模式的意图。</p>
<p>因此，这表明设计模式并不局限于特定的实现或抽象的具体形式。</p>
<p><strong>设计模式不仅限于面向对象编程或动态多态</strong></p>
<p>让我们考虑策略设计模式的另一个用例：来自 <code>&lt;numeric&gt;</code> 头文件的标准库 <code>accumulate()</code> 函数模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，<code>std::accumulate()</code> 将给定范围内的所有元素相加，第三个参数指定总和的初始值，由于 <code>std::accumulate()</code> 使用该参数的类型作为返回类型，因此显式地将类型指定为 <code>int{0}</code> 而不是简单的 <code>0</code>，以防止微妙的误解。</p>
<p>然而，累加元素只是冰山一角：如果你需要，可以通过提供第四个参数来指定如何累加元素。</p>
<p>例如，你可以使用 <code>&lt;functional&gt;</code> 头文件中的 <code>std::plus</code> 或 <code>std::multiplies</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">{});</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">product</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;&gt;</span><span class="p">{});</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过第四个参数，<code>std::accumulate()</code> 可用于任何类型的归约操作，因此第四个参数代表了归约操作的实现。</p>
<p>这样，它允许我们通过从外部注入归约操作的细节来改变实现。</p>
<p>因此，<code>std::accumulate()</code> 不依赖于单一的具体实现，而是可以根据特定需求进行定制，<br/>这正是策略设计模式的意图。</p>
<p><code>std::accumulate()</code> 的强大之处在于其通用形式的策略设计模式，如果没有能力改变这种行为，它的用处将非常有限。由于策略设计模式，可能的用途是无限的。</p>
<p><code>std::accumulate()</code> 的例子表明，设计模式，即使是经典的GoF模式，也不局限于一种特定的实现，并且不限于面向对象编程。</p>
<p>显然，许多这些模式的意图对于其他范式（如函数式编程或泛型编程）也是有用的。</p>
<p>因此，设计模式不仅限于动态多态性，相反，它们同样适用于静态多态性，并且可以与C++模板结合使用。</p>
<p>为了进一步强调这一点并展示策略设计模式的另一个例子，考虑 <code>std::vector</code> 和 <code>std::set</code> 类模板的声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">vector</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">	<span class="k">class</span> <span class="nc">set</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>标准库中的所有容器（除了 <code>std::array</code>）都提供了指定自定义分配器的机会。</p>
<p>对于 <code>std::vector</code> 来说，它是第二个模板参数；<br/>对于 <code>std::set</code> 来说，它是第三个参数。</p>
<p>容器的所有内存请求都通过给定的分配器处理。</p>
<p>通过暴露一个模板参数用于分配器，标准库容器为你提供了从外部自定义内存分配的机会，它们使你能够定义一组算法（在这种情况下，是一个内存获取算法），并将每个算法封装起来，从而使它们可互换。</p>
<p>因此，你可以独立于使用这些算法的客户端（在这种情况下是容器）来更改这个算法。</p>
<p>阅读了上述描述后，你应该能识别出策略设计模式。在这个例子中，策略再次基于静态多态性并通过模板参数实现。显然，策略不限于动态多态性。</p>
<p>虽然很明显设计模式总体上并不局限于面向对象编程或动态多态性，但仍然应该明确指出，有些设计模式的意图是为了缓解面向对象编程中的常见问题（例如，访问者模式和原型模式）。</p>
<p>当然，也有一些专注于函数式编程或泛型编程的设计模式（例如，递归模板模式 [CRTP] 和表达式模板）。</p>
<p>虽然大多数设计模式并不是特定于某个范式的，其意图可以在多种实现中使用，但有些模式则更加具体。</p>
<p>在接下来的章节中，你会看到这两类的例子，你会看到一些具有非常普遍意图的设计模式，因此具有广泛的实用性。</p>
<p>此外，你还会看到一些更特定于某种范式的模式，由于其特性，它们在目标领域之外可能没有用处。</p>
<p>尽管如此，它们都具有设计模式的主要特征：名称、意图和某种形式的抽象。</p>
<p>总结来说：设计模式不仅限于面向对象编程，也不限于动态多态性，更具体地说，设计模式不关乎特定的实现，也不是特定语言的习惯用法。相反，它们完全关注以特定方式解耦软件实体的意图。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>将设计模式视为解决设计问题的工具，而不是目标。</li>
<li>请注意，设计模式不仅限于面向对象编程。</li>
<li>记住，设计模式不仅限于动态多态性。</li>
<li>理解设计模式不是特定于某种语言的习惯用法。</li>
</ul>
<h3 id="准则13设计模式无处不在">准则13：设计模式无处不在
</h3><p>上一节已经表明，设计模式不仅限于面向对象编程或动态多态性，它们也不是特定语言的习惯用法，并且不局限于某种特定的实现。</p>
<p>然而，由于这些常见的误解以及我们不再将C++视为纯粹的面向对象编程语言，有些人甚至声称设计模式已经过时或被淘汰。</p>
<p>我想象你现在可能有些怀疑。“过时？这难道不是有点夸张吗？”你可能会问。好吧，不幸的是并非如此。</p>
<p>让我讲一个小故事，在2021年初，我有幸在一个德国C++用户组中做了一次关于设计模式的虚拟演讲，我的主要目标是解释什么是设计模式，并说明它们在今天仍然非常有用。</p>
<p>在演讲过程中，我感到很好，充满动力，希望能帮助人们看到设计模式带来的所有好处。</p>
<p>然而，几天后，当演讲在YouTube上发布后，有一位用户评论说：“真的吗？2021年的设计模式？”</p>
<p>我非常希望你现在正在摇头表示不相信，是的，我也无法相信这一点，尤其是在展示了C++标准库中有数百个设计模式的例子之后。不，设计模式既不过时也不淘汰，事实远非如此。</p>
<p>为了证明设计模式仍然非常活跃和相关，让我们考虑C++标准库中更新的分配器设施。</p>
<p>请看下面使用来自 <code>std::pmr</code>（多态内存资源）命名空间的分配器的代码示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="mi">1000</span><span class="o">&gt;</span> <span class="n">raw</span><span class="p">;</span>  <span class="c1">// 注意：未初始化！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span><span class="n">raw</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">raw</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">{</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">strings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;String longer than what SSO can handle&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">strings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Another long string that goes beyond SSO&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">strings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;A third long string that cannot be handled by SSO&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子展示了如何使用 <code>std::pmr::monotonic_buffer_resource</code> 作为分配器，将所有的内存分配重定向到一个预定义的字节缓冲区。</p>
<p>首先，我们创建了一个大小为1000字节的缓冲区，形式是一个 <code>std::array</code>（注意：未初始化）。<br/>该缓冲区通过传递第一个元素的指针（通过 <code>raw.data()</code>）和缓冲区的大小（通过 <code>raw.size()</code>）提供给 <code>std::pmr::monotonic_buffer_resource</code> 作为内存源。<br/><code>monotonic_buffer_resource</code> 的第三个参数代表一个备份分配器，当 <code>monotonic_buffer_resource</code> 耗尽内存时使用。<br/>因为我们在这个例子中不需要额外的内存，所以我们使用 <code>std::pmr::null_memory_resource()</code> 函数，它返回一个总是分配失败的标准分配器的指针。<br/>这意味着无论你怎么请求内存，由 <code>std::pmr::null_memory_resource()</code> 返回的分配器都会在请求内存时抛出异常。<br/>创建的缓冲区作为分配器传递给字符串向量，该向量现在将从初始字节缓冲区获取所有内存。</p>
<p>此外，由于向量将其分配器转发给其元素，即使我们通过 <code>emplace_back()</code> 函数添加的三个字符串都太长而不能依赖小字符串优化（SSO），它们也将从字节数组中获取所有内存。</p>
<p>因此，在整个示例中没有使用动态内存；所有内存都将从字节数组中获取。</p>
<p>乍一看，这个例子似乎不需要任何设计模式就能工作。然而，这个例子中使用的分配器功能至少使用了四种不同的设计模式：模板方法设计模式、装饰器设计模式、适配器设计模式和（再次）策略设计模式。</p>
<p>如果你计算单例模式，甚至有五种设计模式：<code>null_memory_resource()</code> 函数是基于单例模式实现的：它返回一个静态存储持续时间对象的指针，用于保证最多只有一个此类分配器实例。</p>
<p>所有来自 <code>pmr</code> 命名空间的C++分配器，包括由 <code>null_memory_resource()</code> 和 <code>monotonic_buffer_resource</code> 返回的分配器，都是从 <code>std::pmr::memory_resource</code> 基类派生的。</p>
<p>如果你查看 <code>memory_resource</code> 类的定义，第一个设计模式就变得可见了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">memory_resource</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 虚析构函数、一些构造函数和赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="na">[[nodiscard]]</span> <span class="kt">void</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">is_equal</span><span class="p">(</span><span class="n">memory_resource</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">do_allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">do_deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">do_is_equal</span><span class="p">(</span><span class="n">memory_resource</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std::pmr
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你可能会注意到，类的公共部分中的三个函数在类的私有部分中有一个对应的虚函数。</p>
<p>虽然公共的 <code>allocate()</code>、<code>deallocate()</code> 和 <code>is_equal()</code> 函数代表了类的用户接口，但 <code>do_allocate()</code>、<code>do_deallocate()</code> 和 <code>do_is_equal()</code> 函数代表了派生类的接口。</p>
<p>这种关注点分离是 <strong>非虚拟接口（NVI）</strong> 模式的例子，它本身也是 <strong>模板方法设计模式</strong> 的一个例子。</p>
<p><strong>第二个设计模式：装饰器设计模式</strong></p>
<p>我们隐式使用的第二个设计模式是 <strong>装饰器设计模式</strong>。装饰器帮助你构建分配器的层次结构，并将一个分配器的功能扩展到另一个分配器。这个想法在这行代码中变得更加清晰：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span> <span class="n">raw</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">raw</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过将 <code>null_memory_resource()</code> 函数返回的分配器传递给 <code>monotonic_buffer_resource</code>，我们增强了它的功能。</p>
<p>每当我们通过 <code>allocate()</code> 函数请求 <code>monotonic_buffer_resource</code> 分配内存时，它可能会将调用转发给其备份分配器。</p>
<p>这样，我们可以实现许多不同类型的分配器，这些分配器可以轻松组合形成一个具有不同分配策略层的完整内存子系统。这种结合和重用功能的方式正是 <strong>装饰器设计模式</strong> 的优势所在。</p>
<p><strong>第三个设计模式：适配器设计模式</strong></p>
<p>你可能已经注意到，在示例代码中我们使用了 <code>std::pmr::vector</code> 和 <code>std::pmr::string</code>。</p>
<p>我假设你还记得 <code>std::string</code> 只是 <code>std::basic_string&lt;char&gt;</code> 的类型别名。知道这一点后，下面的内容应该不会让你感到意外：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">CharT</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Traits</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">char_traits</span><span class="o">&lt;</span><span class="n">CharT</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">basic_string</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="n">CharT</span><span class="p">,</span> <span class="n">Traits</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">CharT</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std::pmr
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些类型别名仍然指向常规的 <code>std::vector</code> 和 <code>std::basic_string</code> 类，但不再暴露分配器的模板参数。</p>
<p>相反，它们使用 <code>std::pmr::polymorphic_allocator</code> 作为分配器。</p>
<p>这是一个 <strong>适配器设计模式</strong> 的例子，适配器的目的是帮助你将两个不匹配的接口粘合在一起。</p>
<p>在这种情况下，<code>polymorphic_allocator</code> 帮助在经典静态接口（传统C++分配器所需）和新的动态分配器接口（<code>std::pmr::memory_resource</code> 所需）之间进行转换。</p>
<p><strong>第四个设计模式：策略设计模式</strong></p>
<p>我们示例中使用的第四个也是最后一个设计模式，再次是 <strong>策略设计模式</strong>。</p>
<p>通过公开分配器的模板参数，标准库容器如 <code>std::vector</code> 和 <code>std::string</code> 让你可以从外部自定义内存分配。</p>
<p>这是 <strong>策略设计模式</strong> 的静态形式，与自定义算法的目的相同（参见“准则12：注意设计模式的误解”）。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>理解任何类型的抽象和任何解耦尝试很可能代表了一种已知的设计模式。</li>
<li>了解不同的设计模式及其解耦的意图。</li>
<li>根据设计模式的意图，在必要时应用它们。</li>
</ul>
<h3 id="准则14使用设计模式的名称来传达意图">准则14：使用设计模式的名称来传达意图
</h3><p>在前两节中，你了解了什么是设计模式，它不是什么，以及设计模式无处不在。</p>
<p>你还了解到每个设计模式都有一个名称，这个名称表达了清晰、简洁且明确的意图。因此，名称承载着意义。通过使用设计模式的名称，你可以表达问题是什么，选择了哪种解决方案来解决问题，并描述代码预期如何演变。</p>
<p>例如，考虑标准库中的 <code>accumulate()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BinaryOperation</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">T</span> <span class="n">accumulate</span><span class="p">(</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三个模板参数名为 <code>BinaryOperation</code>，虽然这确实传达了传递的可调用对象需要接受两个参数的事实，但名称并没有传达参数的意图。</p>
<p>为了更清晰地表达意图，可以将其命名为 <code>BinaryReductionStrategy</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BinaryReductionStrategy</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">T</span> <span class="n">accumulate</span><span class="p">(</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">,</span> <span class="n">BinaryReductionStrategy</span> <span class="n">op</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>术语“Reduction”和名称“Strategy”对每个C++程序员来说都具有意义，因此，你现在更清晰地捕捉并表达了你的意图：该参数允许依赖注入一个二元操作，从而允许你指定归约操作的工作方式。因此，该参数解决了自定义的问题。</p>
<p>然而，正如你将在第5章看到的，策略设计模式传达了对该操作有一定的期望，你只能指定归约操作的工作方式；不能重新定义 <code>accumulate()</code> 的功能。</p>
<p>如果你想表达这一点，你应该使用命令设计模式的名称：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">UnaryCommand</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">UnaryCommand</span> <span class="n">for_each</span><span class="p">(</span> <span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryCommand</span> <span class="n">f</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::for_each()</code> 算法允许你将任何一元操作应用于一系列元素，为了表达这一意图，第二个模板参数可以命名为 <code>UnaryCommand</code>，这明确表示对该操作几乎没有预期的要求。</p>
<p>另一个来自标准库的例子展示了设计模式名称能为一段代码带来多少价值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Print</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;double: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;string: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{};</span>  
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="s">&#34;C++ Variant example&#34;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">Print</span><span class="p">{},</span> <span class="n">v</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>main()</code> 函数中，我们创建了一个包含三个选项（<code>int</code>、<code>double</code> 和 <code>std::string</code>）的 <code>std::variant</code>。</p>
<p>接下来一行，我们分配了一个C风格字符串字面量，它会在变体内部转换为 <code>std::string</code>。</p>
<p>然后我们通过 <code>std::visit()</code> 函数和 <code>Print</code> 函数对象打印变体的内容。</p>
<p>注意 <code>std::visit()</code> 函数的名称，该名称直接引用了访问者设计模式，因此明确表达了其意图：你可以对变体实例中包含的封闭类型集应用任何操作。此外，你可以非侵入式地扩展操作集。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>使用设计模式的名称来传达解决方案的意图。</li>
<li>使用设计模式的名称来提高可读性。</li>
</ul>
<h2 id="第四章-访问者设计模式">第四章 访问者设计模式
</h2><p>本章完全专注于访问者设计模式，如果你已经听说过访问者设计模式，甚至在自己的设计中使用过它，你可能会好奇为什么我选择访问者作为第一个详细解释的设计模式。</p>
<p>是的，访问者肯定不是最耀眼的设计模式之一，然而，它绝对是一个很好的例子，可以展示你在实现设计模式时拥有的多种选择，以及这些实现方式可以有多么不同。</p>
<p>它还将作为一个有效的例子，展示现代C++的优势。</p>
<p><strong>准则15：为添加类型或操作进行设计</strong></p>
<p>首先，我们在“准则15：为添加类型或操作进行设计”中讨论当你涉足动态多态性领域时需要做出的基本设计决策：关注类型还是操作。在这个准则中，我们还会讨论编程范式的内在优势和劣势。</p>
<p><strong>准则16：使用访问者扩展操作</strong></p>
<p>在“准则16：使用访问者扩展操作”中，我会向你介绍访问者设计模式。我将解释它的意图是扩展操作而不是类型，并向你展示经典访问者模式的优点和缺点。</p>
<p><strong>准则17：考虑使用 <code>std::variant</code> 实现访问者</strong></p>
<p>在“准则17：考虑使用 <code>std::variant</code> 实现访问者”中，你会了解到访问者设计模式的现代实现。我将向你介绍 <code>std::variant</code> 并解释这种特定实现的许多优点。</p>
<p><strong>准则18：警惕无环访问者的性能问题</strong></p>
<p>在“准则18：警惕无环访问者的性能问题”中，我会向你介绍无环访问者。乍一看，这种方法似乎解决了访问者模式的一些基本问题，但仔细观察后我们会发现，运行时开销可能使这种实现不适用。</p>
<h3 id="准则15为添加类型或操作进行设计">准则15：为添加类型或操作进行设计
</h3><p>对于你来说，动态多态性这个术语可能听起来像是有很多自由，它可能让你感觉像小时候一样：有无尽的可能性，没有任何限制！</p>
<p>然而，你已经长大了并面对现实：你不可能拥有一切，总是需要做出选择。</p>
<p>不幸的是，动态多态性也是如此，尽管听起来像是完全的自由，但仍然有一个限制性的选择：你是想扩展类型还是操作？</p>
<p>为了更好地理解我的意思，让我们回到第三章中的场景：我们希望绘制一个给定的形状，我们坚持使用动态多态性，并且在初次尝试中，我们将使用传统的过程式编程来实现这个问题。</p>
<p><strong>过程式解决方案</strong></p>
<p>第一个头文件 <code>Point.h</code> 提供了一个相当简单的 <code>Point</code> 类，这主要是为了使代码完整，但也给了我们一个提示，即我们正在处理二维形状：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Point.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Point</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个概念性的头文件 <code>Shape.h</code> 显得更加有趣：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="nc">ShapeType</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">circle</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">square</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">protected</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Shape</span><span class="p">(</span> <span class="n">ShapeType</span> <span class="n">type</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">type_</span><span class="p">(</span> <span class="n">type</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl">   <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ShapeType</span> <span class="nf">getType</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">type_</span><span class="p">;</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">ShapeType</span> <span class="n">type_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们引入了枚举 <code>ShapeType</code>，它目前列出了两个枚举值：<code>circle</code> 和 <code>square</code>，显然，我们最初只处理圆形和方形。</p>
<p>其次，我们引入了类 <code>Shape</code>。考虑到保护构造函数和虚析构函数，你可以预见 <code>Shape</code> 是作为基类使用的。<br/>但这并不是 <code>Shape</code> 最令人惊讶的细节：<code>Shape</code> 有一个类型为 <code>ShapeType</code> 的数据成员，这个数据成员通过构造函数初始化，并可以通过 <code>getType()</code> 成员函数查询。</p>
<p>显然，<code>Shape</code> 将其类型以 <code>ShapeType</code> 枚举的形式存储。</p>
<p><code>Shape</code> 基类的一个使用示例是 <code>Circle</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span> <span class="kt">double</span> <span class="n">radius</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">Shape</span><span class="p">(</span> <span class="n">circle</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="n">radius_</span><span class="p">(</span> <span class="n">radius</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* Checking that the given radius is valid */</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Circle</code> 公开继承自 <code>Shape</code>，因此由于 <code>Shape</code> 缺少默认构造函数，需要初始化基类。<br/>因为它是圆形，所以它使用 <code>circle</code> 枚举值作为基类构造函数的参数。</p>
<p>正如之前所述，我们希望绘制形状。因此，我们引入了用于圆形的 <code>draw()</code> 函数。<br/>为了避免与任何绘图实现细节紧密耦合，<code>draw()</code> 函数在概念性头文件 <code>DrawCircle.h</code> 中声明，在对应的源文件中定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawCircle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Circle</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span> <span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawCircle.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;DrawCircle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* some graphics library */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span> <span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... Implementing the logic for drawing a circle 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，不仅仅是圆形，如 square 枚举所示，还有一个 Square 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span> <span class="kt">double</span> <span class="n">side</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">Shape</span><span class="p">(</span> <span class="n">square</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="n">side_</span><span class="p">(</span> <span class="n">side</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* Checking that the given side length is valid */</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span>  <span class="c1">// Or any corner, if you prefer 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawSquare.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span> <span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawSquare.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawSquare.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* some graphics library */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span> <span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... Implementing the logic for drawing a square 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Square</code> 类与 <code>Circle</code> 类非常相似。主要区别在于 <code>Square</code> 使用 <code>square</code> 枚举值初始化其基类。</p>
<p>现在有了圆形和方形，我们希望绘制整个不同形状的向量。为此，我们引入了 <code>drawAllShapes()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawAllShapes.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shapes</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawAllShapes.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawAllShapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shapes</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="k">switch</span><span class="p">(</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl">      <span class="p">{</span> 
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nl">circle</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">            <span class="n">draw</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">shape</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nl">square</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">            <span class="n">draw</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">shape</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">      <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>drawAllShapes()</code>  接受一个 <code>std::unique_ptr&lt;Shape&gt; </code> 形式的形状向量，指向基类的指针是为了容纳不同种类的具体形状，而 std::unique_ptr 则用于通过 RAII 惯用法自动管理这些形状。</p>
<p>在函数内部，我们开始遍历向量以绘制每个形状。不幸的是，此时我们只有 Shape 指针。<br/>因此，我们需要通过 getType() 函数询问每个形状：你是什么类型的形状？如果形状回复 circle，我们知道必须将其绘制为 Circle 并执行相应的 static_cast。如果形状回复 square，我们将其绘制为 Square。</p>
<p>我感觉你对这个解决方案不太满意。但在讨论其不足之处之前，让我们先看看 main() 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawAllShapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Shapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// Creating some shapes 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shapes</span> <span class="n">shapes</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span> <span class="mf">2.3</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span> <span class="mf">1.2</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span> <span class="mf">4.1</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// Drawing all shapes 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">drawAllShapes</span><span class="p">(</span> <span class="n">shapes</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它确实可以工作！使用这个 main() 函数，代码编译并绘制三个形状（两个圆形和一个方形）。<br/>这不是很好吗？是的，但它不会阻止你对此方案进行抱怨：“多么原始的解决方案！不仅使用 switch 来区分不同种类的形状是个糟糕的选择，而且还没有默认情况！还有谁有这个疯狂的想法，通过未限定范围的枚举来编码形状的类型？”</p>
<p>你怀疑地看向我的方向……</p>
<p>好吧，我能理解你的反应。但让我们更详细地分析这个问题。<br/>让我猜一下：你记得“准则5：设计扩展”，你现在想象添加第三种形状需要做什么。<br/>首先，你需要扩展枚举。例如，我们需要添加新的枚举值 triangle：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">ShapeType</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">circle</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">square</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">triangle</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，这种添加不仅会影响 drawAllShapes() 函数中的 switch 语句（现在真正不完整），还会影响所有从 Shape 继承的类（Circle 和 Square）。<br/>这些类依赖于枚举，因为它们依赖于 Shape 基类并且直接使用该枚举。<br/>因此，更改枚举将导致所有相关源文件重新编译，你应该认识到这是一个严重的问题。</p>
<p>事实上，问题的核心是所有形状类和函数对枚举的直接依赖，任何对枚举的更改都会引发连锁反应，要求依赖文件重新编译。<br/>显然，这直接违反了开放封闭原则（OCP）（见“准则5：设计扩展”）。<br/>这看起来不对：添加一个 Triangle 不应该导致 Circle 和 Square 类重新编译。</p>
<p>还有更多问题。除了实际编写一个 Triangle 类（这个留给你自己想象），你还需要更新 switch 语句以处理三角形：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shapes</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="k">switch</span><span class="p">(</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="p">{</span> 
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nl">circle</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">            <span class="n">draw</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">shape</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nl">square</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">            <span class="n">draw</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">shape</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">         <span class="k">case</span> <span class="nl">triangle</span><span class="p">:</span>   
</span></span><span class="line"><span class="cl">            <span class="n">draw</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Triangle</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">shape</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">      <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我可以想象你的抗议：“复制粘贴！重复！”是的，在这种情况下，开发者很可能会使用复制粘贴来实现新逻辑，这样做很方便，因为新情况与前两种情况非常相似。</p>
<p>实际上，这表明设计可以改进。然而，我看到一个更为严重的缺陷：在一个更大的代码库中，这不会是唯一的 <code>switch</code> 语句。相反，会有其他需要更新的 <code>switch</code> 语句。<br/>有多少个？十几个？五十个？超过一百个？你如何找到所有这些？好吧，你可能会争辩说编译器会帮助你完成这项任务。对于 <code>switch</code> 语句可能是这样，但如果也有 <code>if-else-if</code> 级联呢？<br/>然后，在更新马拉松结束后，当你认为已经完成时，如何保证你真正更新了所有必要的部分？</p>
<p>是的，我能理解你的反应以及为什么你不喜欢这种代码：这种显式处理类型的方式是一个维护噩梦。<br/>引用 Scott Meyers 的话：</p>
<p><strong>这种基于类型的编程在 C 语言中有很长的历史，我们知道它会导致基本上不可维护的程序。</strong></p>
<p><strong>面向对象解决方案</strong></p>
<p>那么让我问一下：你会怎么做？你会如何实现形状的绘制？我猜你可能会使用面向对象的方法，这意味着你会抛弃枚举，并在 <code>Shape</code> 基类中添加一个纯虚函数 <code>draw()</code>。<br/>这样，<code>Shape</code> 就不再需要记住它的类型了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>有了这个基类，派生类现在只需要实现 <code>draw()</code> 成员函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span> <span class="kt">double</span> <span class="n">radius</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span> <span class="n">radius</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* Checking that the given radius is valid */</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* some graphics library */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">draw</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... Implementing the logic for drawing a circle 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span> <span class="kt">double</span> <span class="n">side</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">side_</span><span class="p">(</span> <span class="n">side</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* Checking that the given side length is valid */</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* some graphics library */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Square</span><span class="o">::</span><span class="n">draw</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... Implementing the logic for drawing a square 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一旦  <code>virtual draw()</code> 函数到位并由所有派生类实现，就可以用它来重构 <code>drawAllShapes()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawAllShapes.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shapes</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawAllShapes.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;DrawAllShapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shapes</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我可以看见你放松下来，开始微笑，这看起来好多了，更加简洁。<br/>虽然我知道你喜欢这个解决方案，并希望在这个舒适区多待一会儿，但不幸的是，我必须指出其中的一个缺陷。是的，这个解决方案也可能有缺点。</p>
<p>正如本节开头所提到的，通过面向对象的方法，我们现在可以非常容易地添加新类型，我们只需要编写一个新的派生类即可，我们不需要修改或重新编译任何现有代码(除了 main() 函数),这完美地满足了<strong>开放封闭原则(OCP)</strong>。</p>
<p>然而，你是否注意到我们不能再轻松地添加操作了？<br/>例如，假设我们需要一个 <strong>virtual serialize() 函数</strong> 将 Shape 转换为字节流，<br/>我们如何在不修改现有代码的情况下添加这个功能？任何人如何在不修改 Shape 基类的情况下轻松添加这个操作？</p>
<p>不幸的是，这已经不可能了，我们现在处理的是一个封闭的操作集，这意味着我们在添加操作时违反了 OCP。<br/>要添加虚拟函数，基类需要被修改，所有派生类（圆形、方形等）都需要实现新的函数，即使该函数可能永远不会被调用。<br/>总之，面向对象解决方案在添加类型方面符合 OCP，但在添加操作方面违反了它。</p>
<p>我知道你以为我们已经彻底告别了过程式解决方案，但让我们再看一眼，在过程式方法中，添加新操作实际上非常简单。<br/>新操作可以通过自由函数或独立类的形式添加，不需要修改 Shape 基类或任何派生类。<br/>因此，在过程式解决方案中，我们在添加操作方面符合 OCP，但是如我们所见，过程式解决方案在添加类型时违反了 OCP。</p>
<p>因此，它似乎是面向对象解决方案的倒置，反之亦然。</p>
<p><strong>注意动态多态性中的设计选择</strong></p>
<p>这个例子的关键在于使用动态多态性时存在一个设计选择：要么你可以通过固定操作的数量来轻松添加类型，要么你可以通过固定类型的数量来轻松添加操作。</p>
<p>因此，开放封闭原则（OCP）有两个维度：在设计软件时，你必须有意识地决定你期望哪种扩展。</p>
<p>面向对象编程的优势在于可以轻松添加新的类型，但其弱点是添加操作变得更加困难。</p>
<p>过程式编程的优势在于可以轻松添加操作，但添加类型则非常麻烦（见表4-1）。</p>
<p><strong>这取决于你的项目</strong>：<br/>如果你预计会频繁添加新类型而不是操作，你应该努力实现一种将操作视为封闭集、类型视为开放集的OCP解决方案。<br/>如果你预计会添加操作，你应该努力实现一种将类型视为封闭集、操作视为开放集的过程式解决方案。如果做出了正确的选择，你将节省自己和同事的时间，并且扩展将会变得自然和容易。</p>
<p><strong>表4-1. 不同编程范式的优缺点</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>编程范式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>过程式编程</td>
<td>添加操作</td>
<td>添加（多态）类型</td>
</tr>
<tr>
<td>面向对象编程</td>
<td>添加（多态）类型</td>
<td>添加操作</td>
</tr>
</tbody>
</table></div>
<p>注意这些优势：基于你对代码库如何演化的预期，选择合适的设计方法以支持扩展。不要忽视这些弱点，也不要让自己陷入不幸的维护噩梦。</p>
<p>我猜你现在可能在想是否有可能同时拥有两个开放集，据我所知，这不是不可能的，但通常不切实际。<br/>例如，在“准则18：警惕无环访问者的性能”中，我会展示性能可能会受到显著影响。</p>
<p>由于你可能是基于模板的编程和类似的编译时工作的粉丝，我也应该明确指出静态多态性并没有相同的限制。<br/>虽然在动态多态性中，设计轴之一（类型和操作）需要固定，但在静态多态性中，这两类信息在编译时都是可用的。因此，两方面都可以轻松扩展（如果你做得正确）。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>
<p>注意不同编程范式的优缺点。</p>
</li>
<li>
<p>利用范式的优势，但避免其弱点。</p>
</li>
<li>
<p>理解动态多态性中类型或操作的添加选择。</p>
</li>
<li>
<p>当你主要想添加类型时，优先选择面向对象解决方案。</p>
</li>
<li>
<p>当你主要想添加操作时，优先选择过程式/函数式解决方案。</p>
</li>
</ul>
<h3 id="准则16使用访问者模式扩展操作">准则16：使用访问者模式扩展操作
</h3><p>在上一节中，你看到面向对象编程（OOP）的优势在于可以轻松添加类型，而其弱点在于难以添加操作。当然，OOP对此有一个解决方案：访问者设计模式。</p>
<p>访问者设计模式是Gang of Four（GoF）所描述的经典设计模式之一。它的重点在于允许你频繁地添加操作而不是类型。让我通过前面的示例（形状绘制）来解释访问者设计模式。</p>
<p>在图4-1中，你看到了形状层次结构。<code>Shape</code>类再次作为多个具体形状的基类。在这个例子中，只有两个类：<code>Circle</code>和<code>Square</code>，但当然也可以有更多的形状类，例如<code>Triangle</code>、<code>Rectangle</code>或<code>Ellipse</code>类。</p>
<p><strong>分析设计问题</strong></p>
<p>假设你确定已经拥有了所有你需要的形状，也就是说，你认为形状集合是一个封闭集。<br/>然而，你缺少的是额外的操作，例如，你缺少一个旋转形状的操作，你也希望序列化形状，即将形状实例转换为字节流。<br/>当然，你还希望绘制形状。此外，你希望任何人能够添加新的操作。</p>
<p>因此，你期望有一个开放的操作集，每一个新的操作现在都需要你在基类中插入一个新的虚函数。<br/>不幸的是，这在不同的方面可能会带来麻烦，最明显的是，并不是每个人都能在 <code>Shape</code> 基类中添加一个虚函数。</p>
<p>例如，我不能简单地去修改你的代码。因此，这种方法无法满足任何人都能添加操作的期望，虽然你可能已经将此视为最终的负面结论，但让我们详细分析一下虚函数的问题。</p>
<p>如果你决定使用纯虚函数，你将不得不在每个派生类中实现该函数。对于你自己定义的派生类型来说，这可能只是多了一些工作量。但对于其他人通过继承 <code>Shape</code> 基类创建的新形状来说，这可能会增加额外的工作量。<br/>而这是面向对象编程的优势之一：任何人都可以轻松添加新类型。由于这种情况是可以预期的，因此这可能是不使用纯虚函数的一个原因。</p>
<p>作为替代方案，你可以引入一个普通的虚函数，即带有默认实现的虚函数。<br/>虽然 <code>rotate()</code> 函数的默认行为听起来像是一个非常合理的想法，但 <code>serialize()</code> 函数的默认实现听起来并不容易。</p>
<p>我承认我必须仔细考虑如何实现这样的函数，你现在可能会建议默认情况下抛出异常，但这意味着派生类必须再次实现缺失的行为，这实际上就是一个伪装的纯虚函数，或者明确违反了里氏替换原则（见“准则6：遵循抽象的预期行为”）。</p>
<p>无论哪种方式，在 <code>Shape</code> 基类中添加新操作都是困难的，甚至根本不可能。</p>
<p>其根本原因是添加虚函数违反了开放封闭原则（OCP），如果你确实需要频繁添加新操作，那么你应该设计一种使得操作扩展变得容易的方式。这就是访问者设计模式试图实现的目标。</p>
<p><strong>访问者设计模式解释</strong></p>
<p>访问者设计模式的意图是允许添加操作。</p>
<p>除了 <code>Shape</code> 层次结构外，我现在在图4-2的左侧引入了 <code>ShapeVisitor</code> 层次结构。</p>
<p><code>ShapeVisitor</code> 基类代表形状操作的抽象，因此，你可以认为 <code>ShapeOperation</code> 可能是这个类更好的名字。然而，应用“准则14：使用设计模式的名字来传达意图”是有益的，名字 <code>Visitor</code> 将帮助其他人理解设计。</p>
<p><code>ShapeVisitor</code> 基类为 <code>Shape</code> 层次结构中的每个具体形状提供一个纯虚函数 <code>visit()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeVisitor</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ShapeVisitor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能有更多的 visit() 函数，每个具体形状一个 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，有一个用于 <code>Circle</code> 的 <code>visit()</code> 函数和一个用于 <code>Square</code> 的 <code>visit()</code> 函数。<br/>当然，可能有更多 <code>visit()</code> 函数——例如，一个用于 <code>Triangle</code>，一个用于 <code>Rectangle</code>，一个用于 <code>Ellipse</code>——假设这些也是从 <code>Shape</code> 基类派生的类。</p>
<p>有了 <code>ShapeVisitor</code> 基类后，你现在可以轻松地添加新操作，要添加一个操作，只需添加一个新的派生类。</p>
<p>例如，为了启用旋转形状，你可以引入 <code>Rotate</code> 类并实现所有 <code>visit()</code> 函数。<br/>为了启用绘制形状，你只需要引入一个 <code>Draw</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Draw</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeVisitor</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能有更多的 visit() 函数，每个具体形状一个 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以考虑引入多个 <code>Draw</code> 类，每个图形库一个。你可以轻松做到这一点，因为你不需要修改任何现有代码。<br/>只需通过添加新代码扩展 <code>ShapeVisitor</code> 层次结构即可。</p>
<p>因此，这种设计在添加操作方面符合开放封闭原则（OCP）。</p>
<p>要完全理解访问者的设计特性，重要的是理解为什么访问者设计模式能够满足 OCP。</p>
<p>最初的问题是每次添加新操作都需要修改 <code>Shape</code> 基类，访问者将操作的添加识别为变化点，<br/>通过提取这个变化点，即将其作为一个独立的类，你遵循了单一职责原则（SRP）：<code>Shape</code> 不需要为每个新操作而改变。</p>
<p>这避免了频繁修改 <code>Shape</code> 层次结构，并使得添加新操作变得容易。</p>
<p>因此，SRP 成为了 OCP 的推动者。</p>
<p>要在形状上使用访问者（从 <code>ShapeVisitor</code> 基类派生的类），你现在必须在 <code>Shape</code> 层次结构中添加最后一个函数：<code>accept()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">accept</span><span class="p">(</span><span class="n">ShapeVisitor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定半径的有效性 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">accept</span><span class="p">(</span><span class="n">ShapeVisitor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定边长的有效性 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">accept</span><span class="p">(</span><span class="n">ShapeVisitor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>accept()</code> 函数的实现很简单，它只是根据具体 <code>Shape</code> 的类型调用给定访问者的相应 <code>visit()</code> 函数。</p>
<p>这是通过将 <code>this</code> 指针作为参数传递给 <code>visit()</code> 来实现的，因此，每个派生类中的 <code>accept()</code> 实现相同，但由于不同类型的 <code>this</code> 指针，它会触发给定访问者中 <code>visit()</code> 函数的不同重载。</p>
<p>因此，<code>Shape</code> 基类不能提供默认实现。</p>
<p>现在可以在需要执行操作的地方使用这个 <code>accept()</code> 函数。</p>
<p>例如，<code>drawAllShapes()</code> 函数使用 <code>accept()</code> 来绘制给定形状向量中的所有形状：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">Draw</span><span class="p">{});</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过添加 <code>accept()</code> 函数，你现在可以轻松地扩展 <code>Shape</code> 层次结构以支持更多的操作。</p>
<p>你现在设计了一个开放的操作集，太棒了！<br/>然而，没有万能药，也没有总是有效的设计，每种设计都有优点，但也有缺点。</p>
<p>所以在你开始庆祝之前，我应该告诉你访问者设计模式的不足之处，以便让你全面了解。</p>
<p><strong>分析访问者设计模式的不足</strong></p>
<p>访问者设计模式远非完美。考虑到访问者实际上是为了弥补面向对象编程（OOP）内在的弱点而设计的一种变通方案，而不是基于OOP的优势构建的，这一点是可以预料到的。</p>
<p><strong>第一个缺点：低实现灵活性</strong></p>
<p>第一个缺点是实现灵活性较低。</p>
<p>如果你考虑实现一个 <code>Translate</code> 访问者，这种缺点就变得很明显，<code>Translate</code> 访问者需要通过给定的偏移量移动每个形状的中心点。为此，<code>Translate</code> 需要为每个具体形状实现一个 <code>visit()</code> 函数。</p>
<p>特别是对于 <code>Translate</code>，你可以想象这些 <code>visit()</code> 函数的实现会非常相似，甚至完全相同：旋转一个圆形和旋转一个方形没有什么不同。</p>
<p>然而，你仍然需要编写所有的 <code>visit()</code> 函数，当然，你可以根据DRY原则将逻辑从 <code>visit()</code> 函数中提取出来，并在第三个独立函数中实现以减少重复代码。</p>
<p>但不幸的是，基类的严格要求不允许你将这些 <code>visit()</code> 函数实现为一个统一的函数。结果是一些样板代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Translate</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeVisitor</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 移动圆形和方形有什么区别？你仍然需要实现所有虚函数...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 可能有更多的 visit() 函数，每个具体形状一个 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>类似的实现不灵活还包括 <code>visit()</code> 函数的返回类型，返回类型的决定是在 <code>ShapeVisitor</code> 基类中做出的，派生类无法更改。通常的做法是将结果存储在访问者中并在稍后访问它。</p>
<p><strong>第二个缺点：难以添加新类型</strong></p>
<p>第二个缺点是使用访问者设计模式后，添加新类型变得困难。</p>
<p>之前我们假设你确定已经拥有了所有你需要的形状，这个假设现在变成了限制。</p>
<p>在 <code>Shape</code> 层次结构中添加新的形状需要更新整个 <code>ShapeVisitor</code> 层次结构：你必须在 <code>ShapeVisitor</code> 基类中添加一个新的纯虚函数，并且这个虚函数需要由所有派生类实现。</p>
<p>当然，这带来了我们之前讨论的所有缺点，特别是，你会迫使其他开发人员更新他们的操作。</p>
<p>因此，访问者设计模式要求有一个封闭的类型集，并以此交换开放的操作集。</p>
<p>底层的原因是 <code>ShapeVisitor</code> 基类、具体形状（如 <code>Circle</code> 和 <code>Square</code> 等）以及 <code>Shape</code> 基类之间存在循环依赖。</p>
<p><strong>第三个缺点：侵入性</strong></p>
<p>第三个缺点是访问者的侵入性，要在现有层次结构中添加访问者，你需要在该层次结构的基类中添加<code>virtual accept()</code> 函数。</p>
<p>虽然这通常是可能的，但它仍然存在向现有层次结构添加纯虚函数的常见问题（见“准则15：设计以支持类型或操作的添加”）。</p>
<p>然而，如果不能添加 <code>accept()</code> 函数，则这种形式的访问者不可行。<br/>如果是这种情况，不要担心：我们将在“准则17：考虑使用 std::variant 实现访问者”中看到另一种非侵入性的访问者设计模式。</p>
<p><strong>第四个缺点：继承的 accept() 函数</strong></p>
<p>第四个缺点（尽管较为隐蔽）是 <code>accept()</code> 函数是由派生类继承的。</p>
<p>如果有人后来添加了另一层派生类（可能是你自己）并忘记重写 <code>accept()</code> 函数，访问者将被应用到错误的类型上。不幸的是，你不会得到任何警告。</p>
<p>这只是进一步证明添加新类型变得更加困难。一种可能的解决方案是将 <code>Circle</code> 和 <code>Square</code> 类声明为 <code>final</code>，但这将限制未来的扩展。</p>
<p><strong>第五个缺点：双重分派性能开销</strong></p>
<p>第五个缺点在我们考虑每次操作都需要调用两个虚函数时变得明显。</p>
<p>最初，我们既不知道操作的类型也不知道形状的类型。</p>
<p>第一个虚函数是 <code>accept()</code> 函数，它接收一个抽象的 <code>ShapeVisitor</code>。<code>accept()</code> 函数现在解析具体的形状类型。</p>
<p>第二个虚拟函数是 <code>visit()</code> 函数，它接收一个具体的 <code>Shape</code> 类型。<code>visit()</code> 函数现在解析具体的操作类型。</p>
<p>这种所谓的双重分派不幸并不是免费的。相反，在性能方面，你应该认为访问者设计模式相对较慢。我将在下一个准则中提供一些性能数据。</p>
<p>在谈论性能时，我还应该提到另外两个对性能有负面影响的方面：</p>
<p><strong>频繁的小内存分配</strong>：我们通常单独分配每个形状和访问者。考虑以下 <code>main()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Shapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shapes</span> <span class="n">shapes</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">2.3</span><span class="p">));</span>  
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.2</span><span class="p">));</span>   
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">4.1</span><span class="p">));</span>   
</span></span><span class="line"><span class="cl">    <span class="n">drawAllShapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个 <code>main()</code> 函数中，所有分配都是通过 <code>std::make_unique()</code> 进行的</p>
<p>（例如 <code>shapes.emplace_back(std::make_unique&lt;Circle&gt;(2.3))</code>）。</p>
<p>这些许多小的分配本身就会消耗运行时间，并且最终会导致内存碎片化。</p>
<p>此外，内存布局可能不利于缓存友好，因此，我们通常使用指针来处理生成的形状和访问者。</p>
<p>由此产生的间接性使得编译器更难进行任何形式的优化，并会在性能基准测试中显现出来。</p>
<p>然而，老实说，这不是访问者特有的问题，而是面向对象编程中常见的两个方面。</p>
<p><strong>最后的缺点：复杂性和维护难度</strong></p>
<p>最后的缺点是经验表明，这种设计模式相当难以完全理解和维护。这是一个比较主观的缺点，但两个层次结构之间复杂的相互作用往往让人感觉更像是负担而不是真正的解决方案。</p>
<p><strong>总结</strong></p>
<ul>
<li>
<p>请记住，在现有继承层次结构中添加新操作是困难的。</p>
</li>
<li>
<p>应用访问者设计模式的意图是允许轻松添加操作。</p>
</li>
<li>
<p>要注意访问者设计模式的不足。</p>
</li>
</ul>
<h3 id="准则17考虑使用-stdvariant-实现访问者">准则17：考虑使用 std::variant 实现访问者
</h3><p>在“准则16：使用访问者扩展操作”中，我向你介绍了访问者设计模式。</p>
<p>我想你并不会立刻爱上它：尽管访问者确实具有一些独特的特性，但它也是一个相当复杂的设计模式，具有较强的内部耦合和性能缺陷。</p>
<p>不，绝对不是爱！然而，不用担心，经典形式并不是实现访问者设计模式的唯一方式。</p>
<p>在本节中，我想向你介绍一种不同的实现访问者的方式。我相信这种方法会更符合你的喜好。</p>
<p><strong>std::variant 简介</strong></p>
<p>在本章的开头，我们讨论了不同范式（面向对象编程与过程式编程）的优点和缺点。</p>
<p>特别是，我们谈到了过程式编程在为现有类型集添加新操作方面特别擅长。</p>
<p>那么，与其试图在OOP中寻找变通方法，为什么不利用过程式编程的优势呢？</p>
<p>不，不用担心；当然我不是建议回到最初的解决方案。那种方法太容易出错。相反，我指的是 <strong>std::variant：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Print</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;double: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;string: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个默认包含 &#39;int&#39; 初始化为 0 的 variant
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{};</span>  
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>        <span class="c1">// 分配整数 42 给 variant   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">v</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>      <span class="c1">// 分配双精度浮点数 3.14 给 variant   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">v</span> <span class="o">=</span> <span class="mf">2.71F</span><span class="p">;</span>     <span class="c1">// 分配浮点数，会被提升为双精度浮点数   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">v</span> <span class="o">=</span> <span class="s">&#34;Bjarne&#34;</span><span class="p">;</span>  <span class="c1">// 分配字符串字面量 &#39;Bjarne&#39; 给 variant   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">v</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>        <span class="c1">// 分配整数 43 给 variant   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="k">const</span> <span class="n">i</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>  <span class="c1">// 直接访问值   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>  <span class="c1">// 直接访问值   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">Print</span><span class="p">{},</span> <span class="n">v</span><span class="p">);</span>  <span class="c1">// 应用 Print 访问者   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于你可能还没有机会接触 C++17 的 <strong>std::variant</strong>，请允许我简要介绍一下。</p>
<p>一个 variant 表示几种备选方案中的一种。</p>
<p>例如，在上述代码示例中的 <strong>main()</strong> 函数开始时，<strong>variant</strong> 可以包含一个 <strong>int</strong>、一个 <strong>double</strong> 或一个 <strong>std::string</strong>。请注意我说的是 <strong>“或”</strong> ：一个 variant 只能包含这三种备选方案中的一种，它永远不会同时包含多个，通常情况下也不应该为空。</p>
<p>因此，我们将 variant 称为一种 <strong>“总和类型”</strong> ：可能状态的集合是各备选方案可能状态的总和。</p>
<p>默认的 variant 也不是空的。它被初始化为第一个备选方案的默认值。在这个例子中，默认的 <strong>variant</strong> 包含一个值为 <strong>0</strong> 的<strong>整数</strong>。</p>
<p>改变 variant 的值很简单：你可以直接分配新值。例如，我们可以分配值 42，这意味着 variant 存储了一个值为 42 的整数。</p>
<p>如果我们随后分配双精度浮点数 <strong>3.14</strong>，则 <strong>variant</strong> 将存储一个值为 <strong>3.14</strong> 的双精度浮点数。</p>
<p>如果你想分配一个不属于这些备选方案之一的类型的值，则应用常规转换规则。</p>
<p>例如，如果你想分配一个浮点数，基于常规转换规则，它会被提升为双精度浮点数。</p>
<p>为了存储备选方案，<strong>variant</strong> 提供了刚好足够的内部缓冲区来容纳最大的备选方案。</p>
<p>在我们的例子中，最大的备选方案是 <strong>std::string</strong>，通常是 24 到 32 字节（取决于标准库的具体实现）。</p>
<p>因此，当你分配字符串字面量 <strong>&ldquo;Bjarne&rdquo;</strong> 时，<strong>variant</strong> 首先清理之前的值（这里没什么需要做的，只是一个双精度浮点数），</p>
<p>然后 <strong>构造 std::string</strong> 并将其放置在其自身的<strong>缓冲区</strong>内。</p>
<p>当你改变主意并分配整数 <strong>43</strong> 时，<strong>variant</strong> 会通过其 <strong>析构函数</strong> 正确销毁 <strong>std::string</strong> 并重用内部缓冲区用于整数。</p>
<p>是不是很神奇？<strong>variant</strong> 是类型安全且始终正确初始化的。我们还能要求什么呢？</p>
<p>当然，你想要对 variant 中的值进行一些操作，如果只是存储值而不做任何事情，那将毫无意义。</p>
<p>不幸的是，你不能简单地将 <strong>variant</strong> 赋值给其他任何值，例如 int，以获取回你的值。不，访问值有点复杂。</p>
<p>有几种访问存储值的方法，最直接的方法是使用 <strong>std::get()</strong>。通过 <strong>std::get()</strong>，你可以查询特定类型的值。</p>
<p>如果 <strong>variant</strong> 包含该类型的值，它将返回对该值的<strong>引用</strong>。</p>
<p>如果不包含，则抛出 <strong>std::bad_variant_exception</strong>。</p>
<p>这看起来是一个相当粗鲁的响应，毕竟你是礼貌地请求的，但我们应该感到高兴的是，当 variant 确实不包含某个值时，它不会假装持有该值。至少它是诚实的。</p>
<p>还有一种更友好的方式是 <strong>std::get_if()</strong>。与 <strong>std::get()</strong> 不同，<strong>std::get_if()</strong> <strong>返回一个指针</strong>而不是引用。</p>
<p>如果你请求的类型是 <strong>std::variant</strong> 当前<strong>未持有的类型</strong>，它不会抛出异常，而是<strong>返回 nullptr</strong>。</p>
<p>然而，还有第三种方式，这种方式对我们来说特别有趣：<strong>std::visit()</strong>。</p>
<p><strong>std::visit()</strong> 允许你在存储的值上执行任何操作，更准确地说，它允许你传递一个自定义访问者来对封闭类型集的存储值执行任何操作。听起来熟悉吗？</p>
<p>我们作为第一个参数传递的 <strong>Print</strong> 访问者必须为每个可能的备选方案提供一个函数调用运算符（operator()）。</p>
<p>在这个例子中，这是通过提供三个 <strong>operator()</strong> 来实现的：一个用于 <strong>int</strong>，一个用于 <strong>double</strong>，一个用于 <strong>std::string</strong>。</p>
<p>值得注意的是，<strong>Print</strong> 不必继承自任何基类，也没有任何虚函数。因此，没有强耦合到任何要求。</p>
<p>如果我们愿意，我们也可以将 <strong>int</strong> 和 <strong>double</strong> 的函数调用运算符合并为一个，因为 int 可以转换为 double：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Print</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;int or double: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;string: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然关于哪个版本是我们应该首选的问题目前对我们来说并不特别重要，但你会注意到我们有很多实现灵活性。</p>
<p>只有非常松散的耦合，基于这样一个约定：对于每一个备选方案，都需要有一个 <code>operator()</code>，而不论其确切形式如何。</p>
<p>我们不再有一个强制我们以非常具体方式做事的访问者基类，我们也没有任何备选方案的基类：我们可以自由使用基本类型如 <code>int</code> 和 <code>double</code>，以及任意类类型如 <code>std::string</code>。</p>
<p>也许最重要的是，任何人都可以轻松添加新的操作，不需要修改现有代码。</p>
<p>因此，我们可以认为这是一种过程式解决方案，只不过比最初的基于枚举的解决方案更加优雅，后者使用基类来保存区分器。</p>
<p><strong>重构形状绘制为基于值的非侵入式解决方案</strong></p>
<p>凭借这些特性，std::variant 非常适合我们的绘图示例。让我们使用 std::variant 重新实现形状的绘制。</p>
<p>首先，我们重构 Circle 和 Square 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* 检查给定半径是否有效 */</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* 检查给定边长是否有效 */</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Circle</code> 和 <code>Square</code> 类都被大大简化了：不再需要 <code>Shape</code> 基类，也不再需要实现任何虚函数——特别是 <code>accept()</code> 函数。</p>
<p>因此，这种访问者方法是非侵入式的：这种形式的访问者可以轻松添加到现有类型中！而且不需要为这些类准备任何即将进行的操作。</p>
<p>我们可以完全专注于将这两个类实现为它们本来的样子：几何基本体。</p>
<p>然而，重构中最精彩的部分是实际使用 <code>std::variant</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Circle</span><span class="p">,</span> <span class="n">Square</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Shapes.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">Shapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们的封闭类型集是一组形状，<strong>variant</strong> 现在包含一个 <strong>Circle</strong> 或 <strong>Square</strong>。</p>
<p>那么代表形状类型的抽象集合的好名字是什么呢？嗯……<strong>Shape</strong>。代替抽象出具体形状类型的基类，<strong>std::variant</strong> 现在承担了这一任务。如果你是第一次看到这一点，你可能会感到非常惊讶。</p>
<p>但请稍等，还有更多：这也意味着我们现在可以放弃 <strong>std::unique_ptr</strong>。<br/>记住：我们使用（智能）指针的唯一原因是能够将不同种类的形状存储在同一个向量中。<br/>但现在 <strong>std::variant</strong> 使我们能够做到这一点，我们可以简单地将 <strong>variant</strong> 对象存储在一个单一的向量中。</p>
<p>有了这个功能，我们可以编写自定义操作来处理形状。我们仍然对绘制形状感兴趣。</p>
<p>为此，我们现在实现 Draw 访问者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Draw.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* 一些图形库 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Draw</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Circle</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="cm">/* 实现绘制圆的逻辑 */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Square</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="cm">/* 实现绘制正方形的逻辑 */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次，我们遵循期望为每个备选方案实现一个 <code>operator()</code>：一个是 <code>Circle</code>，另一个是 <code>Square</code>。</p>
<p>但这次我们有选择，不需要实现任何基类，也不需要重写任何虚函数。<br/>因此，不需要为每个备选方案精确实现一个 <code>operator()</code>。</p>
<p>虽然在这个例子中，拥有两个函数似乎是合理的，但我们也可以选择将两个 <code>operator()</code> 合并为一个函数，我们还可以选择操作的返回类型，我们可以本地决定应该返回什么，并且不是由基类独立于特定操作做出全局决策。实现了灵活性。松散耦合，令人惊叹！</p>
<p>最后一块拼图是 <code>drawAllShapes()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawAllShapes.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Shapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span><span class="k">const</span> <span class="n">Shapes</span><span class="o">&amp;</span> <span class="n">shapes</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawAllShapes.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;DrawAllShapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span><span class="k">const</span> <span class="n">Shapes</span><span class="o">&amp;</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">Draw</span><span class="p">{},</span> <span class="n">shape</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>drawAllShapes()</code> 函数被重构以利用 <code>std::visit()</code>。在这个函数中，我们现在将 <code>Draw</code> 访问者应用于存储在向量中的所有 <code>variant</code>。</p>
<p><code>std::visit()</code> 的工作是为你执行必要的类型调度，如果给定的 <code>std::variant</code> 包含一个 <code>Circle</code>，它将调用 <code>Draw::operator()</code> 来绘制圆。否则，它会调用 <code>Draw::operator()</code> 来绘制正方形。</p>
<p>如果你想的话，你可以手动实现相同的调度，使用 <code>std::get_if()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">drawAllShapes</span><span class="p">(</span><span class="k">const</span> <span class="n">Shapes</span><span class="o">&amp;</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">Circle</span><span class="o">*</span> <span class="n">circle</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shape</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">         <span class="c1">// ... 绘制一个圆 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> 
</span></span><span class="line"><span class="cl">      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Square</span><span class="o">*</span> <span class="n">square</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shape</span><span class="p">))</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">         <span class="c1">// ... 绘制一个正方形 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我知道你在想什么：“荒谬！为什么我会想要这样做？这会导致与基于枚举的解决方案相同的维护噩梦。”</p>
<p>我完全同意你的观点：从软件设计的角度来看，这将是一个糟糕的想法。<br/>尽管如此，我不得不说，在这本书的上下文中承认这一点有些困难，有时可能有一个很好的理由这样做：<strong>性能</strong>。</p>
<p>我知道，现在我已经引起了你的兴趣，但由于我们几乎准备好讨论性能问题，允许我暂时推迟这个讨论几段文字。我保证会回到这个问题！</p>
<p>有了所有这些细节，我们终于可以重构 <code>main()</code> 函数了，<br/>但这不需要做太多工作：不再通过 <code>std::make_unique()</code> 创建圆和正方形，而是直接创建圆和正方形，并将它们添加到向量中。</p>
<p>这得益于 <code>variant</code> 的非显式构造函数，它允许隐式转换任何备选方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawAllShapes.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shapes</span> <span class="n">shapes</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Circle</span><span class="p">{</span><span class="mf">2.3</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Square</span><span class="p">{</span><span class="mf">1.2</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Circle</span><span class="p">{</span><span class="mf">4.1</span><span class="p">});</span> 
</span></span><span class="line"><span class="cl">    <span class="n">drawAllShapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种基于值的解决方案的最终结果令人惊叹：没有任何基类。没有虚函数，没有指针。没有手动内存分配。</p>
<p>事情尽可能地直接，几乎没有样板代码。此外，尽管代码看起来与之前的解决方案非常不同，但架构属性是相同的：每个人都可以在不修改现有代码的情况下添加新操作（参见图 4-4）。</p>
<p>因此，我们在添加操作方面仍然满足 OCP（开闭原则）。</p>
<p>如前所述，这种方法是非侵入式的。从架构角度来看，这给你带来了另一个显著的优势，相比于经典的访问者模式。</p>
<p>如果你比较<strong>经典访问者</strong>的依赖关系图（见图 4-3）和 <code>std::variant</code> 解决方案的依赖关系图（见图 4-4），你会看到 <code>std::variant</code> 解决方案的依赖关系图有一个额外的架构边界。</p>
<p>这意味着 <code>std::variant</code> 及其备选方案之间没有循环依赖，我应该重复一遍以强调其重要性：<code>std::variant</code> 及其备选方案之间没有循环依赖！这看似一个小细节，但实际上是一个巨大的架构优势，巨大！例如，你可以即时创建基于 <code>std::variant</code> 的抽象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Circle</span><span class="p">,</span> <span class="n">Square</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;SomeHeader.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Ellipse.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">RoundShapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Circle</span><span class="p">,</span> <span class="n">Ellipse</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;SomeOtherHeader.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Rectangle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include &lt;variant&gt; 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">AngularShapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Square</span><span class="p">,</span> <span class="n">Rectangle</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了我们已经创建的 <code>Shape</code> 抽象外，你还可以创建所有圆形的 <code>std::variant</code>，以及所有角度形状的 <code>std::variant</code>，这两者都可能远离 <code>Shape</code> 抽象。</p>
<p>你可以轻松做到这一点，因为不需要从多个访问者基类派生。相反，形状类不会受到影响。因此，<code>std::variant</code> 解决方案的非侵入性具有最高的架构价值。</p>
<p><strong>性能基准测试</strong></p>
<p>我知道你现在的感觉，是的，这就是一见钟情的感觉。但信不信由你，还有更多内容。有一个我们还没有讨论的话题，这是每个C++开发者都关心的，那就是性能。</p>
<p>虽然这本书并不是专门讨论性能的，但仍然值得一提的是，你不需要担心 <strong>std::variant</strong> 的性能。我可以向你保证它非常快。</p>
<p>然而，在我向你展示基准测试结果之前，请允许我对这些基准测试做一些评论。性能——唉。不幸的是，性能总是一个棘手的话题。总有人抱怨性能问题。因此，我很乐意完全跳过这个话题。</p>
<p>但另一方面，也有人抱怨缺少性能数据。唉，既然无论如何总会有一些抱怨，并且结果实在太好了不容错过，我会向你展示一些基准测试的结果。</p>
<p>但有两个条件：首先，你不应将这些结果视为代表绝对真理的定量值，而只是指向正确方向的定性值。其次，你不会因为我没有使用你最喜欢的编译器、编译标志或IDE而在我的房子前抗议。答应吗？</p>
<p><strong>你</strong>：点头并承诺不会抱怨琐碎的事情！</p>
<p>好的，太棒了，那么表4-2给出了基准测试的结果。</p>
<p><strong>表4-2 不同访问者实现的基准测试结果</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>访问者实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>经典访问者设计模式</td>
<td>1.6161 s</td>
<td>1.8015 s</td>
</tr>
<tr>
<td>面向对象解决方案</td>
<td>1.5205 s</td>
<td>1.1480 s</td>
</tr>
<tr>
<td>枚举解决方案</td>
<td>1.2179 s</td>
<td>1.1200 s</td>
</tr>
<tr>
<td><code>std::variant</code>（使用 <code>std::visit()</code>）</td>
<td>1.1992 s</td>
<td>1.2279 s</td>
</tr>
<tr>
<td><code>std::variant</code>（使用 <code>std::get_if()</code>）</td>
<td>1.0252 s</td>
<td>0.6998 s</td>
</tr>
</tbody>
</table></div>
<p>为了更好地理解这些数字，我应该给你一些背景信息。为了让场景更加现实，我不仅使用了圆和正方形，还使用了矩形和椭圆。</p>
<p>然后在10,000个随机创建的形状上运行了25,000次操作，我没有绘制这些形状，而是通过随机向量更新中心点。</p>
<p>这是因为这种平移操作非常便宜，可以让我更好地展示所有这些解决方案的内在开销（如间接寻址和虚函数调用的开销）。</p>
<p>一个昂贵的操作，如 draw()，会掩盖这些细节，并可能给人以所有方法都非常相似的印象。</p>
<p>我使用了<strong>GCC 11.1</strong>和<strong>Clang 11.1</strong>，并为这两种编译器仅添加了 <strong>-O3</strong> 和 <strong>-DNDEBUG</strong> 编译标志。使用的平台是macOS Big Sur（版本11.4），搭载8核Intel Core i7处理器，主频3.8 GHz，内存64 GB。</p>
<p>从基准测试结果中最明显的结论是，<strong>variant</strong> 解决方案比 <strong>经典访问者</strong> 解决方案更<strong>高效</strong>。这并不令人惊讶：由于双重分派，<strong>经典访问者</strong>实现包含了<strong>很多间接寻址</strong>，因此也<strong>很难优化</strong>。</p>
<p>此外，形状对象的内存布局非常完美：与其他所有解决方案（包括基于枚举的解决方案）相比，所有形状都在内存中连续存储，这是你可以选择的最<strong>有利于缓存的布局</strong>。</p>
<p>第二个结论是，<strong>std::variant</strong> 确实非常高效，甚至可以说是出乎意料地高效。</p>
<p>然而，令人惊讶的是效率高度依赖于我们是否使用 <strong>std::get_if()</strong> 或 <strong>std::visit()</strong>（我答应会回到这一点）。</p>
<p>无论是<strong>GCC</strong>还是<strong>Clang</strong>，在使用 <strong>std::visit()</strong> 时生成的代码都要<strong>慢</strong>得多。我假设 <strong>std::visit()</strong> 在这一点上并没有被完美实现和优化。但是，正如我之前所说，性能总是很复杂，我不打算深入探讨这个谜题。</p>
<p>最重要的是，<strong>std::variant</strong> 的美丽并没有因为糟糕的性能数据而受到破坏。</p>
<p>相反：性能结果有助于加深你与 <strong>std::variant</strong> 新建立的关系。</p>
<p><strong>分析 std::variant 解决方案的不足之处</strong></p>
<p>虽然我不想危及这种关系，但我认为指出一些缺点是我的责任，如果你使用基于 <strong>std::variant</strong> 的解决方案，你将不得不面对这些问题。</p>
<p>首先，我应该再次指出显而易见的事实：作为一种类似于访问者设计模式且基于过程编程的解决方案，<br/><strong>std::variant</strong> 也专注于提供一组开放的操作，其缺点是你必须处理一个封闭的类型集。</p>
<p>添加新类型会引发与我们在 “准则15：为类型或操作的添加进行设计” 中提到的<strong>基于枚举</strong>的解决方案类似的问题。<br/>首先，你必须更新 <strong>variant</strong> 本身，这可能会触发所有使用该 <strong>variant</strong> 类型的代码重新编译（还记得更新枚举吗？）。<br/>此外，你还必须<strong>更新所有操作</strong>，并为新的备选方案添加可能缺失的 <strong>operator()</strong>。<br/>好的一面是，如果缺少这些操作符之一，编译器会报错。坏的一面是，编译器不会生成一条友好、易读的错误信息，而是生成接近所有模板相关错误消息之母的东西。</p>
<p>总的来说，这真的非常像我们之前使用<strong>基于枚举</strong>的解决方案时的经历。</p>
<p><strong>第二个潜在问题</strong>需要注意的是，你应该<strong>避免</strong>在 <strong>variant</strong> 中放置<strong>大小差异很大</strong>的类型。</p>
<p>如果至少有一个备选方案比其他的大得多，<strong>存储许多较小的备选方案可能会浪费大量空间</strong>。<br/>这会对性能产生负面影响，解决方案是不直接存储较大的备选方案，而是<strong>通过代理对象</strong>或<strong>使用桥接设计模式</strong>来存储它们。</p>
<p>当然，这会<strong>引入间接寻址</strong>，这也会<strong>影响性能</strong>。与存储不同大小的值相比，这种方法在性能上的劣势与否需要你自己进行基准测试。</p>
<p>最后但同样重要的是，你应该始终意识到 <strong>variant</strong> 可以揭示很多信息。<br/>虽然它代表了一种运行时抽象，但包含的类型仍然清晰可见。这可能会创建对 <strong>variant</strong> 的物理依赖，即当你修改其中一个备选类型时，可能需要重新编译任何依赖它的代码。</p>
<p>解决方案同样是存储<strong>指针</strong>或<strong>代理对象</strong>，这样可以隐藏实现细节。<br/>不幸的是，这也会对性能产生影响，因为很多性能提升来自于编译器了解这些细节并相应地优化它们。</p>
<p>因此，在性能和封装之间总是存在权衡。</p>
<p>尽管存在这些不足，总体而言，<strong>std::variant</strong> 被证明是一个很好的替代<strong>面向对象编程（OOP）<strong>的</strong>访问者设计模式</strong>。<br/>它大大简化了代码，几乎消除了所有的样板代码，并封装了丑陋且维护密集的部分，同时带来了卓越的性能。</p>
<p>此外，<strong>std::variant</strong> 还证明了一个事实，即设计模式关注的是意图，而不是实现细节。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>理解经典<strong>Visitor</strong>和<strong>std::variant</strong>之间的架构相似性。</li>
<li>注意<strong>std::variant</strong>与面向对象访问者解决方案相比的优势。</li>
<li>使用<strong>std::variant</strong>的非侵入性来动态创建抽象。</li>
<li>记住<strong>std::variant</strong>的缺点，并在不合适的时候避免使用它</li>
</ul>
<h3 id="准则18警惕无环访问者的性能">准则18：警惕无环访问者的性能
</h3><p>正如你在“准则15：为类型或操作的添加进行设计”中看到的，当你使用动态多态性时，你必须做出一个决定：你可以支持开放的类型集或开放的操作集。</p>
<p>你不能两者兼得，好吧，我特别提到过，据我所知，同时拥有两者并不是不可能的，但通常不切实际。</p>
<p>为了说明这一点，让我向你介绍访问者设计模式的另一种变体：<strong>无环访问者</strong>（Acyclic Visitor）。</p>
<p>在 “准则16：使用访问者扩展操作”中，你看到了<strong>访问者设计模式的关键参与者之间存在循环依赖</strong>：<br/><strong>访问者基类依赖于形状的具体类型（如 Circle、Square 等），具体类型的形状依赖于 Shape 基类，而 Shape 基类又依赖于访问者基类。</strong></p>
<p>由于这种循环依赖，将所有这些关键角色锁定在一个架构层次上，使得向访问者添加新类型变得困难。</p>
<p><strong>无环访问者的想法是打破这种依赖关系。</strong></p>
<p>图4-5 显示了无环访问者的UML图。</p>
<p>与GoF访问者相比，虽然图片右侧只有很小的区别，但在左侧有一些根本性的变化。</p>
<p>最重要的是，访问者基类被拆分成了多个基类：<strong>AbstractVisitor</strong> 基类和每个具体形状类型的一个基类（在这个例子中是 <strong>CircleVisitor</strong> 和 <strong>SquareVisitor</strong>）。</p>
<p>所有访问者都必须继承自 <strong>AbstractVisitor</strong> 基类，但现在也有选择可以继承自具体的形状访问者基类。</p>
<p>如果一个操作想要支持<strong>圆形</strong>，它就继承自 <strong>CircleVisitor</strong> 基类并实现针对 <strong>Circle</strong> 的 <strong>visit() 函数</strong>。</p>
<p>如果它不想支持圆形，则只需不继承 CircleVisitor。</p>
<p>以下代码片段展示了访问者基类的一种可能实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;AbstractVisitor.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">AbstractVisitor</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractVisitor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Visitor.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Visitor</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Visitor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>AbstractVisitor 基类只是一个带有虚析构函数的空基类。不需要其他任何函数。正如你将看到的，AbstractVisitor 仅作为一个通用标记来识别访问者，并不需要提供任何操作。在C++中，我们倾向于以类模板的形式实现具体的形状访问者基类。Visitor 类模板根据特定的形状类型进行参数化，并为该特定形状引入纯虚函数 visit()。</p>
<p>在我们的 Draw 访问者的实现中，我们现在将继承自三个基类：</p>
<p><code>AbstractVisitor、Visitor&lt;Circle&gt; </code> 和 <code>Visitor&lt;Square&gt;</code> ，因为我们希望支持 Circle 和 Square：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Draw</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractVisitor</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">             <span class="k">public</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">             <span class="k">public</span> <span class="n">Visitor</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span> <span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="cm">/* ... 实现绘制圆的逻辑 ... */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span> <span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="cm">/* ... 实现绘制正方形的逻辑 ... */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种实现选择打破了循环依赖。如图4-6所示，架构的高层不再依赖于具体的形状类型。无论是形状（<code>Circle</code> 和 <code>Square</code>）还是操作现在都位于架构边界的低层。我们现在可以同时添加类型和操作。</p>
<p>此刻，你看起来非常怀疑，几乎是责备地看向我。我不是说过两者兼得是不可能的吗？显然，这是可能的，对吧？好吧，再一次强调，我没有声称这是不可能的。我更倾向于说这可能是不切实际的。现在你已经看到了无环访问者的优势，让我向你展示这种方法的缺点。</p>
<p>首先，让我们看一下 <strong>Circle</strong> 中 <strong>accept()</strong> 函数的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">accept</span><span class="p">(</span><span class="n">AbstractVisitor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>   
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">*</span> <span class="n">cv</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Visitor</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>   
</span></span><span class="line"><span class="cl">            <span class="n">cv</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可能已经注意到 <strong>Shape</strong> 层次结构中的一个小变化：虚函数 accept() 现在接受一个 <strong>AbstractVisitor</strong>。</p>
<p>你还记得 <strong>AbstractVisitor</strong> 本身并不实现任何操作。因此，<strong>Circle</strong> 不是在 <strong>AbstractVisitor</strong> 上调用 <strong>visit()</strong> 函数，而是通过执行 <strong>dynamic_cast</strong> 来确定给定的访问者是否支持圆形（<code>Visitor&lt;Circle&gt;</code> ）。</p>
<p>请注意，它执行的是指针转换，这意味着 <strong>dynamic_cast</strong> 将返回一个有效的 <code>Visitor&lt;Circle&gt;</code>  指针或 nullptr。<br/>如果返回一个有效的 <code>Visitor&lt;Circle&gt;</code>  指针，它将调用相应的 <strong>visit()</strong> 函数。</p>
<p>虽然这种方法确实有效，并且是打破访问者设计模式循环依赖的一部分，但使用 <strong>dynamic_cast</strong> 总会让人感到不安。</p>
<p><strong>dynamic_cast</strong> 应该总是让人有点怀疑，因为如果使用不当，它可能会破坏架构。<br/>这种情况发生在我们从架构的高层对位于架构低层的东西进行强制类型转换时。<br/>在我们的例子中，实际上是可以使用的，因为我们是在架构的低层使用它。因此，通过将低层的知识插入到高层并不会破坏架构。</p>
<p>真正的缺陷在于运行时的开销。当我们运行与“准则17：考虑使用 std::variant 实现访问者”相同的基准测试时，你会发现无环访问者的运行时间几乎比循环访问者高出一个数量级（见表4-3）。</p>
<p>原因是 <strong>dynamic_cast</strong> 很慢，非常慢。对于这个应用尤其如此。我们在这里进行的是交叉转换（cross-cast）。<br/>我们不仅仅是在向下转换到特定的派生类，而是在继承层次结构的另一个分支上进行转换。这种交叉转换，再加上虚拟函数调用，比简单的向下转换要昂贵得多。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>访问者实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>无环访问者</td>
<td>14.3423 s</td>
<td>7.3445 s</td>
</tr>
<tr>
<td>循环访问者</td>
<td>1.6161 s</td>
<td>1.8015 s</td>
</tr>
<tr>
<td>面向对象解决方案</td>
<td>1.5205 s</td>
<td>1.1480 s</td>
</tr>
<tr>
<td>枚举解决方案</td>
<td>1.2179 s</td>
<td>1.1200 s</td>
</tr>
<tr>
<td><code>std::variant</code>（使用 <code>std::visit()</code>）</td>
<td>1.1992 s</td>
<td>1.2279 s</td>
</tr>
<tr>
<td><code>std::variant</code>（使用 <code>std::get_if()</code>）</td>
<td>1.0252 s</td>
<td>0.6998 s</td>
</tr>
</tbody>
</table></div>
<p><strong>本节总结</strong></p>
<ul>
<li>了解无循环访问器的架构优势。</li>
<li>请注意该解决方案的显著性能缺点。</li>
</ul>
<h2 id="第五章-策略和命令设计模式">第五章 策略和命令设计模式
</h2><p>本章专门讨论两种最常用的设计模式：<strong>策略设计模式</strong> 和 <strong>命令设计模式</strong>。事实上，它们是非常常用的：C++ 标准库本身就使用了这两种模式数十次，而且很有可能你自己也多次使用过它们。这两种模式可以被视为每个开发者的基石工具。</p>
<p>在“<strong>准则19：使用策略隔离事物的实现方式</strong>”中，我将向你介绍策略设计模式。我将展示为什么它是最有用和最重要的设计模式之一，并解释为什么你会在许多场景中发现它非常有用。</p>
<p>在“<strong>准则20：优先使用组合而非继承</strong>”中，我们将探讨继承以及为什么许多人对它有抱怨。你会发现继承本身并不是坏的，但和其他任何东西一样，它有其优点和局限性。最重要的是，我将解释许多经典设计模式的力量并非来源于继承，而是来源于组合。</p>
<p>在“<strong>准则21：使用命令隔离事物的操作内容</strong>”中，我将向你介绍命令设计模式。我将展示如何高效地使用该设计模式，并给你一个关于命令与策略之间比较的概念。</p>
<p>在“<strong>准则22：优先使用值语义而非引用语义</strong>”中，我们将深入探讨引用语义的领域。然而，我们会发现这个领域并不特别友好和好客，并且会让我们担心代码的质量。因此，我们将迁移到值语义的领域，这将为我们提供许多对代码库有益的功能。</p>
<p>在“<strong>准则23：优先使用基于值的策略和命令实现</strong>”中，我们将再次回顾策略和命令模式。我将展示如何应用我们在值语义领域获得的见解，并基于 <strong>std::function</strong> 实现这两种设计模式。</p>
<p>通过这些指南，你将更好地理解如何在实际项目中有效使用策略和命令设计模式，并学会如何选择适当的实现方式以优化代码质量和性能。希望这些内容对你有所帮助！</p>
<h3 id="准则19使用策略隔离事物的实现方式">准则19：使用策略隔离事物的实现方式
</h3><p>让我们假设你和你的团队即将实现一个新的2D图形工具。除了其他需求外，它需要处理简单的几何图元，如圆形、正方形等，并且这些图元需要被绘制（见图5-1）。</p>
<p>图5-1. 初始的Shape继承层次结构</p>
<p>一些类已经实现了，例如一个 Shape 基类、一个 Circle 类和一个 Square 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* 一些图形库 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 实现绘制圆的逻辑 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Point.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的边长是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="nf">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">center_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">center_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* 一些图形库 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Square</span><span class="o">::</span><span class="n">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 实现绘制正方形的逻辑 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最重要的方面是 <code>Shape</code> 基类中的纯虚函数 <code>draw()</code>（）。</p>
<p>在你休假期间，你的团队成员已经为 <code>Circle</code> 和 <code>Square</code> 类实现了这个 <code>draw()</code> 成员函数，使用的是OpenGL（和）。</p>
<p>该工具已经能够绘制圆形和正方形，并且整个团队一致认为生成的图形看起来非常整洁。每个人都感到满意！</p>
<p><strong>分析设计问题</strong>
除了你之外的每个人，从假期回来后，你当然立即意识到已实现的解决方案违反了单一职责原则（SRP）。</p>
<p>目前来看，<strong>Shape</strong> 层次结构并没有<strong>为变化而设计</strong>。</p>
<p>首先，改变形状的绘制方式并不容易，在当前实现中，只有一种固定的绘制形状的方式，并且无法非侵入性地更改这些细节。因为你已经预测到该工具将需要支持多个图形库，这绝对是一个问题。其次，如果你最终进行更改，则需要在多个不相关的地点修改行为。</p>
<p>但还有更多问题。由于绘制功能是在 <strong>Circle</strong> 和 <strong>Square</strong> 类中实现的，因此 <strong>Circle</strong> 和 <strong>Square</strong> 类依赖于 <strong>draw()</strong> 的实现细节，这意味着它们依赖于 OpenGL。</p>
<p>尽管圆和正方形应该主要是简单的几何图元，但现在这两个类在所有使用的地方都必须承担使用 <strong>OpenGL</strong> 的负担。</p>
<p>当你向同事们指出这些问题时，他们一开始有些不知所措。同时也有点恼火，因为他们没有预料到你会指出他们美丽解决方案中的任何缺陷。然而，你有一个非常好的解释问题的方法，最终他们同意了你的观点并开始思考更好的解决方案。</p>
<p>没过多久，他们就想出了一个更好的方法。几天后的下一次团队会议上，他们展示了他们的新想法：在继承层次结构中增加一层（见图5-2）。</p>
<p>为了演示这个想法，他们已经实现了 <strong>OpenGLCircle</strong> 和 <strong>OpenGLSquare</strong> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 不再实现 draw() 成员函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLCircle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">OpenGLCircle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OpenGLCircle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">Circle</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLCircle.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;OpenGLCircle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* OpenGL 图形库头文件 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">OpenGLCircle</span><span class="o">::</span><span class="n">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 使用 OpenGL 实现绘制圆的逻辑 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 不再实现 draw() 成员函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLSquare.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">OpenGLSquare</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Square</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OpenGLSquare</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">Square</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLSquare.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;OpenGLSquare.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* OpenGL 图形库头文件 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">OpenGLSquare</span><span class="o">::</span><span class="n">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 使用 OpenGL 实现绘制正方形的逻辑 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>继承！当然！通过简单地从 <strong>Circle</strong> 和 <strong>Square</strong> 派生，并将 <strong>draw()</strong> 函数的实现进一步下移到层次结构中，可以很容易地以不同的方式实现绘制。</p>
<p>例如，可能会有 <strong>MetalCircle</strong> 和 <strong>VulkanCircle</strong>，假设需要支持 <strong>Metal</strong> 和 <strong>Vulkan</strong> 库。突然之间，改变变得容易了，对吧？</p>
<p>虽然你的同事们仍然为他们的新解决方案感到非常自豪，但你已经意识到这种方法不会长期有效。并且很容易展示其缺点：你只需要考虑另一个需求，例如一个 <strong>serialize()</strong> 成员函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>serialize()</strong> 成员函数旨在将形状转换为字节序列，可以存储在文件或数据库中，然后可以从字节序列反序列化以重新创建完全相同的形状。就像 <strong>draw()</strong> 成员函数一样，<strong>serialize()</strong> 成员函数也可以以多种方式实现。例如，你可以使用 <strong>protobuf</strong> 或 <strong>Boost.serialization</strong> 库。</p>
<p>使用将实现细节向下移动到继承层次结构的相同策略，这将很快导致一个相当复杂且相当人为的层次结构（见图5-3）。考虑以下类名：<strong>OpenGLProtobufCircle</strong>、<strong>MetalBoostSerialSquare</strong> 等等。</p>
<p>可笑吧？我们该如何组织这种结构呢？我们应该在层次结构中添加另一层（如 <strong>Square</strong> 分支所示）吗？</p>
<p>这种方法会迅速导致一个深层次且复杂的层次结构，或者我们是否应该更平坦地展开层次结构（如 Circle 分支所示）？关于重用实现细节又该怎么办呢？例如，如何在 <strong>OpenGLProtobufCircle</strong> 和 <strong>OpenGLBoostSerialCircle</strong> 类之间重用 <strong>OpenGL</strong> 代码？</p>
<p><strong>策略设计模式解释</strong></p>
<p>你意识到你的同事们过于迷恋继承，而你需要拯救这一天。</p>
<p>他们似乎需要有人向他们展示如何为这种变化进行正确的设计，并为他们提供一个适当的解决方案。</p>
<p>正如两位务实的程序员所言：<strong>“继承很少是答案。”</strong> 问题仍然是违反了单一职责原则（SRP），因为你需要计划如何改变不同形状的绘制方式，你应该将绘制方面识别为一个变化点。</p>
<p>有了这个认识，正确的做法是为变化设计，遵循SRP，并提取变化点。这就是策略设计模式的意图，它是经典GoF设计模式之一。</p>
<p>意图：“<strong>定义一组算法，封装每个算法，并使它们可以互换。策略模式允许算法独立于使用它的客户端进行变化。</strong>” 而不是在派生类中实现虚函数 <strong>draw()</strong>，你可以引入另一个类来专门用于绘制形状。</p>
<p>在经典的<strong>面向对象</strong>（OO）形式的<strong>策略设计模式</strong>中，这是通过引入 <strong>DrawStrategy 基类</strong>来实现的（见图5-4）。</p>
<p>现在将绘制方面隔离出来，使得我们可以在不修改形状类的情况下更改绘制的实现。这实现了<strong>SRP</strong>的思想。你现在也可以在不修改任何其他代码的情况下引入新的 <strong>draw()</strong> 实现。这满足了<strong>开放封闭原则</strong>（OCP）。再一次，在这种面向对象设置中，<strong>SRP</strong>是<strong>OCP</strong>的推动者。</p>
<p>以下代码片段展示了 <strong>DrawStrategy</strong> 基类的一个简单实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Circle</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DrawStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">DrawStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">square</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>DrawStrategy</strong> 类带有虚拟析构函数和两个纯虚函数 <strong>draw()</strong>，一个用于圆形，一个用于正方形。</p>
<p>为了编译这个基类，你需要前向声明 <strong>Circle</strong> 和 <strong>Square</strong> 类。</p>
<p>由于策略设计模式，<strong>Shape</strong> 基类没有变化。它仍然代表所有形状的抽象，并因此提供了一个纯虚函数 <strong>draw()</strong>。策略模式旨在提取实现细节，因此只影响派生类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能还有其他函数，例如 &#39;serialize()&#39; 成员函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然由于策略模式 <code>Shape</code> 基类没有变化，但 <code>Circle</code> 和 <code>Square</code> 类受到了影响：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawStrategy</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效且给定的 std::unique_ptr 实例不是 nullptr */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawStrategy</span><span class="o">&gt;</span> <span class="n">drawer_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawStrategy</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的边长是否有效且给定的 std::unique_ptr 实例不是 nullptr */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawStrategy</span><span class="o">&gt;</span> <span class="n">drawer_</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，<code>Circle</code> 和 <code>Square</code> 都期望在其构造函数中接收一个指向 <code>DrawStrategy</code> 的 <code>unique_ptr</code>。</p>
<p>这允许我们从外部配置绘制行为，通常称为依赖注入。<code>unique_ptr</code> 被移动到相同类型的新的数据成员中。</p>
<p>还可以提供相应的 setter 函数，这将允许你在稍后的时间点更改绘制行为。<code>draw()</code> 成员函数现在不需要自己实现绘制逻辑，只需调用给定 <code>DrawStrategy</code> 的 <code>draw()</code> 函数。</p>
<p><strong>分析朴素解决方案的不足</strong></p>
<p>太棒了！有了这个实现，你现在可以在本地、隔离地改变形状绘制的行为，并让每个人都能实现新的绘制行为。然而，目前我们的策略实现有一个严重的设计缺陷。</p>
<p>为了分析这个缺陷，假设你需要添加一种新的形状，比如三角形。这应该很容易，因为正如我们在“<strong>准则15：设计以增加类型或操作</strong>”中讨论的那样，<strong>面向对象编程</strong>（OOP）的优势在于能够轻松添加新类型。</p>
<p>当你开始引入三角形时，你会发现添加新类型的形状并不像预期的那么简单。</p>
<p>首先，你需要编写新类。这是可以预料的，也不是问题。但随后你必须更新 <strong>DrawStrategy</strong> 基类，以便也能绘制三角形。反过来，这会对圆形和正方形产生不幸的影响：<strong>Circle</strong> 和 <strong>Square</strong> 类都需要重新编译、重新测试并可能重新部署。更广泛地说，所有形状都会受到影响。而这种情况应该是有问题的。为什么在添加一个 <strong>Triangle</strong> 类时，圆形和正方形需要重新编译？</p>
<p>技术上的原因是通过 <strong>DrawStrategy</strong> 基类，所有形状隐式地知道彼此。</p>
<p>因此，添加一个新的形状会影响所有其他形状。根本的设计原因是<strong>违反了接口分离原则</strong>（ISP）（见“<strong>准则3：分离接口以避免人为耦合</strong>”）。</p>
<p>通过定义单一的 <strong>DrawStrategy</strong> 基类，你人为地将圆形、正方形和三角形耦合在一起。由于这种耦合，你使得添加新类型变得更加困难，从而限制了<strong>OOP</strong>的优势。相比之下，你创造了一种与我们讨论过程化解决方案时非常相似的情况（见“<strong>准则15：设计以增加类型或操作</strong>”）。</p>
<p>“<strong>难道我们无意中重新实现了访问者设计模式吗？</strong>”你可能会问。</p>
<p>我明白你的意思：<strong>DrawStrategy</strong> 确实看起来很像访问者。但不幸的是，它并不能满足访问者的意图，因为你不能轻易地添加其他操作。要做到这一点，你需要<strong>侵入性</strong>地在 <strong>Shape</strong> 层次结构中添加一个虚拟成员函数。“而且它也不是策略模式，因为我们无法添加类型，对吧？”是的，正确。从设计的角度来看，这是最糟糕的情况。</p>
<p>要正确实现<strong>策略设计模式</strong>，你必须分别提取每个形状的实现细节。你需要为每种形状引入一个 <strong>DrawStrategy</strong> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawCircleStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Circle</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DrawCircleStrategy</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">DrawCircleStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawCircleStrategy</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效且给定的 &#39;std::unique_ptr&#39; 不是 nullptr */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawCircleStrategy</span><span class="o">&gt;</span> <span class="n">drawer_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawSquareStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DrawSquareStrategy</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">DrawSquareStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">square</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawSquareStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawSquareStrategy</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的边长是否有效且给定的 &#39;std::unique_ptr&#39; 不是 nullptr */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawSquareStrategy</span><span class="o">&gt;</span> <span class="n">drawer_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于 <strong>Circle</strong> 类，你需要引入 <strong>DrawCircleStrategy</strong> 基类，而对于 <strong>Square</strong> 类，则是 <strong>DrawSquareStrategy</strong> 基类。</p>
<p>随着 <strong>Triangle</strong> 类的添加，你也需要添加一个 <strong>DrawTriangleStrategy</strong> 基类。只有这样，你才能正确分离关注点，并仍然允许每个人添加新类型和形状绘制的新实现。</p>
<p>有了这些功能，你可以轻松实现用于绘制圆形、正方形甚至三角形的新策略类。例如，考虑实现 <strong>DrawCircleStrategy</strong> 接口的 <strong>OpenGLCircleStrategy</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLCircleStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* OpenGL 图形库 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OpenGLCircleStrategy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DrawCircleStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OpenGLCircleStrategy</span><span class="p">(</span><span class="cm">/* 绘制相关的参数 */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 绘制相关的数据成员，例如颜色、纹理等 */</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，<strong>Circle</strong> 和 <strong>DrawCircleStrategy</strong> 类位于相同的架构级别。</p>
<p>更值得注意的是它们之间的循环依赖关系：<strong>Circle</strong> 依赖于 <strong>DrawCircleStrategy</strong>，但 <strong>DrawCircleStrategy</strong> 也依赖于 <strong>Circle</strong>。但是不要担心：虽然乍一看这似乎是个问题，但实际上并不是。这是一个必要的关系，表明 <strong>Circle</strong> 真正拥有 <strong>DrawCircleStrategy</strong> 并由此创建了所需依赖倒置，如“<strong>准则9：注意抽象的所有权</strong>”中所讨论的那样。</p>
<p>“使用类模板实现不同的 <strong>draw</strong> 策略类是否可行？我想象中的类似于用于无环访问者的访问者类”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DrawStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">DrawStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是一个好主意，也正是你应该做的。通过此类模板，你可以将 <strong>DrawStrategy</strong> 提升到更高的架构级别，重用代码，并遵循<strong>DRY原则</strong>（见图5-6）。此外，如果从一开始就采用这种方法，我们将不会陷入人为耦合不同类型的问题。是的，我真的喜欢这个！</p>
<p>尽管这是我们如何实现这样一个策略类的方式，但你仍然不应该期望这会减少基类的数量（仍然是相同的，只是生成的），或者这会为你节省很多工作。</p>
<p><strong>DrawStrategy</strong> 的实现，例如 <strong>OpenGLCircleStrategy</strong> 类，代表了大部分的工作，并且几乎不会改变：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLCircleStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* OpenGL 图形库 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">OpenGLCircleStrategy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DrawStrategy</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设类似实现的 <code>OpenGLSquareStrategy</code>，我们现在可以将所有内容放在一起，并再次绘制形状，这次是使用策略设计模式正确解耦的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;OpenGLCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;OpenGLSquareStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Shapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Shapes</span> <span class="n">shapes</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一些形状，每个形状都配备了相应的OpenGL绘制策略 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">            <span class="mf">2.3</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OpenGLCircleStrategy</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...红色...*/</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">            <span class="mf">1.2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OpenGLSquareStrategy</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...绿色...*/</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">            <span class="mf">4.1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OpenGLCircleStrategy</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...蓝色...*/</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制所有形状 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>访问者模式与策略模式的比较</strong></p>
<p>既然你已经了解了访问者设计模式和策略设计模式，你可能会疑惑这两者的区别是什么。毕竟，它们的实现看起来相当相似。然而，尽管在实现上有一些相似之处，这两种设计模式的特性是非常不同的。</p>
<p>使用访问者设计模式时，我们将一般操作的添加视为变化点。因此，我们为操作创建了一个抽象，这反过来允许每个人添加操作。不幸的副作用是，添加新的形状类型变得不再容易。</p>
<p>使用策略设计模式时，我们将单个函数的实现细节视为变化点。引入这些实现细节的抽象后，我们仍然能够轻松地添加新的形状类型，但无法轻松地添加新操作。添加一个操作仍然需要侵入性地添加一个虚拟成员函数。因此，策略设计模式的意图与访问者设计模式的意图正好相反。</p>
<p>将这两种设计模式结合起来以获得两者的优点（使添加类型和操作都变得容易）听起来很有前景。不幸的是，这种方法行不通：无论你先应用哪种设计模式，都会固定两个自由轴中的一个。因此，你应该记住这两种设计模式的优点和缺点，并根据你对代码库演化的预期来应用它们。</p>
<p><strong>分析策略设计模式的不足</strong></p>
<p>我已经向你展示了策略设计模式的优势：它通过引入一个抽象来减少对特定实现细节的依赖。然而，在软件设计中没有万能药，每种设计都有其一系列的缺点。策略设计模式也不例外，考虑潜在的缺点同样重要。</p>
<p>首先，虽然某个操作的实现细节已经被提取和隔离，但该操作本身仍然是具体类型的一部分。这一事实证明了上述限制，即我们仍然不能轻易地添加操作。与访问者不同，策略保留了OOP的优势，使你可以轻松添加新类型。</p>
<p>其次，尽早识别这些变化点是有回报的。否则需要进行大规模重构。当然，这并不意味着你应该一开始就用策略模式实现一切以防未来需要重构。这样做可能会导致过度设计。但在有迹象表明实现细节可能发生变化，或者有多重实现的需求时，应该尽快实施必要的修改。最好的建议，虽然是有点不具体的，就是保持事情尽可能简单（KISS原则；保持简单，愚蠢）。</p>
<p>第三，如果你通过基类实现策略模式，性能肯定会因为额外的运行时间接调用而受到影响。性能还受到许多手动分配（<code>std::make_unique()</code> 调用）、由此产生的内存碎片以及由于众多指针造成的各种间接调用的影响。这是可以预料的，但你的实现的灵活性以及每个人都可以添加新实现的机会可能会超过这种性能损失。当然，这取决于具体情况，你需要逐案决定。如果你使用模板实现策略模式（见“基于策略的设计”讨论），这种缺点就不成问题。</p>
<p>最后但并非最不重要的，策略设计模式的主要缺点是单一策略应处理单一操作或一组紧密相关的函数。否则，你又会违反单一职责原则（SRP）。如果需要提取多个操作的实现细节，则需要有多个策略基类和多个数据成员，可以通过依赖注入设置。例如，考虑有一个额外的 <code>serialize()</code> 成员函数的情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DrawCircleStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Circle</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DrawCircleStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">DrawCircleStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;SerializeCircleStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SerializeCircleStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">SerializeCircleStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;SerializeCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawCircleStrategy</span><span class="o">&gt;</span> <span class="n">drawer</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SerializeCircleStrategy</span><span class="o">&gt;</span> <span class="n">serializer</span> 
</span></span><span class="line"><span class="cl">                    <span class="cm">/* 可能还有更多与策略相关的参数 */</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">serializer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">serializer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效且给定的 std::unique_ptrs 不是 nullptrs */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">serializer_</span><span class="o">-&gt;</span><span class="n">serialize</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DrawCircleStrategy</span><span class="o">&gt;</span> <span class="n">drawer_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SerializeCircleStrategy</span><span class="o">&gt;</span> <span class="n">serializer_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能还有更多与策略相关的数据成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然这会导致基类的大量增加以及由于多个指针而导致实例变大，但也提出了如何设计类以便方便地分配多个不同策略的问题。因此，策略设计模式在需要隔离少量实现细节的情况下最为强大。如果你遇到需要提取许多操作细节的情况，最好考虑其他方法（例如第7章的外部多态设计模式或第8章的类型擦除设计模式）。</p>
<p><strong>基于策略的设计</strong></p>
<p>正如前面章节所展示的，策略设计模式不仅限于动态多态性。相反，策略的意图可以通过使用模板在静态多态性中完美实现。例如，考虑标准库中的以下两个算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ForwardIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryPredicate</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">ForwardIt</span> <span class="n">partition</span><span class="p">(</span><span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryPredicate</span> <span class="n">p</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RandomIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Compare</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">RandomIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::partition()</code> 和 <code>std::sort()</code> 算法都使用了策略设计模式。<code>std::partition()</code> 的 <code>UnaryPredicate</code> 参数和 <code>std::sort()</code> 的 <code>Compare</code> 参数代表了一种从外部注入部分行为的方法。更具体地说，这两个参数允许你指定元素如何排序。因此，这两个算法提取了其特定行为的一部分，并以概念的形式为这些行为提供了抽象（见“指南7：理解基类与概念之间的相似性”）。这与面向对象形式的策略不同，不会产生任何运行时性能损失。</p>
<p>类似的思路也可以在 <code>std::unique_ptr</code> 类模板中看到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Deleter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">unique_ptr</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Deleter</span><span class="o">&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[],</span> <span class="n">Deleter</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于基础模板和数组专用模板，都可以指定第二个模板参数为显式的 <code>Deleter</code>。通过这个参数，你可以决定是否要通过 <code>delete</code>、<code>free()</code> 或其他释放函数来释放资源。甚至可以“滥用” <code>std::unique_ptr</code> 来执行完全不同的清理操作。</p>
<p>这种灵活性也是策略设计模式的证据。模板参数允许你将一些清理行为注入到类中。这种形式的策略也被称为基于策略的设计，这是安德烈·亚历山德雷斯库在2001年提出的一种设计理念。其思想相同：提取并隔离类模板的具体行为，以提高可变性、可扩展性、可测试性和可重用性。因此，基于策略的设计可以被视为策略设计模式的静态多态形式。显然，这种设计非常有效，如标准库中众多应用所展示的那样。</p>
<p>你还可以将基于策略的设计应用于形状绘制的例子。考虑以下 <code>Circle</code> 类的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;DrawCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DrawCircleStrategy</span><span class="o">&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="n">DrawCircleStrategy</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/*some arguments*/</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DrawCircleStrategy</span> <span class="n">drawer_</span><span class="p">;</span>  <span class="c1">// 如果假定给定的策略是无状态的，则可能可以省略。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>与其在构造函数中传递 <code>std::unique_ptr</code> 到 <code>DrawCircleStrategy</code> 基类，不如通过模板参数指定策略。最大的优势是由于较少的指针间接调用而带来的性能提升：你可以直接调用由 <code>DrawCircleStrategy</code> 提供的具体实现，而不是通过 <code>std::unique_ptr</code> 调用。缺点是你会失去在运行时调整特定 <code>Circle</code> 实例绘制策略的灵活性。此外，你不会再有一个单一的 <code>Circle</code> 类。你会为每个绘制策略有一个 <code>Circle</code> 的实例化。最后但并非最不重要的是，你应该记住类模板通常完全位于头文件中。因此，你可能会失去在源文件中隐藏实现细节的机会。一如既往，没有完美的解决方案，选择“正确”的解决方案取决于实际上下文。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>要明白，继承很少能解决问题。</li>
<li>应用Strategy设计模式的目的是提取一组内聚功能的实现细节。</li>
<li>为每个操作实现一个策略，以避免人为耦合。</li>
<li>将基于策略的设计视为策略设计模式的编译时形式。</li>
</ul>
<h3 id="准则20优先使用组合而非继承">准则20：优先使用组合而非继承
</h3><p>在90年代和21世纪初面向对象编程（OOP）热潮之后，如今的OOP处于守势。反对OOP并强调其缺点的声音越来越强烈。这不仅限于C++社区，也包括其他编程语言社区。虽然OOP整体确实有一些局限性，但让我们聚焦于引起最多争议的一个特性：继承。正如Sean Parent所说：</p>
<p><strong>“继承是万恶之源。”</strong></p>
<p>虽然继承被宣传为一种非常自然且直观的方式去模拟现实世界的关系，但实际上它比承诺的要难用得多。当你我们在讨论Liskov替换原则（LSP）时已经看到了继承的微妙失败（见“指南6：遵循抽象的预期行为”）。但继承还有其他方面常常被误解。</p>
<p>首先，继承总是被认为简化了可重用性。这似乎是直观的，因为从另一个类继承代码看起来很容易重用。不幸的是，这种重用并不是继承带来的那种重用。继承不是关于重用基类中的代码；相反，它是关于通过使用基类多态地重用其他代码。例如，假设有一个稍微扩展的 <code>Shape</code> 基类，以下函数适用于所有类型的形状，并因此可以被 <code>Shape</code> 基类的所有实现重用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">translate</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="cm">/*some arguments*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能有其他成员函数 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rotateAroundPoint</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mergeShapes</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">writeToFile</span><span class="p">(</span><span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sendViaRPC</span><span class="p">(</span><span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所有四个函数（<code>rotateAroundPoint</code>、<code>mergeShapes</code>、<code>writeToFile</code> 和 <code>sendViaRPC</code>）都是基于 <code>Shape</code> 抽象构建的。所有这些函数仅耦合到所有类型形状的公共接口，而不是任何特定的形状。所有类型的形状都可以围绕一个点旋转、合并、写入文件并通过RPC发送。每种形状都“重用”了此功能。</p>
<p>正是通过抽象表达功能的能力创造了代码重用的机会。与基类中包含的小量代码相比，这种功能预计会产生大量的代码。因此，真正的可重用性是由类型的多态使用创建的，而不是由多态类型创建的。</p>
<p>其次，继承被认为有助于解耦软件实体。虽然这绝对是正确的（例如，回想一下“指南9：注意抽象的所有权”中关于依赖倒置原则（DIP）的讨论），但往往没有解释继承也会产生耦合。你之前已经看到过这一点。在实现访问者设计模式时，你体验到了继承如何强制某些实现细节给你。在一个经典的访问者模式中，你必须实现访问者基类的纯虚函数，即使这对你的应用程序来说并不理想。你对函数参数或返回类型也没有太多选择。这些都是固定的。</p>
<p>你在讨论策略设计模式开始时也体验到了这种耦合。在这种情况下，继承强制了一种结构耦合，导致了更深的继承层次结构，导致了可疑的类命名，并损害了重用性。</p>
<p>在此时，你可能会觉得我在试图完全诋毁继承。好吧，说实话，我只是想让它看起来有点不好，但只是必要的程度。明确地说：继承并不坏，也不意味着不应该使用它。相反：继承是一个非常强大的特性，如果使用得当，你可以用它做令人难以置信的事情。然而，“如果使用得当”这部分是个问题。继承已经被证明很难正确使用（肯定比我们被告知的要难得多；参见我之前的理由），因此经常被无意中误用。它也被过度使用，因为许多开发人员习惯于用它来解决各种问题。这种过度使用似乎是许多问题的根源，正如Michael Feathers所言：</p>
<p>“[编程差异]在1990年代失宠，当时许多人注意到如果过度使用继承会相当麻烦。”</p>
<p>在许多情况下，继承既不是正确的解决方案也不是正确的工具。大多数时候，使用组合更为可取。你应该不会对此感到惊讶，因为你已经看到这是事实。组合是OO形式的策略设计模式如此有效的根本原因，而不是继承。引入抽象和聚合相应的数据成员使策略设计模式如此强大，而不是基于继承的不同策略实现。实际上，你会发现许多设计模式坚实地基于组合，而不是继承。所有这些模式都能通过继承进行扩展，但它们本身是通过组合实现的。</p>
<p><strong>委托给服务：拥有优于是。</strong> ——Andrew Hunt和David Thomas，《实用程序员》</p>
<p>这是许多设计模式的一般要点。我建议你将这一见解牢记在心，因为它将对你理解本书剩余部分中看到的设计模式非常有用，并将提高你实现的质量。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>要明白继承经常被过度使用，有时甚至被误用。</li>
<li>请记住，继承创建了紧密耦合。</li>
<li>要认识到许多设计模式是通过组合而不是继承来实现的。</li>
</ul>
<h3 id="准则21使用命令模式隔离操作内容">准则21：使用命令模式隔离操作内容
</h3><p>在我们开始这条指南之前，让我们先做一个实验。</p>
<p>打开你喜欢的电子邮件客户端，给我写一封电子邮件。添加以下内容：“我爱您的书！它让我整晚都睡不着，并且让我忘记了所有的烦恼。” 好的，很好。现在点击发送。</p>
<p>干得不错！给我几秒钟检查我的邮箱……还没有收到……还是没有……让我们再试一次：点击重新发送。还是没有。</p>
<p>嗯，我猜有些服务器可能出了问题。或者是我这边的所有命令都失败了：<code>WriteCommand</code>（写命令）、<code>SendCommand</code>（发送命令）、<code>ResendCommand</code>（重新发送命令），等等。真不幸。</p>
<p>但尽管这个实验失败了，你现在应该对另一个GoF设计模式有了一个很好的理解：<strong>命令设计模式</strong>。</p>
<p><strong>命令设计模式解析</strong></p>
<p>命令设计模式专注于封装和隔离工作包，这些工作包通常只执行一次，并且通常是立即执行的。为此，它识别不同类型的工作包作为变化点，并引入相应的抽象，允许轻松实现新的工作包类型。</p>
<p>意图：“<strong>将请求封装为对象，从而让你可以使用不同的请求参数化客户端，队列或记录请求，并支持可撤销的操作。</strong>”</p>
<p>以计算器为例，下面是命令设计模式的一个实现。第一个代码片段展示了<code>CalculatorCommand</code>基类的实现，它代表了对给定整数进行数学运算的抽象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;CalculatorCommand.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CalculatorCommand</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">CalculatorCommand</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">undo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>CalculatorCommand</code>类期望派生类实现纯虚函数<code>execute()</code>和<code>undo()</code>。对于<code>undo()</code>的预期是它实现了必要的操作来逆转<code>execute()</code>函数的效果。</p>
<p>加法和减法类都代表了计算器可能的命令，因此它们实现了<code>CalculatorCommand</code>基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Add.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CalculatorCommand.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Add</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CalculatorCommand</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">operand</span><span class="p">)</span> <span class="o">:</span> <span class="n">operand_</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">operand_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">undo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">operand_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">operand_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Subtract.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CalculatorCommand.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Subtract</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CalculatorCommand</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Subtract</span><span class="p">(</span><span class="kt">int</span> <span class="n">operand</span><span class="p">)</span> <span class="o">:</span> <span class="n">operand_</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">operand_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">undo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">operand_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">operand_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Add</code>类实现了<code>execute()</code>函数用于加法操作，并实现了<code>undo()</code>函数用于减法操作。<code>Subtract</code>类则实现了相反的操作。</p>
<p>由于<code>CalculatorCommand</code>层次结构的存在，<code>Calculator</code>类本身可以保持相当简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Calculator.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CalculatorCommand.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Calculator</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CalculatorCommand</span><span class="o">&gt;</span> <span class="n">command</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">undoLast</span><span class="p">();</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">result</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">CommandStack</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CalculatorCommand</span><span class="o">&gt;&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">current_</span><span class="p">{};</span>  
</span></span><span class="line"><span class="cl">    <span class="n">CommandStack</span> <span class="n">stack_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Calculator.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Calculator.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">Calculator</span><span class="o">::</span><span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CalculatorCommand</span><span class="o">&gt;</span> <span class="n">command</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">current_</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">current_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">stack_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">command</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Calculator</span><span class="o">::</span><span class="n">undoLast</span><span class="p">()</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">stack_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">command</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">stack_</span><span class="p">.</span><span class="n">top</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">    <span class="n">stack_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="n">current_</span> <span class="o">=</span> <span class="n">command</span><span class="o">-&gt;</span><span class="n">undo</span><span class="p">(</span><span class="n">current_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Calculator</span><span class="o">::</span><span class="n">result</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">current_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Calculator</span><span class="o">::</span><span class="n">clear</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">current_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">CommandStack</span><span class="p">{}.</span><span class="n">swap</span><span class="p">(</span><span class="n">stack_</span><span class="p">);</span>  <span class="c1">// 清空栈 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们只需要两个函数来进行计算活动：<code>compute()</code>和<code>undoLast()</code>。</p>
<p><code>compute()</code>函数接收一个<code>CalculatorCommand</code>实例，立即执行它以更新当前值，并将其存储在栈中。<code>undoLast()</code>函数通过从栈中弹出最后一个执行的命令并调用其<code>undo()</code>方法来撤销最后一次操作。</p>
<p><code>main()</code>函数将所有部分组合在一起：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Calculator.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Add.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Subtract.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Calculator</span> <span class="n">calculator</span><span class="p">{};</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">op1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Add</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">op2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Add</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">op3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Subtract</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">op4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Subtract</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op1</span><span class="p">));</span>  <span class="c1">// 计算 0 + 3，存储并返回 3 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op2</span><span class="p">));</span>  <span class="c1">// 计算 3 + 7，存储并返回 10 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op3</span><span class="p">));</span>  <span class="c1">// 计算 10 - 4，存储并返回 6 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">calculator</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op4</span><span class="p">));</span>  <span class="c1">// 计算 6 - 2，存储并返回 4 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">calculator</span><span class="p">.</span><span class="n">undoLast</span><span class="p">();</span>  <span class="c1">// 撤销最后一次操作，存储并返回 6 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="k">const</span> <span class="n">res</span> <span class="o">=</span> <span class="n">calculator</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>  <span class="c1">// 获取最终结果：6 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先创建一个计算器，并创建一系列操作，依次应用这些操作。</p>
<p>之后，通过<code>undo()</code>操作撤销<code>op4</code>，然后查询最终结果。</p>
<p>这种设计很好地遵循了<strong>SOLID</strong>原则。它遵守<strong>单一职责原则</strong>（SRP），因为通过<strong>命令设计模式</strong>已经提取了变化点。因此，<code>compute()</code>和<code>undo()</code>不需要是虚函数。<strong>SRP</strong>也促进了<strong>开闭原则</strong>（OCP），使我们可以添加新操作而无需修改现有代码。</p>
<p>最后，如果正确分配了<code>Command</code>基类的所有权，则设计也符合<strong>依赖倒置原则</strong>（DIP）。</p>
<p><strong>命令设计模式的第二个经典示例：线程池</strong></p>
<p><strong>命令设计模式</strong>的另一个经典示例是<strong>线程池</strong>。</p>
<p>线程池的作用是维护多个线程，等待任务以便并行执行。</p>
<p>这一想法通过以下<code>ThreadPool</code>类实现：它提供了一些成员函数来将某些任务分配给特定数量的可用线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Command</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="cm">/* 执行和撤销任何类型操作的抽象接口 */</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kr">inline</span> <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kr">inline</span> <span class="n">size_t</span> <span class="nf">active</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kr">inline</span> <span class="n">size_t</span> <span class="nf">ready</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">schedule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Command</span><span class="o">&gt;</span> <span class="n">command</span><span class="p">);</span>   <span class="c1">// 安排一个任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">wait</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>最重要的是，<code>ThreadPool</code>允许你通过<code>schedule()</code>函数安排一个任务。</p>
<p>这个任务可以是任何类型的：<code>ThreadPool</code>完全不关心其线程需要执行什么类型的工作。</p>
<p>通过<code>Command</code>基类，它与实际调度的任务类型完全解耦。</p>
<p>只需从<code>Command</code>派生，就可以制定任意任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FormattingCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="cm">/* 实现磁盘格式化 */</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PrintCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="cm">/* 实现打印任务 */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个初始有两个工作线程的线程池 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ThreadPool</span> <span class="n">threadpool</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 安排两个并发任务 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">threadpool</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">FormattingCommand</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/* 一些参数 */</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">    <span class="n">threadpool</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">PrintCommand</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/* 一些参数 */</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待线程池完成所有命令 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">threadpool</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>例如，<code>FormattingCommand</code>任务会获取必要的信息，通过操作系统触发磁盘格式化。</p>
<p>另一种情况是<code>PrintCommand</code>，它接收所有数据以触发打印作业。</p>
<p>在这个线程池示例中，你也能够识别出<strong>命令设计模式</strong>的效果：不同类型的任务被识别为变化点，并被提取出来（这也遵循了单一职责原则），这使你可以实现不同类型的任务而无需修改现有代码（符合开闭原则）。</p>
<p>当然，标准库中也有一些例子展示了命令设计模式的应用。</p>
<p>例如，在<code>std::for_each()</code>算法中可以看到命令设计模式的实际应用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryFunction</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">UnaryFunction</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>第三个参数</strong>指定了算法应对所有给定元素执行什么任务。这个任务可以是任何操作，从操作元素到打印它们，可以通过简单的函数指针或强大的lambda表达式指定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">multBy10</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 将所有整数乘以10 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">multBy10</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 打印所有整数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">});</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上述代码中，<code>std::for_each</code>的第一个调用将向量中的每个整数乘以10，第二个调用则打印这些整数。通过使用不同的函数或lambda表达式作为第三个参数，你可以轻松地改变<code>std::for_each</code>的行为，从而实现高度灵活的操作。这种灵活性正是命令设计模式的核心优势之一。</p>
<p><strong>命令设计模式与策略设计模式的对比</strong></p>
<p>“等一下！”你可能会喊道，“你不是刚刚解释过标准库算法是通过策略设计模式实现的吗？这不是完全与之前的陈述矛盾吗？” 是的，你是对的。就在几页之前，我确实解释了<code>std::partition()</code>和<code>std::sort()</code>算法是通过策略设计模式实现的。</p>
<p>因此，我承认现在看起来像是自相矛盾。然而，我没有声称所有算法都基于策略模式。让我解释一下。</p>
<p>从结构上看，<strong>策略设计模式</strong>和<strong>命令设计模式</strong>是相同的：无论是使用动态多态还是静态多态。</p>
<p>从实现角度来看，<strong>策略</strong>和<strong>命令</strong>之间没有区别。两者的差异完全在于它们的设计意图。</p>
<p><strong>策略设计模式</strong>指定某件事应该如何完成，而<strong>命令设计模式</strong>则指定应该完成什么。</p>
<p>例如，考虑<code>std::partition()</code>和<code>std::for_each()</code>算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ForwardIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryPredicate</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">ForwardIt</span> <span class="n">partition</span><span class="p">(</span><span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryPredicate</span> <span class="n">p</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryFunction</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">UnaryFunction</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>std::partition()</code>算法中，你只能控制如何选择元素，而在<code>std::for_each()</code>算法中，你可以控制对给定范围内每个元素应用什么操作。</p>
<p>在形状示例中，你只能指定如何绘制某种形状，而在线程池示例中，你完全负责决定安排什么操作。</p>
<p>此外，还有两个指标可以帮助你区分这两种设计模式的应用：</p>
<p><strong>依赖注入</strong>：如果你有一个对象并通过动作（执行依赖注入）配置它，那么你很可能在使用策略设计模式。如果你不使用动作来配置对象，而是直接执行该动作，那么你很可能在使用<strong>命令设计模式</strong>。在我们的计算器示例中，我们没有传递动作来配置计算器，而是立即评估了该动作。因此，我们基于命令模式构建。</p>
<p>另外，我们也可以通过策略模式实现计算器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;CalculatorStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CalculatorStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">CalculatorStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">compute</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Calculator.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CalculatorStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Calculator</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CalculatorStrategy</span><span class="o">&gt;</span> <span class="n">operation</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">compute</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">current_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CalculatorStrategy</span><span class="o">&gt;</span> <span class="n">operation_</span><span class="p">;</span>  <span class="c1">// 需要一个默认值！ 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Calculator.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Calculator.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Calculator</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CalculatorStrategy</span><span class="o">&gt;</span> <span class="n">operation</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">operation_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">operation</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Calculator</span><span class="o">::</span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">current_</span> <span class="o">=</span> <span class="n">operation_</span><span class="o">-&gt;</span><span class="n">compute</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个计算器实现中，策略是通过<code>set()</code>函数注入的。<code>compute()</code>函数使用注入的策略进行计算。但是请注意，这种方法使得实现合理的撤销机制更加困难。</p>
<p><strong>撤销操作</strong>：如果你的动作提供了一个撤销操作来回滚它所做的工作，并封装了执行撤销所需的一切，那么你很可能在处理<strong>命令设计模式</strong>。</p>
<p>如果你的动作没有提供撤销操作，因为它专注于如何完成某事或缺乏回滚操作的信息，那么你很可能在处理<strong>策略设计模式</strong>。</p>
<p>然而，我要明确指出的是，缺少撤销操作并不能作为策略模式的结论性证据。如果意图是指定应该做什么，即使没有撤销操作，仍然可能是命令模式的一种实现。</p>
<p>例如，<code>std::for_each()</code>算法仍然期望一个命令，尽管不需要撤销操作。</p>
<p>撤销操作应被视为命令设计模式的一个可选特性，而不是定义性的特征。在我看来，撤销操作并不是命令设计模式的优势，而是一种纯粹的必要性：如果一个动作有完全自由做任何它想做的事情，那么只有这个动作本身才能回滚操作（当然，假设你不希望为每次调用命令存储完整的副本）。</p>
<p>我承认这两个模式之间没有明确的分界线，而且它们之间存在灰色地带。然而，争论某事物是命令还是策略并没有意义，甚至可能失去一些朋友。更重要的是利用它们提取实现细节和分离关注点的能力。两种设计模式都可以帮助你隔离变化和扩展，从而遵循<strong>单一职责原则</strong>（SRP）和<strong>开闭原则</strong>（OCP）。</p>
<p>毕竟，这可能是为什么在C++标准库中有如此多这两种设计模式的例子的原因。</p>
<p><strong>分析命令设计模式的不足之处</strong></p>
<p><strong>命令设计模式</strong>的优点类似于<strong>策略设计模式</strong>的优点：<strong>命令模式</strong>通过引入某种抽象（例如基类或概念）帮助你解耦具体任务的实现细节。这种抽象允许你轻松添加新任务。因此，命令模式同时满足了<strong>SRP</strong>和<strong>OCP</strong>。</p>
<p>然而，<strong>命令设计模式</strong>也有其缺点。与策略设计模式相比，其缺点列表相当短。唯一真正的缺点是由于额外的间接层导致的运行时性能开销，尤其是在通过基类实现命令模式时（经典的GoF风格）。再次强调，由你决定增加的灵活性是否超过了运行时性能的损失。</p>
<p>总之，就像策略设计模式一样，命令设计模式是设计模式目录中最基本和最有用的模式之一。你会在许多不同的情况下遇到命令模式的实现，无论是静态的还是动态的。因此，理解命令模式的意图、优点和缺点将在许多时候证明是有用的。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>应用Command设计模式，目的是抽象和封装一个（可能是可撤销的）操作。</li>
<li>请注意，命令和策略设计模式之间的界限是可变的。</li>
<li>对动态和静态应用程序都使用Command。</li>
</ul>
<h3 id="准则22优先使用值语义而非引用语义">准则22：优先使用值语义而非引用语义
</h3><p>在“<strong>准则19：使用策略模式隔离如何完成任务</strong>”和“<strong>准则21：使用命令模式隔离应该完成什么任务</strong>”中，我分别向你介绍了<strong>策略设计模式</strong>和<strong>命令设计模式</strong>。</p>
<p>在这两种情况下，示例都是基于经典的GoF风格构建的：它们通过继承层次结构使用动态多态性。这种经典面向对象的风格缺乏现代感，可以想象你现在可能已经因为咬指甲而惹恼了你的美甲师。</p>
<p>你可能会想：“难道没有另一种更好的方式来实现策略和命令模式吗？一种更‘现代’的方法？” 是的，放心；确实有。这种方法对于我们现在称之为 <strong>现代C++</strong> 的哲学非常重要，以至于它值得一个单独的指南来解释其优点。</p>
<p>我相信你的美甲师会理解这次小插曲的原因。</p>
<p><strong>GoF风格的不足：引用语义</strong></p>
<p>由四人组（Gang of Four）收集并在他们的书中介绍的<strong>设计模式</strong>是作为<strong>面向对象设计模式</strong>引入的。</p>
<p>他们书中描述的<strong>23种设计模式</strong>几乎都使用至少一个<strong>继承层次结构</strong>，因此牢牢扎根于<strong>面向对象编程领域</strong>。</p>
<p><strong>模板</strong>作为显而易见的第二选择，在GoF的书中并没有扮演任何角色，这种<strong>纯粹的面向对象风格</strong>就是我所称的<strong>GoF风格</strong>。</p>
<p>从今天的视角来看，这种风格可能显得老旧、过时，但我们需要记住这本书是在1994年10月发布的。那时，模板可能已经是语言的一部分（至少在《注释参考手册》(ARM)中有正式描述），但我们还没有与模板相关的惯用法，C++仍然普遍被视为一种面向对象的编程语言。因此，使用C++的常见方式是主要使用继承。</p>
<p>今天我们知道，<strong>GoF风格存在一些缺点</strong>。其中最重要且通常被提到最多的是<strong>性能问题</strong>：</p>
<ul>
<li>虚函数增加了运行时开销，并减少了编译器优化的机会。</li>
<li>小型多态对象的多次分配消耗额外的运行时间，导致内存碎片化，并导致缓存使用不佳。</li>
<li>数据的排列方式通常不利于数据访问方案。</li>
</ul>
<p><strong>性能</strong>确实不是<strong>GoF风格</strong>的强项。不进行全面讨论所有可能的GoF风格的不足之处，让我们关注另一个我认为特别有趣的缺点：<strong>GoF风格</strong>属于我们今天所说的<strong>引用语义</strong>（有时也称为指针语义）。</p>
<p>这种风格因其主要使用<strong>指针</strong>和<strong>引用</strong>来命名。</p>
<p>为了展示术语<strong>引用语义</strong>的含义及其通常带有的负面含义，让我们看一下以下使用C++20 <code>std::span</code> 类模板的代码示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;span&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; )</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">w</span><span class="p">{</span> <span class="n">v</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">s</span><span class="p">{</span> <span class="n">v</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>  <span class="c1">// 编译错误！   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>  <span class="c1">// 成功！  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 输出 ( 1 2 99 4 ); 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>  <span class="c1">// 成功！   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 输出 ? 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>print()</code> 函数展示了 <code>std::span</code> 的用途。<code>std::span</code> 类模板表示数组的抽象。</p>
<p><code>print()</code> 函数可以与任何类型的数组（内置数组、<code>std::array</code>、<code>std::vector</code> 等）一起使用，<br/>而不耦合到任何特定类型的数组。</p>
<p>在具有动态范围的 <code>std::span</code> 示例中（没有第二个模板参数表示数组大小），典型的 <code>std::span</code> 实现包含两个数据成员：<strong>指向数组第一个元素的指针 和 数组的大小</strong>。</p>
<p>因此，<code>std::span</code> 很容易复制，通常按值传递。除此之外，<code>print()</code> 只是遍历 <code>std::span</code> 的元素（在我们的例子中是整数）并通过 <code>std::cout</code> 打印它们。</p>
<p>在 <code>main()</code> 函数中，我们首先创建 <code>std::vector&lt;int&gt;</code> v 并立即填充整数 1、2、3 和 4。<br/>然后我们创建另一个 <code>std::vector</code> <strong>w</strong> 作为 <strong>v</strong> 的副本 和 <code>std::span</code> <strong>s</strong>。</p>
<p><strong>w</strong> 和 <strong>s</strong> 都被声明为 <code>const</code>，紧接着，我们尝试修改 <strong>w</strong> 和 <strong>s</strong> 在索引 2 处的值。<br/>尝试更改 w 失败并出现编译错误：w 被声明为 <code>const</code>，因此无法更改包含的元素。<br/>然而，尝试更改 s 则成功。尽管 s 被声明为 <code>const</code>，也不会出现编译错误。</p>
<p>原因是： <strong>s</strong> 不是 <strong>v</strong> 的副本，不代表一个值。相反，它代表对 v 的引用。<br/>它实际上充当指向 v 第一个元素的指针。因此，<code>const</code> 限定符在语义上等同于声明指针 <code>const</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">s</span><span class="p">{</span> <span class="n">v</span> <span class="p">};</span>  <span class="c1">// s 作为指向 v 第一个元素的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span><span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="p">};</span>   <span class="c1">// 等效语义
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然指针 <code>ptr</code> 不能被改变，并且在其生命周期内将始终指向 v 的第一个元素，但引用的整数可以轻松修改。<br/>要防止对整数进行赋值，需要为 <code>int</code> 添加额外的 <code>const</code> 限定符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">s</span><span class="p">{</span><span class="n">v</span><span class="p">};</span>   <span class="c1">// s 表示指向常量整数的常量指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span><span class="p">{</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="p">};</span>  <span class="c1">// 等效语义
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于指针和 <code>std::span</code> 的语义是等价的，<code>std::span</code> 显然属于引用语义的范畴。这带来了一些额外的风险，如 <code>main()</code> 函数剩余部分所示。下一步，我们打印 s 引用的元素。注意，你也可以直接传递向量 v，因为 <code>std::span</code> 提供了必要的转换构造函数来接受 <code>std::vector</code>。<code>print()</code> 函数将正确输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">(</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">99</span> <span class="mi">4</span> <span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为我们可以（并且现在数字 1 到 4 可能听起来有点无聊），我们现在将一组新数字赋给向量 v。诚然，选择 5、6、7、8 和 9 既不特别有创意也不有趣，但它会达到目的。紧接着，我们再次通过 s 写入第二个索引并再次打印 s 引用的元素。当然，我们期望输出是 <code>( 5 6 99 8 9 )</code>，但不幸的是并非如此。我们可能会得到以下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">(</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">99</span> <span class="mi">4</span> <span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也许你会完全震惊，并因此多出几根白发，也许你会感到惊讶，或者你会心知肚明地微笑并点头：是的，当然，未定义行为！</p>
<p>当我们将新值赋给 <code>std::vector</code> <strong>v</strong> 时，我们不仅改变了值，还改变了向量的大小。<br/>原本存储四个值的向量现在需要存储五个元素，因此，向量可能进行了重新分配，从而改变了其第一个元素的地址。<br/>不幸的是，<code>std::span</code> <strong>s</strong> 没有收到通知，并且仍然紧紧持有旧的第一个元素的地址。<br/>因此，当我们尝试通过 s 向 v 写入时，我们并不是写入当前的 v 数组，而是写入了一个已经被丢弃的内存区域，该区域曾经是 v 的内部数组。这是典型的未定义行为，也是引用语义的经典问题。</p>
<p>“嘿，你是不是在试图诋毁 <code>std::span</code>？”你问。不，我并不是在暗示 <code>std::span</code> 和 <code>std::string_view</code> 是不好的。</p>
<p>相反，我实际上非常喜欢这两个工具，因为它们提供了非常简单且廉价的抽象，分别用于各种数组和字符串。<br/>然而，请记住每个工具都有其优缺点。当我使用它们时，我会有意识地使用它们，完全意识到任何非拥有引用类型都需要仔细注意其所引用值的生命周期。例如，虽然我认为它们作为函数参数非常有用，但我倾向于不在数据成员中使用它们。生命周期问题的风险太高了。</p>
<p><strong>引用语义：第二个示例</strong></p>
<p>“当然，我知道这一点，”你争辩道。“我也不会长时间存储 <code>std::span</code>。然而，我仍然不相信引用和指针是个问题。” 好的，如果第一个例子还不足以让你震惊，我还有一个第二个例子。</p>
<p>这次我将使用 STL 算法之一 <code>std::remove()</code>。<br/><code>std::remove()</code> 算法接受三个参数：一个用于遍历以移除特定值的所有元素的范围的迭代器对，以及第三个表示要移除的值的参数。特别注意，第三个参数是通过常量引用传递的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">ForwardIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">ForwardIt</span> <span class="n">remove</span><span class="p">(</span> <span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>让我们来看下面的代码示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>  
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">));</span>   
</span></span><span class="line"><span class="cl"><span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="o">*</span><span class="n">pos</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们从初始化了一些随机数字的 <code>std::vector</code> v 开始。</p>
<p>现在我们感兴趣的是移除向量中代表最大值的所有元素。在我们的例子中，这个值是 42，并且在向量中出现了两次。执行移除的第一步是使用 <code>std::max_element()</code> 算法确定最大值。<code>std::max_element()</code> 返回指向最大值的迭代器。如果范围内有多个元素等同于最大元素，则返回指向第一个此类元素的迭代器。</p>
<p>移除最大值的第二步是对 <code>std::remove()</code> 的调用。我们通过 <code>begin(vec)</code> 和 <code>end(vec)</code> 传递元素范围，并通过解引用 <code>pos</code> 迭代器传递最大值。最后，我们通过调用成员函数 <code>erase()</code> 完成操作：我们删除由 <code>std::remove()</code> 算法返回的位置到向量末尾之间的所有值。这一系列操作通常被称为 erase-remove 惯用法。</p>
<p>我们期望从向量中移除两个 42，并因此期望得到以下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">(</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">3</span> <span class="mi">27</span> <span class="mi">4</span> <span class="o">-</span><span class="mi">8</span> <span class="mi">22</span> <span class="mi">37</span> <span class="mi">4</span> <span class="mi">18</span> <span class="mi">9</span> <span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，这个期望并不成立。相反，向量现在包含以下值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">( 1 -3 27 4 -8 22 42 37 18 9 )
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，向量仍然包含一个 42，但现在缺少了一个 4。这种行为不当的根本原因仍然是引用语义：通过将解引用的迭代器传递给 <code>remove()</code> 算法，我们隐式地指定了该位置存储的值应该被移除。然而，在移除了第一个 42 后，该位置现在存储的是值 4。<code>remove()</code> 算法会移除所有值为 4 的元素。因此，下一个被移除的值不是下一个 42，而是下一个 4，依此类推。</p>
<p>“好的，我明白了！但这个问题已经成为历史了！今天，我们不再使用 erase-remove 惯用法了。C++20 终于为我们提供了自由的 <code>std::erase()</code> 函数！” 我希望同意这个说法，但遗憾的是，我只能确认 <code>std::erase()</code> 函数的存在：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Alloc</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Alloc</span><span class="o">&gt;::</span><span class="n">size_type</span> 
</span></span><span class="line"><span class="cl"><span class="n">erase</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">U</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::erase()</code> 函数也通过常量引用传递其第二个参数，即要移除的值。因此，我刚才描述的问题仍然存在。解决这个问题的唯一方法是显式地确定最大元素并将其传递给 <code>std::remove()</code> 算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">greatest</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">greatest</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“你是不是在认真建议我们不要再使用<strong>引用参数</strong>了？” 不，绝对不是！当然你应该使用引用参数，例如出于性能考虑。<br/>然而，我希望引起一定的意识，希望你现在理解了问题所在：引用，尤其是<strong>指针</strong>，让我们的生活变得复杂得多，理解代码变得更加困难，因此更容易在代码中引入错误。<br/>特别是指针引发了很多问题：它是一个有效的指针还是 <code>nullptr</code>？谁拥有指针背后的资源并管理其生命周期？当然，由于我们扩展了工具箱并拥有了<strong>智能指针</strong>，生命周期问题不再是大问题。<br/>正如核心指南 R.3 清楚指出的那样：<strong>原始指针</strong>（<code>T*</code>）是非拥有的。</p>
<p>结合知道<strong>智能指针</strong>承担了所有权的责任，这大大清理了指针的语义。<br/>但是，尽管<strong>智能指针</strong>当然是非常有价值的工具，并且因其优点而被誉为“现代 C++”的重大成就，它们最终只是修补引用语义在我们推理代码能力上撕开的漏洞。<br/>是的，引用语义使理解代码和推理重要细节变得更加困难，因此是我们希望避免的东西。</p>
<p><strong>现代C++哲学：值语义</strong></p>
<p>“但是等等，”我能听到你反驳，“我们还有什么其他选择？我们应该怎么做？我们如何处理继承层次结构？我们不能避免使用指针，对吧？” 如果你有类似的想法，那么我有一个非常好的消息告诉你：是的，有更好的解决方案。</p>
<p>这个解决方案使你的代码更容易理解、推理，并且可能对性能产生积极影响（还记得我们讨论过的引用语义的负面性能影响）。这个解决方案就是值语义。</p>
<p>值语义在C++中并不是新鲜事物。这个想法已经是原始STL的一部分。让我们考虑最著名的STL容器之一 <code>std::vector</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">v2</span><span class="p">{</span> <span class="n">v1</span> <span class="p">};</span>  
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span> <span class="n">v1</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span> <span class="n">v1</span> <span class="o">!=</span> <span class="n">v2</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">v3</span><span class="p">{</span> <span class="n">v1</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl"><span class="n">v3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>  <span class="c1">// 编译错误!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们从一个名为 <code>v1</code> 的 <code>std::vector</code> 开始，包含五个整数。接下来，我们创建 <code>v1</code> 的副本，称为 <code>v2</code>。向量 <code>v2</code> 是一个真正的副本，有时也称为深拷贝，它现在拥有自己的内存块和整数，不引用 <code>v1</code> 中的整数。我们可以通过比较两个向量来验证这一点（它们被证明是相等的），但第一个元素的地址不同。修改 <code>v2</code> 中的一个元素会导致两个向量不再相等。是的，两个向量都有自己的数组，它们不共享内容，即不试图“优化”复制操作。</p>
<p>你可能听说过一些技术，例如写时复制（copy-on-write）。确实，在C++11之前，这曾是 <code>std::string</code> 的常见实现。然而，自C++11以来，由于C++标准中的要求，<code>std::string</code> 不再允许使用写时复制。原因是这种“优化”在一个多线程世界中很容易变成劣化。因此，我们可以确信复制构造会创建一个真正的副本。</p>
<p>最后，我们创建另一个名为 <code>v3</code> 的副本，并将其声明为 <code>const</code>。如果我们尝试修改 <code>v3</code> 的值，将会得到编译错误。这表明一个 <code>const</code> 向量不仅防止添加和删除元素，而且所有元素也被视为 <code>const</code>。从语义角度来看，这意味着 <code>std::vector</code> 和任何STL容器一样，被视为一个值。是的，一个值，就像一个 <code>int</code>。如果我们复制一个值，我们不会只复制部分值，而是整个值。如果我们使一个值 <code>const</code>，它不仅仅是部分 <code>const</code>，而是完全 <code>const</code>。这就是值语义的基本原理。我们已经看到了一些优点：与指针和引用相比，值更容易推理。例如，改变一个值不会影响其他值。变化是局部的，而不是发生在别处。这是一个编译器用于其优化工作的优势。此外，值不需要我们考虑所有权问题。值负责自己的内容。值还使得思考线程问题变得更加容易。这并不意味着没有问题了（你希望如此！），但代码肯定更容易理解。值不会给我们留下很多疑问。</p>
<p>“好的，我明白了代码清晰性的要点，”你争辩道，“但是关于性能呢？频繁处理复制操作是不是非常昂贵？” 是的，你是正确的；复制操作可能是昂贵的。然而，只有当它们真正发生时才会昂贵。在实际代码中，我们通常可以依赖于复制省略、移动语义和按引用传递。此外，我们已经看到，从性能角度来看，值语义可能会给我们带来性能提升。当然，我指的是“指南17：考虑使用 <code>std::variant</code> 实现访问者模式”中的 <code>std::variant</code> 示例。在这个例子中，使用 <code>std::variant</code> 类型的值显著提高了我们的性能，因为减少了指针导致的间接寻址和更好的内存布局及访问模式。</p>
<p>让我们来看第二个示例。这次我们考虑以下 <code>to_int()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">to_int</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数解析给定的字符串（是的，我使用 <code>std::string_view</code> 以提高性能）并将其转换为 <code>int</code>。对我们来说最有趣的问题是如何处理错误，或者说，如果字符串无法转换为 <code>int</code>，函数应该做什么。第一个选项是在这种情况下返回 0。然而，这种方法有问题，因为 0 是 <code>to_int()</code> 函数的有效返回值。我们将无法区分成功和失败。</p>
<p>另一种可能的方法是抛出异常。尽管异常可能是C++原生的错误信号工具，但对于这个问题，根据个人风格和偏好，这可能显得过于复杂。同时，考虑到很大一部分C++社区不能使用异常，这一选择可能会限制函数的可用性。</p>
<p>第三种可能性是稍微改变签名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">to_int</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在函数接受一个可变 <code>int</code> 的引用作为第二个参数，并返回一个 <code>bool</code>。如果成功，函数返回 <code>true</code> 并设置传入的整数；如果失败，函数返回 <code>false</code> 并保持整数不变。虽然这对你来说似乎是一个合理的折衷方案，但我认为我们现在进一步进入了引用语义的领域（包括所有潜在的误用）。同时，代码的清晰度有所下降：返回结果最自然的方式是通过返回值，但现在结果是由输出值产生的。例如，这阻止我们将结果赋值给 <code>const</code> 值。因此，我认为这是迄今为止最不利的方法。</p>
<p>第四种方法是通过指针返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">to_int</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从语义上讲，这种方法非常吸引人：如果成功，函数返回指向 <code>int</code> 的有效指针；如果失败，返回 <code>nullptr</code>。因此，代码的清晰度得到了改善，因为我们能清楚地区分这两种情况。然而，我们在动态内存分配和使用 <code>std::unique_ptr</code> 进行生命周期管理方面付出了代价，仍然停留在引用语义的领域。所以问题是：如何利用语义上的优势但仍坚持值语义？解决方案的形式是 <code>std::optional</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">to_int</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::optional</code> 是一种值类型，表示另一个值，在我们的例子中是 <code>int</code>。因此，<code>std::optional</code> 可以取 <code>int</code> 能取的所有值。<code>std::optional</code> 的特殊之处在于它为封装的值增加了一个状态，表示无值的状态。因此，我们的 <code>std::optional</code> 是一个可能存在也可能不存在的 <code>int</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;charconv&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">to_int</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">oi</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">i</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="k">const</span> <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">from_chars</span><span class="p">(</span><span class="n">sv</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">sv</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">sv</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">i</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">ec</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">oi</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">oi</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="s">&#34;42&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">optional_int</span> <span class="o">=</span> <span class="n">to_int</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// ... 成功：返回的 std::optional 包含一个整数值 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">else</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// ... 失败：返回的 std::optional 不包含值 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从语义上讲，这等同于指针方法，但我们不需要支付动态内存分配的成本，也不需要处理生命周期管理。这个解决方案语义清晰、易于理解且高效。</p>
<p><strong>使用值语义实现设计模式</strong></p>
<p>“那设计模式呢？”你问。“几乎所有的GoF模式都基于继承层次结构，因此是引用语义。我们应该如何处理这个问题？” 这是一个非常好的问题。并且为我们提供了一个完美的桥梁到下一个指南。简短的回答是：你应该优先使用值语义来实现设计模式。是的，认真地说！这些解决方案通常会带来更全面、可维护的代码，并且（通常）具有更好的性能。</p>
<h3 id="准则23优先使用基于值的策略和命令实现">准则23：优先使用基于值的策略和命令实现
</h3><p>在“<strong>准则19：使用策略模式隔离操作方式</strong>”中，我向你介绍了<strong>策略设计模式</strong>；在“<strong>准则21：使用命令模式隔离操作内容</strong>”中，我介绍了<strong>命令设计模式</strong>。</p>
<p>我展示了这两种设计模式是你日常工具箱中的重要解耦工具。然而，在“指南22：优先使用值语义而非引用语义”中，我提出了使用值语义比引用语义更好的观点。这当然引发了一个问题：如何将这一智慧应用于策略和命令设计模式？这里有一个可能的基于值语义的解决方案：利用 <code>std::function</code> 的抽象能力。</p>
<p><strong><code>std::function</code> 简介</strong></p>
<p>如果你还没有听说过 <code>std::function</code>，让我来介绍一下。<code>std::function</code> 是对可调用对象（例如函数指针、函数对象或lambda表达式）的抽象。唯一的要求是该可调用对象满足特定的函数类型，这是作为唯一的模板参数传递给 <code>std::function</code> 的。以下代码给出了一个印象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;foo: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个默认的 std::function 实例。调用它会导致 std::bad_function_call 异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 将一个可调用对象赋值给 &#39;f&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lambda: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 使用整数 &#39;1&#39; 调用 &#39;f&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// 将 &#39;f&#39; 复制到 &#39;g&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="n">f</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>  <span class="c1">// 将不同的可调用对象赋值给 &#39;f&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// 使用整数 &#39;2&#39; 调用 &#39;f&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// 使用整数 &#39;3&#39; 调用 &#39;g&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>main()</code> 函数中，我们创建了一个名为 <code>f</code> 的 <code>std::function</code> 实例。模板参数指定了所需的函数类型。在我们的例子中，这是 <code>void(int)</code>。“函数类型……”你说。“你不指的是函数指针类型吗？” 好吧，由于这可能是你以前很少见过的东西，让我解释一下什么是函数类型，并将其与你可能更常见的函数指针类型进行对比。以下示例同时使用了函数类型和函数指针类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">FunctionType</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">FunctionPointerType</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1">// using FunctionPointerType = FunctionType*;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>第一行显示了一个函数类型。此类型表示任何接受 <code>double</code> 并返回 <code>double</code> 的函数。这种函数类型的例子包括 <code>std::sin</code>、<code>std::cos</code>、<code>std::log</code> 或 <code>std::sqrt</code> 的相应重载。第二行显示了一个函数指针类型。注意括号中的小星号——这使得它成为指针类型。此类型表示函数类型的 <code>FunctionType</code> 函数的地址。因此，函数类型和函数指针类型之间的关系非常类似于 <code>int</code> 和指向 <code>int</code> 的指针之间的关系：虽然有许多 <code>int</code> 值，但指向 <code>int</code> 的指针存储的是恰好一个 <code>int</code> 的地址。</p>
<p>回到 <code>std::function</code> 示例：最初，实例是空的，因此你不能调用它。如果你仍然尝试这样做，<code>std::function</code> 实例会抛出 <code>std::bad_function_call</code> 异常。最好别惹它。让我们为它分配一些满足函数类型要求的可调用对象，例如一个（可能是有状态的）lambda。这个lambda接受一个 <code>int</code> 并不返回任何东西。相反，它通过描述性的输出消息打印出它已被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nl">lambda</span><span class="p">:</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>好的，这工作得很好。让我们试试别的：我们现在通过 <code>f</code> 创建另一个 <code>std::function</code> 实例 <code>g</code>。然后我们将另一个可调用对象分配给 <code>f</code>。这次，我们分配了 <code>foo()</code> 函数的指针。同样，这个可调用对象满足 <code>std::function</code> 实例的要求：它接受一个 <code>int</code> 并不返回任何东西。直接在分配后，你用整数 <code>2</code> 调用 <code>f</code>，这触发了预期的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nl">foo</span><span class="p">:</span> <span class="mi">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这可能是一个简单的例子。然而，下一个函数调用要有趣得多。如果你用整数 <code>3</code> 调用 <code>g</code>，输出表明 <code>std::function</code> 坚实地基于值语义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nl">lambda</span><span class="p">:</span> <span class="mi">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在初始化 <code>g</code> 期间，实例 <code>f</code> 被复制。并且它是按照值应该被复制的方式复制的：它没有执行“浅拷贝”，这会导致当 <code>f</code> 随后改变时影响 <code>g</code>，而是执行了一个完整的复制（深拷贝），包括lambda的复制。因此，改变 <code>f</code> 不会影响 <code>g</code>。这就是值语义的好处：代码简单直观，你不必担心意外破坏其他地方的内容。</p>
<p>在此基础上，<code>std::function</code> 的功能可能会让人感觉有点像魔法：它是如何能够接受任何类型的可调用对象，包括像lambda这样的东西？它是如何存储任何可能的类型，甚至是它不知道的类型，即使这些类型显然没有任何共同点？不用担心：在第8章，我会详细介绍一种称为类型擦除的技术，它是 <code>std::function</code> 背后的魔法。</p>
<p><strong>重构绘制形状的代码</strong></p>
<p><code>std::function</code> 提供了我们需要的一切来重构我们在“指南19：使用策略模式隔离操作方式”中的绘图示例。它表示单个可调用对象的抽象，这正是我们替换 <code>DrawCircleStrategy</code> 和 <code>DrawSquareStrategy</code> 层次结构所需要的，每个层次结构都包含一个单一的虚函数。因此，我们依赖于 <code>std::function</code> 的抽象能力：</p>
<p>Shape.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>Circle.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DrawStrategy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查给定半径的有效性以及 &#39;std::function&#39; 实例是否不为空 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>Square.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DrawStrategy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">),</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查给定边长的有效性以及 &#39;std::function&#39; 实例是否不为空 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，在 <code>Circle</code> 类中，我们为期望的 <code>std::function</code> 类型添加了一个类型别名（）。这个 <code>std::function</code> 类型表示任何可以接受 <code>Circle</code> 对象和可能几个与绘图相关的参数，并且不返回任何东西的可调用对象。当然，我们在 <code>Square</code> 类中也添加了相应的类型别名（）。在 <code>Circle</code> 和 <code>Square</code> 的构造函数中，我们现在接受一个 <code>std::function</code> 类型的实例（）作为指向策略基类（<code>DrawCircleStrategy</code> 或 <code>DrawSquareStrategy</code>）指针的替代。这个实例立即被移动（）到数据成员 <code>drawer_</code> 中，该成员也是 <code>DrawStrategy</code> 类型（）。</p>
<p>“嘿，为什么你通过值传递 <code>std::function</code> 实例？这不是非常低效吗？我们应该优先通过引用传递吗？” 简短回答：不，通过值传递并不低效，而是对替代方案的一种优雅妥协。我承认，这可能令人惊讶。由于这是一个值得注意的实现细节，让我们仔细看看。</p>
<p>如果我们使用常量引用，我们会遇到 rvalue 不必要地被复制的缺点。如果传递给我们的是一个 rvalue，这个 rvalue 将绑定到（lvalue）常量引用。然而，当我们把这个常量引用传递给数据成员时，它会被复制。这不是我们的意图：我们自然希望它是移动的。简单的原因是我们不能从 <code>const</code> 对象移动（即使使用 <code>std::move</code>）。因此，为了高效处理 rvalue，我们必须提供接受 rvalue 引用的 <code>Circle</code> 和 <code>Square</code> 构造函数重载（<code>DrawStrategy&amp;&amp;</code>）。为了性能，我们将为 <code>Circle</code> 和 <code>Square</code> 提供两个构造函数。</p>
<p>提供两个构造函数（一个用于 lvalue，一个用于 rvalue）确实有效且高效，但我不会称之为优雅。此外，我们应该让同事避免处理这些问题。</p>
<p>为此，我们利用了 <code>std::function</code> 的实现。<code>std::function</code> 提供了拷贝构造函数和移动构造函数，因此我们知道它可以高效地移动。当我们通过值传递 <code>std::function</code> 时，要么会调用拷贝构造函数，要么会调用移动构造函数。如果我们传递的是一个 lvalue，拷贝构造函数会被调用，复制 lvalue。然后我们将这个副本移动到数据成员中。总共，我们将执行一次拷贝和一次移动来初始化 <code>drawer_</code> 数据成员。如果我们传递的是一个 rvalue，移动构造函数会被调用，移动 rvalue。结果参数策略将被移动到数据成员 <code>drawer_</code> 中。总共，我们将执行两次移动操作来初始化 <code>drawer_</code> 数据成员。因此，这种形式代表了一种很好的妥协：它优雅，几乎没有效率上的差异。</p>
<p>一旦我们重构了 <code>Circle</code> 和 <code>Square</code> 类，我们可以以任何形式实现不同的绘图策略（作为函数、函数对象或 lambda）。例如，我们可以实现以下 <code>OpenGLCircleStrategy</code> 作为函数对象：</p>
<p>OpenGLCircleStrategy.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">OpenGLCircleStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OpenGLCircleStrategy</span><span class="p">(</span><span class="cm">/* Drawing related arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 绘图相关的数据成员，如颜色、纹理等 */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>唯一需要遵循的约定是我们需要提供一个调用操作符，该操作符接受一个 <code>Circle</code> 和可能几个与绘图相关的参数，并且不返回任何东西（满足函数类型 <code>void(Circle const&amp;, /*…*/)</code>）。</p>
<p>假设类似的实现用于 <code>OpenGLSquareStrategy</code>，我们现在可以创建不同种类的形状，配置所需的绘图行为，并最终绘制它们：</p>
<p>main.cpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;OpenGLCircleStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;OpenGLSquareStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Shapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shapes</span> <span class="n">shapes</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一些形状，每个形状都配备了相应的 OpenGL 绘图策略 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="n">OpenGLCircleStrategy</span><span class="p">(</span><span class="cm">/*...red...*/</span><span class="p">)));</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">OpenGLSquareStrategy</span><span class="p">(</span><span class="cm">/*...green...*/</span><span class="p">)));</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">4.1</span><span class="p">,</span> <span class="n">OpenGLCircleStrategy</span><span class="p">(</span><span class="cm">/*...blue...*/</span><span class="p">)));</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制所有形状 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>main()</code> 函数与使用经典策略实现的原始实现非常相似（参见“指南19：使用策略模式隔离操作方式”）。然而，这种非侵入式、无基类的方法进一步减少了耦合。这在解决方案的依赖关系图中变得明显（见图5-9）：我们可以以任何形式实现绘图功能（作为自由函数、函数对象或 lambda），并且不必遵守基类的要求。此外，通过 <code>std::function</code>，我们自动反转了依赖关系（参见“指南9：注意抽象的所有权”）。</p>
<p><strong>性能基准测试</strong></p>
<p>“我喜欢这种灵活性、自由度。这太棒了！但是性能呢？” 是的，就像一个真正的C++开发者会说的那样。当然，性能非常重要。但在展示性能结果之前，让我先提醒你我们用来获取表4-2（“指南16：使用访问者模式扩展操作”）数据的基准场景。对于基准测试，我实现了四种不同类型的形状（圆形、正方形、椭圆和矩形）。再次运行25,000次平移操作在10,000个随机创建的形状上。我使用了GCC 11.1和Clang 11.1两个编译器，并且只添加了 <code>-O3</code> 和 <code>-DNDEBUG</code> 编译标志。平台是搭载8核Intel Core i7处理器（3.8 GHz）、64 GB内存的macOS Big Sur（版本11.4）。</p>
<p>有了这些信息，你就可以准备好查看性能结果了。表5-1展示了基于策略实现的绘图示例以及使用 <code>std::function</code> 的解决方案的性能数字。</p>
<p><strong>表5-1 不同策略实现的性能结果</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>策略实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向对象解决方案</td>
<td>1.5205 s</td>
<td>1.1480 s</td>
</tr>
<tr>
<td>使用 <code>std::function</code></td>
<td>2.1782 s</td>
<td>1.4884 s</td>
</tr>
<tr>
<td>手动实现 <code>std::function</code></td>
<td>1.6354 s</td>
<td>-</td>
</tr>
<tr>
<td>经典策略实现</td>
<td>1.4465 s</td>
<td>1.6372 s</td>
</tr>
</tbody>
</table></div>
<p>为了参考，第一行显示了来自“指南15：设计以增加类型或操作”的面向对象解决方案的性能。如你所见，这个解决方案提供了最佳性能。然而，这不是意外的结果：由于策略设计模式无论实际实现如何都会引入额外的开销，因此性能预期会有所降低。</p>
<p>不过，意想不到的是，<code>std::function</code> 实现带来了性能开销（特别是在GCC的情况下显著）。但请稍等，在你将这种方法扔进心理垃圾桶之前，请考虑第三行。它展示了使用类型擦除技术的手动实现 <code>std::function</code>，这项技术将在第8章解释。这个实现表现得更好，实际上与经典策略设计模式的实现一样好（或对Clang来说几乎一样好）。这一结果表明问题不在于值语义，而是 <code>std::function</code> 的具体实现细节。总之，从性能角度来看，基于值语义的方法并不比经典方法差，反而如前所述，它改善了许多代码的重要方面。</p>
<p><strong>分析 <code>std::function</code> 解决方案的不足</strong></p>
<p>总体而言，策略设计模式的 <code>std::function</code> 实现提供了许多好处。首先，你的代码变得更清晰易读，因为你不必处理指针及其相关的生命周期管理（例如，使用 <code>std::unique_ptr</code>），也不必经历通常的引用语义问题（参见“指南22：优先使用值语义而非引用语义”）。其次，你促进了松耦合。在这种情况下，<code>std::function</code> 起到了编译防火墙的作用，保护你免受不同策略实现的实现细节影响，同时为开发人员提供了巨大的灵活性来实现不同的策略解决方案。</p>
<p>尽管有这些优点，没有一种解决方案是没有缺点的——即使是 <code>std::function</code> 方法也有其劣势。我已经指出，如果你依赖标准实现，可能会存在性能劣势。虽然有一些解决方案可以最小化这种影响（参见第8章），但它仍然是你在代码库中需要考虑的因素。</p>
<p>还有一个设计相关的问题。<code>std::function</code> 只能替换单个虚函数。如果你需要抽象多个虚函数，这种情况可能出现在你想使用策略设计模式配置多个方面时，或者你需要命令设计模式中的 <code>undo()</code> 函数时，你将不得不使用多个 <code>std::function</code> 实例。这不仅会因为多个数据成员而增加类的大小，还会因为如何优雅地处理传递多个 <code>std::function</code> 实例的问题而带来接口负担。因此，<code>std::function</code> 方法最适合用于替换单一或非常少量的虚函数。不过，这并不意味着你不能对多个虚函数使用基于值的方法：如果遇到这种情况，可以考虑通过直接应用 <code>std::function</code> 技术到你的类型上来泛化该方法。我将在第8章解释如何做到这一点。</p>
<p>尽管有这些不足之处，基于值语义的方法被证明是策略设计模式的一个绝佳选择。命令设计模式也是如此。因此，请记住这条指南作为迈向现代C++的重要步骤。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>考虑使用 <code>std::function</code> 来实现策略或命令设计模式。</li>
<li>注意 <code>std::function</code> 的性能劣势。</li>
<li>了解类型擦除是策略和命令设计模式中值语义方法的一般化。</li>
</ul>
<h2 id="第六章-适配器观察者和crtp设计模式">第六章 适配器、观察者和CRTP设计模式
</h2><p>在本章中，我们将注意力转向三个必须了解的设计模式：两个GoF（Gang of Four，四人组）设计模式——适配器（Adapter）和观察者（Observer），以及奇特的递归模板模式（Curiously Recurring Template Pattern, CRTP）设计模式。</p>
<p><strong>准则24：使用适配器标准化接口</strong></p>
<p>在“准则24：使用适配器标准化接口”中，我们将讨论如何通过适配接口使不兼容的事物协同工作。为此，我将向你展示适配器设计模式及其在继承层次结构和泛型编程中的应用。你还将获得不同类型适配器的概述，包括对象适配器、类适配器和函数适配器。</p>
<p><strong>准则25：应用观察者作为抽象通知机制</strong></p>
<p>在“准则25：应用观察者作为抽象通知机制”中，我们将讨论如何观察状态变化并接收相关通知。在此背景下，我将向你介绍观察者设计模式，这是最著名且最常用的模式之一。我们将讨论经典的GoF风格观察者模式，以及如何在现代C++中实现观察者模式。</p>
<p><strong>准则26：使用CRTP引入静态类型分类</strong></p>
<p>在“准则26：使用CRTP引入静态类型分类”中，我们将关注CRTP。我将向你展示如何使用CRTP定义一组相关类型的编译时关系，以及如何正确实现CRTP基类。</p>
<p><strong>准则27：使用CRTP创建静态混合类</strong></p>
<p>在“准则27：使用CRTP创建静态混合类”中，我将继续讲述CRTP的应用，展示如何使用CRTP创建编译时混合类。我们还将看到语义继承与技术继承之间的区别：语义继承用于创建抽象，而技术继承仅作为实现细节，用于提高技术上的优雅性和便利性。</p>
<h3 id="准则24使用适配器标准化接口">准则24：使用适配器标准化接口
</h3><p>假设你已经实现了“准则3：分离接口以避免人为耦合”中的文档示例，并且因为你严格遵循接口隔离原则（ISP），你对它的运作方式相当满意：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">JSONExportable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="o">~</span><span class="n">JSONExportable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Serializable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="o">~</span><span class="n">Serializable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span> 
</span></span><span class="line"><span class="cl">   <span class="o">:</span> <span class="k">public</span> <span class="n">JSONExportable</span> 
</span></span><span class="line"><span class="cl">   <span class="p">,</span> <span class="k">public</span> <span class="n">Serializable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，有一天你需要引入Pages文档格式。当然，它与你已有的Word文档格式相似，但不幸的是，你不熟悉Pages格式的具体细节。更糟糕的是，由于你有很多其他事情要做，没有太多时间去熟悉这种格式。</p>
<p>幸运的是，你知道有一个相当合理的开源实现——OpenPages类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OpenPages</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">void</span> <span class="n">convertToBytes</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exportToJSONFormat</span><span class="p">(</span><span class="n">OpenPages</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pages</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从好的方面来看，这个类几乎提供了你所需的一切：一个用于序列化文档内容的<code>convertToBytes()</code>成员函数，以及一个将Pages文档转换为JSON格式的自由函数<code>exportToJSONFormat()</code>。不幸的是，它不符合你的接口期望：你希望有一个<code>serialize()</code>成员函数而不是<code>convertToBytes()</code>成员函数。并且你希望有一个<code>exportToJSON()</code>成员函数而不是自由函数<code>exportToJSONFormat()</code>。最终，第三方类并没有继承自你的<code>Document</code>基类，这意味着你无法轻松地将其整合到现有的类层次结构中。不过，这个问题有一个解决方案：使用适配器设计模式进行无缝集成。</p>
<p><strong>使用适配器设计模式进行无缝集成</strong></p>
<p>为了使<code>OpenPages</code>类适应你的现有接口，你可以创建一个适配器类。适配器类将充当桥梁，使得<code>OpenPages</code>类能够符合你的接口要求。以下是具体的实现方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 适配器类，使OpenPages类符合Serializable和JSONExportable接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">OpenPagesAdapter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">JSONExportable</span><span class="p">,</span> <span class="k">public</span> <span class="n">Serializable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">OpenPages</span> <span class="n">openPages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OpenPagesAdapter</span><span class="p">(</span><span class="k">const</span> <span class="n">OpenPages</span><span class="o">&amp;</span> <span class="n">op</span><span class="p">)</span> <span class="o">:</span> <span class="n">openPages</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 实现Serializable接口的serialize方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">openPages</span><span class="p">.</span><span class="n">convertToBytes</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将convertToBytes的结果写入ByteStream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 这里假设有一些逻辑将字节数据写入bs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 实现JSONExportable接口的exportToJSON方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">exportToJSONFormat</span><span class="p">(</span><span class="n">openPages</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用适配器类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OpenPages</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">OpenPagesAdapter</span> <span class="n">adapter</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 现在可以像使用Document类一样使用adapter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ByteStream</span> <span class="n">bs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">adapter</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">adapter</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这种方式，你可以无缝地将<code>OpenPages</code>类集成到你的现有系统中，而无需修改其原始实现。适配器类起到了桥梁的作用，使得<code>OpenPages</code>类能够符合你的接口标准。</p>
<p><strong>适配器设计模式解析</strong></p>
<p>适配器设计模式是经典的GoF（四人组）设计模式之一。它专注于标准化接口，并帮助非侵入性地向现有的继承层次结构中添加功能。</p>
<p><strong>意图：</strong> “将一个类的接口转换为客户期望的另一个接口。适配器使得原本由于接口不兼容而无法协同工作的类能够一起工作。”</p>
<p>图6-1展示了你的适配器场景的UML图：你已经有了<code>Document</code>基类（我们暂时忽略<code>JSONExportable</code>和<code>Serializable</code>接口），并且已经实现了几种不同类型的文档（例如，使用<code>Word</code>类）。这个层次结构的新成员是<code>Pages</code>类。</p>
<p><code>Pages</code>类充当第三方<code>OpenPages</code>类的包装器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Pages</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">void</span> <span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">exportToJSONFormat</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">pages</span><span class="p">.</span><span class="n">convertToBytes</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">OpenPages</span> <span class="n">pages</span><span class="p">;</span>  <span class="c1">// 对象适配器的例子 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Pages</code>通过将调用转发到相应的<code>OpenPages</code>函数来实现<code>Document</code>接口：对<code>exportToJSON()</code>的调用被转发到自由函数<code>exportToJSONFormat()</code>，而对<code>serialize()</code>的调用则被转发到成员函数<code>convertToBytes()</code>。</p>
<p>有了<code>Pages</code>类，你可以轻松地将第三方实现集成到现有的层次结构中。非常容易做到这一点：你可以在不修改其任何代码的情况下进行集成。这种非侵入性的特性正是适配器设计模式的最大优势之一：任何人都可以通过添加适配器来适应一个接口以匹配另一个现有接口。</p>
<p>在这种情况下，<code>Pages</code>类作为对<code>OpenPages</code>类实际实现细节的抽象。因此，适配器设计模式将接口的关注点与实现细节分离。这很好地符合单一职责原则（SRP），并与开闭原则（OCP）的意图相契合（参见“指南2：为变化设计”和“指南5：为扩展设计”）。</p>
<p>某种程度上，<code>Pages</code>适配器作为一个间接层，从一组函数映射到另一组函数。请注意，严格来说，并不一定需要将一个函数映射到另一个函数。相反，你可以灵活地决定如何将预期的函数集映射到可用的函数集。因此，适配器并不一定代表一对一的关系，也可以支持一对多的关系。</p>
<p>假设你有以下两个类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 第三方库提供的类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">OpenPages</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">convertToBytes</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exportToJSONFormat</span><span class="p">(</span><span class="n">OpenPages</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pages</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以及你已有的<code>Document</code>基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了使<code>OpenPages</code>类适应<code>Document</code>接口，你可以创建一个适配器类<code>Pages</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Pages</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Document</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">OpenPages</span> <span class="n">pages</span><span class="p">;</span>  <span class="c1">// 对象适配器的例子 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">exportToJSONFormat</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">pages</span><span class="p">.</span><span class="n">convertToBytes</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，<code>Pages</code>类通过将<code>Document</code>接口的方法转发给<code>OpenPages</code>类的方法，实现了适配器的功能。具体来说：</p>
<ul>
<li><code>exportToJSON()</code>方法被转发到自由函数<code>exportToJSONFormat()</code>。</li>
<li><code>serialize()</code>方法被转发到<code>OpenPages</code>类的<code>convertToBytes()</code>方法。</li>
</ul>
<p>这样，<code>Pages</code>类就可以无缝地融入你的现有系统中，而无需修改<code>OpenPages</code>类的原始实现。适配器设计模式的这种灵活性使其成为解决接口不兼容问题的强大工具，特别是在需要集成第三方库或旧有系统时。</p>
<p><strong>对象适配器与类适配器</strong></p>
<p><code>Pages</code>类是一个所谓的对象适配器的例子。这个术语指的是你存储了被包装类型的实例。或者，如果被包装类型是某个继承层次结构的一部分，你可以存储该层次结构基类的指针。这将允许你使用对象适配器处理所有属于该层次结构的类型，从而大大提高了对象适配器的灵活性。</p>
<p>相比之下，还有一种实现所谓的类适配器的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Pages</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Document</span> 
</span></span><span class="line"><span class="cl">            <span class="p">,</span> <span class="k">private</span> <span class="n">OpenPages</span>  <span class="c1">// 类适配器的例子   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">void</span> <span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">exportToJSONFormat</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="o">-&gt;</span><span class="n">convertToBytes</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种方式中，不是存储被适配类型的实例，而是通过（可能非公开地）继承它，并相应地实现预期接口。然而，正如在“指南20：优先组合而非继承”中讨论的那样，基于组合构建通常是更好的选择。通常情况下，对象适配器比类适配器更灵活，因此应优先选择对象适配器。只有在以下几种情况下，你可能会更倾向于使用类适配器：</p>
<ol>
<li>如果你需要覆盖一个虚函数。</li>
<li>如果你需要访问一个受保护的成员函数。</li>
<li>如果你需要适应的类型在另一个基类之前构造。</li>
<li>如果你需要共享一个共同的虚基类或覆盖虚基类的构造。</li>
<li>如果你可以从空基类优化（EBO）中获得显著优势。</li>
</ol>
<p>否则，在大多数情况下，你应该优先选择对象适配器。</p>
<p><strong>关于命名的讨论</strong></p>
<p>“我喜欢这个设计模式——它很强大。但是，我刚想起来你建议在代码中使用设计模式的名字来传达意图。这个类不应该叫做<code>PagesAdapter</code>吗？” 你提出了一个很好的观点。我很高兴你记得“指南14：使用设计模式的名字来传达意图”，确实我在其中提到设计模式的名字有助于理解代码。我承认在这个例子中，我对两种命名约定都持开放态度。虽然我看到了<code>PagesAdapter</code>这个名字的优点，因为它立即传达了你使用了适配器设计模式，但我并不认为有必要明确说明这个类是一个适配器。对我来说，适配器在这里更像是一个实现细节：我不需要知道<code>Pages</code>类没有自己实现所有细节，而是使用了<code>OpenPages</code>类。这就是为什么我说要“考虑使用这个名字”。你应该根据具体情况决定。</p>
<p><strong>标准库中的例子</strong></p>
<p>适配器设计模式的一个有用应用是标准化不同种类容器的接口。假设我们有以下的<code>Stack</code>基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Stack.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Stack</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Stack</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个<code>Stack</code>类提供了必要的接口来访问栈顶元素、检查栈是否为空、查询栈的大小、将元素压入栈以及移除栈顶元素。这个基类现在可以用于为各种数据结构实现不同的适配器，例如<code>std::vector</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;VectorStack.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Stack.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">VectorStack</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vec_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vec_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vec_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">vec_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">vec_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vec_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可能会担心：“你真的建议用抽象基类来实现栈吗？你不担心性能影响吗？每次调用成员函数时，都要付出虚拟函数调用的代价！” 不，当然我不是这么建议的。显然你是对的，我也完全同意你的看法：从C++的角度来看，这种容器显得奇怪且非常低效。为了提高效率，我们通常通过类模板来实现相同的想法。这是C++标准库采用的方法，以三种STL类的形式实现容器适配器：<code>std::stack</code>、<code>std::queue</code>和<code>std::priority_queue</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Container</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">stack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Container</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Container</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Compare</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">priority_queue</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这三个类模板将给定容器类型的接口适配到特定用途。例如，<code>std::stack</code>类模板的目的是将容器接口适配到栈操作：<code>top()</code>、<code>empty()</code>、<code>size()</code>、<code>push()</code>、<code>emplace()</code>、<code>pop()</code>和<code>swap()</code>。默认情况下，你可以使用三个可用的序列容器：<code>std::vector</code>、<code>std::list</code>和<code>std::deque</code>。对于任何其他容器类型，你可以特化<code>std::stack</code>类模板。</p>
<p>“这感觉熟悉多了，”你说，明显松了一口气。我完全同意。我也认为标准库的方法更适合容器的目的。但比较这两种方法仍然很有趣。虽然<code>Stack</code>基类和<code>std::stack</code>类模板之间有许多技术上的差异，但这两者的用途和语义都非常相似：它们都提供了一种将任何数据结构适配到给定栈接口的能力。并且两者都作为变化点，允许你在不修改现有代码的情况下非侵入性地添加新的适配器。</p>
<p><strong>适配器设计模式与策略设计模式的比较</strong></p>
<p>“这三个STL类似乎实现了适配器的目的，但这不就是策略设计模式中配置行为的方式吗？这和<code>std::unique_ptr</code>及其删除器不是一样的吗？”你问道。是的，你是对的。从结构上看，策略设计模式和适配器设计模式非常相似。然而，正如在“指南11：理解设计模式的目的”中解释的那样，设计模式的结构可能相似甚至相同，但它们的意图不同。在这种情况下，容器参数不仅仅指定行为的一个方面，而是大部分或全部行为。类模板只是给定类型的封装器——它们主要适配接口。因此，适配器的主要关注点是标准化接口并将不兼容的功能集成到现有的规范集中；而另一方面，策略设计模式的主要关注点是从外部配置行为，构建并提供预期的接口。此外，对于适配器而言，不需要随时重新配置行为。</p>
<p><strong>函数适配器</strong></p>
<p>适配器设计模式的其他例子包括标准库中的自由函数<code>begin()</code>和<code>end()</code>。“你认真的吗？”你惊讶地问，“你声称自由函数是适配器设计模式的例子？这不是类的工作吗？”其实不一定。自由<code>begin()</code>和<code>end()</code>函数的目的是将任何类型的迭代器接口适配到预期的STL迭代器接口。因此，它将可用的一组函数映射到预期的一组函数，并与其他适配器具有相同的目的。主要区别在于，与基于继承（运行时多态）或模板（编译时多态）的对象适配器或类适配器不同，<code>begin()</code>和<code>end()</code>依赖于函数重载，这是C++中的第二种主要编译时多态机制。尽管如此，某种形式的抽象仍然存在。</p>
<p><strong>注意</strong></p>
<p>记住所有类型的抽象都代表一组需求，因此必须遵守里氏替换原则（LSP）。这对重载集也适用；参见“指南8：理解重载集的语义要求”。</p>
<p>考虑以下函数模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Range</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">traverseRange</span><span class="p">(</span><span class="n">Range</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">range</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">element</span> <span class="p">:</span> <span class="n">range</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>traverseRange()</code>函数中，我们通过基于范围的for循环遍历给定范围内包含的所有元素。遍历通过编译器使用自由<code>begin()</code>和<code>end()</code>函数获取的迭代器完成。因此，前面的for循环等价于以下形式的for循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Range</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">traverseRange</span><span class="p">(</span><span class="n">Range</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">range</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="nf">first</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">range</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="nf">last</span><span class="p">(</span><span class="n">end</span><span class="p">(</span><span class="n">range</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span><span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">element</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>显然，基于范围的for循环更方便使用。然而，在表面之下，编译器生成的代码基于自由<code>begin()</code>和<code>end()</code>函数。注意其开头的两个using声明：目的是为给定范围类型启用参数相关查找（ADL）。ADL确保即使重载函数位于用户特定的命名空间中，也会调用“正确的”<code>begin()</code>和<code>end()</code>函数。这意味着你可以为任何类型重载<code>begin()</code>和<code>end()</code>，并将预期接口映射到不同的、特定用途的函数集。</p>
<p>这种类型的函数适配器在2004年被Matthew Wilson称为“shim”。该技术的一个重要特性是完全非侵入性：可以为任何类型添加一个自由函数，甚至是第三方库提供的类型。因此，以shims或函数适配器编写的任何通用代码都能让你拥有巨大的能力，将几乎任何类型适配到预期接口。因此，你可以想象shims或函数适配器是泛型编程的核心。</p>
<p><strong>分析适配器设计模式的不足</strong></p>
<p>尽管适配器设计模式有其价值，但我应该明确指出这个设计模式有一个问题。</p>
<p>考虑以下例子，我借鉴自Eric Freeman和Elisabeth Robson：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Duck.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Duck</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Duck</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">quack</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">fly</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;MallardDuck.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Duck.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">MallardDuck</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Duck</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">quack</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">fly</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们从抽象的<code>Duck</code>类开始，该类引入了两个纯虚函数<code>quack()</code>和<code>fly()</code>。确实，这是一个相当预期且自然的鸭子类接口，并且当然会引发一些期望：鸭子发出非常独特的声音并且能够很好地飞行。许多可能的鸭子类型实现了这个接口，例如<code>MallardDuck</code>类。现在，由于某些原因，我们也需要处理火鸡：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Turkey.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Turkey</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Turkey</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">gobble</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 火鸡不会嘎嘎叫，而是咯咯叫！ 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">fly</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;WildTurkey.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">WildTurkey</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Turkey</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">gobble</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">fly</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>火鸡由抽象的<code>Turkey</code>类表示，当然有许多不同种类的具体火鸡实现，比如<code>WildTurkey</code>。为了使事情变得更糟，出于某些原因，鸭子和火鸡需要一起使用。一种可能的方法是假装火鸡是一只鸭子。毕竟，火鸡与鸭子非常相似。好吧，虽然它不会嘎嘎叫，但它会咯咯叫（典型的火鸡声音），而且它也能飞（虽然距离不长，但确实能飞）。因此，你可以使用<code>TurkeyAdapter</code>来适配火鸡到鸭子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;TurkeyAdapter.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">TurkeyAdapter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Duck</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="n">TurkeyAdapter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Turkey</span><span class="o">&gt;</span> <span class="n">turkey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">turkey_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">turkey</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">quack</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">turkey_</span><span class="o">-&gt;</span><span class="n">gobble</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">fly</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">turkey_</span><span class="o">-&gt;</span><span class="n">fly</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Turkey</span><span class="o">&gt;</span> <span class="n">turkey_</span><span class="p">;</span>  <span class="c1">// 这是一个对象适配器的例子 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然这是一个有趣的鸭子类型解释，但这个例子很好地展示了将外来事物轻松集成到现有层次结构中是多么容易。火鸡根本不是鸭子，即使我们希望它是。我认为<code>quack()</code>和<code>fly()</code>函数很可能违反了LSP。这些函数实际上并没有做我期望的事情（至少我很确定我希望听到的是嘎嘎叫而不是咯咯叫的动物，并且我希望看到像鸭子一样真正飞行的东西）。当然，这取决于具体的上下文，但不可否认的是，适配器设计模式使得组合不相干的事物变得非常容易。因此，在应用此设计模式时，非常重要的是要考虑预期的行为并检查是否违反了LSP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;MallardDuck.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;WildTurkey.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;TurkeyAdapter.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">DuckChoir</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Duck</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">give_concert</span><span class="p">(</span><span class="n">DuckChoir</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">duck_choir</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">duck</span> <span class="p">:</span> <span class="n">duck_choir</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">duck</span><span class="o">-&gt;</span><span class="n">quack</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">DuckChoir</span> <span class="n">duck_choir</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 让我们雇佣世界上最好的鸭子组成合唱团
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">duck_choir</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MallardDuck</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">duck_choir</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MallardDuck</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">duck_choir</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MallardDuck</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// 不幸的是，我们还雇了一个伪装成鸭子的火鸡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">turkey</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">WildTurkey</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">turkey_in_disguise</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TurkeyAdapter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">turkey</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">duck_choir</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">turkey_in_disguise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// 演出将是一场音乐灾难...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">give_concert</span><span class="p">(</span><span class="n">duck_choir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>本节总结</strong></p>
<ul>
<li>应用<strong>Adapter</strong>设计模式的目的是<strong>调整接口</strong>，以便不兼容的部分可以一起工作。</li>
<li>请注意，<strong>Adapter</strong>对动态和静态多态性都很有用。</li>
<li>区分对象适配器、类适配器和函数适配器。</li>
<li>理解适配器和策略设计模式之间的区别。</li>
<li>在使用<strong>Adapter</strong>设计模式时，要注意LSP违规</li>
</ul>
<h3 id="准则25应用观察者作为抽象通知机制">准则25：应用观察者作为抽象通知机制
</h3><p>你很可能之前听说过观察者模式。“哦，是的，当然我听说过——这不就是所谓的社交媒体平台对我们所做的吗？”你问道。嗯，虽然不是我所指的具体内容，但确实，我们可以把这些平台称为观察者。而且，他们做的事情也遵循某种模式，尽管这不是一个设计模式。实际上，我指的是GoF（四人组）设计模式中最受欢迎的设计模式之一——观察者设计模式。即使你还不熟悉这个概念，你也可能在生活中有过与有用的观察者的经验。例如，你可能注意到在某些消息应用程序中，一旦你阅读了一条新消息，发送者会立即被告知。这意味着消息显示为“已读”而不是仅仅“已送达”。这项小服务本质上是由现实生活中的观察者完成的：一旦新消息的状态发生变化，发送者就会收到通知，从而有机会对状态变化做出响应。</p>
<p><strong>观察者设计模式解释</strong>
在许多软件场景中，希望在某个状态发生变化时立即获得反馈：任务队列中添加了一个新任务、配置对象中的设置被更改、结果准备好被提取等。但是同时，引入主题（被观察实体，会发生变化）与其观察者（基于状态变化而被通知的回调函数）之间的显式依赖关系是非常不可取的。相反，主题应该对潜在的多种不同类型的观察者保持不知情。原因很简单，任何直接的依赖都会使软件更难改变和扩展。这种主题与其潜在多个观察者之间的解耦正是观察者设计模式的目的。</p>
<p>像所有设计模式一样，观察者设计模式识别出一个方面作为变化点（一个变化或预期会变化的方面），并以抽象的形式提取它。因此，它有助于解耦软件实体。在观察者的情况下，引入新观察者的需求——扩展一对多依赖关系——被认为是变化点。如图6-2所示，这种变化点通过观察者基类的形式实现。</p>
<p>观察者类代表了所有可能的观察者实现的抽象。这些观察者被附加到由具体主题类（ConcreteSubject）表示的特定主题上。为了减少观察者与其主题之间的耦合，或者通过提供所有通用服务来简化代码重复，可以使用主题抽象来进行attach()和detach()操作。该主题还可以在其状态发生变化时通知所有附加的观察者，并触发它们相应的更新功能（update()）。</p>
<p>“引入观察者基类是不是单一职责原则（SRP）的另一个例子？”你问。是的，你100%正确：提取观察者类、提取变化点正是SRP的实际应用（参见“指南2：为变化而设计”）。再次强调，SRP充当开放封闭原则（OCP）的推动者（参见“指南5：为扩展而设计”）：通过引入观察者抽象，任何人都可以在不需要修改现有代码的情况下添加新的观察者类型（例如，具体观察者ConcreteObserver）。如果你注意观察者基类的所有权，并确保观察者类位于架构的高级别，那么你也满足了依赖倒置原则（DIP）。</p>
<p><strong>经典观察者实现</strong></p>
<p>“很好，我明白了！很高兴再次看到这些设计原则的实际应用，但我希望能够看到一个具体的观察者例子。” 我理解。那么让我们来看一个具体的观察者实现。然而，在我们开始看代码之前，我应该清楚地说明以下示例的局限性。你可能已经熟悉观察者模式，因此你可能在寻找关于许多棘手实现细节的帮助和深入建议：如何处理附加和分离观察者的顺序、多次附加同一个观察者以及特别是在并发环境中使用观察者。我必须诚实地说明，我的意图并不是回答这些问题。这种讨论就像是打开潘多拉魔盒，很快会把我们带入实现细节的领域。不，尽管你可能会失望，但我的意图主要是停留在软件设计的层面上。</p>
<p>像前面的设计模式一样，我们从观察者设计模式的经典实现开始。核心元素是观察者基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Observer.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Observer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="cm">/*...*/</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个类最重要的实现细节是纯虚函数<code>update()</code>，当观察者被通知某个状态变化时就会调用它。有三种定义<code>update()</code>函数的方式，提供了合理的实现和设计灵活性。第一种方式是通过一个或多个<code>update()</code>函数推送更新状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update1</span><span class="p">(</span> <span class="cm">/*arguments representing the updated state*/</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update2</span><span class="p">(</span> <span class="cm">/*arguments representing the updated state*/</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种形式的观察者通常被称为“推观察者”。在这种形式中，观察者由主题提供所有必要的信息，因此不需要自己从主题中提取任何信息。这可以显著减少与主题的耦合，并为多个主题重用观察者类创造机会。此外，每种状态变化都有单独的重载函数也是一个选项。在前面的代码片段中有两个<code>update()</code>函数，每个对应一种可能的状态变化。由于总是明确知道哪个状态发生了变化，观察者不需要“搜索”任何状态变化，这证明是高效的。</p>
<p>“对不起，”你说，“但这不是违反了接口隔离原则（ISP）吗？我们应该通过将<code>update()</code>函数分开到几个基类来分离关注点吗？” 这是一个很好的问题！显然，你在警惕人为的耦合。非常好！你是正确的：我们可以将具有多个<code>update()</code>函数的观察者拆分为更小的观察者类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observer1</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update1</span><span class="p">(</span> <span class="cm">/*arguments representing the updated state*/</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observer2</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update2</span><span class="p">(</span> <span class="cm">/*arguments representing the updated state*/</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>理论上，这种方法可以帮助减少对特定主题的耦合，并更容易为不同的主题重用观察者。不同观察者可能对不同的状态变化感兴趣，因此人为地将所有可能的状态变化耦合在一起可能是违反ISP的。当然，如果能够避免很多不必要的状态变化通知，这可能会带来效率提升。</p>
<p>不幸的是，特定的主题不太可能区分不同类型的观察者。首先，因为这需要主题存储不同类型的指针（对于主题来说处理起来不方便），其次，因为不同状态变化之间可能存在某种联系。在这种情况下，主题期望观察者对所有可能的状态变化都感兴趣。从这个角度来看，将多个<code>update()</code>函数组合到一个基类中是合理的。无论怎样，具体观察者很可能需要处理所有类型的状态变化。我知道，即使只对其中一小部分感兴趣，也必须处理多个<code>update()</code>函数，这可能是个麻烦。但是，仍然要确保不要无意中违反里氏替换原则（LSP），如果不遵守某些预期行为（如果有）。</p>
<p>有几个潜在缺点使得推观察者并不理想。首先，观察者总是得到所有信息，无论是否需要。因此，只有在观察者大多数时候都需要这些信息时，这种推送风格才有效。否则，很多努力会浪费在不必要的通知上。其次，推送会产生对传递给观察者的参数数量和种类的依赖。对这些参数的任何更改都需要在继承观察者类中进行大量后续更改。</p>
<p>一些这些缺点可以通过第二种观察者替代方案解决。可以只传递主题的引用来观察者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">subject</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于没有向观察者传递特定信息，继承自观察者基类的类需要自行从主题中提取新信息。因此，这种形式的观察者通常被称为“拉观察者”。优点是对参数数量和种类的依赖减少。衍生观察者可以自由查询任何信息，而不仅仅是改变的状态。另一方面，这种设计会在继承自观察者的类和主题之间创建强直接依赖关系。因此，任何对主题的更改都会轻易影响观察者。此外，观察者可能需要“搜索”状态变化，如果多个细节发生了变化，这可能会证明是不必要的低效。</p>
<p>如果你仅考虑单个变化状态，性能劣势可能不会对你构成限制。不过，请记住软件会发生变化：主题可能会增长，随之而来的是通知不同类型变化的需求。适应这些变化会导致大量的额外工作。从这个角度看，推观察者似乎是一个更好的选择。</p>
<p>幸运的是，存在第三种替代方案，消除了之前的许多缺点，从而成为我们的首选：除了传递主题引用外，还传递一个标签以提供有关哪个属性已更改的信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Observer.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Observer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">subject</span><span class="p">,</span> <span class="cm">/*Subject-specific type*/</span> <span class="n">property</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该标签可以帮助观察者决定某个状态变化是否有趣。通常表示为主题特定枚举类型，列出所有可能的状态变化。遗憾的是，这增加了观察者类对特定主题的耦合。</p>
<p>“通过将观察者基类实现为类模板，是否可以移除对特定主题的依赖？”你问道。请看以下代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Observer.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Subject</span><span class="p">,</span> <span class="k">typename</span> <span class="n">StateTag</span> <span class="o">&gt;</span>  
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">subject</span><span class="p">,</span> <span class="n">StateTag</span> <span class="n">property</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是一个很好的建议。通过将观察者类定义为类模板的形式，我们可以轻松将其提升到更高的架构级别。在这种形式下，类不依赖于任何特定主题，因此可以被希望定义一对多关系的许多不同主题重复使用。然而，你不应对此改进期望过高：效果仅限于观察者类。具体主题会期望该观察者类的具体实例化，并且具体实现的观察者仍然强烈依赖于主题。</p>
<p>为了更好地理解为什么会这样，让我们看一下一个可能的主题实现。在你最初的关于社交媒体的评论之后，我建议我们为人物实现一个观察者。好吧，这个例子可能在道德上有问题，但它会达到目的，所以我们就用这个例子吧。至少我们知道是谁造成的。</p>
<p>以下<code>Person</code>类代表一个被观察的人物：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Observer.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Person</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">enum</span> <span class="nc">StateChange</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">forenameChanged</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">      <span class="n">surnameChanged</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">      <span class="n">addressChanged</span> 
</span></span><span class="line"><span class="cl">   <span class="p">};</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">PersonObserver</span> <span class="o">=</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">StateChange</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">forename_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">forename</span><span class="p">)</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="n">surname_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">surname</span><span class="p">)</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="nf">attach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="nf">detach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">notify</span><span class="p">(</span> <span class="n">StateChange</span> <span class="n">property</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">forename</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newForename</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">surname</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newSurname</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">address</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newAddress</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">forename</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">forename_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">surname</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">surname_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">address_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PersonObserver</span><span class="o">*&gt;</span> <span class="n">observers_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，<code>Person</code>只是三个数据成员的聚合：<code>forename_</code>、<code>surname_</code>和<code>address_</code>（我知道，这是一个人非常简单的表示）。此外，一个人持有注册观察者的<code>std::set</code>。请注意，观察者是通过指向<code>PersonObserver</code>实例的指针注册的。这有两个原因：首先，这展示了模板化的观察者类的目的：<code>Person</code>类实例化了自己的观察者类型。其次，指针在这里非常有用，因为对象的地址是唯一的。因此，通常使用地址作为观察者的唯一标识符。</p>
<p>“这不应该使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>吗？”你问。不，在这种情况下不需要。指针仅作为注册观察者的句柄；它们不应该拥有观察者。因此，任何拥有智能指针都是不合适的工具。唯一合理的选择是<code>std::weak_ptr</code>，它可以让你检查悬空指针。然而，<code>std::weak_ptr</code>不适合用作<code>std::set</code>的键（即使是带有自定义比较器）。虽然有一些方法仍然可以使用<code>std::weak_ptr</code>，但我将坚持使用原始指针。但这并不意味着我们要放弃现代C++的好处。在这种情况使用原始指针是完全有效的。这也体现在C++核心指南F.7中： 对于一般用途，取<code>T*</code>或<code>T&amp;</code>参数而不是智能指针。</p>
<p>每当对人的状态变化感兴趣时，都可以通过<code>attach()</code>成员函数注册一个观察者。当你不再希望接收通知时，可以通过<code>detach()</code>成员函数注销观察者。这两个函数是观察者设计模式的核心组成部分，并且是应用该设计模式的明确标志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">Person</span><span class="o">::</span><span class="n">attach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="p">[</span><span class="n">pos</span><span class="p">,</span><span class="n">success</span><span class="p">]</span> <span class="o">=</span> <span class="n">observers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">observer</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">success</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">Person</span><span class="o">::</span><span class="n">detach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="p">(</span> <span class="n">observers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">observer</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0U</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以根据自己的需求自由实现<code>attach()</code>和<code>detach()</code>函数。在这个例子中，我们允许一个观察者只能注册一次到<code>std::set</code>中。如果你尝试第二次注册同一个观察者，函数会返回<code>false</code>。同样，如果你尝试注销一个未注册的观察者，也会返回<code>false</code>。请注意，不允许多次注册是我的选择。在其他场景中，接受重复注册可能是可取甚至必要的。无论如何，主题的行为和接口在所有情况下都应该一致。</p>
<p>另一个观察者设计模式的核心函数是<code>notify()</code>成员函数。每当发生某种状态变化时，此函数会被调用以通知所有注册的观察者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span> <span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="n">iter</span><span class="o">=</span><span class="n">begin</span><span class="p">(</span><span class="n">observers_</span><span class="p">);</span> <span class="n">iter</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">observers_</span><span class="p">);</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="k">const</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iter</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="n">property</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“为什么<code>notify()</code>函数的实现如此复杂？范围基于的for循环难道不够吗？”你问得对，我应该解释一下这里发生了什么。给出的表达式确保可以在迭代期间检测到<code>detach()</code>操作。例如，如果观察者在调用<code>update()</code>函数时决定自我分离，则可能发生这种情况。但我不能说这种实现是完美的：不幸的是，它无法应对<code>attach()</code>操作。而且不要开始询问并发问题！因此，这只是观察者实现细节为何如此棘手的一个例子。</p>
<p><code>notify()</code>函数在所有三个设置函数中被调用。请注意，在所有三个函数中，我们总是传递不同的标签来指示哪个属性已更改。这个标签可以由继承自观察者基类的类用来确定变化的性质：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">forename</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newForename</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">forename_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newForename</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">notify</span><span class="p">(</span> <span class="n">forenameChanged</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">surname</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newSurname</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">surname_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newSurname</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">notify</span><span class="p">(</span> <span class="n">surnameChanged</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">address</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newAddress</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">address_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newAddress</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">notify</span><span class="p">(</span> <span class="n">addressChanged</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>有了这些机制，你现在可以编写新的完全符合OCP（开闭原则）的观察者。例如，你可以决定实现一个<code>NameObserver</code>和一个<code>AddressObserver</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;NameObserver.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Observer.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Person.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">NameObserver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;NameObserver.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;NameObserver.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">NameObserver</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">forenameChanged</span> <span class="o">||</span> 
</span></span><span class="line"><span class="cl">       <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">surnameChanged</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// ... 响应名字变化 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;AddressObserver.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Observer.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Person.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">AddressObserver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;AddressObserver.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;AddressObserver.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">AddressObserver</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">addressChanged</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// ... 响应地址变化 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>装备了这两个观察者后，现在无论何时人的名字或地址发生变化，你都会收到通知：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;AddressObserver.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;NameObserver.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Person.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">NameObserver</span> <span class="n">nameObserver</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">AddressObserver</span> <span class="n">addressObserver</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Person</span> <span class="n">homer</span><span class="p">(</span> <span class="s">&#34;Homer&#34;</span>     <span class="p">,</span> <span class="s">&#34;Simpson&#34;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Person</span> <span class="n">marge</span><span class="p">(</span> <span class="s">&#34;Marge&#34;</span>     <span class="p">,</span> <span class="s">&#34;Simpson&#34;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Person</span> <span class="n">monty</span><span class="p">(</span> <span class="s">&#34;Montgomery&#34;</span><span class="p">,</span> <span class="s">&#34;Burns&#34;</span>   <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// 注册观察者 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">homer</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">marge</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">monty</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// 更新Homer Simpson的信息 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">homer</span><span class="p">.</span><span class="n">forename</span><span class="p">(</span> <span class="s">&#34;Homer Jay&#34;</span> <span class="p">);</span>  <span class="c1">// 添加中间名 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// 更新Marge Simpson的信息 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">marge</span><span class="p">.</span><span class="n">address</span><span class="p">(</span> <span class="s">&#34;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&#34;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// 更新Montgomery Burns的信息 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">monty</span><span class="p">.</span><span class="n">address</span><span class="p">(</span> <span class="s">&#34;Springfield Nuclear Power Plant&#34;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// 注销观察者 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">homer</span><span class="p">.</span><span class="n">detach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在了解了这么多实现细节之后，让我们退一步看看更大的图景。图6-3显示了这个观察者示例的依赖关系图。</p>
<p>由于决定以类模板的形式实现观察者类，观察者类位于我们架构的最高层次。这使你能够为多种用途重用观察者类，例如<code>Person</code>类。<code>Person</code>类声明了自己的<code>Observer&lt;Person,Person::StateChange&gt;</code>类型，并通过这种方式将自己的代码注入其自身的架构层次。具体的人观察者，如<code>NameObserver</code>和<code>AddressObserver</code>，可以在此声明的基础上构建。</p>
<p><strong>基于值语义的观察者实现</strong></p>
<p>“我理解你为什么从经典实现开始，但既然你已经强调了偏好值语义的重要性，那么在一个基于值语义的世界中，观察者会是什么样子呢？” 这是一个非常好的问题，因为这是非常合理的下一步。正如在“指南22：优先选择值语义而不是引用语义”中解释的那样，有很多好的理由避免引用语义的领域。然而，我们不会完全偏离经典的实现：为了注册和注销观察者，我们总是需要某种唯一的标识符来标识观察者，而观察者的唯一地址只是解决这个问题最简单、最方便的方法。因此，我们将继续使用指针来引用已注册的观察者。但是，<code>std::function</code>是一种优雅的方式来避免继承层次结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Observer.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Subject</span><span class="p">,</span> <span class="k">typename</span> <span class="n">StateTag</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Observer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">OnUpdate</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span><span class="n">StateTag</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   <span class="k">explicit</span> <span class="nf">Observer</span><span class="p">(</span> <span class="n">OnUpdate</span> <span class="n">onUpdate</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">onUpdate_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">onUpdate</span><span class="p">)</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// 可能响应无效/空的 std::function 实例 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="c1">// 非虚函数 update 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">subject</span><span class="p">,</span> <span class="n">StateTag</span> <span class="n">property</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">onUpdate_</span><span class="p">(</span> <span class="n">subject</span><span class="p">,</span> <span class="n">property</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">OnUpdate</span> <span class="n">onUpdate_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>代替将观察者类实现为基类，并要求派生类以特定方式继承并实现<code>update()</code>函数，我们通过组合（参见“指南20：优先选择组合而不是继承”）来分离关注点。观察者类首先提供了一个名为<code>OnUpdate</code>的类型别名，用于预期签名的<code>std::function</code>类型。通过构造函数，您传递了一个<code>std::function</code>实例，并将其移动到数据成员<code>onUpdate_</code>中。<code>update()</code>函数现在的工作是将调用及其参数转发给<code>onUpdate_</code>。</p>
<p><code>std::function</code>的灵活性可以通过更新后的<code>main()</code>函数轻松展示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Observer.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Person.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">propertyChanged</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">forenameChanged</span> <span class="o">||</span> 
</span></span><span class="line"><span class="cl">       <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">surnameChanged</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// ... 响应名字变化 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">PersonObserver</span> <span class="o">=</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="n">PersonObserver</span> <span class="n">nameObserver</span><span class="p">(</span> <span class="n">propertyChanged</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="n">PersonObserver</span> <span class="n">addressObserver</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">      <span class="p">[</span><span class="cm">/*捕获的状态*/</span><span class="p">](</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">         <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">addressChanged</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">         <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="c1">// ... 响应地址变化 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="p">}</span> 
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="n">Person</span> <span class="n">homer</span><span class="p">(</span> <span class="s">&#34;Homer&#34;</span>     <span class="p">,</span> <span class="s">&#34;Simpson&#34;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Person</span> <span class="n">marge</span><span class="p">(</span> <span class="s">&#34;Marge&#34;</span>     <span class="p">,</span> <span class="s">&#34;Simpson&#34;</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Person</span> <span class="n">monty</span><span class="p">(</span> <span class="s">&#34;Montgomery&#34;</span><span class="p">,</span> <span class="s">&#34;Burns&#34;</span>   <span class="p">);</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="c1">// 注册观察者 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">homer</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">marge</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">monty</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于选择了侵入性较低的方法，并且与<code>std::function</code>解耦，如何实现<code>update()</code>函数的选择完全取决于观察者的实现者（无状态、有状态等）。对于<code>nameObserver</code>，我们依赖于自由函数<code>propertyChanged()</code>，它本身是高度解耦的，因为它不绑定到任何类并且可能在多个场合重用。另一方面，<code>addressObserver</code>选择使用lambda表达式，该表达式可以捕获一些状态。无论如何，这两个观察者只需要遵循所需的<code>std::function</code>类型的必要签名这一约定。</p>
<p>“为什么我们仍然需要观察者类？难道我们不能直接使用<code>std::function</code>吗？” 从功能角度来看，观察者类本身并没有添加任何东西。然而，作为值语义的真正产物，我们倾向于复制或移动<code>std::function</code>对象。但在这种情况下这不是所希望的：特别是如果您使用的是有状态观察者，您不希望您的观察者的副本被调用。尽管技术上可行，但传递指向<code>std::function</code>的指针并不常见。因此，观察者类仍可以作为<code>std::function</code>的适配器（参见“指南24：使用适配器标准化接口”）发挥作用。</p>
<p><strong>分析观察者设计模式的不足</strong></p>
<p>“这并不是我期望的值语义解决方案，但我仍然喜欢它！” 我很高兴您这么想。确实，值语义的优势结合观察者设计模式的优点（即事件与其相应动作的解耦以及轻松添加新种类观察者的能力）工作得非常好。不幸的是，没有完美的设计，每个设计也有其缺点。</p>
<p>首先，应该明确指出，演示的<code>std::function</code>方法仅适用于具有单个<code>update()</code>函数的拉取观察者。由于<code>std::function</code>只能处理单一可调用对象，任何需要多个<code>update()</code>函数的方法都无法由单个<code>std::function</code>处理。因此，对于具有多个<code>update()</code>函数的推送观察者或潜在增长的<code>update()</code>函数数量，<code>std::function</code>通常不是最佳选择（记住，代码往往会发生变化！）。不过，可以泛化<code>std::function</code>的方法。如果需要，类型擦除设计模式（参见第8章）是首选。</p>
<p>第二个（较小的）缺点是，如您所见，没有纯粹基于值的实现。虽然我们可以使用<code>std::function</code>实现<code>update()</code>功能以获得灵活性，但我们仍然使用原始指针来附加和分离观察者。这一点很容易解释：使用指针作为唯一标识符的优点实在太多，无法忽视。此外，对于有状态观察者，我们不想处理实体的副本。当然，这仍然需要我们检查<code>nullptr</code>（这需要额外的努力），并且我们必须始终支付指针代表的间接费用。我个人认为这是一个小问题，因为这种方法有许多优点。</p>
<p>更大的缺点是观察者的潜在实现问题：注册和注销的顺序可能会有很大影响，特别是在允许观察者多次注册的情况下。此外，在多线程环境中，线程安全地注册和注销观察者以及事件处理是非常复杂的主题。例如，不可信的观察者在回调期间如果行为不当可能会冻结服务器，并且为任意计算实现超时非常复杂。然而，这个话题远远超出了本书的范围。</p>
<p>然而，属于本书范围的是观察者过度使用的所谓危险：它可以快速且容易地导致复杂的互连网络。事实上，如果不小心，可能会意外引入无限循环的回调！因此，开发人员有时会对使用观察者感到担忧，并担心单个通知可能会由于这些互连而导致巨大的全局响应。虽然这种危险确实存在，但如果设计合理并且观察者实现正确，则任何通知序列都应该沿着有向无环图（DAG）朝着架构的低层运行。而这正是良好软件设计的美妙之处。</p>
<p>总结来说，旨在提供状态变化通知的解决方案，观察者设计模式被证明是最著名和最常用的模式之一。除了潜在棘手的实现细节外，它无疑是每个开发人员工具箱中应包含的设计模式之一。应用观察者设计模式以创建主题与其观察者之间的一对多关系，并了解推送观察者与拉取观察者之间的权衡。利用基于值语义的观察者实现的优势。</p>
<h3 id="准则26使用crtp引入静态类型类别"><strong>准则26：使用CRTP引入静态类型类别</strong>
</h3><p>C++ 真的有很多值得探索的地方。它带有许多特性、许多语法上的奇特之处以及大量的令人惊叹但难以发音（对于新手来说几乎是神秘的）的缩写词：RAII、ADL、CTAD、SFINAE、NTTP、IFNDR 和 SIOF。哦，多么有趣！其中一个神秘的缩写是 CRTP，即 Curiously Recurring Template Pattern（奇妙递归模板模式）的缩写。</p>
<p>如果你因为这个名字毫无意义而感到困惑，不要担心：在 C++ 中，名字通常是随意选择的，但一旦选定就不会再更改。这个模式是由 James Coplien 在 1995 年 2 月的《C++ Report》中命名的，因为他意识到这种模式在许多不同的 C++ 代码库中反复出现。并且奇怪的是，尽管这种模式基于继承（可能作为抽象），但它并没有表现出许多其他经典设计模式通常具有的性能缺点。因此，CRTP 绝对值得一看，因为它可能会成为你设计模式工具箱中一个有价值甚至可以说是“奇妙”的补充。</p>
<p><strong>CRTP 的动机</strong></p>
<p>在 C++ 中，性能非常重要。事实上，在某些上下文中，使用虚函数的性能开销被认为是完全不可接受的。因此，在性能敏感的上下文中，例如某些计算机游戏或高频交易的部分，不会使用虚函数。同样的情况也适用于高性能计算（HPC）。在 HPC 中，任何条件或间接操作，包括虚函数，都被禁止出现在最影响性能的部分，例如计算内核的最内层循环。使用它们会带来太多的性能开销。</p>
<p>为了说明这一点及其重要性，让我们考虑以下来自线性代数（LA）库的 <code>DynamicVector</code> 类模板示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DynamicVector.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DynamicVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">value_type</span>     <span class="o">=</span> <span class="n">T</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">iterator</span>       <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 构造函数和特殊成员函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="n">T</span><span class="o">&amp;</span>       <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">iterator</span>       <span class="nf">begin</span><span class="p">();</span>   
</span></span><span class="line"><span class="cl">   <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">iterator</span>       <span class="nf">end</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">   <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 许多数值函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">values_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">DynamicVector</span> <span class="k">const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vector</span> <span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">element</span> <span class="p">:</span> <span class="n">vector</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; )&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">os</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">l2norm</span><span class="p">(</span> <span class="n">DynamicVector</span> <span class="k">const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vector</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span> <span class="n">begin</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="n">T</span><span class="p">{}</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 更多内容
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>尽管名称如此，<code>DynamicVector</code> 并不代表容器，而是用于 LA 计算的数值向量。名称中的“动态”部分意味着它以动态方式分配其元素，在此示例中使用 <code>std::vector</code>。因此，它适用于大型 LA 问题（肯定是在数百万个元素的范围内）。虽然此类可能包含许多数值运算，但从接口角度来看，你可能会称之为容器：它提供了常用的嵌套类型（<code>value_type</code>、<code>iterator</code> 和 <code>const_iterator</code>）、查询当前元素数量的 <code>size()</code> 函数、通过索引访问单个元素的下标运算符（一个用于非常量向量，一个用于常量向量）、迭代元素的 <code>begin()</code> 和 <code>end()</code> 函数。除了成员函数外，它还提供了一个输出运算符和至少一个 LA 操作，用于计算向量的欧几里得范数（通常也称为 L2 范数，因为它近似于离散向量的 L2 范数）。</p>
<p>然而，<code>DynamicVector</code> 不是唯一的向量类。在我们的 LA 库中，你还会发现以下 <code>StaticVector</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;StaticVector.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Size</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StaticVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">value_type</span>     <span class="o">=</span> <span class="n">T</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">iterator</span>       <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 构造函数和特殊成员函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="n">T</span><span class="o">&amp;</span>       <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">   <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">iterator</span>       <span class="nf">begin</span><span class="p">();</span>   
</span></span><span class="line"><span class="cl">   <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">iterator</span>       <span class="nf">end</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">   <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 许多数值函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;</span> <span class="n">values_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Size</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">                          <span class="n">StaticVector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">element</span> <span class="p">:</span> <span class="n">vector</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; )&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">os</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Size</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">l2norm</span><span class="p">(</span> <span class="n">StaticVector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span> <span class="n">begin</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="n">T</span><span class="p">{}</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 更多内容
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>“这不是几乎与 <code>DynamicVector</code> 类相同吗？”你可能会问。是的，这两个类确实非常相似。<code>StaticVector</code> 类提供了与 <code>DynamicVector</code> 相同的接口，如嵌套类型 <code>value_type</code>、<code>iterator</code> 和 <code>const_iterator</code>、查询当前元素数量的 <code>size()</code> 成员函数、下标运算符、迭代元素的 <code>begin()</code> 和 <code>end()</code> 函数。它还包括一个输出运算符和一个自由的 <code>l2norm()</code> 函数。然而，两者之间有一个重要的性能相关的区别：正如名称中的“静态”所暗示的那样，<code>StaticVector</code> 不动态分配其元素。相反，它使用类内的缓冲区来存储其元素，例如使用 <code>std::array</code>。因此，与 <code>DynamicVector</code> 相比，<code>StaticVector</code> 的所有功能都针对少量固定数量的元素进行了优化，例如 2D 或 3D 向量。</p>
<p>“好的，我理解这对性能很重要，但这仍然导致了大量的代码重复，对吧？”你再次正确。如果仔细查看两个向量类的关联输出运算符，你会发现这两个函数的实现是相同的。这是非常不理想的：如果发生任何变化，例如向量格式的变化（记住：变化是软件开发中的唯一不变，必须预期并处理；参见“指南2：为变化而设计”），那么你将不得不在多个地方进行修改，而不仅仅是一个地方。这违反了“不要重复自己”（DRY）原则：很容易忘记或错过更新某一处，从而引入不一致甚至错误。</p>
<p>“但这不是可以通过稍微更通用的函数模板轻松解决的问题吗？例如，我可以想象以下适用于所有密集向量的输出运算符：”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">DenseVector</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">DenseVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 如前所述 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然这似乎是一个适当的解决方案，但我不会在拉取请求中接受此代码。该函数模板确实更通用，但我绝对不会称其为“稍微”更通用；你建议的是可以编写的最通用的输出运算符。是的，该函数模板的名称可能暗示它仅适用于密集向量（包括 <code>DynamicVector</code> 和 <code>StaticVector</code>），但实际上，该函数模板会接受任何类型：<code>DynamicVector</code>、<code>StaticVector</code>、<code>std::vector</code>、<code>std::string</code> 以及基本类型如 <code>int</code> 和 <code>double</code>。它根本无法指定任何要求或约束。因此，它违反了核心指南 T.10： 为所有模板参数指定概念。</p>
<p>虽然此输出运算符适用于所有密集向量和序列容器，但对于不提供预期接口的类型，你会得到编译错误。或者更糟糕的是，你可能会微妙地违反隐式的要求和期望，从而违反 LSP（参见“指南6：遵循抽象的预期行为”）。当然，你不会有意这样做，但很可能是无意间发生的：此输出运算符是任何类型的完美匹配，并且即使你不期望也会被使用。因此，这个函数模板将成为输出运算符重载集中的一个不幸添加。我们需要的是一组全新的类型，一个新的类型类别。</p>
<p>“这不是基类的作用吗？我们不能简单地定义一个 <code>DenseVector</code> 基类来为所有密集向量定义预期接口吗？考虑以下 <code>DenseVector</code> 基类的草图：”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>  <span class="c1">// 元素类型 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="o">~</span><span class="n">DenseVector</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="n">T</span><span class="o">&amp;</span>       <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">virtual</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">DenseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 如前所述 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“这应该可以工作，对吧？我只是不确定如何声明 <code>begin()</code> 和 <code>end()</code> 函数，因为我无法从不同迭代器类型（如 <code>std::vector&lt;T&gt;::iterator</code> 和 <code>std::array&lt;T&gt;::iterator</code>）中抽象出来。” 我也有类似的感觉，这个问题没有快速解决方案。但还有一个更为严重的问题：有了这个基类，我们会将所有成员函数变成虚成员函数。这包括 <code>begin()</code> 和 <code>end()</code> 函数，但最重要的是两个下标运算符。后果将是显著的：每次访问向量的一个元素时，我们现在都需要调用一个虚函数。每一次访问！因此，有了这个基类，我们就告别了高性能。</p>
<p>然而，构建抽象的基本类的想法本身是好的。我们只需要以不同的方式去做。这就是我们应该仔细看看 CRTP 的地方。</p>
<p><strong>CRTP 设计模式解释</strong></p>
<p>CRTP 设计模式建立在创建抽象的基本类这一常见想法上。但是，它通过编译时关系而不是运行时关系（通过虚函数）在基类和派生类之间建立了联系。</p>
<p>CRTP 设计模式通过识别一个方面作为变化点（一个变化或预期会变化的方面）并将其提取为抽象形式来帮助解耦软件实体。在这种情况下，引入新观察者的需求——扩展一对多依赖关系——被认为是变化点。如图 6-2 所示，这种变化点通过观察者基类的形式实现。</p>
<p><code>Observer</code> 类代表所有可能的观察者实现的抽象。这些观察者附加到由具体主题类（<code>ConcreteSubject</code>）表示的特定主题上。为了减少观察者与其主题之间的耦合，或者通过提供所有通用服务来简化代码重复，可以使用主题抽象来进行 <code>attach()</code> 和 <code>detach()</code> 操作。该主题还可以在其状态发生变化时通知所有附加的观察者，并触发它们相应的更新功能（<code>update()</code>）。</p>
<p>CRTP 设计模式基于使用基类创建抽象的常见思想。但它不是通过虚函数在基类和派生类之间建立运行时关系，而是创建编译时关系。</p>
<p><code>DenseVector</code> 基类和 <code>DynamicVector</code> 派生类之间的编译时关系是通过将基类升级为类模板来创建的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DenseVector.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;DynamicVector.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DynamicVector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DenseVector</span><span class="o">&lt;</span><span class="n">DynamicVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>CRTP 的奇妙之处在于，基类的新模板参数表示关联派生类的类型。例如，<code>DynamicVector</code> 等派生类需要提供自己的类型来实例化基类。</p>
<p>“哇，等一下——这怎么可能？”你可能会问。确实可以。为了实例化一个模板，你不需要完整的类型定义。使用不完整类型就足够了。这种不完整类型在编译器看到 <code>DynamicVector</code> 类声明后即可获得。实际上，这段语法起到了前向声明的作用。因此，<code>DynamicVector</code> 类确实可以使用自身作为 <code>DenseVector</code> 基类的模板参数。</p>
<p>当然，你可以根据喜好命名基类的模板参数（例如，简单地命名为 <code>T</code>），但正如“指南14：使用设计模式名称传达意图”中讨论的那样，使用设计模式的名称或常用名称有助于传达意图。因此，你可以将参数命名为 <code>CRTP</code>，这很好地传达了模式，但不幸的是只对熟悉的人有意义。其他人会对此缩写感到困惑。因此，模板参数通常称为 <code>Derived</code>，这完美表达了其用途并传达了意图：它代表派生类的类型。</p>
<p>通过这个模板参数，基类现在知道了实际派生类型的类型。虽然它仍然代表所有密集向量的抽象和公共接口，但现在能够访问和调用派生类型中的具体实现。例如，在 <code>size()</code> 成员函数中发生这种情况：<code>DenseVector</code> 使用 <code>static_cast</code> 将自身转换为派生类的引用，并调用该类的 <code>size()</code> 函数。乍一看，这看起来像是递归函数调用（在 <code>size()</code> 函数内部调用 <code>size()</code> 函数），但实际上是在派生类中调用 <code>size()</code> 成员函数。</p>
<p>“所以这就是你所说的编译时关系。基类代表具体派生类型和实现细节的抽象，但仍确切知道实现细节在哪里。所以我们真的不需要任何虚函数。” 正确。通过 CRTP，我们现在能够实现一个通用接口，并通过简单的 <code>static_cast</code> 将每个调用转发给派生类。这样做没有任何性能损失。实际上，基类函数很可能会被内联，如果 <code>DenseVector</code> 是唯一的或第一个基类，<code>static_cast</code> 甚至不会产生单条汇编指令。它只是告诉编译器将对象视为派生类型的对象。</p>
<p>为了提供一个干净的 CRTP 基类，我们还需要更新一些细节：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DenseVector.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="o">~</span><span class="n">DenseVector</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">   <span class="n">Derived</span><span class="o">&amp;</span>       <span class="n">derived</span><span class="p">()</span>       
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl">   <span class="n">Derived</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">derived</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为我们想避免任何虚函数，所以我们也对虚析构函数不感兴趣。因此，我们将析构函数实现为保护部分中的非虚函数。这完全符合核心指南 C.35： 基类析构函数应该是公共且虚的，或者是受保护且非虚的。</p>
<p>需要注意的是，此析构函数的定义阻止了编译器生成两个移动操作。由于 CRTP 基类通常是空的，没有什么可移动的内容，这不是问题；但仍然要时刻注意“规则5”。</p>
<p>我们还应该避免在基类的每个成员函数中使用 <code>static_cast</code>。虽然这是正确的，但任何类型转换都应该被视为可疑行为，应尽量减少。因此，我们添加了两个 <code>derived()</code> 成员函数，它们执行转换并在其他成员函数中使用。这样不仅使代码更简洁、遵循 DRY 原则，而且看起来也远不那么可疑。</p>
<p>有了 <code>derived()</code> 函数，我们现在可以定义下标运算符和 <code>begin()</code> 和 <code>end()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span>       <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">begin</span><span class="p">()</span>       <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">end</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">end</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，这些函数不像 <code>size()</code> 成员函数那样直接。特别是返回类型证明有点难以指定，因为这些类型依赖于 <code>Derived</code> 类的实现。“嗯，那不应该太难吧，”你说。“这就是为什么派生类型提供了几个嵌套类型，如 <code>value_type</code>、<code>iterator</code> 和 <code>const_iterator</code>，对吧？” 实际上，直接询问似乎是直观的做法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">using</span> <span class="n">value_type</span>     <span class="o">=</span> <span class="k">typename</span> <span class="n">Derived</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">iterator</span>       <span class="o">=</span> <span class="k">typename</span> <span class="n">Derived</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Derived</span><span class="o">::</span><span class="n">const_iterator</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">value_type</span><span class="o">&amp;</span>       <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span>       <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">iterator</span>       <span class="nf">begin</span><span class="p">()</span>       <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">iterator</span>       <span class="nf">end</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们查询派生类中的 <code>value_type</code>、<code>iterator</code> 和 <code>const_iterator</code> 类型（不要忘记 <code>typename</code> 关键字）并使用这些类型来指定我们的返回类型。这看起来很简单，对吧？你几乎可以肯定这并不那么简单。如果你尝试这样做，Clang 编译器会报出一条非常奇怪且令人困惑的错误消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">CRTP</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">29</span><span class="o">:</span><span class="mi">41</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">type</span> <span class="n">named</span> <span class="err">&#39;</span><span class="n">value_type</span><span class="err">&#39;</span> <span class="n">in</span> <span class="err">&#39;</span><span class="n">DynamicVector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="err">&#39;</span> 
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Derived</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                      <span class="o">~~~~~~~~~~~~~~~~~~^~~~~~~~~~</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“没有 <code>DynamicVector&lt;int&gt;</code> 中的 <code>value_type</code> —— 很奇怪。” 你的第一个想法是你搞砸了。一定是拼写错误。当然！所以你回到代码中检查拼写。然而，结果是拼写没有问题。你再次检查 <code>DynamicVector</code> 类：那里有嵌套的 <code>value_type</code> 成员。而且一切都是公开的。错误信息毫无意义。你重新检查一切，再检查一遍，半小时后你得出结论：“编译器有一个 bug！”</p>
<p>不，这不是编译器的 bug。无论是 Clang 还是其他编译器都没有 bug。GCC 提供了一个不同的但稍微更具启发性的错误消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">CRTP</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">29</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">use</span> <span class="n">of</span> <span class="n">incomplete</span> <span class="n">type</span> <span class="err">&#39;</span><span class="k">class</span> <span class="nc">DynamicVector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="err">&#39;</span> 
</span></span><span class="line"><span class="cl"><span class="mi">29</span> <span class="o">|</span>    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Derived</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="o">^~~~~~~~~~</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Clang 编译器是对的：在 <code>DynamicVector</code> 类中还没有 <code>value_type</code>。还没有！当你查询嵌套类型时，<code>DynamicVector</code> 类的定义还没有被看到，<code>DynamicVector</code> 仍然是一个不完整类型。这是因为编译器会在 <code>DynamicVector</code> 类定义之前实例化 <code>DenseVector</code> 基类。毕竟，从语法上看，基类是在类主体之前指定的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DynamicVector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DenseVector</span><span class="o">&lt;</span><span class="n">DynamicVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，没有办法使用派生类的嵌套类型来指定 CRTP 类的返回类型。实际上，只要派生类是不完整类型，你就不能使用任何东西。“但是为什么我可以调用派生类的成员函数呢？这难道不会导致同样的问题吗？” 幸运的是，这可以工作（否则 CRTP 模式根本无法工作）。但这仅在类模板的一个特殊属性下有效：成员函数仅在实际调用时才实例化。由于实际调用通常发生在派生类定义可用之后，因此不存在缺少定义的问题。此时，派生类不再是不完整类型。</p>
<p>“好的，我明白了。但我们如何指定下标运算符和 <code>begin()</code> 和 <code>end()</code> 函数的返回类型呢？” 处理这个问题最方便的方法是使用返回类型推导。这是一个使用 <code>decltype(auto)</code> 返回类型的绝佳机会：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span>       <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">begin</span><span class="p">()</span>       <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">end</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">end</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“仅仅使用 <code>auto</code> 不够吗？例如，我们可以这样定义返回类型：”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 注意：这种方法在这种情况下可能不够通用，而 `decltype(auto)` 总是有效的 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span><span class="o">&amp;</span>       <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span>       <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">derived</span><span class="p">()[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span>       <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">derived</span><span class="p">().</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种情况下，这确实是足够的。然而，正如我一直强调的，代码会发生变化。最终，可能会出现另一个衍生向量类，它不存储值而是按值返回。例如，考虑一个 <code>ZeroVector</code> 类，它代表向量的零元素。这样的向量不会存储所有元素，因为这样做会浪费资源，而是可能实现为空类，每次访问元素时返回零值。在这种情况下，<code>auto&amp;</code> 返回类型将是不正确的。是的，编译器（希望）会警告你这一点。但你可以通过返回与派生类相同的类型来避免整个问题。这种返回类型由 <code>decltype(auto)</code> 表示。</p>
<p><strong>分析 CRTP 设计模式的不足</strong></p>
<p>“哇，这个 CRTP 设计模式听起来太棒了。所以，除了这些比平常稍微复杂一点的实现细节之外，这不是解决所有虚函数性能问题的办法吗？这难道不是所有与继承相关问题的关键、圣杯吗？” 我能理解你的热情！乍一看，CRTP 确实像是解决各种继承层次结构的终极方案。不幸的是，这是一种错觉。记住：每种设计模式都有其优点，但也有缺点。CRTP 设计模式有几个相当限制性的缺点。</p>
<p>第一个，也是最限制性的缺点之一是缺乏一个通用基类。为了强调其严重性，我再重复一遍：没有通用基类！实际上，每个派生类都有不同的基类。例如，<code>DynamicVector&lt;T&gt;</code> 类有 <code>DenseVector&lt;DynamicVector&lt;T&gt;&gt;</code> 基类。<code>StaticVector&lt;T, Size&gt;</code> 类有 <code>DenseVector&lt;StaticVector&lt;T, Size&gt;&gt;</code> 基类（见图 6-4）。因此，每当需要一个通用基类时，比如用于在集合中存储不同类型，CRTP 设计模式就不是一个合适的选择。</p>
<p>“哦，哇，我看到这确实是一个真正的限制。但我们不能让 CRTP 基类从一个通用基类派生吗？” 你可能会争辩。不，实际上不行，因为这样做会要求我们再次引入虚函数。“好吧，我明白了。那么使用 <code>std::variant</code> 模拟一个通用基类呢？” 是的，这是一个选项。然而，请记住 <code>std::variant</code> 实际上是访问者设计模式的一种表现形式（见“指南 16：使用访问者扩展操作”）。由于 <code>std::variant</code> 需要知道其所有潜在替代项，这将限制你添加新类型的自由度。所以你看，即使你可能不喜欢它，CRTP 并不能替代所有的继承层次结构。</p>
<p>第二个，同样可能非常限制性的缺点是，所有与 CRTP 基类接触的东西本身都变成了模板。这对于所有与该基类一起工作的函数来说尤其如此。例如，升级后的输出运算符和 <code>l2norm()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">DenseVector</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">l2norm</span><span class="p">(</span> <span class="n">DenseVector</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两个函数应该适用于所有从 <code>DenseVector</code> CRTP 类派生的类。当然，它们不应该依赖于派生类的具体类型。因此，这两个函数必须是函数模板：<code>Derived</code> 类型必须被推导出来。虽然在一个线性代数库的上下文中，这通常不是问题，因为几乎所有功能都是用模板实现的，但在其他上下文中，这可能是一个很大的缺点。将大量代码转换为模板并将定义移到头文件中，实际上牺牲了源文件的封装性。是的，这可能确实是一个严重的缺点！</p>
<p>第三，CRTP 是一种侵入式设计模式。派生类必须通过继承自 CRTP 基类来明确选择加入。虽然在我们自己的代码中这可能不是问题，但你无法轻易地为外部代码添加基类。在这种情况下，你必须求助于适配器设计模式（见“指南 24：使用适配器标准化接口”）。因此，CRTP 不提供非侵入式设计模式的灵活性（例如，使用 <code>std::variant</code> 实现的访问者设计模式、适配器设计模式等）。</p>
<p>最后但并非最不重要的一点是，CRTP 不提供运行时多态性，只提供编译时多态性。因此，只有在需要某种静态类型抽象的情况下，这种模式才有意义。如果不是这样，它也不是所有继承层次结构的替代品。</p>
<p><strong>CRTP 的未来：CRTP 与 C++20 概念的比较</strong></p>
<p>“我明白了，你是对的。CRTP 是纯粹的编译时多态性。然而，这让我思考：我们能否基于 C++20 概念而不是 CRTP 来构建？考虑以下代码。我们可以使用概念来定义一组类型的接口要求，并将函数和运算符限制为仅那些提供预期接口的类型：”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">DenseVector</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">   <span class="k">requires</span> <span class="p">(</span> <span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">      <span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="o">&amp;&amp;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">requires</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="n">t</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">const_iterator</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">const_iterator</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="n">DenseVector</span> <span class="n">VectorT</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">VectorT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vector</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// ... 如之前一样 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>你完全正确。我同意，这是一个非常合理的替代方案。实际上，C++20 概念与 CRTP 非常相似，但提供了更简单、非侵入式的替代方法。特别是由于其非侵入性，如果你可以使用 C++20 概念并可以通过概念定义静态类型集，你应该优先选择概念而不是 CRTP。</p>
<p>尽管如此，我对这个解决方案并不完全满意。虽然这种形式的输出运算符有效地将函数模板限制为仅那些提供预期接口的类型，但它并没有完全限制函数模板到我们的密集向量类型集。仍然有可能传递 <code>std::vector</code> 和 <code>std::string</code>（<code>std::string</code> 在 <code>std</code> 命名空间中已经有一个输出运算符）。因此，这个概念还不够具体。但是如果你遇到这种情况，不用担心：有一种使用标签类的解决方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVectorTag</span> <span class="p">{};</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">DenseVector</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 密集向量的所有要求定义（如前） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_base_of_v</span><span class="o">&lt;</span><span class="n">DenseVectorTag</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DynamicVector</span> <span class="o">:</span> <span class="k">private</span> <span class="n">DenseVectorTag</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过从 <code>DenseVectorTag</code> 类（最好是私有继承）派生，像 <code>DynamicVector</code> 这样的类可以标识为属于某个特定类型的集合。因此，函数和运算符模板可以有效地限制为仅接受那些明确选择加入类型集合的类型。</p>
<p>不幸的是，这里有个问题：这种方法不再是非侵入式的。为了克服这一限制，我们引入了一个可定制的类型特征类来进行编译时间接调用。换句话说，我们应用单一职责原则（SRP）并将关注点分离：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DenseVectorTag</span> <span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IsDenseVector</span>  
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">DenseVectorTag</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">IsDenseVector_v</span> <span class="o">=</span> <span class="n">IsDenseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">DenseVector</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 密集向量的所有要求定义（如前） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&amp;&amp;</span> <span class="n">IsDenseVector_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DynamicVector</span> <span class="o">:</span> <span class="k">private</span> <span class="n">DenseVectorTag</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Size</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StaticVector</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Size</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">IsDenseVector</span><span class="o">&lt;</span> <span class="n">StaticVector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;</span> <span class="o">&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> 
</span></span><span class="line"><span class="cl"><span class="p">{};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>IsDenseVector</code> 类模板及其对应的变量模板指示给定类型是否属于密集向量类型集。DenseVector 概念不会直接查询给定类型，而是通过 <code>IsDenseVector</code> 类型特征间接询问。这样，类可以选择通过继承 <code>DenseVectorTag</code> 或通过非侵入式地特化 <code>IsDenseVector</code> 类型特征来明确选择加入类型集合。在这种形式下，概念方法真正取代了经典的 CRTP 方法。</p>
<p>总结来说，CRTP 是一种用于定义相关类型家族之间编译时关系的出色设计模式。最有趣的是，它解决了继承层次结构中可能遇到的所有性能问题。然而，CRTP 有一些潜在的限制性缺点，例如缺乏通用基类、模板代码的快速传播以及仅限于编译时多态性。在 C++20 中，考虑用概念替换 CRTP，因为概念提供了更简单且非侵入式的替代方案。然而，如果你无法使用 C++20 概念并且 CRTP 适用，它将对你非常有价值。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>应用 CRTP 设计模式为相关类型家族定义编译时抽象。</li>
<li>注意从 CRTP 基类到派生类的有限访问。</li>
<li>记住 CRTP 设计模式的限制，特别是缺乏通用基类。</li>
<li>尽可能优先选择 C++20 概念而非 CRTP 设计模式。</li>
</ul>
<h3 id="准则27使用-crtp-实现静态混入类">准则27：使用 CRTP 实现静态混入类
</h3><p>在“准则 26：使用 CRTP 引入静态类型类别”中，我向你介绍了 CRTP 设计模式。我也可能给你留下了 CRTP 已经过时的印象，被 C++20 概念的出现所取代。然而，有趣的是，事实并非如此。至少不完全是。那是因为我还没有告诉你完整的故事。CRTP 仍然可能有价值：不是作为设计模式，而是作为实现模式。让我们稍微偏离一下，进入实现模式的领域，让我来解释。</p>
<p><strong>强类型动机</strong></p>
<p>考虑以下 <code>StrongType</code> 类模板，它表示任何其他类型的包装器，目的是创建唯一且命名的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;StrongType.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tag</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StrongType</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">StrongType</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">value_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个类可以用于定义类型如 <code>Meter</code>、<code>Kilometer</code> 和 <code>Surname</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Distances.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;StrongType.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Meter</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">MeterTag</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Kilometer</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">KilometerTag</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;StrongType.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Surname</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">SurnameTag</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用别名模板（alias templates）为 <code>Meter</code> 和 <code>Kilometer</code> 允许你选择不同的类型（例如 <code>long</code> 或 <code>double</code>）来表示距离。尽管这些类型基于基础类型或标准库类型（如 <code>std::string</code>），它们代表具有语义意义的独特类型（强类型），不能在算术操作中意外地组合在一起，例如加法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Distances.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">Meter</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">{</span> <span class="mi">120L</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">Meter</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">{</span> <span class="mi">50L</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">km</span> <span class="o">=</span> <span class="n">Kilometer</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">{</span> <span class="mi">30L</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">surname1</span> <span class="o">=</span> <span class="n">Surname</span><span class="p">{</span> <span class="s">&#34;Stroustrup&#34;</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">surname2</span> <span class="o">=</span> <span class="n">Surname</span><span class="p">{</span> <span class="s">&#34;Iglberger&#34;</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 正确地不会编译！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">m1</span> <span class="o">+</span> <span class="n">km</span><span class="p">;</span>              
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 同样正确地不会编译！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">surname1</span> <span class="o">+</span> <span class="n">surname2</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 不幸的是这也无法编译。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">;</span>              
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然 <code>Meter</code> 和 <code>Kilometer</code> 都通过 <code>long</code> 表示，但不能直接将 <code>Meter</code> 和 <code>Kilometer</code> 相加。这是很好的：它不会留下任何意外引入错误的漏洞。同样也不能将两个 <code>Surname</code> 相加，尽管 <code>std::string</code> 提供了字符串拼接的加法运算符。这也是很好的：强类型有效地限制了底层类型的不期望操作。</p>
<p>不幸的是，这一“特性”也阻止了两个 <code>Meter</code> 实例的相加。然而，这种操作是可取的：直观、自然，并且由于操作的结果仍然是 <code>Meter</code> 类型，因此物理上也是准确的。为了实现这一点，我们可以为 <code>Meter</code> 类型实现一个加法运算符。然而，显然这不会是唯一的加法运算符。我们还需要为其他强类型（如 <code>Kilometer</code>、<code>Mile</code>、<code>Foot</code> 等）实现类似的运算符。由于所有这些实现看起来都一样，这违反了 DRY 原则。因此，扩展 <code>StrongType</code> 类模板以包含加法运算符似乎是合理的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tag</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Tag</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Tag</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Tag</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Tag</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于这个加法运算符的表述方式，不可能将两个不同的 <code>StrongType</code> 实例（例如 <code>Meter</code> 和 <code>Kilometer</code>）相加，但它允许相同实例化的两个 <code>StrongType</code> 实例相加。“哦，但我看到了一个问题：虽然现在可以将两个 <code>Meter</code> 或两个 <code>Kilometer</code> 相加，但也可以将两个 <code>Surname</code> 相加。我们不希望那样！” 你是对的：这是不希望的。我们需要的是特定 <code>StrongType</code> 实例化中操作的有意添加。这就是 CRTP 发挥作用的地方。</p>
<p><strong>使用 CRTP 作为实现模式</strong></p>
<p>与其直接为 <code>StrongType</code> 类模板配备操作，我们通过混入类（mixin classes）提供这些操作：这些基类“注入”所需的操作。这些混入类是通过 CRTP 实现的。例如，考虑表示加法操作的 <code>Addable</code> 类模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Addable.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Addable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Derived</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">lhs</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">Derived</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">Derived</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Derived</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>   
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Derived</span><span class="p">{</span> <span class="n">lhs</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>模板参数的名字揭示了它的用途：<code>Addable</code> 是一个 CRTP 基类。<code>Addable</code> 只提供了两个函数，作为隐藏友元实现：赋值加法运算符和加法运算符。这两个运算符都定义在指定的 <code>Derived</code> 类型上，并被注入到周围的命名空间中。因此，任何从这个 CRTP 基类派生的类都会“继承”两个自由加法运算符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;StrongType.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tag</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StrongType</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Addable</span><span class="o">&lt;</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Tag</span><span class="o">&gt;</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Distances.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;StrongType.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Meter</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">MeterTag</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Distances.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">Meter</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">{</span> <span class="mi">100</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">Meter</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">{</span> <span class="mi">50</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="k">const</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">;</span>  <span class="c1">// 编译并得到 150 米的结果 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“我理解混入类的目的，但在这个形式下，所有 <code>StrongType</code> 的实例都会继承一个加法运算符，即使有些实例不需要加法操作，对吧？” 是的，确实如此。因此，我们还没有完成。我们希望的是有选择地将混入类添加到那些需要操作的 <code>StrongType</code> 实例中。我们的解决方案是将混入类以可选模板参数的形式提供。为此，我们将 <code>StrongType</code> 类模板扩展为带有变长模板模板参数包的形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;StrongType.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tag</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span><span class="err">... </span><span class="nc">Skills</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StrongType</span> 
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="k">private</span> <span class="n">Skills</span><span class="o">&lt;</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Tag</span><span class="p">,</span><span class="n">Skills</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">...</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种扩展使我们能够为每个单独的强类型指定所需的技能。例如，考虑另外两个技能 <code>Printable</code> 和 <code>Swappable</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Printable.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Printable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">os</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Swappable.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Derived</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Swappable</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Derived</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>  <span class="c1">// 启用 ADL 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span> <span class="n">lhs</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>结合 <code>Addable</code> 技能，我们现在可以组装具有所需技能的强类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Distances.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;StrongType.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Meter</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">MeterTag</span><span class="p">,</span> <span class="n">Addable</span><span class="p">,</span> <span class="n">Printable</span><span class="p">,</span> <span class="n">Swappable</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Kilometer</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">KilometerTag</span><span class="p">,</span> <span class="n">Addable</span><span class="p">,</span> <span class="n">Printable</span><span class="p">,</span> <span class="n">Swappable</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;StrongType.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Surname</span> <span class="o">=</span> <span class="n">StrongType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">SurnameTag</span><span class="p">,</span> <span class="n">Printable</span><span class="p">,</span> <span class="n">Swappable</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Meter</code> 和 <code>Kilometer</code> 都可以进行加法、打印和交换，而 <code>Surname</code> 可以打印和交换，但不能相加（即不接收 <code>Addable</code> 混入类，因此不从其派生）。</p>
<p>“这太好了。我理解在这种情况下 CRTP 混入类的目的。但这个 CRTP 示例与之前的示例有什么不同？” 很好的问题。你问得对，实现细节非常相似。但有几个显著的区别。注意，CRTP 基类没有提供虚或保护析构函数。因此，与之前的示例相比，它不是设计为多态基类。还要注意，在这个示例中，使用 CRTP 基类作为私有基类就足够了，甚至更好。因此，在这种情况下，CRTP 基类不代表抽象，而是仅作为一个实现细节。因此，CRTP 不具备设计模式的特性，也不充当设计模式。它仍然是一个模式，但在这里只是作为一个实现模式。</p>
<p>CRTP 示例的主要区别在于我们如何使用继承。对于 CRTP 设计模式，我们根据 LSP 使用继承作为抽象：基类代表派生类的要求，以及可用和预期的行为。用户代码通过指向基类的指针或引用直接访问操作，这反过来要求我们提供虚或保护析构函数。当这样实现时，CRTP 成为了软件设计的一个真正元素——一个设计模式。</p>
<p>相比之下，对于 CRTP 实现模式，我们使用继承来实现技术上的优雅和便利。基类成为实现细节，不需要被调用代码知道或使用。因此，它不需要虚或保护析构函数。当这样实现时，CRTP 保持在实现细节层面，因此是一个实现模式。然而，在这种形式下，CRTP 并不与 C++20 概念竞争。相反：在这种形式下，CRTP 是无可替代的，因为它代表了一种提供静态混入功能的独特技术。因此，CRTP 今天仍然在使用，并且是每个 C++ 开发者工具箱中的宝贵补充。</p>
<p>总结来说，CRTP 并没有过时，但它的价值已经改变。在 C++20 中，CRTP 被概念所取代，因此不再作为设计模式。然而，它继续作为混入类的实现模式有价值。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>请注意将CRTP用作设计模式和将其用作实现模式之间的区别。</li>
<li>要理解表示抽象的CRTP基类充当设计模式。</li>
<li>要了解，不表示抽象的CRTP基类充当实现模式。</li>
</ul>
<h2 id="第七章-桥接原型和外部多态设计模式">第七章 桥接、原型和外部多态设计模式
</h2><p>在本章中，我们将专注于两个经典的 GoF（Gang of Four）设计模式：桥接设计模式和原型设计模式。此外，我们还将研究外部多态设计模式。乍一看，这种选择可能显得像是一个杰出的、几乎随机的设计模式组合。然而，我选择这些模式有两个原因：首先，根据我的经验，这三个模式在设计模式目录中是最有用的。因此，你应该对它们的意图、优点和缺点有相当好的了解。其次且同样重要的是：它们在第八章中都将发挥至关重要的作用。</p>
<p><strong>准则 28：构建桥梁以消除物理依赖</strong></p>
<p>在这一部分，我将向你介绍桥接设计模式及其最简单的形式——Pimpl 惯用法。最重要的是，我将展示如何使用桥接来通过解耦接口与实现细节来减少物理耦合。</p>
<p><strong>准则 29：注意桥接性能的增益与损失</strong></p>
<p>在这一部分，我们将明确地探讨桥接对性能的影响。我们将运行基准测试，比较没有桥接的实现、基于桥接的实现以及“部分”桥接的实现。</p>
<p><strong>准则 30：应用原型进行抽象复制操作</strong></p>
<p>在这一部分，我将向你介绍克隆的艺术。也就是说，我们将讨论复制操作，特别是抽象复制操作。为此目的，我们将采用原型设计模式。</p>
<p><strong>准则 31：使用外部多态实现非侵入式运行时多态</strong></p>
<p>在这一部分，我们将继续分离关注点的旅程，通过从类中提取函数的实现细节。为了进一步减少依赖性，我们将这种分离提升到一个新的水平：不仅提取虚拟函数的实现细节，还提取整个函数本身，这将通过外部多态设计模式来实现。</p>
<h3 id="准则-28构建桥梁以消除物理依赖">准则 28：构建桥梁以消除物理依赖
</h3><p>根据词典，术语“桥”表示时间、地点或连接或过渡的方式。如果我问你“桥”这个词对你意味着什么，我相信你会有一个类似的定义。你可能会隐式地想到连接两件事物，并因此使它们更接近。</p>
<p>例如，你可能会想到一个被河流分隔的城市。一座桥会将城市的两边连接起来，使它们更接近，并节省人们很多时间。</p>
<p>你也可能想到电子学中的桥，它连接电路的两个独立部分。音乐中有桥，现实世界中也有很多例子，这些桥帮助我们连接事物。</p>
<p>是的，直觉上，“桥”这个词暗示着增加接近和邻近性。因此，桥接设计模式恰恰相反：它支持你减少物理依赖，并帮助解耦，即保持需要一起工作的两个功能模块在彼此之间保持一定距离，从而不需了解太多对方的细节。</p>
<p><strong>一个激励的例子</strong></p>
<p>为了说明我的想法，考虑以下 <code>ElectricCar</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricEngine.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">ElectricEngine</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">start</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">stop</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ElectricEngine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">ElectricCar</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">drive</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ElectricEngine</span> <span class="n">engine_</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与汽车相关的数据成员（轮子、驱动系统等） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ElectricCar.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">ElectricCar</span><span class="o">::</span><span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">engine_</span><span class="p">{</span><span class="cm">/* engine arguments */</span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 初始化其他数据成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>顾名思义，<code>ElectricCar</code> 类配备了一个 <code>ElectricEngine</code>。然而，尽管在现实中这样的车可能非常有吸引力，当前的实现细节却令人担忧：由于 <code>engine_</code> 数据成员的存在，《ElectricCar.h》头文件需要包含《ElectricEngine.h》头文件。编译器需要看到 <code>ElectricEngine</code> 的类定义，因为否则它无法确定 <code>ElectricCar</code> 实例的大小。</p>
<p>然而，包含《ElectricEngine.h》头文件很容易导致传递性的物理依赖：每个包含《ElectricCar.h》头文件的文件都会物理上依赖于《ElectricEngine.h》头文件。因此，每当头文件发生更改时，<code>ElectricCar</code> 类以及潜在的许多其他类都会受到影响。它们可能需要重新编译、重新测试，甚至在最坏的情况下重新部署……唉。</p>
<p>此外，这种设计暴露了所有实现细节。“你是什么意思？类的私有部分不是用来隐藏和封装实现细节的吗？” 是的，它是私有的，但 <code>private</code> 标签只是一个访问标签。它不是一个可见性标签。</p>
<p>因此，你的类定义中的所有内容（我是指所有内容）对所有能看到 <code>ElectricCar</code> 类定义的人都可见。这意味着你不能在不被人注意的情况下改变这个类的实现细节。特别是，如果你需要提供 ABI 稳定性，即你的类的内存表示不能改变，这可能是一个问题。</p>
<p>稍微好一点的方法是只存储一个指向 <code>ElectricEngine</code> 的指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">ElectricEngine</span><span class="p">;</span>  <span class="c1">// 前向声明 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">ElectricCar</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">drive</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ElectricEngine</span><span class="o">&gt;</span> <span class="n">engine_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与汽车相关的数据成员（轮子、驱动系统等） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ElectricCar.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ElectricEngine.h&gt;</span><span class="cp">   
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">ElectricCar</span><span class="o">::</span><span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">engine_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ElectricEngine</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/* engine arguments */</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 初始化其他数据成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 其他 &#39;ElectricCar&#39; 成员函数，使用指向 &#39;ElectricEngine&#39; 的指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这种情况下，只需要向前声明 <code>ElectricEngine</code> 类即可，因为编译器不需要知道类定义来确定 <code>ElectricCar</code> 实例的大小。</p>
<p>此外，物理依赖也消失了，因为《ElectricEngine.h》头文件已经移到了源文件中。<br/>因此，从依赖关系的角度来看，这个解决方案要好得多，仍然存在的问题是实现细节的可见性，每个人仍然可以看到 <code>ElectricCar</code> 构建在 <code>ElectricEngine</code> 之上，因此每个人都仍然隐式地依赖于这些实现细节。</p>
<p>因此，任何对这些细节的更改，例如升级到新的 <code>PowerEngine</code>，都会影响使用《ElectricCar.h》头文件的所有类。“这是不好的，对吧？” 确实如此，因为变化是可以预期的（参见“指南 2：为变化而设计”）。</p>
<p>为了摆脱这种依赖并获得随时轻松更改实现细节而不被人注意的便利，我们必须引入抽象。经典的抽象形式是引入抽象类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Engine.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Engine</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Engine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与引擎相关的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Engine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ElectricCar</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">drive</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span> <span class="n">engine_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与汽车相关的数据成员（轮子、驱动系统等） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricEngine.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Engine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ElectricEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Engine</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">start</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ElectricCar.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ElectricEngine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">ElectricCar</span><span class="o">::</span><span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">engine_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ElectricEngine</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/* engine arguments */</span><span class="p">)}</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 初始化其他数据成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... 其他 &#39;ElectricCar&#39; 成员函数，主要使用 &#39;Engine&#39; 抽象，但也可能明确处理 &#39;ElectricEngine&#39;
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>有了 <code>Engine</code> 基类，我们可以使用这种抽象实现 <code>ElectricCar</code> 类，没有人需要知道我们使用的实际引擎类型。也没有人需要知道我们何时升级引擎。</p>
<p>通过这种实现，我们可以随时通过仅修改源文件轻松更改实现细节。因此，通过这种方法，我们真正最小化了对 <code>ElectricEngine</code> 实现的依赖。我们将这一细节的知识变成我们的秘密实现细节。通过这样做，我们构建了一座桥梁。</p>
<p><strong>桥接设计模式解释</strong></p>
<p>桥接设计模式是1994年由GoF（四人组）引入的经典设计模式之一。桥接的目的在于通过将某些实现细节封装在抽象之后来最小化物理依赖。在C++中，它充当编译防火墙，使更改变得容易：</p>
<p>在这个意图的表述中，四人组讨论了“抽象”和“实现”。在我们的例子中，<code>ElectricCar</code> 类代表“抽象”，而 <code>Engine</code> 类代表“实现”（参见图7-1）。</p>
<p>这两者都应该能够独立变化，即对其中任何一个的更改都不应影响另一个。</p>
<p>易于更改的障碍是 <code>ElectricCar</code> 类与其引擎之间的物理依赖。因此，想法是提取并隔离这些依赖关系。</p>
<p>通过以 <code>Engine</code> 抽象的形式隔离它们，分离关注点，并满足单一职责原则（SRP），你可以获得灵活地更改、调整或升级引擎的方式（参见“指南 2：为变化而设计”）。</p>
<p>这种变化不再在 <code>ElectricCar</code> 类中可见。结果是，现在可以轻松添加新的引擎类型而不让“抽象”察觉。这符合开放封闭原则（OCP）的思想（参见“指南 5：为扩展而设计”）。</p>
<p>虽然这为我们提供了轻松应用更改的能力，并实现了桥接的想法，但我们可以采取一个额外的步骤来进一步解耦和减少重复。</p>
<p>假设我们不仅对电动汽车感兴趣，还对内燃机汽车感兴趣。因此，对于每一种我们计划实现的汽车类型，我们都希望引入相同的与引擎细节解耦方式，即相同的桥接。为了减少重复并遵循DRY原则，我们可以将桥接相关的实现细节提取到 <code>Car</code> 基类中。<code>Car</code> 基类封装了与关联 <code>Engine</code> 的桥接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Car.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Engine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Car</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span> <span class="n">engine</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与汽车相关的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Engine</span><span class="o">*</span> <span class="n">getEngine</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pimpl_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">    <span class="n">Engine</span> <span class="k">const</span><span class="o">*</span> <span class="nf">getEngine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pimpl_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span>  <span class="c1">// Pointer-to-implementation (pimpl)   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... 更多与汽车相关的数据成员（轮子、驱动系统等） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过添加 <code>Car</code> 类，“抽象”和“实现”都获得了易于扩展的机会，并且可以独立变化。尽管 <code>Engine</code> 基类仍然在此桥接关系中代表“实现”，但现在 <code>Car</code> 类扮演了“抽象”的角色。</p>
<p>关于 <code>Car</code> 类的第一个值得注意的细节是受保护的构造函数。这个选择确保只有派生类才能指定引擎类型。</p>
<p>构造函数接受一个指向 <code>Engine</code> 的 <code>std::unique_ptr</code> 并将其移动到其 <code>pimpl_</code> 数据成员。这个指针数据成员是所有类型的 <code>Car</code> 的单一实现指针，通常称为 pimpl。</p>
<p>这个不透明指针表示到封装的实现细节的桥接，并实质上代表了整个桥接设计模式。</p>
<p>因此，在代码中使用名称 <code>pimpl</code> 来指示你的意图是一个好主意（记住“指南 14：使用设计模式的名称传达意图”）。</p>
<p>注意 <code>pimpl_</code> 被声明在类的私有部分，尽管派生类需要使用它，这一选择是由核心指南 C.133 动机： 避免保护的数据成员。 实际上，经验表明，保护的数据成员几乎不比公共数据成员更好。</p>
<p>因此，为了授予访问 <code>pimpl</code> 的权限，<code>Car</code> 类提供了受保护的 <code>getEngine()</code> 成员函数。</p>
<p><code>ElectricCar</code> 类相应地进行了调整：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Engine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ElectricCar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ElectricCar.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ElectricCar.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ElectricEngine.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">ElectricCar</span><span class="o">::</span><span class="n">ElectricCar</span><span class="p">(</span><span class="cm">/* maybe some engine arguments */</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ElectricEngine</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/* engine arguments */</span><span class="p">))</span>   
</span></span><span class="line"><span class="cl"><span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而不是实现桥接本身，<code>ElectricCar</code> 类现在继承自 <code>Car</code> 基类。这种继承关系引入了通过指定一个 <code>Engine</code> 初始化 <code>Car</code> 基类的要求。这项任务在 <code>ElectricCar</code> 构造函数中完成。</p>
<p><strong>Pimpl惯用法</strong></p>
<p>有一种更简单的桥接设计模式形式，几十年来在C和C++中被广泛成功使用。为了看一个例子，让我们考虑以下的<code>Person</code>类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">year_of_birth</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多访问函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">city_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">zip_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year_of_birth_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能还有更多的数据成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个人包含了许多数据成员：名字、姓氏、完整的邮政地址、出生年份等，并且可能需要在未来添加更多数据成员，如手机号码、Twitter账号或下一个社交媒体热潮的账户信息。</p>
<p>换句话说，可以合理地认为<code>Person</code>类需要随着时间扩展或更改，甚至可能会频繁更改。这可能会给该类的用户带来很多不便：每当<code>Person</code>发生变化时，使用<code>Person</code>的用户必须重新编译他们的代码。更不用说ABI稳定性了：<code>Person</code>实例的大小会改变！</p>
<p>为了隐藏所有对<code>Person</code>实现细节的更改并获得ABI稳定性，你可以使用桥接设计模式。</p>
<p>然而，在这种特定情况下，不需要提供以基类形式的抽象：只有一个并且确切的<code>Person</code>实现。因此，我们所做的就是引入一个名为<code>Impl</code>的私有嵌套类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Person</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">pimpl_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Person.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Person</span><span class="o">::</span><span class="n">Impl</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">city</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">zip</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year_of_birth</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能还有更多的数据成员 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>嵌套的<code>Impl</code>类的任务是封装<code>Person</code>的实现细节。因此，<code>Person</code>类中唯一的剩余数据成员是一个指向<code>Impl</code>实例的<code>std::unique_ptr</code>。</p>
<p>其他所有数据成员以及潜在的一些非虚辅助函数都被移到了<code>Impl</code>类中。</p>
<p>请注意，<code>Impl</code>类仅在<code>Person</code>类中声明但未定义，相反，它在相应的源文件中定义。</p>
<p>只有这样，所有细节及其更改（如添加或删除数据成员，更改数据成员类型等）才会对<code>Person</code>的用户隐藏。</p>
<p>这个<code>Person</code>的实现使用了桥接设计模式的最简单形式：这种局部、非多态形式的桥接被称为Pimpl惯用法。它带来了桥接模式的所有解耦优势，但尽管其简单性，仍然导致了<code>Person</code>类实现稍微复杂一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1">//#include &lt;memory&gt; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Person</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Person</span><span class="p">();</span>    
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Person</span><span class="p">();</span>   
</span></span><span class="line"><span class="cl">    <span class="n">Person</span><span class="p">(</span><span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="n">Person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="n">Person</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="n">Person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">year_of_birth</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多访问函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">pimpl_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1">//#include &lt;Person.h&gt; 
</span></span></span><span class="line"><span class="cl"><span class="c1">//#include &lt;string&gt; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Person</span><span class="o">::</span><span class="n">Impl</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">::</span><span class="n">Person</span><span class="p">()</span>   
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">()}</span> 
</span></span><span class="line"><span class="cl"><span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">::~</span><span class="n">Person</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">::</span><span class="n">Person</span><span class="p">(</span><span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl"><span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">&amp;</span> <span class="n">Person</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pimpl_</span> <span class="o">=</span> <span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">::</span><span class="n">Person</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">))}</span> 
</span></span><span class="line"><span class="cl"><span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">&amp;</span> <span class="n">Person</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pimpl_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Person</span><span class="o">::</span><span class="n">year_of_birth</span><span class="p">()</span> <span class="k">const</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">year_of_birth</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... 更多Person成员函数 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Person</code>构造函数通过<code>std::make_unique()</code>初始化<code>pimpl_</code>数据成员。当然，这涉及动态内存分配，这意味着需要清理动态内存。“所以我们使用<code>std::unique_ptr</code>，”你说。正确。但也许令人惊讶的是，尽管我们使用<code>std::unique_ptr</code>为此目的，仍然需要手动处理析构函数。</p>
<p>“为什么我们必须这样做？<code>std::unique_ptr</code>的目的不就是我们不必处理清理吗？” 是的，但我们仍需这么做。</p>
<p>让我解释一下：如果你不编写析构函数，编译器会为你生成一个析构函数。不幸的是，它会在<code>&lt;Person.h&gt;</code>头文件中生成析构函数。<code>Person</code>的析构函数将触发<code>std::unique_ptr</code>数据成员析构函数的实例化，这反过来又需要<code>Impl</code>类析构函数的定义。</p>
<p>然而，<code>Impl</code>的定义不在头文件中，而是在源文件中定义，否则，它会违背桥接的目的。</p>
<p>因此，编译器会发出关于不完整类型<code>Impl</code>的错误。幸运的是，你不必放弃<code>std::unique_ptr</code>来解决这个问题（事实上你不应该放弃）。问题相当简单：只需将<code>Person</code>析构函数的定义移到源文件中即可：在类定义中声明析构函数并在源文件中通过<code>=default</code>定义它。</p>
<p>由于<code>std::unique_ptr</code>不能被复制，你必须实现拷贝构造函数以保持<code>Person</code>类的拷贝语义。</p>
<p>同样的道理也适用于拷贝赋值运算符，请注意，此运算符假设每个<code>Person</code>实例都将有一个有效的<code>pimpl_</code>。这一假设解释了移动构造函数的实现：而不是简单地移动<code>std::unique_ptr</code>，它执行可能失败或抛出异常的动态内存分配与<code>std::make_unique()</code>。因此，它没有被声明为<code>noexcept</code>。</p>
<p>这一假设还解释了为什么<code>pimpl_</code>数据成员被声明为<code>const</code>，一旦初始化，指针将不再改变，即使在移动操作中也是如此，包括移动赋值运算符。</p>
<p>最后一个值得注意的细节是<code>year_of_birth()</code>成员函数的定义位于源文件中。尽管这个简单的getter函数是一个很好的内联候选者，但是定义仍需移到源文件中。</p>
<p>原因是头文件中的<code>Impl</code>是一个不完全类型。这意味着在头文件中无法访问任何成员（数据和函数）。这只能在源文件中进行，或者更确切地说，只要编译器知道 <code>Impl</code> 的定义，这种情况才有可能实现。</p>
<p><strong>桥接与策略设计模式的比较</strong></p>
<p>“我有一个问题，”你说，“我看到桥接和策略设计模式之间有很大的相似之处。我知道你说过设计模式有时结构上非常相似，唯一的区别在于它们的意图。但这两者之间的具体区别是什么？”</p>
<p>我理解你的问题，这两种模式之间的相似性确实有些令人困惑。然而，有一些方法可以帮助区分它们：如何初始化相应数据成员是一个强有力的指标，表明你在使用哪种模式。</p>
<p>如果一个类不想知道某些实现细节，并因此提供了从外部传递这些细节的机会（例如，通过构造函数或设置函数），那么你很可能在处理策略设计模式。因为灵活配置行为（即减少逻辑依赖）是它的主要关注点，策略模式属于行为设计模式类别。</p>
<p>例如，在以下代码片段中，<code>Database</code>类的构造函数就是一个明显的标志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DatabaseEngine</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">DatabaseEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 许多数据库特定的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Database</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Database</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DatabaseEngine</span><span class="o">&gt;</span> <span class="n">engine</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 许多数据库特定的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DatabaseEngine</span><span class="o">&gt;</span> <span class="n">engine_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 数据库不了解任何实现细节，并通过其构造函数从外部请求 -&gt; 策略设计模式 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Database</span><span class="o">::</span><span class="n">Database</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DatabaseEngine</span><span class="o">&gt;</span> <span class="n">engine</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">engine_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际的<code>DatabaseEngine</code>类型从外部传入，这使得它成为策略设计模式的一个很好的例子。</p>
<p>另一方面，如果一个类了解实现细节，但主要想减少对这些细节的物理依赖，则你很可能在处理桥接设计模式。</p>
<p>在这种情况下，类不会提供任何机会从外部设置指针，也就是说，指针是一个实现细节，并在内部设置。</p>
<p>由于桥接设计模式主要关注实现细节的物理依赖，而不是逻辑依赖，因此桥接模式属于结构性设计模式类别。</p>
<p>例如，考虑以下代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Database</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Database</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DatabaseEngine</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 数据库了解所需的实现细节，但不想过于依赖它 -&gt; 桥接设计模式 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Database</span><span class="o">::</span><span class="n">Database</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConcreteDatabaseEngine</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/* 一些参数 */</span><span class="p">)}</span>  
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>桥接设计模式的应用有一个明显的标志：不是接受外部的 <code>Engine</code> ，而是<code>Database</code>类的构造函数了解<code>ConcreteDatabaseEngine</code>并内部设置它。</p>
<p>图7-4显示了数据库示例的桥接实现的依赖关系图。最重要的是，<code>Database</code>类与<code>ConcreteDatabaseEngine</code>类处于相同的架构级别，并且不允许其他人提供不同的实现。这表明与策略设计模式相比，桥接在逻辑上耦合到特定实现，但在物理上仅通过<code>DatabaseEngine</code>抽象解耦。</p>
<p><strong>分析桥接设计模式的不足</strong></p>
<p>“我完全理解为什么桥接设计模式在社区中如此受欢迎。它的解耦特性真的非常好！”你感叹道。“然而，你一直告诉我每个设计都有其优缺点。我预计会有一些性能损失？”</p>
<p>很好，你还记得每个设计都有其缺点。当然，这包括桥接设计模式，尽管它被证明是非常有用的。是的，你的假设是正确的，确实会有一些性能开销。</p>
<p>桥接设计模式带来的五种开销中的第一种源于这样一个事实：桥接引入了额外的间接层：<strong>pimpl</strong> 指针使得所有对实现细节的访问都变得更加昂贵。</p>
<p>然而，这个指针导致的性能损失有多大是一个需要单独讨论的问题（参见“指南 29：注意桥接的性能增益与损失”）。</p>
<p>不过，这并不是性能开销的唯一来源，还有更多。取决于你是否使用抽象，你可能还需要支付虚函数调用的开销。</p>
<p>此外，由于即使是访问数据成员的最简单函数也无法内联，你也需要为此支付更多的成本。当然，每当创建一个新的基于桥接实现的类实例时，你还需要为额外的动态内存分配支付成本。</p>
<p>最后但同样重要的是，你还应该考虑到引入 <strong>pimpl</strong>  指针所带来的内存开销。所以，是的，隔离物理依赖并隐藏实现细节并不是没有代价的，而是会导致相当大的开销。</p>
<p>尽管如此，这不应该是普遍抛弃桥接解决方案的理由：这总是取决于具体情况。例如，如果底层实现执行缓慢、昂贵的任务（如系统调用），那么这种开销可能根本无法测量。换句话说，是否使用桥接应该根据具体情况决定，并通过性能基准测试来支持。</p>
<p>此外，你已经看到了实现细节并意识到代码复杂性有所增加。由于代码的简洁性和可读性是一种美德，这应该被视为一个缺点。的确，这仅影响类的内部实现，而不影响用户代码。但是，对于经验较少的开发人员来说，一些细节（例如需要在源文件中定义析构函数）可能会令人困惑。</p>
<p>总结来说，桥接设计模式是减少物理依赖最有价值和最常用的解决方案之一。尽管如此，你应该意识到桥接引入的开销和复杂性。以下是一些具体的考虑因素：</p>
<p><strong>性能开销：</strong></p>
<ul>
<li>额外的间接层（pimpl指针）使访问实现细节的成本更高。</li>
<li>使用抽象时，可能需要支付虚函数调用的开销。</li>
<li>简单函数无法内联，增加了成本。</li>
<li>创建新实例时需要进行额外的动态内存分配。</li>
<li>引入 pimpl 指针带来了内存开销。</li>
</ul>
<p><strong>代码复杂性：</strong></p>
<ul>
<li>实现细节变得更为复杂，虽然这对用户代码的影响较小。</li>
<li>对于经验较少的开发人员来说，某些细节（如在源文件中定义析构函数）可能会造成困惑。</li>
</ul>
<p>因此，在选择是否使用桥接设计模式时，应权衡其优点和缺点，并根据具体需求进行评估。<br/>特别是在性能敏感的应用场景中，建议通过实际的性能基准测试来验证桥接设计模式的实际效果。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>注意由数据成员或包括引入的物理依赖关系。</li>
<li>应用桥接设计模式的目的是将物理依赖与实现细节隔离开来；</li>
<li>建议使用pimpl数据成员进行桥接通信。</li>
<li>了解桥接设计模式的优点和缺点。</li>
<li>了解减少物理依赖（桥接）和减少逻辑依赖（策略）之间的区别。</li>
</ul>
<h3 id="准则-29注意桥接的性能增益与损失">准则 29：注意桥接的性能增益与损失
</h3><p>在“准则 28：构建桥梁以消除物理依赖”中，我们详细讨论了桥接设计模式。</p>
<p>虽然我想象桥接的设计和解耦方面给你留下了积极的印象，但我必须让你意识到使用这种模式可能会引入性能损失。“是的，这让我有些担心。性能对我来说很重要，听起来桥接会带来巨大的性能开销，”你说。</p>
<p>这是一个非常普遍的预期，由于性能至关重要，我真的应该给你一个概念，告诉你在使用桥接时需要预期多少开销。然而，我也应该展示如何明智地使用桥接来提高代码的性能。</p>
<p>听起来难以置信？让我向你展示如何做到这一点。</p>
<p><strong>桥接的性能影响</strong></p>
<p>正如在“准则 28：构建桥梁以消除物理依赖”中讨论的那样，桥接实现的性能受到许多因素的影响：通过间接层访问、虚函数调用、内联、动态内存分配等。</p>
<p>由于这些因素和可能的组合非常多，无法给出桥接会耗费多少性能的确切答案。没有捷径，也没有替代方法可以代替为自己的代码组装一些基准测试并运行它们以得出确切答案。</p>
<p>我想展示的是，确实存在由于间接访问数据成员而带来的性能损失，但你仍然可以使用桥接来实际提高性能。</p>
<p>让我们从给你一个关于基准测试的概念开始，为了形成对指针间接层成本的看法，我们将比较以下两种 <code>Person</code> 类的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person1.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Person1</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">city_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">zip_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year_of_birth_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Person1</code> 结构表示一种不基于桥接实现的类型。所有七个数据成员（六个 <code>std::string</code> 和一个 <code>int</code>）都直接属于结构本身。</p>
<p>总共而言，并假设是一个64位机器，一个 <code>Person1</code> 实例的大小是152字节（Clang 11.1）或200字节（GCC 11.1）。</p>
<p>另一方面，<code>Person2</code> 结构是通过Pimpl惯用法实现的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Person2.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Person2</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person2</span><span class="p">(</span><span class="cm">/*...各种person参数...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Person2</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person2.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Person2.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Person2</span><span class="o">::</span><span class="n">Impl</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">city</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">zip</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year_of_birth</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person2</span><span class="o">::</span><span class="n">Person2</span><span class="p">(</span><span class="cm">/*...各种person参数...*/</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...各种person参数...*/</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person2</span><span class="o">::~</span><span class="n">Person2</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所有七个数据成员都被移到嵌套的 <code>Impl</code> 结构中，并且只能通过 <code>pimpl</code> 指针访问。</p>
<p>虽然嵌套的 <code>Impl</code> 结构的总大小与 <code>Person1</code> 的大小相同，但 <code>Person2</code> 结构的大小仅为8字节（再次假设是64位机器）。</p>
<p><strong>注意</strong>：通过桥接设计，你可以减少类型的大小，有时甚至显著减少。这可以证明非常有价值，例如，如果你想将该类型作为 <code>std::variant</code> 的替代方案（参见“准则 17：考虑使用 <code>std::variant</code> 实现访问者”）。</p>
<p>因此，让我概述一下基准测试：我将创建两个包含25,000个人的 <code>std::vector</code>，每个 <code>Person</code> 实现一个。</p>
<p>这个数量的元素将确保我们在底层CPU的内部缓存之外工作（即，我们将使用总计3.2 MB的内存，Clang 11.1），或者4.2 MB（GCC 11.1）。</p>
<p>所有这些人被赋予任意的名字和地址，以及1957年至2004年之间的出生年份（在撰写本文时，这代表了一个组织中员工合理的年龄范围）。</p>
<p>然后我们将遍历这两个 <code>Person</code> <strong>Vector</strong> 五千次，并每次使用 <code>std::min_element()</code> 确定最年长的人。</p>
<p>结果由于基准测试的重复性而相当无趣，一百次迭代后，你会觉得无聊到不想再看。</p>
<p>唯一重要的是看到直接访问数据成员（<code>Person1</code>）和间接访问数据成员（<code>Person2</code>）之间的性能差异。表7-1显示了不同 <code>Person</code> 实现的性能结果，归一化为 <code>Person1</code> 实现的性能。</p>
<p>表7-1 不同 <code>Person</code> 实现的性能结果（归一化性能）</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th><code>Person</code> 实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Person1</code>（无 pimpl）</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td><code>Person2</code>（完整 Pimpl 惯用法）</td>
<td>1.1099</td>
<td>1.1312</td>
</tr>
</tbody>
</table></div>
<p>很明显，在这个特定的基准测试中，桥接实现带来了相当显著的性能损失：对于GCC是11.0%，对于Clang是13.1%。这听起来很多！然而，不要把这些数字看得太认真：显然，结果严重依赖于实际元素的数量、实际数据成员的数量和类型、运行系统的具体配置以及基准测试中执行的实际计算。</p>
<p>如果你改变其中任何一个细节，数字也会改变。因此，这些数字仅表明由于间接访问数据成员而导致有一些，甚至是更多的开销。</p>
<p><strong>使用部分桥接改进性能</strong></p>
<p>“好吧，但这是一个预期的结果，对吧？我应该从中学习什么？”你问道。</p>
<p>我承认这个基准测试非常具体，并不能回答所有问题。然而，它确实为我们提供了一个机会，实际上可以通过桥接来提高性能。</p>
<p>如果你仔细观察 <code>Person1</code> 的实现，你可能会意识到对于给定的基准测试，可达到的性能相当有限：尽管 <code>Person1</code> 的总大小是152字节（Clang 11.1）或200字节（GCC 11.1），但我们只使用了4字节，即单个 <code>int</code>，从整个数据结构中。</p>
<p>这被证明是非常浪费和低效的：因为在基于缓存的架构中，内存总是按缓存行加载，我们从内存中加载的大部分数据实际上根本没有使用。事实上，几乎我们从内存中加载的所有数据都没有被使用：假设缓存行长度为64字节，我们只使用了大约6%的加载数据。</p>
<p>因此，尽管我们根据所有人的出生年来确定最年长的人听起来像是一个计算受限的操作，但实际上我们完全受内存限制：机器根本无法足够快地提供数据，整数单元大多数时间处于空闲状态。</p>
<p>这种设置为我们提供了使用桥接来提高性能的机会，<br/>假设我们可以区分经常使用的数据（如名字、姓氏和出生年份）和很少使用的数据（如邮政地址）。<br/>基于这种区分，我们现在相应地安排数据成员：所有经常使用的数据成员直接存储在 <code>Person</code> 类中。<br/>所有很少使用的数据成员存储在 <code>Impl</code> 结构中。这导致了 <code>Person3</code> 实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Person3.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Person3</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Person3</span><span class="p">(</span><span class="cm">/*...各种person参数...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Person3</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year_of_birth_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Impl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Person3.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Person3.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">struct</span> <span class="nc">Person3</span><span class="o">::</span><span class="n">Impl</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">city</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">zip</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person3</span><span class="o">::</span><span class="n">Person3</span><span class="p">(</span><span class="cm">/*...各种person参数...*/</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">forename_</span><span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="n">surname_</span><span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="n">year_of_birth_</span><span class="p">{</span><span class="cm">/*...*/</span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">,</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*...address相关的参数...*/</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person3</span><span class="o">::~</span><span class="n">Person3</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个 <code>Person3</code> 实例的总大小为 <strong>64字节</strong> （Clang 11.1，两个24字节的 <code>std::string</code>，一个整数，一个指针，以及由于对齐要求的四个填充字节）或 <strong>80字节</strong>（GCC 11.1，两个32字节的 <code>std::string</code>，一个整数，一个指针，以及一些填充）。</p>
<p>因此，<code>Person3</code> 实例只有 <code>Person1</code> 实例的一半大小。这种大小上的差异是可以测量的：表7-2显示了所有 <code>Person</code> 实现的性能结果，包括 <code>Person3</code>。同样，结果归一化为 <code>Person1</code> 实现的性能。</p>
<p>表7-2 不同 <code>Person</code> 实现的性能结果（归一化性能）</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th><code>Person</code> 实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Person1</code>（无 pimpl）</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td><code>Person2</code>（完整 Pimpl 惯用法）</td>
<td>1.1099</td>
<td>1.1312</td>
</tr>
<tr>
<td><code>Person3</code>（部分 Pimpl 惯用法）</td>
<td>0.8597</td>
<td>0.9353</td>
</tr>
</tbody>
</table></div>
<p>与 <code>Person1</code> 实现相比，<code>Person3</code> 的性能提高了14.0%（GCC 11.1）和6.5%（Clang 11.1）。</p>
<p>而且，如前所述，这只是因为我们减少了 <code>Person3</code> 实现的大小。</p>
<p>“哇，这是出乎意料的。我明白了，桥接不一定总是对性能有害，”你说。</p>
<p>是的，确实如此。当然，这总是取决于具体的设置，但区分经常使用和很少使用的数据成员并通过实现“部分”桥接来减少数据结构的大小，可能会对性能产生非常积极的影响。</p>
<p>“性能提升很大，这很好，但这不是违背了桥接的初衷吗？”你问道。</p>
<p>确实，你意识到隐藏实现细节和为了性能“内联”数据成员之间存在二元对立。如常，这取决于具体情况：你需要逐案决定要优先考虑哪一方面。</p>
<p>你也意识到在两个极端之间有一系列完整的解决方案：没有必要将所有数据成员都隐藏在桥接后面。最终，你才是找到给定问题最优解的人。</p>
<p>总之，尽管桥接通常会导致一定的性能损失，但在适当的情况下，实现部分桥接可能会对性能产生非常积极的影响。然而，这只是影响性能的众多因素之一。因此，你应该始终检查桥接是否会导致性能瓶颈，或者部分桥接是否能解决性能问题。最好的验证方法是基于实际代码和尽可能多的实际数据进行有代表性的基准测试。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>请记住，桥接可能会对性能产生负面影响。</li>
<li>需要注意的是，当分离常用数据和不常用数据时，部分桥接可能对性能有正面影响。</li>
<li>始终通过有代表性的基准测试来确认性能瓶颈或改进；不要依赖你的直觉。</li>
</ul>
<h3 id="准则-30应用原型模式进行抽象复制操作">准则 30：应用原型模式进行抽象复制操作
</h3><p>想象一下你坐在一家高档的意大利餐厅里，正在研究菜单。哦，天哪，他们提供了这么多美味的东西.</p>
<p>千层面听起来很棒，但他们提供的比萨选择也很棒。真是难以选择……</p>
<p>然而，你的思绪被打断了，因为服务员端着一道看起来非常诱人的菜肴走过。不幸的是，那道菜不是为你准备的，而是为另一桌客人准备的。哦，哇，那香味……在这一刻，你知道不再需要考虑你想吃什么了：无论是什么，你都要点同样的菜。“啊，服务员，我想要他们点的那道菜。”</p>
<p>同样的问题也可能出现在你的代码中，用C++术语来说，你向服务员请求的是别人盘子里菜肴的副本。</p>
<p>复制一个对象，即创建实例的精确副本，是C++中一项基本重要的操作。<br>如此重要以至于类默认配备了拷贝构造函数和拷贝赋值运算符——这是所谓的“特殊成员函数”中的两个。<br/>然而，在请求一份菜肴的副本时，不幸的是你并不知道具体是什么菜肴。用C++术语来说，你只有一个指向基类的指针（比如说，一个 <code>Dish*</code>）。<br></p>
<p>不幸的是，尝试通过 <code>Dish*</code> 使用拷贝构造函数或拷贝赋值运算符通常不起作用。<br>尽管如此，你仍然想要一个精确的副本。</p>
<p>这个问题的解决方案是另一个经典的GoF设计模式：原型设计模式。</p>
<p><strong>一个关于复制动物的例子：绵羊</strong></p>
<p>作为一个例子，让我们考虑以下 <code>Animal</code> 基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Animal.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Animal</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与动物相关的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了表示 <code>Animal</code> 应该是一个基类的虚析构函数外，类只提供了一个处理打印可爱动物声音的 <code>makeSound()</code> 函数。</p>
<p>一个这样的动物示例是 <code>Sheep</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Sheep.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Animal.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Sheep</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Sheep</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)}</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">makeSound</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与动物相关的函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Sheep.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Sheep.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">Sheep</span><span class="o">::</span><span class="n">makeSound</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;baa</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>main()</code> 函数中，我们现在可以创建一只绵羊并让它发出声音：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Sheep.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建唯一的 Dolly 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">dolly</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Sheep</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;Dolly&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 触发 Dolly 的叫声 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dolly</span><span class="o">-&gt;</span><span class="n">makeSound</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Dolly 很棒，对吧？而且非常可爱！事实上，她非常有趣，我们希望再有一个 Dolly。</p>
<p>然而，我们只有一个指向基类的指针——一个 <code>Animal*</code>。我们不能通过 <code>Sheep</code> 的拷贝构造函数或拷贝赋值运算符来复制它，因为我们（技术上）甚至不知道我们正在处理的是一只 <code>Sheep</code>。它可以是任何种类的动物（例如狗、猫、绵羊等）。</p>
<p>我们也不想只复制 <code>Sheep</code> 的 <code>Animal</code> 部分，因为这被称为切片。哦，我的天，我刚刚意识到这个例子可能特别不适合解释原型设计模式,分割动物听起来很糟糕,所以让我们迅速继续,我们在哪儿？啊，是的，我们想要一个 Dolly 的副本，但我们只有一个 <code>Animal*</code>。这时原型设计模式就派上用场了。</p>
<p><strong>原型设计模式解释</strong></p>
<p>原型设计模式是由四人组收集的五种创建型设计模式之一。它专注于提供一种创建某些抽象实体副本的抽象方式。</p>
<p>意图：“指定要创建的对象种类，使用一个原型实例，并通过复制这个原型创建新的对象。”</p>
<p>原型设计模式通常通过基类中的 <code>virutal clone()</code> 函数实现。考虑更新后的 <code>Animal</code> 基类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Animal.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Animal</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 原型设计模式 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这个 <code>clone()</code> 函数，任何人都可以请求给定（原型）动物的抽象副本，而无需了解任何特定类型的动物（如 Dog、Cat 或 Sheep）。当 <code>Animal</code> 基类正确分配到架构的高层时，它遵循依赖倒置原则。</p>
<p><code>clone()</code> 函数被声明为纯虚函数，这意味着派生类必须实现它。但是，派生类不能随意实现该函数，而是应该返回自身的精确副本（任何其他结果都会违反LSP；参见“准则 6：遵守抽象的预期行为”）。</p>
<p>这个副本通常是通过 <code>new</code> 动态创建并通过指向基类的指针返回的。当然，这不仅导致了一个指针，还需要显式地删除副本。</p>
<p>由于手动清理在现代C++中被认为是不好的做法，指针以 <code>std::unique_ptr</code> 到 <code>Animal</code> 的形式返回。</p>
<p><code>Sheep</code> 类相应地进行了更新：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Sheep.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Animal.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">class</span> <span class="nc">Sheep</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Sheep</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)}</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">makeSound</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>  <span class="c1">// 原型设计模式 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Sheep.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Sheep.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="n">Sheep</span><span class="o">::</span><span class="n">makeSound</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;baa</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">Sheep</span><span class="o">::</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Sheep</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// 复制构造一只绵羊 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在 <code>Sheep</code> 类必须实现 <code>clone()</code> 函数并返回其自身的精确副本：在其自己的 <code>clone()</code> 函数内部，它使用 <code>std::make_unique()</code> 函数及其自己的拷贝构造函数，即使 <code>Sheep</code> 类在未来发生变化，也总是假定会做正确的事情。这种方法有助于避免不必要的重复，从而遵循DRY原则（参见“指南 2：设计变化”）。</p>
<p>请注意，<code>Sheep</code> 类既没有删除也没有隐藏其拷贝构造函数和拷贝赋值运算符。因此，如果你有一只绵羊，你仍然可以通过特殊成员函数复制这只绵羊。这是完全可以的：<code>clone()</code> 仅增加了一种创建副本的方式——一种执行虚拟复制的方式。</p>
<h3 id="准则-31使用外部多态实现非侵入式运行时多态">准则 31：使用外部多态实现非侵入式运行时多态
</h3><p>在“准则 2：设计变化”中，我们看到了关注点分离设计原则的巨大优势。在“准则 19：使用策略隔离事物的执行方式”中，我们利用这种力量通过策略设计模式从一组形状中提取绘图实现细节。</p>
<p>然而，尽管这显著减少了依赖关系，并且我们在“准则 23：优先使用基于值的策略和命令实现”中借助 <code>std::function</code> 现代化了解决方案，但仍然存在一些缺点。特别是，形状类仍然不得不处理 <code>draw()</code> 操作，虽然出于耦合的原因，处理实现细节是不可取的。</p>
<p>此外，也是最重要的一点，策略方法在提取多个多态操作时显得有些不切实际。为了进一步减少耦合并从我们的形状中提取多态操作，我们将继续这一旅程，并将关注点分离原则提升到一个全新的、可能不熟悉的水平：我们将完全分离多态行为。为此，我们将应用外部多态设计模式。</p>
<p><strong>外部多态设计模式解释</strong></p>
<p>让我们回到绘制形状的例子和我们在“准则 23：优先使用基于值的策略和命令实现”中的最新版 <code>Circle</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DrawStrategy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">          <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效且给定的 &#39;std::function&#39; 实例不为空 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">drawer_</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过策略设计模式，我们克服了最初对 <code>draw()</code> 成员函数实现细节的强耦合。我们也找到了一个基于 <code>std::function</code> 的值语义解决方案。</p>
<p>然而，<code>draw()</code> 成员函数仍然是所有从 <code>Shape</code> 基类派生的类的公共接口的一部分，所有的形状都继承了实现它的义务。这是一个明显的缺陷：可以说，绘制功能应该是独立的，是形状的一个孤立方面，而形状本身不应该知道它们可以被绘制的事实。我们已经提取了实现细节这一事实进一步加强了这一论点。</p>
<p>“那么，让我们直接提取 <code>draw()</code> 成员函数，对吧？”你争辩道。你是对的。不幸的是，乍一看这似乎是一件很难做到的事情。我希望你还记得“指南 15：为类型或操作的添加进行设计”，在那里我们得出结论，当你主要想添加类型时，你应该优先选择面向对象的解决方案。从这个角度来看，我们似乎被 <strong>virtual</strong> 的 <code>draw()</code> 函数和表示所有形状可用操作集的 <code>Shape</code> 基类所困，即需求列表。</p>
<p>不过，有一个解决方案。一个相当令人惊讶的方案：我们可以使用外部多态设计模式来提取完整的多态行为。该模式由 Chris Cleeland、Douglas C. Schmidt 和 Timothy H. Harrison 在 1996 年的一篇论文中引入。其意图是使非多态类型（没有单个 <strong>virtual</strong> 函数的类型）能够以多态方式处理。</p>
<p><strong>外部多态设计模式</strong></p>
<p><strong>意图</strong>：“允许不相关且没有 <strong>virtual</strong> 方法的 C++ 类以多态方式处理。这些不相关的类可以通过使用它们的软件以统一的方式处理。”</p>
<p>首先引人注目的是，不再有 <code>Shape</code> 基类。在外部多态设计模式中，不同种类的形状（如 <code>Circle</code>、<code>Square</code> 等）被认为是简单的、非多态类型。</p>
<p>此外，形状不需要知道任何关于绘制的信息。设计模式不是要求形状继承自 <code>Shape</code> 基类，而是引入了一个独立的继承层次结构，形式上表现为 <code>ShapeConcept</code> 和 <code>ShapeModel</code> 类。这种外部层次结构通过引入所有期望的形状操作和要求来为形状引入多态行为。</p>
<p>在我们的简单例子中，多态行为仅包含 <code>draw()</code> 函数。然而，当然，需求集合可以更大（例如 <code>rotate()</code>、<code>serialize()</code> 等）。这一组虚拟函数已被移到抽象的 <code>ShapeConcept</code> 类中，现在它取代了之前的 <code>Shape</code> 基类。</p>
<p>主要的区别在于具体形状不需要了解 <code>ShapeConcept</code>，特别是不需要继承它。因此，形状完全解耦于虚函数集。唯一继承自 <code>ShapeConcept</code> 的类是 <code>ShapeModel</code> 类模板。这个类为特定类型的形状（如 <code>Circle</code>、<code>Square</code> 等）实例化，并作为其包装器。然而，<code>ShapeModel</code> 不会自己实现虚函数的逻辑，而是将请求委托给所需的实现。</p>
<p>“哇，太棒了！我明白了：这个外部层次结构提取了整个虚函数集，从而提取了形状的所有多态行为。”</p>
<p>是的，正是如此。再次强调，这是关注点分离和单一职责原则（SRP）的一个例子。在这种情况下，完整的多态行为被识别为变化点并从形状中提取出来。</p>
<p>而且，SRP 作为开闭原则（OCP）的推动者：有了 <code>ShapeModel</code> 类模板，你可以轻松地将任何新的非多态形状类型添加到 <code>ShapeConcept</code> 层次结构中。只要新类型满足所有所需的操作，这就可以工作。</p>
<p>“我真的很印象深刻。然而，我不确定你所说的‘满足所有所需的操作’是什么意思。你能详细说明一下吗？”</p>
<p>当然可以！我认为当展示具体的代码示例时，好处会变得清晰。因此，让我们用外部多态设计模式重构完整的形状绘制示例。</p>
<p><strong>具体代码示例</strong></p>
<p>首先，我们需要定义 <code>ShapeConcept</code> 和 <code>ShapeModel</code> 类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;ShapeConcept.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ShapeConcept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ShapeModel.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ShapeConcept.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeType</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">ShapeModel</span><span class="p">(</span><span class="n">ShapeType</span> <span class="n">shape</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">shape_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里调用实际的绘制逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">shape_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ShapeType</span> <span class="n">shape_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们修改 <code>Circle</code> 类，使其不继承自 <code>Shape</code>，并且只包含绘制逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 绘制逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Drawing a circle with radius &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">radius_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，在主程序中，我们可以创建 <code>ShapeModel</code> 的实例并使用它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;ShapeModel.h&#34;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Circle.h&#34;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">&gt;&gt;</span> <span class="n">shapes</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个 Circle 对象并将其包装在 ShapeModel 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Circle</span> <span class="n">circle</span><span class="p">(</span><span class="mf">10.0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">circleModel</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ShapeModel</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">circle</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">circleModel</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用绘制函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这种方式，我们可以将绘制逻辑与形状的具体实现解耦，并允许灵活地添加新的形状类型，而无需修改现有的代码。</p>
<p><strong>形状绘制再探讨</strong></p>
<p>让我们从 <code>Circle</code> 和 <code>Square</code> 类开始：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的半径是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多获取器和与圆相关的实用函数 */</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多数据成员 */</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的边长是否有效 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多获取器和与正方形相关的实用函数 */</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多数据成员 */</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两个类已经被简化为基本的几何实体。它们完全是非多态的，即不再有基类且没有虚拟函数。最重要的是，这两个类完全不知道任何可能引入人工依赖的操作，如绘制、旋转、序列化等。</p>
<p>相反，所有这些功能都在 <code>ShapeConcept</code> 基类中引入，并由 <code>ShapeModel</code> 类模板实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ShapeConcept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能更多的多态操作 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DrawStrategy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">ShapeT</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">ShapeModel</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">shape_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">)},</span> 
</span></span><span class="line"><span class="cl">          <span class="n">drawer_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="cm">/* 检查给定的 &#39;std::function&#39; 不为空 */</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">shape_</span><span class="p">);</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能更多的多态操作 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ShapeT</span> <span class="n">shape_</span><span class="p">;</span>   <span class="c1">// 组合而非继承（记住“指南 20：优先使用组合而非继承”）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>ShapeConcept</code> 类引入了一个纯虚函数 <code>draw()</code>。</p>
<p>在我们的例子中，这个唯一的虚函数代表了形状的所有要求集。尽管集合很小，但 <code>ShapeConcept</code> 类代表了一种经典的抽象，符合里氏替换原则（LSP）（见“指南 6：遵守抽象的预期行为”）。这种抽象在 <code>ShapeModel</code> 类模板中实现。</p>
<p>值得注意的是，<code>ShapeModel</code> 的实例是唯一继承自 <code>ShapeConcept</code> 的类；不期望其他类进入这种关系。<code>ShapeModel</code> 类模板将为每种所需的形状类型实例化，即 <code>ShapeT</code> 模板参数可以是 <code>Circle</code>、<code>Square</code> 等类型。请注意，<code>ShapeModel</code> 存储了相应形状的一个实例，它作为一个包装器，通过所需的多态行为（在我们的情况下是 <code>draw()</code> 函数）增强特定形状类型。</p>
<p>由于 <code>ShapeModel</code> 实现了 <code>ShapeConcept</code> 抽象，因此需要提供 <code>draw()</code> 函数的实现。然而，实现 <code>draw()</code> 细节的责任并不在于 <code>ShapeModel</code> 自身。相反，它应该将绘制请求转发到实际的实现。为此，我们可以再次使用策略设计模式和 <code>std::function</code> 的抽象能力。</p>
<p>这一选择很好地解耦了绘制的实现细节和所有必要的绘制数据（颜色、纹理、透明度等），这些数据可以存储在可调用对象中。因此，<code>ShapeModel</code> 存储了一个 <code>DrawStrategy</code> 实例，并在触发 <code>draw()</code> 函数时使用该策略。</p>
<p>尽管如此，策略设计模式和 <code>std::function</code> 并不是唯一的选择。在 <code>ShapeModel</code> 类模板内，你可以完全灵活地按自己的方式实现绘制。换句话说，在 <code>ShapeModel::draw()</code> 函数中，你定义了特定形状类型的真正需求。例如，你可以选择转发到 <code>ShapeT</code> 形状的成员函数（不必命名为 <code>draw()</code>！），或者转发到形状的自由函数。只需确保不要对 <code>ShapeModel</code> 或 <code>ShapeConcept</code> 抽象施加人为的要求。无论哪种方式，用于实例化 <code>ShapeModel</code> 的任何类型都必须满足这些要求才能使代码编译。</p>
<p>“<code>ShapeModel</code> 是否是对最初的 <code>Circle</code> 和 <code>Square</code> 类的一种泛化？那些也持有 <code>std::function</code> 实例的类？” 是的，这是一个很好的认识。</p>
<p>实际上，可以说 <code>ShapeModel</code> 是初始形状类的模板版本。因此，它有助于减少引入策略行为所需的样板代码，并根据 DRY 原则改进实现（见“指南 2：设计变化”）。然而，你获得的好处更多：例如，由于 <code>ShapeModel</code> 已经是一个类模板，你可以轻松地从当前的运行时策略实现切换到编译时策略实现（即基于策略的设计；见“指南 19：使用策略隔离事物的执行方式”）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span> <span class="o">&gt;</span>   
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">ShapeModel</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">shape_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">)},</span> 
</span></span><span class="line"><span class="cl">          <span class="n">drawer_</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">)}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">shape_</span><span class="p">);</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ShapeT</span> <span class="n">shape_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了基于 <code>std::function</code>，你还可以向 <code>ShapeModel</code> 类模板传递一个额外的模板参数，表示绘制策略（）。这个模板参数甚至可以有一个默认值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DefaultDrawer</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">obj</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">draw</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span> <span class="o">=</span> <span class="n">DefaultDrawer</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">ShapeModel</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span> <span class="o">=</span> <span class="n">DefaultDrawer</span><span class="p">{})</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 如前所述 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与直接对 <code>Circle</code> 和 <code>Square</code> 类应用基于策略的设计相比，这种编译时方法在此上下文中只有好处而没有缺点。首先，由于减少了运行时间接调用（<code>std::function</code> 的预期性能劣势），你获得了性能提升。其次，你不需要通过添加模板参数来人为地扩充 <code>Circle</code>、<code>Square</code> 和所有其他形状类以配置绘制行为。你现在只需要为包装器这样做，这会增强绘制行为，并且只在一个地方完成（这再次很好地遵循了 DRY 原则）。第三，你不需要通过将常规类转换为类模板而在头文件中增加额外的代码。只有已经作为类模板的精简版 <code>ShapeModel</code> 需要驻留在头文件中。因此，你避免了创建额外的依赖关系。</p>
<p>“哇，这个设计模式越来越好了。这真是继承和模板的强大结合！” 是的，我完全同意。这是结合运行时和编译时多态的一个范例：<code>ShapeConcept</code> 基类为所有可能的类型提供了抽象，而派生的 <code>ShapeModel</code> 类模板为特定形状代码提供了代码生成。最令人印象深刻的是，这种结合带来了巨大的优势，减少了依赖关系。</p>
<p>看看图7-8，它展示了我们实现外部多态设计模式的依赖关系图。在架构的最高层次上是 <code>ShapeConcept</code> 和 <code>ShapeModel</code> 类，它们共同代表了形状的抽象。<code>Circle</code> 和 <code>Square</code> 是这种抽象的可能实现，但仍然完全独立：没有继承关系，没有组合，什么都没有。只有为特定类型的形状和特定的 <code>DrawStrategy</code> 实现实例化 <code>ShapeModel</code> 类模板时，才会将所有方面结合起来。然而，请特别注意，所有这一切都发生在我们架构的最低层：模板代码在所有依赖关系已知的地方生成，并“注入”到我们架构的正确层级。因此，我们确实拥有一个适当的架构：所有依赖关系连接都朝着更高的层级运行，并几乎自动遵循依赖倒置原则（DIP）。</p>
<p><strong>功能实现后，我们可以自由实现任何所需的绘制行为</strong></p>
<p>例如，我们可以再次使用OpenGL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;OpenGLDrawStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include </span><span class="cm">/* OpenGL 图形库头文件 */</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OpenGLDrawStrategy</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OpenGLDrawStrategy</span><span class="p">(</span><span class="cm">/* 与绘制相关的参数 */</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">square</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 与绘制相关的数据成员，如颜色、纹理等 */</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于 <code>OpenGLDrawStrategy</code> 不需要继承自任何基类，你可以自由地按需实现它。如果愿意，你可以将绘制圆和绘制正方形的实现合并到一个类中。这不会创建任何人为的依赖关系，类似于我们在“指南 19：使用策略隔离事物的执行方式”中所经历的，我们将这些功能合并到了基类中。</p>
<p><strong>注意</strong></p>
<p>将绘制圆和正方形结合在一个类中表示的内容与从两个策略基类继承类是相同的。在架构的这一层面上，这不会创建任何人为的依赖关系，仅是一个实现细节。唯一需要遵循的约定是为 <code>Circle</code> 和 <code>Square</code> 提供函数调用运算符（），因为这是 <code>ShapeModel</code> 类模板中定义的调用约定。</p>
<p>在 <code>main()</code> 函数中，我们将所有细节组合在一起：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;OpenGLDrawStrategy.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">Shapes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">&gt;&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">CircleModel</span> <span class="o">=</span> <span class="n">ShapeModel</span><span class="o">&lt;</span><span class="n">Circle</span><span class="p">,</span> <span class="n">OpenGLDrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">SquareModel</span> <span class="o">=</span> <span class="n">ShapeModel</span><span class="o">&lt;</span><span class="n">Square</span><span class="p">,</span> <span class="n">OpenGLDrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Shapes</span> <span class="n">shapes</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一些形状，每个都配备了OpenGL绘制策略 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CircleModel</span><span class="o">&gt;</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">            <span class="n">Circle</span><span class="p">{</span><span class="mf">2.3</span><span class="p">},</span> <span class="n">OpenGLDrawStrategy</span><span class="p">(</span><span class="cm">/*...红色...*/</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SquareModel</span><span class="o">&gt;</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">            <span class="n">Square</span><span class="p">{</span><span class="mf">1.2</span><span class="p">},</span> <span class="n">OpenGLDrawStrategy</span><span class="p">(</span><span class="cm">/*...绿色...*/</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CircleModel</span><span class="o">&gt;</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">            <span class="n">Circle</span><span class="p">{</span><span class="mf">4.1</span><span class="p">},</span> <span class="n">OpenGLDrawStrategy</span><span class="p">(</span><span class="cm">/*...蓝色...*/</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制所有形状 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">shape</span> <span class="p">:</span> <span class="n">shapes</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，我们首先创建一个空的形状向量（这次是 <code>std::unique_ptr&lt;ShapeConcept&gt;</code> 的向量）（），然后添加三个形状。在调用 <code>std::make_unique()</code> 时，我们实例化了 <code>ShapeModel</code> 类用于 <code>Circle</code> 和 <code>Square</code>（称为 <code>CircleModel</code> 和 <code>SquareModel</code> 以提高可读性），并传递了必要的细节（具体的形状和相应的 <code>OpenGLDrawStrategy</code>）。之后，我们能够以所需的方式绘制所有形状。</p>
<p>总体而言，这种方法提供了许多显著的优点：</p>
<ul>
<li><strong>关注点分离和从形状类型中提取多态行为</strong>：消除了对图形库等的所有依赖，创建了非常松散的耦合，并且很好地遵循了单一职责原则（SRP）。</li>
<li><strong>形状类型变得更简单且非多态</strong>：可以轻松添加新的形状类型，甚至可能是第三方类型，因为你不再需要侵入式地继承自 <code>Shape</code> 基类或创建适配器（见“指南 24：使用适配器标准化接口”）。因此，完美地遵循了开闭原则（OCP）。</li>
<li><strong>显著减少通常与继承相关的样板代码</strong>：只需在一个地方实现，这很好地遵循了DRY原则。</li>
<li><strong>由于 <code>ShapeConcept</code> 和 <code>ShapeModel</code> 类属于一起并且共同形成抽象</strong>，更容易遵循依赖倒置原则（DIP）。</li>
<li><strong>通过利用可用的类模板减少间接调用的数量</strong>，可以提高性能。</li>
</ul>
<p>此外，外部多态设计模式还有一个更为令人印象深刻的优势：你可以非侵入式地为任何类型配备多态行为。真的，任何类型，甚至是像 <code>int</code> 这样简单的类型。为了演示这一点，让我们看一下以下代码片段，假设 <code>ShapeModel</code> 配备了一个默认绘制器（DefaultDrawer），该绘制器期望被包装的类型提供一个自由的 <code>draw()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 绘制一个整数，例如将其打印到命令行 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ShapeModel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>  <span class="c1">// 绘制整数   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们为 <code>int</code> 提供了一个自由的 <code>draw()</code> 函数（）。在 <code>main()</code> 函数中，我们现在实例化了一个 <code>ShapeModel</code> 用于 <code>int</code>。这一行会编译，因为 <code>int</code> 满足所有要求：它提供了一个自由的 <code>draw()</code> 函数。因此，在下一行我们可以“绘制”这个整数。</p>
<p>“你真的希望我这样做吗？”你皱着眉头问道。不，我不建议你在实际项目中这样做。请将此视为技术演示，而不是推荐做法。但是尽管如此，这确实令人印象深刻：我们刚刚非侵入式地为一个 <code>int</code> 配备了多态行为。确实令人印象深刻！</p>
<p><strong>外部多态与适配器的比较</strong></p>
<p>“既然你提到适配器设计模式，我觉得它与外部多态设计模式非常相似。这两者之间有什么区别？” 很好的问题！你提出了原始论文中Cleeland、Schmidt和Harrison也讨论过的问题。是的，这两种设计模式确实非常相似，但有一个非常明显的区别：虽然适配器设计模式专注于标准化接口，并使类型或函数适应现有的接口，但外部多态设计模式创建一个新的外部层次结构，从一组相关的非多态类型中进行抽象。所以，如果你将某些东西适应现有接口，则（很可能）应用的是适配器设计模式。然而，如果你为了以多态方式处理一组现有类型而创建一个新的抽象，则（最有可能）应用的是外部多态设计模式。</p>
<p><strong>分析外部多态设计模式的不足</strong></p>
<p>“我感觉你非常喜欢外部多态设计模式，对吗？”你可能会这么想。是的，确实如此，我对这种设计模式感到非常惊讶。在我看来，这种设计模式是实现松耦合的关键，遗憾的是它并不广为人知。也许是因为许多开发者并没有完全接受关注点分离的原则，并倾向于将所有内容都放入少数几个类中。尽管我对外部多态充满热情，但我不想给人留下这种设计模式完美无缺的印象。不，正如多次提到的，每个设计都有其优点和缺点，外部多态设计模式也不例外。</p>
<p>外部多态设计模式的主要不足在于它并没有真正满足简洁和简单解决方案的期望，尤其是基于值语义的解决方案。它不会减少指针的使用，不会减少手动分配的数量，也不会降低继承层次结构的数量，更不会简化用户代码。相反，由于需要显式地实例化 <code>ShapeModel</code> 类，用户代码会显得稍微复杂一些。然而，如果你认为这是一个严重的缺点，或者你在想“这应该以某种方式自动化”，那么我有一个好消息：在“指南 32：考虑用类型擦除替代继承层次结构”中，我们将探讨一种现代 C++ 解决方案，它可以优雅地解决这个问题。</p>
<p>除此之外，我还想提醒两点需要注意的地方：</p>
<p><strong>适当的抽象</strong>：外部多态的应用并不会免除你思考适当抽象的责任。<code>ShapeConcept</code> 基类同样要遵循接口隔离原则（ISP）。</p>
<p>例如，我们可以很容易地将外部多态应用到“指南 3：通过分离接口避免人为耦合”中的 <code>Document</code> 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DocumentConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Document</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DocumentT</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DocumentModel</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DocumentT</span> <span class="n">document_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>DocumentConcept</code> 类扮演了 <code>ShapeConcept</code> 基类的角色，而 <code>DocumentModel</code> 类模板则扮演了 <code>ShapeModel</code> 类模板的角色。然而，这个外部化的层次结构与原始层次结构存在同样的问题：对于只需要 <code>exportToJSON()</code> 功能的所有代码来说，它引入了对 <code>ByteStream</code> 的人为依赖。正确的做法是通过将接口分离为 JSON 导出和序列化这两个正交方面来分离关注点。</p>
<p><strong>语义一致性</strong>：</p>
<p>外部多态，就像适配器设计模式一样，使得包装那些不符合语义预期的类型变得非常容易。类似于“指南 24：使用适配器标准化接口”中的鸭子类型示例，我们假装火鸡是一只鸭子，我们也假装 <code>int</code> 是一个形状。为了满足要求，我们所要做的就是提供一个自由的 <code>draw()</code> 函数。虽然这很简单，但可能过于简单。</p>
<p>因此，请记住用于实例化 <code>ShapeModel</code> 类模板的类（如 <code>Circle</code>、<code>Square</code> 等）必须遵守里氏替换原则（LSP）。毕竟，<code>ShapeModel</code> 类只是一个包装器，并将 <code>ShapeConcept</code> 类定义的要求传递给具体的形状。</p>
<p>因此，具体的形状负责正确实现预期的行为。任何未能完全满足这些期望的情况都可能导致（潜在的微妙）行为异常。不幸的是，由于这些要求已经被外部化，沟通预期行为变得更加困难。</p>
<p>然而，在 <code>int</code> 示例中，可能是我们自己选择的抽象有问题。或许 <code>ShapeConcept</code> 基类并不能很好地代表形状的抽象。合理地说，形状不仅仅是绘制。也许我们应该将抽象命名为 <code>Drawable</code>，这样 LSP 就会被满足。也许不是。最终，一切都归结于抽象的选择。这让我们回到第 2 章的主题：“构建抽象的艺术”。这并不容易，但也许这些例子表明它是重要的，非常重要。这可能是软件设计的本质。</p>
<p>总之，尽管外部多态设计模式可能无法满足你对简单或基于值的解决方案的期望，但它仍然是实现软件实体解耦的重要一步。从减少依赖的角度来看，这种设计模式似乎是松耦合的关键成分，并且是关注点分离力量的一个绝佳示例。</p>
<p>它还给我们一个重要启示：使用这种设计模式，你可以非侵入式地为任何类型配备多态行为（例如虚拟函数），从而使任何类型都可以表现得多态，甚至是一个简单的值类型如 <code>int</code>。这一认识开启了一个全新的、令人兴奋的设计空间，我们将在下一章继续探索。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>应用外部多态设计模式的目的是支持对非多态类型的多态处理。</li>
<li>将外部多态性设计模式视为实现松耦合的关键。</li>
<li>利用外部化继承层次结构的设计灵活性。</li>
<li>理解外部多态和适配器之间的区别。</li>
<li>选择非侵入性解决方案而不是侵入性解决方案。</li>
</ul>
<h2 id="第八章-类型擦除设计模式">第八章 类型擦除设计模式
</h2><p>关注点分离和值语义是我在本书中多次提到的两个核心要点。</p>
<p>在本章中，这两者被巧妙地结合进了一个最有趣的现代C++设计模式之一：类型擦除。</p>
<p>鉴于这一模式可被视为当前最为热门的话题之一，在本章中我将为你提供一个非常全面、深入的介绍，涵盖类型擦除的所有方面。当然，这包括所有与设计相关的方面以及大量关于实现细节的具体信息。</p>
<p>在 <strong>“准则32：考虑用类型擦除替代继承层次结构</strong>”中，我会向你介绍类型擦除，并让你了解为何这种设计模式是依赖性减少和值语义如此出色的结合。我还会带你走过一个基本的拥有类型的类型擦除实现过程。</p>
<p>“<strong>准则33：注意类型擦除的优化潜力</strong>”是一个例外：尽管在这本书中我主要关注的是依赖性和设计方面，但在这一条指南中，我将完全专注于与性能相关的实现细节。我会展示如何应用小缓冲区优化(SBO)以及如何实现手动虚拟分派来加速你的类型擦除实现。</p>
<p>在“<strong>准则34：注意拥有类型擦除包装器的设置成本</strong>”部分，我们将探讨拥有类型擦除实现的设置成本。我们会发现，值语义伴随有一个成本，有时我们可能不愿意支付这个成本。</p>
<p>基于此原因，我们敢于踏入引用语义领域，实现一种非拥有的类型擦除形式。通过这些讨论，我们可以更深刻地理解类型擦除模式在现代C++编程中的重要性和实际应用价值。</p>
<h3 id="准则32考虑用类型擦除替代继承层次结构">准则32：考虑用类型擦除替代继承层次结构
</h3><p>本书中反复提到的几条建议包括：</p>
<ul>
<li>最小化依赖。</li>
<li>分离关注点。</li>
<li>优先组合而非继承。</li>
<li>优先非侵入式解决方案。</li>
<li>优先值语义而非引用语义。</li>
</ul>
<p>单独使用这些指导原则，它们对代码质量有非常积极的影响。然而，结合起来使用，这些指南证明更加有效。</p>
<p>在讨论“<strong>准则31：使用外部多态实现非侵入式运行时多态性</strong>”中的外部多态设计模式时，你已经体验过这一点。</p>
<p>提取多态行为被证明是非常强大的，并解锁了前所未有的松耦合水平。然而，令人失望的是，演示的外部多态实现并没有给你一种非常现代的解决问题的方式。</p>
<p>该实现基于引用语义（许多指针、手动分配和手动生命周期管理），而不是遵循偏好值语义的建议。</p>
<p>因此，你期待的缺失细节是基于值语义的外部多态设计模式实现。而这个解决方案通常被称为类型擦除。</p>
<p><strong>类型擦除的历史</strong></p>
<p>在详细介绍之前，让我们快速回顾一下类型擦除的历史。“得了吧”，你可能会说，“这真的有必要吗？我迫不及待地想看到它是如何工作的。”</p>
<p>好吧，我保证简短说明。但确实，我认为这是讨论中必要的细节，有两个原因：首先，展示我们作为社区，除了最有经验的C++专家之外，可能忽视了这项技术太久；其次，给予这项技术发明者应有的认可。</p>
<p>类型擦除设计模式常归功于最早也是最著名的介绍这一技术之一的演讲，</p>
<p>在2013年的<strong>GoingNative</strong>大会上，<strong>Sean Parent</strong>做了题为《继承是邪恶的基础类》的演讲，他回顾了<strong>Photoshop</strong>开发的经验，并讨论了基于继承实现的危险性和缺点。</p>
<p>他还提出了一种解决继承问题的方法，后来被称为类型擦除。</p>
<p>尽管Sean的演讲可能是最早的记录之一，也因此可能是关于类型擦除最知名的资源，但在那之前这种技术已经被使用了很长时间。</p>
<p>例如，<strong>类型擦除</strong>被用于<strong>Boost</strong>库中的多个地方，比如<strong>Douglas Gregor</strong>为<strong>boost::function</strong>所做的工作。</p>
<p>然而，据我所知，这项技术最早是在<strong>Kevlin Henney</strong>于2000年7月至8月版的《C++ Report》上发表的一篇论文中讨论的。</p>
<p>在这篇论文中，<strong>Kevlin</strong>通过一个代码示例展示了<strong>类型擦除</strong>，该示例后来演变成了我们现在所知的C++17的<strong>std::any</strong>。</p>
<p>最重要的是，他是第一个优雅地结合几种设计模式来围绕一组无关的、非多态类型形成基于值语义实现的人。</p>
<p>自那时以来，许多常见的类型采用了这种技术，为各种应用提供了值类型。其中一些类型甚至进入了标准库。例如，我们已经看到了代表可调用对象值抽象的<strong>std::function</strong>，以及我提到过的代表几乎任何东西的抽象容器值（因此得名）但不暴露任何功能的<strong>std::any</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;any&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_literals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">any</span> <span class="n">a</span><span class="p">;</span>          <span class="c1">// 创建一个空的 &#39;any&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>               <span class="c1">// 存储一个&#39;int&#39;到 &#39;any&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;some string&#34;</span><span class="n">s</span><span class="p">;</span>  <span class="c1">// 将 &#39;int&#39; 替换为 &#39;std::string&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 我们能做的只是从 &#39;any&#39; 中取回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>还有使用类型擦除存储分配删除器的<strong>std::shared_ptr</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 创建带有自定义删除器的&#39;std::shared_ptr&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 注意删除器不是类型的一部分！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">42</span><span class="p">},</span> <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">){</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}};</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// &#39;std::shared_ptr&#39; 在作用域结束时销毁，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// 通过自定义删除器删除&#39;int&#39;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“看起来只需要为删除器提供第二个模板参数会更简单，就像<strong>std::unique_ptr</strong>那样。为什么<strong>std::shared_ptr</strong>不以相同方式实现呢？”</p>
<p>其实，<strong>std::shared_ptr</strong>和<strong>std::unique_ptr</strong>的设计不同是有充分理由的。</p>
<p><strong>std::unique_ptr</strong>的理念是最简单的原始指针包装，它应像原始指针一样快，并且大小也相同。</p>
<p>因此，不希望将删除器与托管指针一起存储。因此，对于无状态删除器，<strong>std::unique_ptr</strong>的设计可以避免任何尺寸开销。</p>
<p>然而，不幸的是，这个第二个模板参数很容易被忽略，导致人为的限制。相比之下，<strong>std::shared_ptr</strong>的设计避免了这种耦合，因为它有机会使用类型擦除实际上擦除删除器的类型，移除任何形式的可能依赖。</p>
<p><strong>类型擦除设计模式解析</strong></p>
<p>“哇，这听起来确实很有趣。这让我对学习类型擦除更加兴奋了。”</p>
<p>好吧，那我们开始吧。然而，请不要期待任何魔法或革命性的新想法。</p>
<p>类型擦除只不过是一个复合设计模式，意味着它是其他三种设计模式的非常聪明且优雅的组合，</p>
<p>这三种设计模式分别是 <strong>外部多态</strong>（实现解耦效果和类型擦除非侵入性本质的关键成分；参见“准则31：使用外部多态实现非侵入式运行时多态性”）、</p>
<p><strong>桥接模式</strong>（创建基于值语义实现的关键；参见“准则28：构建桥梁以消除物理依赖”）以及（可选的）</p>
<p><strong>原型模式</strong>（处理结果值的复制语义所需；参见“准则30：应用原型进行抽象复制操作”）。</p>
<p>这三个设计模式构成了类型擦除的核心，当然，要记住的是，存在不同的解释和实现，主要是为了适应特定上下文。结合这三个设计模式的目的是创建一个包装类型，它代表了一种松散耦合、非侵入式的抽象。</p>
<p><strong>类型擦除复合设计模式</strong></p>
<p><strong>意图</strong>：“为一组扩展的、不相关的、可能非多态但具有相同语义行为的类型提供基于值的、非侵入式的抽象。”</p>
<p>这个表述旨在尽可能简洁且必要地精确。然而，这个意图的每一个细节都带有意义。因此，详细阐述可能是有帮助的：</p>
<ul>
<li><strong>基于值的</strong>： 类型擦除的意图是创建可以复制、移动，并且最重要的是易于推理的值类型。然而，这样的值类型并不具备常规值类型的同等质量；存在一些限制。特别是，类型擦除最适合于一元操作，但对于二元操作有一定的局限性。</li>
<li><strong>非侵入式的</strong>： 类型擦除的意图是基于外部多态设计模式的例子创建一种外部、非侵入式的抽象。所有提供抽象所期望行为的类型都会自动得到支持，而无需对它们进行任何修改。</li>
<li><strong>可扩展的、不相关的类型集合</strong>： 类型擦除牢固地基于面向对象的原则，即能够轻松添加类型。然而，这些类型不应有任何连接。它们不必通过某些基类共享共同的行为。相反，应该能够将任何合适的类型轻松添加到该类型集合中，无需任何侵入措施。</li>
<li><strong>可能的非多态类型</strong>： 正如外部多态设计模式所展示的，类型不应该通过继承加入集合。它们也不必自行提供虚拟功能，而是应与其多态行为解耦。然而，包含基类或虚函数的类型并未被排除在外。</li>
<li><strong>相同的语义行为</strong>： 目标不是为所有可能的类型提供抽象，而是为一组提供相同操作（包括相同的语法）并遵循预期行为（根据LSP，参见“指南6：遵守抽象的预期行为”）的类型提供语义抽象。如果可能的话，对于任何未提供预期功能的类型，应生成编译时错误。</li>
</ul>
<p>考虑到这种意图的表述，因为模式的结构主要由外部多态设计模式的固有结构主导，最重要的区别和补充是在架构的最高层次上的Shape类。</p>
<p>这个类作为外部多态引入的外部层次结构的包装器。主要是因为这个外部层次结构不会再直接使用，同时也反映了ShapeModel存储或“拥有”具体类型的事实，因此类模板名称已更改为OwningShapeModel。</p>
<p>通过这种方式，类型擦除不仅提供了一种强大的工具来管理不同类型之间的复杂关系，还确保了代码的简洁性和灵活性，使其成为现代C++编程中的重要设计模式之一。</p>
<p><strong>拥有类型擦除的实现</strong>
好的，现在让我们在回顾类型擦除的结构时，来看看它的具体实现细节。</p>
<p>尽管你之前已经见过所有这些成分的实际应用，但实现细节对于初学者来说并不友好，甚至可以说有些令人生畏。</p>
<p>尽管我选择了我自己知道的最简单的类型擦除实现，情况依然如此，因此，我会尽量保持一切在合理的水平上，不会过多地深入到实现细节中。</p>
<p>这包括，例如，我不打算挤出每一个微小的性能提升，我不会使用转发引用或避免动态内存分配，</p>
<p>同时，我会优先考虑代码的可读性和清晰度。虽然这对您来说可能有些失望，但我相信这会省去我们很多麻烦。</p>
<p>然而，如果您想深入了解实现细节和优化选项，我建议您参考“<strong>准则33：了解类型擦除的优化潜力</strong>”。</p>
<p>我们再次从<strong>Circle</strong>和<strong>Square</strong>类开始：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Circle</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">radius_</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">radius</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">radius_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多获取器和圆特定的实用函数 */</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">radius_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多数据成员 */</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Square</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">side_</span><span class="p">(</span><span class="n">side</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">side</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">side_</span><span class="p">;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多获取器和正方形特定的实用函数 */</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">side_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* 更多数据成员 */</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两个类自从我们在讨论外部多态时遇到它们以来没有变化。</p>
<p>但是，再次强调这两者是完全无关的、互不相识，并且最重要的是非多态的，意味着它们不继承任何基类或自行引入虚函数。</p>
<p>我们还看到了<strong>ShapeConcept</strong>和<strong>OwningShapeModel</strong>类，后者以前称为<strong>ShapeModel</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConcept</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ShapeConcept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OwningShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span>   
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">OwningShapeModel</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">shape_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> 
</span></span><span class="line"><span class="cl">          <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">shape_</span><span class="p">);</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OwningShapeModel</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ShapeT</span> <span class="n">shape_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">    <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace detail 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>除了名称更改外，还有几个重要的不同点，例如，这两个类已被移到detail命名空间，该命名空间的名称表明，这两个类现在成为实现细节的一部分，即不再直接使用。</p>
<p><strong>ShapeConcept</strong>类仍然引入纯虚函数 <strong>draw()</strong> 来表示绘制形状的要求。</p>
<p>此外，<strong>ShapeConcept</strong>现在还引入了 纯虚 <strong>clone()</strong> 函数。</p>
<p>&ldquo;我知道这是什么，这是原型设计模式！&rdquo; 是的，正确。 <strong>clone()</strong> 这个名字与原型模式密切相关，并强烈暗示了这种设计模式（但不是保证）。</p>
<p>然而，尽管选择这个函数名非常合理和标准，但需要明确指出的是，<strong>clone()</strong> 和 <strong>draw()</strong> 函数名的选择是我们自己的：这些名字现在是实现细节，与我们对ShapeT类型的期望名称没有任何关系。</p>
<p>我们可以同样命名为<strong>do_draw()<strong>和</strong>do_clone()</strong>，这不会对ShapeT类型产生任何影响。</p>
<p>对ShapeT类型的真实要求是由 <strong>draw()</strong> 和 <strong>clone()</strong> 函数的实现定义的。</p>
<p>作为外部层次结构的基类，<strong>ShapeConcept</strong>的 <strong>draw()</strong> 函数、<strong>clone()</strong> 函数和析构函数代表了所有形状的要求集。</p>
<p>这意味着所有形状必须提供某种绘图行为——它们必须是可复制和可销毁的。请注意，这三个函数仅为此示例的要求选择。特别是，可复制性并不是所有类型擦除实现的一般要求。</p>
<p><strong>OwningShapeModel</strong>类再次代表了<strong>ShapeConcept</strong>类的唯一实现。如同之前，<strong>OwningShapeModel</strong>在其构造函数中接受一个具体的形状类型和绘制策略，并使用这些来初始化其两个数据成员。</p>
<p>由于<strong>OwningShapeModel</strong>继承自<strong>ShapeConcept</strong>，它必须实现两个纯虚函数。<strong>draw()<strong>函数通过应用给定的绘制策略来实现，而</strong>clone()<strong>函数则被实现为返回相应</strong>OwningShapeModel</strong>的精确副本。</p>
<p>注意： 如果您现在在想，“哦不， <strong>std::make_unique()</strong> 。这意味着动态内存。然后我就不能在我的代码中使用它了！”——别担心。<strong>std::make_unique()</strong> 只是实现细节，一种保持示例简单的选择。在“准则33：了解类型擦除的优化潜力”中，您将看到如何通过SBO避免动态内存。</p>
<p>“目前为止，我并不怎么印象深刻。我们几乎没超过外部多态设计模式的实现。” 我完全理解您的批评。</p>
<p>然而，我们距离将外部多态转变为类型擦除只差一步，即从引用语义切换到值语义。</p>
<p>我们只需要一个值类型，一个围绕<strong>ShapeConcept</strong>和<strong>OwningShapeModel</strong>引入的外部层次结构的包装器，处理所有我们不想手动执行的细节：<strong>OwningShapeModel</strong>类模板的实例化、管理指针、执行分配以及处理生命周期。这个包装器以<strong>Shape</strong>类的形式给出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">OwningShapeModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">        <span class="n">pimpl_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">ShapeConcept</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Shape</strong>类的第一个，也是最重要的细节是模板化的构造函数。此构造函数的第一个参数可以接受任何形状（称为ShapeT），</p>
<p>第二个参数则是所需的 <strong>DrawStrategy</strong> ,为了简化相应的 <strong>detail::OwningShapeModel</strong> 类模板的实例化，使用方便的类型别名证明是有帮助的。该别名用于通过 <strong>std::make_unique()</strong> 实例化所需的模型。形状和绘制策略都传递给新模型。</p>
<p>新创建的模型用于初始化Shape类的一个数据成员：<strong>pimpl_</strong>。“我也认出了这个，这是桥接模式！” 您高兴地宣布。</p>
<p>是的，又对了。这是桥接设计模式的应用。在构造过程中，我们基于实际给定的<strong>ShapeT</strong>和<strong>DrawStrategy</strong>类型创建了一个具体的<strong>OwningShapeModel</strong>，但我们将其存储为指向<strong>ShapeConcept</strong>的指针。</p>
<p>通过这样做，您创建了一个通往实现细节的桥梁，一个通往真实形状类型的桥梁。</p>
<p>然而，在初始化 <strong>pimpl_</strong> 之后，在构造函数完成后，<strong>Shape</strong> 不再记住实际类型。</p>
<p><strong>Shape</strong>没有模板参数或任何成员函数会揭示它存储的具体类型，也没有数据成员记住给定类型。它持有的只是一个指向ShapeConcept基类的指针。因此，其实现的真实形状类型已经被擦除。因此得名设计模式：<strong>类型擦除</strong>。</p>
<p>我们的<strong>Shape</strong>类缺少的唯一功能是一个真正的值类型所需的复制和移动操作。幸运的是，由于应用了<strong>std::unique_ptr</strong>，我们的工作量相当有限。由于编译器生成的析构函数和两个移动操作都会起作用，我们只需处理两个复制操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shape</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">())</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 复制并交换惯用法 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Shape</span> <span class="nf">copy</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="n">pimpl_</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>复制构造函数</strong>可能是难以实现的函数之一，因为我们不知道存储在其他<strong>Shape</strong>中的具体形状类型。</p>
<p>然而，通过在 <strong>ShapeConcept</strong> 基类中提供 <strong>clone()</strong> 函数，我们可以在不需要知道具体类型的情况下请求一个精确的副本。实现 复制赋值运算符最短、最无痛且最方便 的方法是基于复制并交换惯用法构建。</p>
<p>此外，<strong>Shape</strong> 类提供了一个所谓的隐藏友元函数 <strong>draw()</strong> ，这个友元函数被称为隐藏友元，因为它虽然是一个自由函数，但在 <strong>Shape</strong> 类的主体内定义。</p>
<p>作为友元，它被授予对私有数据成员的完全访问权限，并会被注入到包围的命名空间中。</p>
<p>“你说过朋友不好？” 您问道。我承认，那是我说过的（参见“准则4：设计可测试性”）。</p>
<p>然而，我也明确指出隐藏友元是可以的。在这种情况下，<strong>draw()</strong> 函数是 <strong>Shape</strong> 类不可分割的一部分，确实是真正的朋友（几乎是家庭的一员）。</p>
<p>“但它应该是一个成员函数，对吧？” 您争论道。确实，那也是一个有效的替代方案。如果您更喜欢这种方式，请继续。</p>
<p>在这种情况下，我的偏好是使用自由函数，因为我们的目标之一是通过提取 <strong>draw()</strong> 操作来减少依赖关系。这一目标也应在Shape实现中反映出来。然而，由于该函数需要访问 <strong>pimpl_</strong> 数据成员，并且为了不增加 <strong>draw()</strong> 函数的重载集合，我将其实现为隐藏友元。</p>
<p>就是这样，全部内容。让我们看看新的功能如何优雅地工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个圆作为具体形状类型的代表 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Circle</span> <span class="n">circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个绘制策略形式的lambda表达式 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">drawer</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Circle</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 将形状和绘制策略结合在一个&#39;Shape&#39;抽象中 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这个构造函数调用将实例化一个针对给定&#39;Circle&#39;和lambda类型的&#39;detail::OwningShapeModel&#39; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shape</span> <span class="n">shape1</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">drawer</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制形状 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">draw</span><span class="p">(</span><span class="n">shape1</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过复制构造函数创建形状的副本 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shape</span> <span class="n">shape2</span><span class="p">(</span><span class="n">shape1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制副本会产生相同的结果 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">draw</span><span class="p">(</span><span class="n">shape2</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，我们创建一个形状作为具体形状类型的代表，这感觉很简单，对吧？无需手动分配，也不需要处理指针。</p>
<p>通过 <strong>draw()</strong> 函数，我们能够绘制这个 <strong>Shape</strong>。</p>
<p>紧接着，我们创建形状的副本，这是一个真实的副本，不是一个简单的指针副本。通过 <strong>draw()</strong> 函数绘制副本会产生相同的结果。这感觉很好：您可以依赖值类型的复制操作（在这种情况下，是复制构造函数），并且不需要手动克隆。非常棒，对吧？而且绝对比手动使用外部多态要好得多。</p>
<p>尽管在介绍了所有这些实现细节后，可能一开始不容易看出这一点，但如果您仔细分析实现细节的丛林，我希望您能体会到这种方法的美妙之处：您不再需要处理指针，没有手动分配，也不需要再处理继承层次结构。所有这些细节都在那里，是的，但所有证据都被很好地封装在 <strong>Shape</strong> 类中。</p>
<p>尽管如此，您并没有失去解耦的好处：您仍然能够轻松添加新类型，并且具体形状类型仍然对绘制行为一无所知。它们仅通过 <strong>Shape</strong> 构造函数连接到所需的功能。</p>
<p>“我在想，”您开始问，“难道我们不能让它变得更简单吗？我设想一个 <strong>main()</strong> 函数如下所示”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;YourMain.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个圆作为具体形状类型的代表 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Circle</span> <span class="n">circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 将圆绑定到某些绘制功能 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">drawingCircle</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]()</span> <span class="p">{</span> <span class="n">myCircleDrawer</span><span class="p">(</span><span class="n">circle</span><span class="p">);</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 对带有绘制行为的圆进行类型擦除 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shape</span> <span class="n">shape</span><span class="p">(</span><span class="n">drawingCircle</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制形状 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">draw</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是个很棒的想法。记住，您负责类型擦除包装器的所有实现细节以及如何将类型和操作实现结合起来。</p>
<p>如果您更喜欢这种形式，请继续。但是请不要忘记，在我们的Shape示例中，为了简单和代码简洁，我特意仅使用了具有外部依赖性的单一功能（绘制）。</p>
<p>可能会有更多的函数引入依赖关系，例如形状的序列化。在这种情况下，<strong>lambda</strong> 方法将不起作用，因为您需要多个命名函数（例如，<strong>draw()</strong> 和 <strong>serialize()</strong> ）。因此，最终取决于具体情况，取决于您的类型擦除包装器代表什么样的抽象。</p>
<p>但无论您选择哪种实现方式，请确保不要引入功能之间的伪依赖或代码重复。</p>
<p>换句话说，请记住“准则2：设计适应变化”！这就是我偏爱基于策略设计模式的解决方案的原因，尽管您不应将其视为唯一的解决方案。相反，您应努力充分利用类型擦除的松散耦合潜力。</p>
<p><strong>分析类型擦除设计模式的不足</strong></p>
<p>尽管类型擦除具有其美丽之处，并且从设计角度来看带来了许多好处，但我不会假装这个设计模式没有任何缺点。不，不公平的是隐瞒可能存在的劣势。</p>
<p>首先，也是最明显的，对你来说可能是这个模式实现的复杂性，正如前面所述，我特意将实现细节保持在一个合理的水平上，希望这能帮助你理解其核心思想。</p>
<p>我希望也给了你这样的印象：它实际上并不是那么困难——类型擦除的基本实现可以在大约30行代码内完成。然而，你可能会觉得它仍然过于复杂。</p>
<p>此外，一旦你开始超越基本实现并考虑性能、异常安全性等方面时，实现细节确实会变得相当棘手，</p>
<p>在这种情况下，使用第三方库（如Louis Dionne的dyno库、Eduardo Madrid的zoo库、Gašper Ažman的erasure库或Steven Watanabe的Boost Type Erasure库）</p>
<p>是你的最佳和最方便的选择，而不是自己处理所有这些细节。</p>
<p>在解释 <strong>类型擦除意图</strong> 时，我还提到了第二个更重要的限制：尽管我们现在处理的是可以复制和移动的值，但使用类型擦除进行二元操作并不直接。例如，对这些值进行相等比较并不容易，就像你期望从常规值中得到的一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">shape1</span> <span class="o">==</span> <span class="n">shape2</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>  <span class="c1">// 不编译！ 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>原因是 <strong>Shape</strong> 最终只是一个具体形状类型的抽象，只存储一个指向基类的指针。</p>
<p>如果你直接使用外部多态，也会遇到完全相同的问题，因此这绝对不是 <strong>类型擦除</strong> 中的新问题，甚至你可能不会将其视为真正的缺点。</p>
<p>然而，虽然相等比较不是当你处理基类指针时的预期操作，但它通常是对值的预期操作。</p>
<p><strong>比较两个类型擦除包装器</strong></p>
<p>“这不是只需在 <strong>Shapes</strong> 接口中暴露必要的功能就可以解决的问题吗？”你可能会问。“例如，我们可以简单地向形状的公共接口添加一个 <strong>area()</strong> 函数，并用它来比较两个对象”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">area</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">area</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“这很容易做到。那么我遗漏了什么？” 我同意这可能是你需要的全部：如果两个对象在某些公共属性相等时即认为它们相等，那么这个操作符将适用于你。一般而言，答案取决于具体情况。</p>
<p>在这个特定的例子中，它取决于 <strong>Shape</strong> 类所代表的抽象的语义。问题是：什么时候两个 <strong>Shapes</strong> 相等？考虑以下带有 <strong>Circle</strong> 和 <strong>Square</strong> 的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Square.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span> <span class="n">shape1</span><span class="p">(</span> <span class="n">Circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">}</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span> <span class="n">shape2</span><span class="p">(</span> <span class="n">Square</span><span class="p">{</span><span class="mf">2.71</span><span class="p">}</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">shape1</span> <span class="o">==</span> <span class="n">shape2</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两个Shapes何时相等？它们是否在面积相等时相等，还是只有在抽象背后的实例相等时才相等，即两者都是同一类型且具有相同的属性？这取决于情况。</p>
<p>同样，我可以问，两个人在什么时候相等？他们的名字相同时相等吗？还是当他们所有的特征都相同时才相等？这取决于所需的语义。</p>
<p>虽然第一个比较很容易实现，但第二个则不然。在一般情况下，我认为第二种情况更可能是所需的语义，因此我认为使用 <strong>类型擦除</strong> 进行相等比较以及更广泛的 <strong>二元操作</strong> 并不直接。</p>
<p>请注意，我没有说相等比较是不可能的。</p>
<p>技术上，你可以让它工作，尽管结果往往是一个相当丑陋的解决方案。</p>
<p>因此，你必须承诺不会告诉任何人你是从我这里得到这个想法的。“你让我更加好奇了，”你带着顽皮的笑容说道。好吧，这就是解决方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isEqual</span><span class="p">(</span> <span class="n">ShapeConcept</span> <span class="k">const</span><span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span> <span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OwningShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">isEqual</span><span class="p">(</span> <span class="n">ShapeConcept</span> <span class="k">const</span><span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">OwningShapeModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span><span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="k">const</span><span class="o">*</span> <span class="n">model</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Model</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>   
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span> <span class="n">model</span> <span class="o">&amp;&amp;</span> <span class="n">shape_</span> <span class="o">==</span> <span class="n">model</span><span class="o">-&gt;</span><span class="n">shape_</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace detail 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">isEqual</span><span class="p">(</span> <span class="n">rhs</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">!</span><span class="p">(</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Circle.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">radius</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">radius</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Square.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Square</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Square</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">side</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">side</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了使相等比较起作用，你可以使用<code>dynamic_cast</code>。</p>
<p>然而，这种相等比较的实现有两个严重的缺点。</p>
<p>首先，正如你在“准则18：注意无环访问者的性能”中看到的，<code>dynamic_cast</code>肯定不能算作快速操作。因此，每次比较你都需要付出相当大的运行时间成本。</p>
<p>其次，在这种实现中，只有当两个 <strong>Shapes</strong> 配备了相同的 <strong>DrawStrategy</strong> 时才能成功比较。</p>
<p>虽然这在一个上下文中可能是合理的，但在另一个上下文中也可能被视为不幸的限制。</p>
<p>我知道的唯一解决方案是返回到<code>std::function</code>来存储绘制策略，但这会导致另一个性能损失。总之，根据上下文的不同，相等比较可能是可能的，但它通常既不容易也不便宜。这证明了我之前的声明，即<strong>类型擦除不支持二元操作</strong>。</p>
<p><strong>类型擦除包装器的接口分离</strong></p>
<p>“接口分离原则（ISP）呢？”你问。“在使用外部多态时，很容易在基类中分离关注点。看起来我们已经失去了这种能力，对吗？”</p>
<p>这是一个很好的问题。你还记得我在 “准则31：使用外部多态实现非侵入式运行时多态性” 中的例子，其中使用了<code>JSONExportable</code>和<code>Serializable</code>基类。</p>
<p>确实，使用类型擦除后，我们不能再使用隐藏的基类，只能使用抽象值类型。因此，看起来好像ISP无法实现了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Document</span>  <span class="c1">// 类型擦除后的&#39;Document&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">ByteStream</span><span class="o">&amp;</span> <span class="n">bs</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 尽管只需要JSON导出，但这里强制耦合到&#39;ByteStream&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">exportDocument</span><span class="p">(</span><span class="n">Document</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">doc</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/* 传递必要的参数 */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，幸运的是，这种印象是错误的。你可以通过提供多个类型擦除抽象轻松遵守ISP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span>  <span class="c1">// 类型擦除后的&#39;Document&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">doc</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/* 传递必要的参数 */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">doc</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="cm">/* 传递必要的参数 */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">JSONExportable</span> <span class="n">jdoc</span> <span class="o">=</span> <span class="n">doc</span><span class="p">;</span>  <span class="c1">// 类型擦除后的&#39;JSONExportable&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">jdoc</span><span class="p">.</span><span class="n">exportToJSON</span><span class="p">(</span><span class="cm">/* 传递必要的参数 */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Serializable</span> <span class="n">sdoc</span> <span class="o">=</span> <span class="n">doc</span><span class="p">;</span>  <span class="c1">// 类型擦除后的&#39;Serializable&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sdoc</span><span class="p">.</span><span class="n">serialize</span><span class="p">(</span><span class="cm">/* 传递必要的参数 */</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在考虑这一点之前，请参阅“指南34：注意拥有类型擦除包装器的设置成本”。</p>
<p>“除了实现复杂性和对一元操作的限制外，似乎没有其他缺点。那么，我不得不说这确实是非常棒的东西！优点明显超过了缺点。”</p>
<p>当然，具体情况总是不同的，意味着在特定上下文中，这些问题可能会引起一些麻烦。但我同意，总的来说，类型擦除被证明是一个非常有价值的设计模式。从设计角度来看，你获得了强大的解耦水平，这将显著减少在更改或扩展软件时的痛苦。尽管这已经很吸引人了，但还有更多内容。我已经多次提到性能，但还没有展示任何性能数据。所以让我们来看看性能结果。</p>
<p><strong>性能基准测试</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>实现类型</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向对象的解决方案</td>
<td>1.5205 秒</td>
<td>1.1480 秒</td>
</tr>
<tr>
<td>std::function</td>
<td>2.1782 秒</td>
<td>1.4884 秒</td>
</tr>
<tr>
<td>手动实现的std::function</td>
<td>1.6354 秒</td>
<td>1.4465 秒</td>
</tr>
<tr>
<td>经典策略</td>
<td>1.6372 秒</td>
<td>1.4046 秒</td>
</tr>
<tr>
<td>类型擦除</td>
<td>1.5298 秒</td>
<td>1.1561 秒</td>
</tr>
</tbody>
</table></div>
<p>“看起来非常有趣。类型擦除似乎相当快。显然只有面向对象的解决方案稍微快一点。”</p>
<p>是的，对于Clang来说，面向对象解决方案的性能稍好一些，但是只有一点点。</p>
<p>然而，请记住，面向对象解决方案并没有解耦任何东西：<code>draw()</code>函数作为 <strong>Shape</strong> 层次结构中的虚函数实现，因此你体验到了与绘图功能的紧密耦合。虽然这可能带来很少的性能开销，但从设计角度来看，这是一个最糟糕的情况。</p>
<p>考虑到这一点，类型擦除的性能数字确实令人惊叹：它的性能比任何策略实现高出6%到20%。</p>
<p>因此，类型擦除不仅提供了最强的解耦，而且其性能也优于所有其他减少耦合的尝试。</p>
<p><strong>关于术语的一点说明</strong></p>
<p>总的来说，类型擦除是一种实现高效且松耦合代码的出色方法。尽管它有一些局限性和缺点，但你可能无法轻易忽视的是其实现细节的复杂性。</p>
<p>因此，包括我和Eric Niebler在内的许多人认为，类型擦除应该成为一个语言特性：</p>
<p>“如果我能回到过去，并且有能力改变C++，而不是添加虚函数，我会添加对类型擦除和概念的语言支持：定义一个单一类型的概念，并自动生成一个类型擦除包装器。”</p>
<p>然而，要将类型擦除确立为一种真正的设计模式，还有更多的工作要做。</p>
<p>我介绍了类型擦除作为一种由外部多态、桥接和原型组成的复合设计模式，它被引入作为一种基于值的技术，用于提供一组类型与其相关操作之间的强解耦。</p>
<p>不幸的是，你可能会看到其他“形式”的类型擦除：随着时间的推移，“类型擦除”这个术语被误用和滥用在各种技术和概念中。</p>
<p>例如，有时人们将<code>void*</code>称为类型擦除。偶尔，你也可能听到在继承层次结构或更具体地指向基类的上下文中提到类型擦除。</p>
<p>最后，在<code>std::variant</code>的上下文中也可能听到类型擦除。</p>
<p>特别是<code>std::variant</code>的例子展示了这种术语滥用是多么严重。虽然外部多态（类型擦除背后的主要设计模式）是关于使你能够添加新类型的，但访问者设计模式及其现代实现<code>std::variant</code>是关于添加新操作的（参见“准则15：设计以添加类型或操作为目标”）。</p>
<p>从软件设计的角度来看，这两种解决方案完全正交：类型擦除真正解耦了具体的类型并擦除了类型信息，而<code>std::variant</code>的模板参数揭示了所有可能的选择，因此让你依赖这些类型。</p>
<p>使用相同的术语来描述两者会导致在使用“类型擦除”这个词时完全没有传达任何信息，并产生这样的评论：“我建议我们使用类型擦除来解决这个问题。” “你能更具体一点吗？你想添加类型还是操作？”</p>
<p>因此，这个术语不会具备设计模式应有的特质；它不会传达任何意图。因此，它将是无用的。</p>
<p>为了给类型擦除在其应有的设计模式殿堂中赢得一席之地，并赋予其意义，请仅在讨论本指南中的意图时使用该术语。</p>
<p><strong>本节总结</strong></p>
<p>应用类型擦除设计模式的目的是为一组可扩展的、无关的、可能是非多态的类型提供基于值的、非侵入式的抽象，这些类型具有相同的语义行为。</p>
<ul>
<li><strong>考虑类型擦除</strong>作为由外部多态、桥接和原型设计模式组成的复合设计模式。</li>
<li><strong>理解类型擦除的优势</strong>，但也记住其局限性。</li>
<li><strong>仅在沟通其意图时使用类型擦除</strong>这一术语，即作为一种允许轻松添加支持固定操作集的类型的设计模式。</li>
</ul>
<p>通过这种方式，你可以确保在使用“类型擦除”这个术语时，它是有意义且清晰的，避免混淆和误解。这不仅有助于澄清设计意图，还能帮助团队成员更好地理解和应用这一强大的设计模式。</p>
<h3 id="准则33了解类型擦除的优化潜力">准则33：了解类型擦除的优化潜力
</h3><p>本书的主要关注点是软件设计。因此，所有关于结构化软件、设计原则、管理依赖和抽象的工具，当然还有设计模式的信息都是核心内容。</p>
<p>尽管如此，我已经多次提到性能非常重要，非常重要！毕竟，C++是一种以性能为中心的编程语言。</p>
<p>因此，我现在做一个例外：本指南专门讨论性能。是的，我是认真的：不谈依赖关系，（几乎）没有分离关注点的例子，也没有值语义，只有性能。</p>
<p>“终于有一些性能相关的知识了——太好了！”你欢呼道。然而，请注意其后果：本指南非常注重实现细节，而在C++中，提及一个细节通常需要处理另外两个细节，因此你很快就会陷入实现细节的泥潭。为了避免这种情况（并让我的出版商满意），我不会详细解释每一个实现细节或演示所有替代方案。但是，我会提供一些参考资料，帮助你深入研究。</p>
<p>在“准则32：考虑用类型擦除替换继承层次结构”中，你看到了我们基本未优化的类型擦除实现的出色性能数据。然而，由于我们现在拥有一个值类型和包装类，而不仅仅是一个指针，我们获得了许多提高性能的机会。因此，我们将探讨两种改进性能的方法：小缓冲区优化（SBO）和手动虚拟调度。</p>
<p><strong>小缓冲区优化（SBO）</strong></p>
<p>让我们开始提升类型擦除实现性能的探索。当谈到性能时，通常首先想到的是优化内存分配。这是因为获取和释放动态内存可能会非常慢且不可预测。实际上，优化内存分配可以决定程序是慢还是快如闪电。</p>
<p>然而，还有第二个原因需要关注内存。在“指南32：考虑用类型擦除替换继承层次结构”中，我可能无意中给你留下了我们需要动态内存来实现类型擦除的印象。确实，在我们的第一个Shape类的初始实现中，无论对象大小如何，构造函数和clone()函数总是无条件地进行动态内存分配，对于小对象和大对象都会执行std::make_unique()。这种选择不仅因为性能问题（特别是对于小对象）受到限制，还因为在某些环境中无法使用动态内存。因此，我应该向你展示你可以对内存做很多事情。实际上，你完全控制着内存管理！因为你使用的是值类型和包装器，所以你可以根据自己的需求处理内存。其中一个选项是完全依赖于类内的内存，并在对象过大时发出编译时错误。或者，你可以根据存储对象的大小在类内内存和动态内存之间切换。这两种方法都可以通过SBO实现。</p>
<p>为了让你了解SBO的工作原理，让我们看一下一个从不在Shape中动态分配内存，而是只使用类内内存的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">Capacity</span> <span class="o">=</span> <span class="mi">32U</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="k">alignof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Concept</span><span class="o">*</span> <span class="n">pimpl</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">Concept</span> <span class="k">const</span><span class="o">*</span> <span class="nf">pimpl</span><span class="p">()</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Concept</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">alignas</span><span class="p">(</span><span class="n">Alignment</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="n">Capacity</span><span class="o">&gt;</span> <span class="n">buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个Shape类不再存储std::unique_ptr，而是拥有一组适当对齐的字节数组（）。为了给Shape的用户提供调整数组容量和对齐方式的灵活性，你可以为Shape类提供两个非类型模板参数Capacity和Alignment（）。虽然这提高了适应不同情况的灵活性，但缺点是将Shape类变成了一个类模板。结果，所有使用这个抽象的函数都可能变成函数模板。这可能是不希望的，例如，你可能需要将代码从源文件移动到头文件。然而，请记住这只是许多可能性之一。正如前面所述，你完全控制着内存管理。</p>
<p>为了方便操作std::byte数组，我们添加了一对pimpl()函数（基于它们仍然实现桥接设计模式的事实，只是使用类内内存）（和）。你可能会说：“哦不，reinterpret_cast！这不是超级危险吗？” 你是正确的；一般来说，reinterpret_cast应被视为潜在危险。然而，在这种特定情况下，C++标准支持我们在这里所做的操作，说明它是完全安全的。</p>
<p>如你所料，我们还需要引入一个外部继承层次结构，基于外部多态设计模式。这次我们在Shape类的私有部分实现这个层次结构。不是因为它更适合这个Shape实现，而是为了展示另一种选择：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">Capacity</span> <span class="o">=</span> <span class="mi">32U</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="k">alignof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Concept</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="o">~</span><span class="n">Concept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">clone</span><span class="p">(</span><span class="n">Concept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">Concept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">OwningModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Concept</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">OwningModel</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">:</span> <span class="n">shape_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">drawer_</span><span class="p">(</span><span class="n">shape_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">clone</span><span class="p">(</span><span class="n">Concept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">OwningModel</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">memory</span><span class="p">),</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// auto* ptr = 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ::new (ptr) OwningModel(*this);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">Concept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="k">override</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">OwningModel</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">memory</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// auto* ptr = 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//    const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ::new (ptr) OwningModel(std::move(*this));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">ShapeT</span> <span class="n">shape_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">alignas</span><span class="p">(</span><span class="n">Alignment</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="n">Capacity</span><span class="o">&gt;</span> <span class="n">buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个上下文中，第一个有趣的细节是clone()函数（）。因为clone()负责创建副本，它需要适应类内内存。因此，它不是通过std::make_unique()创建新模型，而是通过std::construct_at()原地创建新模型。或者，你可以使用placement new在给定的内存位置创建副本。</p>
<p>“等等！这段代码有点难理解。为什么需要这么多转换？它们真的必要吗？” 我承认，这些行有点挑战性。因此，我应该详细解释一下。创建实例的传统方法是通过placement new。然而，使用new总是带有风险，即有人（无论是无意还是恶意）可能会提供一个类特定的new操作符的替代实现。为了避免任何问题并可靠地在指定地址构造对象，给定地址首先通过static_cast转换为void const volatile*，然后通过const_cast转换为void*。得到的地址传递给全局placement new操作符。确实，这不是最明显的代码。因此，建议使用C++20算法std::construct_at()：它提供了完全相同的功能，但语法更加简洁。</p>
<p>然而，我们还需要另一个函数：clone()只处理复制操作。它不适用于移动操作。因此，我们将纯虚move()函数扩展到Concept中，并相应地在OwningModel类模板中实现它。</p>
<p>“这真的有必要吗？我们使用的是类内内存，不能从一个Shape实例移动到另一个。这样做有什么意义？” 你正确地指出我们不能将内存从一个对象移动到另一个，但我们仍然可以移动存储在其中的形状。因此，move()函数将OwningModel从一个缓冲区移动到另一个缓冲区，而不是复制它。</p>
<p>clone()和move()函数用于Shape的复制构造函数、复制赋值运算符、移动构造函数 和 移动赋值运算符中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">Capacity</span> <span class="o">=</span> <span class="mi">32U</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="k">alignof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">other</span><span class="p">.</span><span class="n">pimpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 复制并交换惯用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Shape</span> <span class="nf">copy</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">buffer_</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="n">buffer_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">other</span><span class="p">.</span><span class="n">pimpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 复制并交换惯用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Shape</span> <span class="nf">copy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">buffer_</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="n">buffer_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：pimpl()-&gt;~Concept();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">alignas</span><span class="p">(</span><span class="n">Alignment</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="n">Capacity</span><span class="o">&gt;</span> <span class="n">buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在一对编译时检查确保所需的OwningModel适合类内缓冲区并符合对齐要求之后，通过std::construct_at()在类内缓冲区中实例化一个OwningModel。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类型擦除实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向对象的解决方案</td>
<td>1.5205 秒</td>
<td>1.1480 秒</td>
</tr>
<tr>
<td>std::function</td>
<td>2.1782 秒</td>
<td>1.4884 秒</td>
</tr>
<tr>
<td>手动实现的std::function</td>
<td>1.6354 秒</td>
<td>1.4465 秒</td>
</tr>
<tr>
<td>经典策略</td>
<td>1.6372 秒</td>
<td>1.4046 秒</td>
</tr>
<tr>
<td>类型擦除</td>
<td>1.5298 秒</td>
<td>1.1561 秒</td>
</tr>
<tr>
<td>类型擦除（SBO）</td>
<td>1.3591 秒</td>
<td>1.0348 秒</td>
</tr>
</tbody>
</table></div>
<p>“哇，这真快。这是……让我算一下……大约快20%比最快的策略实现，甚至比面向对象的解决方案更快。” 的确如此。非常令人印象深刻，对吧？尽管如此，你应该记住这些是我系统上的数字。你的数字会有所不同，几乎肯定。但即使你的数字不一样，总体结论是通过处理内存分配有很多优化性能的潜力。</p>
<p>然而，尽管性能出色，我们失去了很多灵活性：只能存储小于或等于指定Capacity的OwningModel实例。更大的模型被排除在外。这让我回到可以在类内和动态内存之间切换的想法，具体取决于给定形状的大小：小形状存储在类内缓冲区中，而大形状则动态分配。你现在可以继续更新Shape的实现以使用这两种类型的内存。然而，在这一点上，最好再次强调我们最重要的设计原则之一：关注点分离。与其将所有逻辑和功能挤进Shape类中，不如更容易且更灵活地分离实现细节，并使用策略设计模式实现Shape（参见“指南19：使用策略隔离事物的执行方式”）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">StoragePolicy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Shape类模板被重写以接受一个StoragePolicy。通过这个策略，你可以从外部指定类应该如何获取内存。当然，这样你也能完美地遵循单一职责原则（SRP）和开闭原则（OCP）。其中一个这样的存储策略可以是DynamicStorage策略类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DynamicStorage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">*</span> <span class="n">create</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">destroy</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>顾名思义，DynamicStorage会通过new等方法动态获取内存。如果你有更强的要求，可以基于<code>std::aligned_alloc()</code>或其他类似功能来提供具有指定对齐方式的动态内存。</p>
<p>类似于DynamicStorage，你还可以提供一个InClassStorage策略：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">Capacity</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">Alignment</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">InClassStorage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">*</span> <span class="n">create</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Capacity</span><span class="p">,</span> <span class="s">&#34;The given type is too large&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_assert</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Alignment</span><span class="p">,</span> <span class="s">&#34;The given type is misaligned&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">T</span><span class="o">*</span> <span class="n">memory</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">data</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// void* const memory = static_cast&lt;void*&gt;(buffer_.data());
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// return ::new (memory) T(std::forward&lt;Args&gt;(args)...);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">destroy</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：ptr-&gt;~T();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">alignas</span><span class="p">(</span><span class="n">Alignment</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="n">Capacity</span><span class="o">&gt;</span> <span class="n">buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所有这些策略类都提供相同的接口：一个用于实例化类型T对象的create()函数和一个用于清理所需操作的destroy()函数。这个接口由Shape类用来触发构造和析构，例如在其模板构造函数和析构函数中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">StoragePolicy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">OwningModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pimpl_</span> <span class="o">=</span> <span class="n">policy_</span><span class="p">.</span><span class="k">template</span> <span class="n">create</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="p">{</span> <span class="n">policy_</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">pimpl_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 其他成员函数，特别是特殊成员函数未显示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="na">[[no_unique_address]]</span> <span class="n">StoragePolicy</span> <span class="n">policy_</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Concept</span><span class="o">*</span> <span class="n">pimpl_</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后一个不应忽视的细节是数据成员：Shape类现在存储了一个给定StoragePolicy的实例，并且，不要惊慌，还有一个指向其Concept的原始指针。确实，没有必要再存储<code>std::unique_ptr</code>，因为我们手动在自己的析构函数中销毁对象。你可能还会注意到storage policy上的[[no_unique_address]]属性。这个C++20特性给你机会节省存储策略的内存。如果策略为空，编译器现在允许不为该数据成员保留任何内存。如果没有这个属性，则需要至少为policy_保留一个字节，但由于对齐限制，可能会更多字节。</p>
<p>总的来说，SBO（小缓冲区优化）是一种有效且最有趣的类型擦除实现优化之一。因此，许多标准类型，如<code>std::function</code>和<code>std::any</code>，使用某种形式的SBO。不幸的是，C++标准库规范并不要求使用SBO。因此，你只能希望SBO被使用；不能依赖它。然而，由于性能如此重要，SBO扮演了如此关键的角色，已经有一些提案建议标准化inplace_function和inplace_any类型。时间会告诉我们这些是否会被纳入标准库。</p>
<p><strong>手动实现函数调度</strong>
“哇，这将被证明是有用的。我还能做些什么来提高我的类型擦除实现的性能吗？”你问道。哦，是的，你可以做更多。这里有第二个潜在的性能优化点。这次我们尝试提高虚拟函数的性能。是的，我指的是由外部继承层次结构（即外部多态设计模式）引入的虚拟函数。</p>
<p>“我们应该如何优化虚拟函数的性能？这不是完全取决于编译器的事情吗？”确实，你是对的。然而，我不是在谈论调整后端、特定于编译器的实现细节，而是讨论用更高效的东西替换虚拟函数。而这确实是可能的。</p>
<p>记住，虚拟函数只不过是一个存储在虚拟函数表中的函数指针。每个至少有一个虚拟函数的类型都有这样一个虚拟函数表。然而，每种类型只有一个虚拟函数表。换句话说，这个表并不存储在每个实例中。因此，为了将虚拟函数表与该类型的每个实例连接起来，类会存储一个额外的隐藏数据成员，我们通常称之为vptr，它是指向虚拟函数表的原始指针。</p>
<p>当你调用一个虚拟函数时，首先通过vptr获取虚拟函数表。一旦到达那里，你可以从虚拟函数表中抓取相应的函数指针并调用它。因此，总共来说，一次虚拟函数调用涉及两次间接寻址：vptr和指向实际函数的指针。因此，粗略地说，虚拟函数调用的成本大约是非内联普通函数调用的两倍。</p>
<p>这两个间接寻址为我们提供了优化的机会：实际上我们可以将间接寻址的数量减少到仅一次。为了实现这一点，我们将采用一种经常有效的优化策略：用空间换取速度。我们将通过在Shape类中存储虚拟函数指针来手动实现虚拟调度。以下代码片段已经为你提供了相当详细的思路：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">OwningModel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">OwningModel</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">value</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">:</span> <span class="n">shape_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">ShapeT</span> <span class="n">shape_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">DrawStrategy</span> <span class="n">drawer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DestroyOperation</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DrawOperation</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">CloneOperation</span> <span class="o">=</span> <span class="kt">void</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="n">DestroyOperation</span><span class="o">*&gt;</span> <span class="n">pimpl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DrawOperation</span><span class="o">*</span> <span class="n">draw_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">CloneOperation</span><span class="o">*</span> <span class="n">clone_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们替换了所有虚拟函数，甚至包括虚拟析构函数，因此不再需要概念基类。因此，外部层次结构简化为仅包含OwningModel类模板，它仍然作为特定形状（ShapeT）和DrawStrategy的存储。尽管如此，它也遇到了同样的命运：所有的虚拟函数都被移除了。唯一剩下的细节是构造函数和数据成员。</p>
<p>虚拟函数被手动函数指针所替代。由于函数指针的语法不太友好，我们添加了一些方便使用的函数类型别名：DestroyOperation代表以前的虚拟析构函数，DrawOperation代表以前的虚拟draw()函数，CloneOperation代表以前的虚拟clone()函数。DestroyOperation用于配置 pimpl_ 数据成员的删除器（并且，它充当了一种策略）。另外两个，DrawOperation和CloneOperation，用于两个额外的函数指针数据成员 draw_ 和 clone_ 。</p>
<p><em><em>“哦不，void</em>！这不是一种古老且超级危险的做法吗？”你惊呼。</em>*</p>
<p>好的，我承认没有解释的话看起来确实非常可疑。然而，请跟随我的思路，我保证一切都会完美且类型安全。现在使这一切工作的关键在于这些函数指针的初始化。它们在Shape类的模板构造函数中被初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">ShapeT</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="n">drawer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="k">new</span> <span class="n">OwningModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">drawer</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                 <span class="p">[](</span><span class="kt">void</span><span class="o">*</span> <span class="n">shapeBytes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">OwningModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                     <span class="k">auto</span><span class="o">*</span> <span class="k">const</span> <span class="n">model</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">shapeBytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                     <span class="k">delete</span> <span class="n">model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                 <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">draw_</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">[](</span><span class="kt">void</span><span class="o">*</span> <span class="n">shapeBytes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">OwningModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">auto</span><span class="o">*</span> <span class="k">const</span> <span class="n">model</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">shapeBytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="o">*</span><span class="n">model</span><span class="o">-&gt;</span><span class="n">drawer_</span><span class="p">)(</span><span class="n">model</span><span class="o">-&gt;</span><span class="n">shape_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">clone_</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">[](</span><span class="kt">void</span><span class="o">*</span> <span class="n">shapeBytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="o">*</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">OwningModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">auto</span><span class="o">*</span> <span class="k">const</span> <span class="n">model</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">shapeBytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="k">new</span> <span class="nf">Model</span><span class="p">(</span><span class="o">*</span><span class="n">model</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">})</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>让我们关注<code>pimpl_</code>数据成员。它通过指向新实例化的OwningModel的指针和一个无状态lambda表达式进行初始化。你可能记得无状态lambda隐式可转换为函数指针。我们利用这个语言特性将lambda直接传递给<code>unique_ptr</code>构造函数的deleter参数，强制编译器应用隐式转换为<code>DestroyOperation*</code>，从而将lambda函数绑定到<code>std::unique_ptr</code>。</p>
<p>“好的，我明白了：lambda可以用来初始化函数指针。但这到底是如何工作的？它做了什么？”同样要记住的是，我们在模板构造函数内部创建了这个lambda。这意味着在此时我们知道传递的ShapeT和DrawStrategy的实际类型。因此，生成的lambda具有关于实例化并存储在<code>pimpl_</code>中的OwningModel类型的全部知识。最终，它会被调用时接收一个<code>void*</code>，即某个OwningModel的地址。但是，基于其对OwningModel实际类型的了解，它可以首先执行从<code>void*</code>到<code>OwningModel&lt;ShapeT, DrawStrategy&gt;*</code>的<code>static_cast</code>。虽然在大多数其他上下文中这种转换会显得可疑且可能是猜测，但在这种情况下它是完全类型安全的：我们可以确定OwningModel的正确类型。因此，我们可以使用得到的指针触发正确的清理行为。</p>
<p><code>draw_</code>和<code>clone_</code>数据成员的初始化非常相似。唯一的区别是lambda执行的操作不同：它们分别执行绘制形状和创建模型副本的正确操作。</p>
<p>我知道这可能需要一些时间来消化。但我们几乎完成了；唯一缺少的细节是特殊成员函数。对于析构函数和两个移动操作，我们可以再次请求编译器生成默认实现。然而，我们必须自己处理拷贝构造函数和拷贝赋值运算符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="n">clone_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">.</span><span class="n">get</span><span class="p">()),</span> <span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">.</span><span class="n">get_deleter</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">draw_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">draw_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">clone_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">clone_</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Copy-and-Swap Idiom
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Shape</span> <span class="nf">copy</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">pimpl_</span><span class="p">,</span> <span class="n">copy</span><span class="p">.</span><span class="n">pimpl_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">draw_</span><span class="p">,</span> <span class="n">copy</span><span class="p">.</span><span class="n">draw_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="n">clone_</span><span class="p">,</span> <span class="n">copy</span><span class="p">.</span><span class="n">clone_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是我们需要做的所有工作，现在准备好测试这个实现。让我们再次更新“指南32：考虑用类型擦除替换继承层次结构”中的基准测试，并使用我们的手动虚拟调度实现运行它。我甚至将手动虚拟调度与之前讨论的小缓冲区优化（SBO）结合了起来。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类型擦除实现</th>
<th>GCC 11.1</th>
<th>Clang 11.1</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向对象解决方案</td>
<td>1.5205 s</td>
<td>1.1480 s</td>
</tr>
<tr>
<td>std::function</td>
<td>2.1782 s</td>
<td>1.4884 s</td>
</tr>
<tr>
<td>手动实现的std::function</td>
<td>1.6354 s</td>
<td>1.4465 s</td>
</tr>
<tr>
<td>经典策略</td>
<td>1.6372 s</td>
<td>1.4046 s</td>
</tr>
<tr>
<td>类型擦除</td>
<td>1.5298 s</td>
<td>1.1561 s</td>
</tr>
<tr>
<td>类型擦除（SBO）</td>
<td>1.3591 s</td>
<td>1.0348 s</td>
</tr>
<tr>
<td>类型擦除（手动虚拟调度）</td>
<td>1.1476 s</td>
<td>1.1599 s</td>
</tr>
<tr>
<td>类型擦除（SBO + 手动虚拟调度）</td>
<td>1.2538 s</td>
<td>1.2212 s</td>
</tr>
</tbody>
</table></div>
<p>对于GCC，手动虚拟调度的性能提升是非常显著的。在我的系统上，运行时间缩短到了1.1476秒，相比未优化的基本类型擦除实现提高了约25%。然而，Clang在这方面并没有显示出任何改进。尽管这可能有些令人失望，但运行时间仍然非常出色。</p>
<p>不幸的是，SBO和手动虚拟调度的组合并没有带来更好的性能。虽然GCC在纯SBO方法的基础上有小幅改进（这对于没有动态内存的环境可能很有趣），但在Clang上这种组合的效果并不如预期。</p>
<p>总结来说，类型擦除实现有很多优化潜力。如果你之前对类型擦除持怀疑态度，这次的性能提升应该给你足够的动力去自行探索。虽然这是令人兴奋的，但重要的是要记住这些优化机会来自何处：只有通过分离虚拟行为的关注点并将行为封装到值类型中，我们才能获得这些优化机会。如果我们只有一个指向基类的指针，就无法实现这一点。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>使用SBO避免小对象昂贵的复制操作。</li>
<li>通过手动实现虚拟调度减少间接寻址次数。</li>
</ul>
<h3 id="准则34注意拥有类型擦除包装器的设置成本">准则34：注意拥有类型擦除包装器的设置成本
</h3><p>在“准则32：考虑用类型擦除替换继承层次结构”和“准则33：意识到类型擦除的优化潜力”中，我引导你通过了基本类型擦除实现的复杂实现细节。是的，这很艰难，但绝对值得努力：你现在变得更强大、更聪明，并且工具箱中多了一个高效且强解耦的设计模式。太棒了！</p>
<p>然而，我们还需要回到这些细节中。我知道你在翻白眼，但还有更多内容。而且我必须承认：我撒了一点小谎。并不是告诉你错误的信息，而是有所遗漏。类型擦除还有一个你应该知道的缺点。一个很大的缺点。一个你可能完全不喜欢的缺点。唉。</p>
<p>拥有类型擦除包装器的设置成本
假设Shape再次成为基类，而Circle是许多派生类之一。那么将一个Circle传递给期望Shape const&amp;的函数将是简单且廉价的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>  <span class="c1">// 经典基类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>  <span class="c1">// 派生类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">useShape</span><span class="p">(</span><span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Circle</span> <span class="n">circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 自动且廉价地从 &#39;Circle const&amp;&#39; 转换为 &#39;Shape const&amp;&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">useShape</span><span class="p">(</span><span class="n">circle</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>尽管类型擦除Shape抽象略有不同（例如，它总是需要一个绘制策略），这种转换仍然是可能的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Circle</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>  <span class="c1">// 非多态几何原语
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>  <span class="c1">// 类型擦除包装类，如前所示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">useShape</span><span class="p">(</span><span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">draw</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Circle</span> <span class="n">circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">drawStrategy</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个临时的 &#39;Shape&#39; 对象，涉及复制操作和内存分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">useShape</span><span class="p">({</span><span class="n">circle</span><span class="p">,</span> <span class="n">drawStrategy</span><span class="p">});</span>  
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，这不再便宜。相反，基于我们之前的实现（包括基本实现和优化实现），调用<code>useShape()</code>函数会涉及几个潜在昂贵的操作：</p>
<ol>
<li><strong>创建临时Shape对象</strong>：编译器使用非显式的模板化Shape构造函数创建一个临时Shape。</li>
<li><strong>构造函数调用</strong>：构造函数调用会导致给定形状的复制操作（对于Circle来说不贵，但对于其他形状可能很昂贵）以及给定绘制策略的复制操作（如果策略是无状态的，基本上是免费的，但取决于存储在对象中的内容，可能会很昂贵）。</li>
<li><strong>Shape构造函数内部</strong>：创建一个新的形状模型，涉及内存分配（隐藏在Shape构造函数中对<code>std::make_unique()</code>的调用中，肯定是昂贵的）。</li>
<li><strong>临时（右值）Shape</strong>：通过常量引用传递给<code>useShape()</code>函数。</li>
</ol>
<p>重要的是要指出，这不是我们Shape实现的具体问题。如果你使用<code>std::function</code>作为函数参数，同样的问题也会困扰你：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">compute</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="k">const</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="k">const</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="k">const</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">compute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">[</span><span class="n">offset</span><span class="o">=</span><span class="mi">15</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，给定的lambda被转换为<code>std::function</code>实例。这种转换会涉及复制操作，并可能涉及内存分配。这完全取决于给定可调用对象的大小以及<code>std::function</code>的实现。因此，<code>std::function</code>是一种不同于<code>std::string_view</code>和<code>std::span</code>的抽象类型。<code>std::string_view</code>和<code>std::span</code>是非拥有的抽象类型，因为它们只包含指向第一个元素的指针和大小，所以它们的复制成本很低。由于这两种类型执行浅拷贝，因此非常适合用作函数参数。另一方面，<code>std::function</code>是一个拥有抽象类型，执行深拷贝。因此，它并不完美适合作为函数参数。不幸的是，我们的Shape实现也是如此。</p>
<p>“哦天哪，我不喜欢这个。一点也不喜欢。这太糟糕了！我要退款！”你惊呼道。我不得不同意这可能是代码库中的一个严重问题。然而，你需要理解底层问题是Shape类的所有权语义：基于其值语义背景，我们当前的Shape实现总是会创建给定形状的副本并始终拥有该副本。虽然这与“指南22：优先选择值语义而非引用语义”讨论的所有好处完全一致，但在这种情况下，它导致了相当不幸的性能损失。不过，别慌——我们可以为此提供一种解决方案：在这种上下文中，我们可以提供一个非拥有的类型擦除实现。</p>
<p><strong>简单的非拥有类型擦除实现</strong></p>
<p>一般来说，基于值语义的类型擦除实现是优美且完全符合现代C++精神的。然而，性能同样重要。有时，性能的重要性可能让你不那么关心值语义部分，而只关心类型擦除所提供的抽象。在这种情况下，你可能会选择一个非拥有的类型擦除实现，尽管这会将你带回引用语义的领域。</p>
<p>好消息是，如果你只需要一个简单的类型擦除包装器，一个代表对基类引用的、非拥有的且可简单复制的包装器，那么所需的代码相当简单。特别是因为你已经在“指南33：意识到类型擦除的优化潜力”中看到了如何手动实现虚拟调度。有了这项技术，简单的非拥有的类型擦除实现只需几行代码即可完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConstRef</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConstRef</span><span class="p">(</span><span class="n">ShapeT</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&amp;</span> <span class="n">drawer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">shape_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">draw_</span><span class="p">([](</span><span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">shapeBytes</span><span class="p">,</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">drawerBytes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">auto</span> <span class="k">const</span><span class="o">*</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ShapeT</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">shapeBytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">auto</span> <span class="k">const</span><span class="o">*</span> <span class="n">drawer</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DrawStrategy</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">drawerBytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="n">drawer</span><span class="p">)(</span><span class="o">*</span><span class="n">shape</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">ShapeConstRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="p">.</span><span class="n">draw_</span><span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">shape_</span><span class="p">,</span> <span class="n">shape</span><span class="p">.</span><span class="n">drawer_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">DrawOperation</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="kt">void</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">shape_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">drawer_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">DrawOperation</span><span class="o">*</span> <span class="n">draw_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>正如名字所示，<code>ShapeConstRef</code>类表示对常量形状类型的引用。它并没有存储给定形状的副本，而是仅以<code>void*</code>的形式保存指向该形状的指针。此外，它还保存一个指向关联绘制策略的<code>void*</code>，以及第三个数据成员——指向手动实现的虚拟<code>draw()</code>函数的函数指针（参见“指南33：意识到类型擦除的优化潜力”）。</p>
<p><code>ShapeConstRef</code>通过引用非const的方式接受其两个参数：形状和绘制策略（可能带有cv限定符）。这种形式不允许将右值传递给构造函数，从而防止了与临时值相关的任何生命周期问题。不幸的是，这并不能保护你免受所有可能的左值生命周期问题的影响，但仍然提供了非常合理的保护。如果你想允许右值传递，你应该重新考虑。如果你真的愿意冒险处理临时值的生命周期问题，那么你可以简单地通过const引用接受参数。只是记住，这不是我给你的建议！</p>
<p>这就是完整的非拥有的实现。它是高效的、简短的、简单的，并且如果不需要存储任何关联的数据或策略对象，还可以更短更简单。有了这个功能，你现在能够创建廉价的形状抽象。以下代码示例通过<code>useShapeConstRef()</code>函数展示了这一点。该函数使你能够通过简单地使用<code>ShapeConstRef</code>作为函数参数来绘制任何类型的形状（圆形、方形等），并使用任何可能的绘制实现。在<code>main()</code>函数中，我们通过具体的形状和具体的绘制策略（在这个例子中是一个lambda）调用<code>useShapeConstRef()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Main.cpp&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">useShapeConstRef</span><span class="p">(</span><span class="n">ShapeConstRef</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">draw</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个圆作为具体形状类型的代表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Circle</span> <span class="n">circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个绘制策略，形式为lambda
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">drawer</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过&#39;ShapeConstRef&#39;抽象直接绘制圆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">useShapeConstRef</span><span class="p">({</span><span class="n">circle</span><span class="p">,</span> <span class="n">drawer</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一调用触发了期望的效果，特别之处在于没有任何内存分配或昂贵的复制操作，而只是通过一组指向给定形状和绘制策略的指针来封装多态行为。这种方式不仅高效，而且避免了许多潜在的性能瓶颈。</p>
<p><strong>更强大的非拥有类型擦除实现</strong></p>
<p>大多数情况下，简单的非拥有的类型擦除实现应该足以满足你的所有需求。</p>
<p>然而，有时它可能还不够。有时候，你可能需要一种稍微不同的形状引用形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Circle.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Shape.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个圆作为具体形状类型的代表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Circle</span> <span class="n">circle</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个绘制策略，形式为lambda
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">drawer</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Circle</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将形状和绘制策略组合在一个&#39;Shape&#39;抽象中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shape</span> <span class="n">shape1</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">drawer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制形状
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">draw</span><span class="p">(</span><span class="n">shape1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建对形状的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 已经可以工作，但形状引用将存储指向&#39;shape1&#39;实例的指针而不是&#39;circle&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ShapeConstRef</span> <span class="n">shaperef</span><span class="p">(</span><span class="n">shape1</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过形状引用进行绘制，结果相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这种方式有效，但涉及两次间接引用！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">draw</span><span class="p">(</span><span class="n">shaperef</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过形状引用创建形状的深拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用简单非拥有的实现这是不可能的！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用简单实现时，这会创建&#39;shaperef&#39;实例的副本。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &#39;shape2&#39;本身将充当引用，并会有三次间接引用...唉。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Shape</span> <span class="n">shape2</span><span class="p">(</span><span class="n">shaperef</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制副本也会产生相同的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">draw</span><span class="p">(</span><span class="n">shape2</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设你有一个名为<code>shape1</code>的类型擦除圆形，你可能希望将这个<code>Shape</code>实例转换为<code>ShapeConstRef</code>。使用当前实现，这可以工作，但<code>shaperef</code>实例会持有指向<code>shape1</code>实例的指针，而不是指向<code>circle</code>的指针。因此，任何使用<code>shaperef</code>的操作都会导致两次间接引用（一次通过<code>ShapeConstRef</code>，另一次通过<code>Shape</code>抽象）。此外，你可能还希望将<code>ShapeConstRef</code>实例转换为<code>Shape</code>实例。在这种情况下，你可能会期望创建底层<code>Circle</code>的完整副本，并且生成的<code>Shape</code>抽象包含并表示该副本。不幸的是，使用当前实现，<code>Shape</code>会创建<code>ShapeConstRef</code>实例的副本，从而引入第三次间接引用。</p>
<p>如果你需要在拥有和非拥有的类型擦除包装器之间更高效的交互，并且在将非拥有的包装器复制到拥有的包装器时需要实际的副本，我可以为你提供一个解决方案。不幸的是，它比之前的实现复杂一些，但幸运的是并不过于复杂。该解决方案基于“指南32：考虑用类型擦除替换继承层次结构”中的基本类型擦除实现，包括<code>ShapeConcept</code>和<code>OwningShapeModel</code>类，位于<code>detail</code>命名空间中，以及<code>Shape</code>类型擦除包装器。你会看到，只需进行一些添加，这些你之前都见过。</p>
<p>第一个添加发生在<code>ShapeConcept</code>基类中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">clone</span><span class="p">(</span><span class="n">ShapeConcept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace detail
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>ShapeConcept</code>类扩展了一个新的<code>clone()</code>函数。与返回新实例化模型副本不同，此函数传递了需要创建新模型的内存地址。</p>
<p>第二个添加是一个新的模型类，即<code>NonOwningShapeModel</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">NonOwningShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonOwningShapeModel</span><span class="p">(</span><span class="n">ShapeT</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&amp;</span> <span class="n">drawer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">shape_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">,</span> <span class="n">drawer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">drawer</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">drawer_</span><span class="p">)(</span><span class="o">*</span><span class="n">shape_</span><span class="p">);</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">OwningShapeModel</span><span class="o">&lt;</span><span class="n">ShapeT</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">shape_</span><span class="p">,</span> <span class="o">*</span><span class="n">drawer_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">clone</span><span class="p">(</span><span class="n">ShapeConcept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">NonOwningShapeModel</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">memory</span><span class="p">),</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// auto* ptr = 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//     const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ::new (ptr) NonOwningShapeModel(*this);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShapeT</span><span class="o">*</span> <span class="n">shape_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl">    <span class="n">DrawStrategy</span><span class="o">*</span> <span class="n">drawer_</span><span class="p">{</span> <span class="k">nullptr</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace detail
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>NonOwningShapeModel</code>非常类似于<code>OwningShapeModel</code>实现，但正如其名称所示，它不存储给定形状和策略的副本，而是仅存储指针。因此，这个类代表了<code>OwningShapeModel</code>类的引用语义版本。此外，<code>NonOwningShapeModel</code>需要覆盖<code>ShapeConcept</code>类的纯虚函数：<code>draw()</code>再次将绘制请求转发给给定的绘制策略，而<code>clone()</code>函数执行复制操作。第一个<code>clone()</code>函数通过创建一个新的<code>OwningShapeModel</code>并复制存储的形状和绘制策略来实现。第二个<code>clone()</code>函数通过<code>std::construct_at()</code>在指定地址创建一个新的<code>NonOwningShapeModel</code>来实现。</p>
<p><strong>增强的拥有型形状模型实现</strong></p>
<p>此外，<code>OwningShapeModel</code>类需要提供新的<code>clone()</code>函数的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OwningShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">clone</span><span class="p">(</span><span class="n">ShapeConcept</span><span class="o">*</span> <span class="n">memory</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">NonOwningShapeModel</span><span class="o">&lt;</span><span class="n">ShapeT</span> <span class="k">const</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="k">const</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">memory</span><span class="p">),</span> <span class="n">shape_</span><span class="p">,</span> <span class="n">drawer_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// auto* ptr = 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//     const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(memory));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ::new (ptr) Model(shape_, drawer_);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace detail
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>OwningShapeModel</code>中的<code>clone()</code>函数实现类似于<code>NonOwningShapeModel</code>类的实现，通过<code>std::construct_at()</code>创建一个新的<code>NonOwningShapeModel</code>实例。</p>
<p>接下来的添加是相应的包装类，它作为外部层次结构<code>ShapeConcept</code>和<code>NonOwningShapeModel</code>的包装器。这个包装器应承担与<code>Shape</code>类相同的责任（即，实例化<code>NonOwningShapeModel</code>类模板并封装所有指针处理），但仅表示对常量具体形状的引用，而不是副本。这个包装器再次以<code>ShapeConstRef</code>类的形式给出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConstRef</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 预期模型实例化的大小：sizeof(ShapeT*) + sizeof(DrawStrategy*) + sizeof(vptr)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">size_t</span> <span class="n">MODEL_SIZE</span> <span class="o">=</span> <span class="mi">3U</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">alignas</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="n">MODEL_SIZE</span><span class="o">&gt;</span> <span class="n">raw_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>正如你所见，<code>ShapeConstRef</code>类非常类似于<code>Shape</code>类，但有几个重要的区别。第一个值得注意的细节是使用了适当对齐的<code>std::byte</code>数组形式的<code>raw_</code>存储（）。这表明<code>ShapeConstRef</code>不进行动态分配，而是牢固地依赖于类内内存。在这种情况下，这是很容易实现的，因为我们可以预测所需的<code>NonOwningShapeModel</code>的大小等于三个指针的大小（假设指向虚函数表的指针<code>vptr</code>与其他指针具有相同的大小）。</p>
<p><code>ShapeConstRef</code>的私有部分还包含几个成员函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConstRef</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">ShapeConstRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">shape</span><span class="p">.</span><span class="n">pimpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConcept</span><span class="o">*</span> <span class="nf">pimpl</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">raw_</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConcept</span> <span class="k">const</span><span class="o">*</span> <span class="nf">pimpl</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ShapeConcept</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">raw_</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们还添加了一个隐藏的朋友<code>draw()</code>函数，并且就像在“指南33：意识到类型擦除的优化潜力”中的SBO实现一样，我们添加了一对<code>pimpl()</code>函数（）。这将使我们能够方便地使用类内的<code>std::byte</code>数组。</p>
<p>第二个值得注意的细节是每个类型擦除实现的签名函数——模板构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConstRef</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 类型&#39;ShapeT&#39;和&#39;DrawStrategy&#39;可能是cv限定的；左值引用防止临时值的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ShapeT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DrawStrategy</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConstRef</span><span class="p">(</span><span class="n">ShapeT</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">,</span> <span class="n">DrawStrategy</span><span class="o">&amp;</span> <span class="n">drawer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">Model</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">NonOwningShapeModel</span><span class="o">&lt;</span><span class="n">ShapeT</span> <span class="k">const</span><span class="p">,</span> <span class="n">DrawStrategy</span> <span class="k">const</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Model</span><span class="p">)</span> <span class="o">==</span> <span class="n">MODEL_SIZE</span><span class="p">,</span> <span class="s">&#34;Invalid size detected&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">static_assert</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">Model</span><span class="p">)</span> <span class="o">==</span> <span class="k">alignof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="s">&#34;Misaligned detected&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pimpl</span><span class="p">()),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">drawer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// auto* ptr = 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//     const_cast&lt;void*&gt;(static_cast&lt;void const volatile*&gt;(pimpl()));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ::new (ptr) Model(shape, drawer);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，你可以选择接受非const引用参数来防止临时值的生命周期问题（非常推荐！）。或者，接受const引用参数，这样允许传递右值，但会使你面临临时值生命周期问题的风险。在构造函数内部，我们首先为所需的模型类型使用一个方便的类型别名（），然后检查模型的实际大小和对齐方式（）。如果不符预期的<code>MODEL_SIZE</code>或指针对齐，我们将创建一个编译时错误。然后通过<code>std::construct_at()</code>在类内内存中构建新模型（）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShapeConstRef</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConstRef</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConstRef</span><span class="p">(</span><span class="n">Shape</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="n">other</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConstRef</span><span class="p">(</span><span class="n">ShapeConstRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">other</span><span class="p">.</span><span class="n">pimpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ShapeConstRef</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ShapeConstRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 复制并交换惯用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ShapeConstRef</span> <span class="nf">copy</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">raw_</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="n">raw_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">ShapeConstRef</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">pimpl</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 或者：pimpl()-&gt;~ShapeConcept();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 显式未声明移动操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了模板<code>ShapeConstRef</code>构造函数外，<code>ShapeConstRef</code>还提供了两个构造函数，以启用从<code>Shape</code>实例的转换。虽然这些不是严格必需的，因为我们可以为<code>Shape</code>创建一个<code>NonOwningShapeModel</code>实例，但这些构造函数直接为相应的底层形状类型创建一个<code>NonOwningShapeModel</code>，从而减少一次间接引用，有助于提高性能。注意，为了使这些构造函数工作，<code>ShapeConstRef</code>需要成为<code>Shape</code>类的朋友。不过不用担心，这是一个很好的友元示例：<code>Shape</code>和<code>ShapeConstRef</code>确实应该在一起工作，甚至可以在同一个头文件中提供。</p>
<p>最后一个值得注意的细节是两个移动操作既没有显式声明也没有删除。由于我们明确地定义了两个复制操作，编译器既不会创建也不会删除这两个移动操作，因此它们完全消失了。这意味着这两个函数永远不会参与重载解析。而且，这与显式删除它们不同：如果它们被删除，则会参与重载解析，如果被选中，则会导致编译错误。但由于这两个函数已经消失，当你尝试移动一个<code>ShapeConstRef</code>时，复制操作会被使用，这些操作既便宜又高效，因为<code>ShapeConstRef</code>仅表示一个引用。因此，这个类故意实现了“规则三”。</p>
<p>我们几乎完成了。最后的细节是在<code>Shape</code>类中添加另一个构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Shape.h&gt; ----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Shape</span><span class="p">(</span><span class="n">ShapeConstRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">pimpl_</span><span class="p">{</span><span class="n">other</span><span class="p">.</span><span class="n">pimpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()}</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这个构造函数，<code>Shape</code>的一个实例会创建一个存储在传入的<code>ShapeConstRef</code>实例中的形状的深拷贝。如果没有这个构造函数，<code>Shape</code>将存储一个<code>ShapeConstRef</code>实例的副本，从而本身充当引用。</p>
<h2 id="第九章-装饰器设计模式">第九章 装饰器设计模式
</h2><p>本章将专门介绍另一个经典设计模式：装饰器设计模式。</p>
<p>多年来，装饰器已被证明在组合和复用不同实现方案时是最有用的设计模式之一。因此，它被广泛使用并不令人意外——甚至被应用于C++标准库功能中最令人印象深刻的重构之一。我在本章的主要目标是让您充分理解为何及何时装饰器是软件设计的绝佳选择。此外，我将向您展示装饰器现代化、更基于值语义的实现形式。</p>
<p>在&quot;准则35：使用装饰器分层添加定制功能&quot;中，我们将深入探讨装饰器设计模式的设计维度。您将了解何时这是正确的设计选择，以及使用它能带来哪些优势。同时，您还将学习该模式与其他设计模式的区别及其潜在缺点。</p>
<p>在&quot;准则36：理解运行时与编译时抽象的权衡&quot;中，我们将继续研究装饰器设计模式的两种实现方案。虽然这两种实现都根植于值语义领域，但第一种基于静态多态，而第二种基于动态多态。尽管两者具有相同的设计意图因而都实现了装饰器模式，但它们的对比将让您体会到设计模式实现方案在设计空间中的广阔可能性。</p>
<h3 id="准则35使用装饰器层次化地添加定制">准则35：使用装饰器层次化地添加定制
</h3><p>自从你通过提出基于策略设计模式的解决方案（还记得“指南19：使用策略隔离事物的实现方式”）解决了团队2D图形工具的设计问题后，你在公司内的设计模式专家声誉已经广为传播。</p>
<p>因此，其他团队来找你寻求指导并不令人意外。有一天，公司商品管理系统中的两位开发人员来到你的办公室请求帮助。</p>
<p><strong>你的同事的设计问题</strong></p>
<p>这两个开发人员所在的团队处理许多不同的项目（见图9-1）。所有这些项目都有一个共同点：它们都有一个价格标签。</p>
<p>为了说明他们的问题，他们选择了两个来自C++商品商店的例子：一个代表C++书籍的类（<code>CppBook</code>类）和一个C++会议门票的类（<code>ConferenceTicket</code>类）。</p>
<p>当开发人员描述他们的设计问题时，你开始理解到他们的问题在于有多种不同的方式来修改价格。最初，他们只需要考虑税费。因此，<code>Item</code>基类配备了一个受保护的数据成员来表示税率：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Money.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Money</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="n">Money</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">Money</span> <span class="n">money</span><span class="p">,</span> <span class="kt">double</span> <span class="n">factor</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">Money</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Money</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Money</span> <span class="n">rhs</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Item.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Item</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">taxRate_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种方法在一段时间内似乎运行良好，直到有一天，他们被要求还要考虑不同的折扣率。这显然需要大量的工作来重构现有的大量类，因为有许多不同的项目。</p>
<p>你可以很容易地想象这是必要的，因为所有派生类都在访问受保护的数据成员。“是的，你应该总是为变化而设计……”你心里想道。</p>
<p>他们承认，他们在<code>Item</code>基类中封装税率的方式并不理想。然而，随着这一认识而来的是理解到，当通过基类中的数据成员表示价格调整时，任何新的价格调整方式都会是一种侵入性的操作，并且总是直接影响<code>Item</code>类。因此，他们开始思考如何避免未来这种大规模的重构，并使添加新的调整器变得容易。“这就是正确的方向！”你心里想道。不幸的是，他们首先想到的方法是通过继承层次结构来分离不同种类的价格调整器（见图9-2）。</p>
<p>他们没有将税和折扣值封装在基类内部，而是把这些调整器提取到派生类中，这些派生类执行所需的价格调整。“嗯…”你开始思考。显然你的表情已经透露出你对这个想法不太满意，所以他们很快告诉你他们已经放弃了这个想法。显然，他们自己也意识到这会导致更多的问题：这种解决方案会迅速导致类型爆炸，并且只能提供较差的功能重用。不幸的是，大量的代码会被重复，因为对于每个特定的项目，税收和折扣的代码必须被复制。最麻烦的是处理同时受税收和某种折扣影响的项目：他们既不喜欢提供两个功能的类，也不想在继承层次中引入另一层（见图9-3）。</p>
<p>显然，让他们感到惊讶的是，他们无法通过直接继承在基类或派生类中处理价格调整器。然而，在你有机会对分离关注点发表任何评论之前，他们解释说他们最近听说了你的策略解决方案。这最终给了他们一个正确重构问题的想法（见图9-4）。</p>
<p>通过将价格调整器提取到一个单独的层次结构中，并通过在构造时使用<code>PriceStrategy</code>配置<code>Item</code>，他们终于找到了一种非侵入性地添加新价格调整器的工作方案，这将为他们节省大量的重构工作。“好吧，这就是分离关注点和支持组合而非继承的好处。”你心里想道。然后你大声问道：“这太棒了，我真的为你高兴。现在一切都看起来很好，你们自己解决了这个问题！那你们为什么还来找我？”</p>
<p>他们告诉你，你的策略解决方案是迄今为止他们能找到的最佳方法（包含感激的表情）。然而，他们承认他们并不是完全满意这种方法。从他们的角度来看，仍然有两个问题存在，当然，他们希望你能有一个解决这些问题的想法。第一个问题是每个<code>Item</code>实例都需要一个策略类，即使没有任何价格调整器应用。虽然他们同意可以通过某种空对象来解决这个问题，但他们觉得应该有一个更简单的解决方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PriceStrategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">PriceStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">update</span><span class="p">(</span><span class="n">Money</span> <span class="n">price</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">NullPriceStrategy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PriceStrategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">update</span><span class="p">(</span><span class="n">Money</span> <span class="n">price</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个问题似乎更难解决。显然，他们有兴趣结合不同的调整器（例如，折扣和税收结合成折扣与税收）。不幸的是，他们在当前实现中遇到了一些代码重复。例如，<code>Tax</code>类和<code>DiscountAndTax</code>类都包含了与税收相关的计算。虽然目前只有这两个调整器，有合理的解决方案可以应对重复问题，但他们预计在添加更多调整器和任意组合时会出现问题。因此，他们想知道是否有另一种更好的解决方案来处理不同种类的价格调整器。</p>
<p>这确实是一个有趣的问题，你很高兴花时间帮助他们。他们完全正确：策略设计模式并不是解决这个问题的正确方法。尽管策略模式是去除对函数完整实现细节依赖并优雅处理不同实现的好方法，但它并不能轻松地组合和重用不同的实现。尝试这样做会迅速导致不理想的复杂策略继承层次结构。</p>
<p>对他们的问题来说，似乎需要一种更类似于分层形式的策略，一种解耦不同价格调整器但也能灵活组合它们的形式。因此，成功的关键在于一致的应用分离关注点原则：任何类似<code>DiscountAndTax</code>类的手动编码组合都是不可取的。此外，解决方案应该是非侵入性的，以便他们能够随时实现新想法而无需修改现有代码。最后，不需要通过某些人工的空对象来处理默认情况。相反，基于组合而不是继承来构建，并以包装器的形式实现价格调整器将是更合理的选择。有了这个认识，你开始微笑。是的，有一种恰好合适的设计模式可以满足这一需求：你的两位客人需要的是装饰器设计模式的实现。</p>
<p><strong>装饰器设计模式解释</strong></p>
<p>装饰器设计模式同样源自GoF（设计模式：可复用面向对象软件的基础）一书。其主要关注点是通过组合灵活地结合不同的功能：</p>
<p><strong>装饰器设计模式</strong></p>
<p><strong>意图</strong>：“动态地给对象附加额外的职责。装饰器提供了一种比继承更灵活的扩展功能的方式。”</p>
<p>图9-5展示了给定<code>Item</code>问题的UML图。</p>
<p>如前所述，<code>Item</code>基类代表所有可能项目的抽象，另一方面，派生的<code>CppBook</code>类作为<code>Item</code>不同实现的代表。</p>
<p>在这个层次结构中的问题是难以向现有的<code>price()</code>函数添加新的调整器。</p>
<p>在装饰器设计模式中，这种新“职责”的添加被识别为一个变化点，并以<code>DecoratedItem</code>类的形式提取出来。这个类是一个独立的、特殊的<code>Item</code>基类实现，表示任何给定项目增加的责任。</p>
<p>一方面，<code>DecoratedItem</code>从<code>Item</code>派生，因此必须遵守<code>Item</code>抽象的所有预期行为（参见“指南6：遵循抽象的预期行为”）另一方面，它还包含一个<code>Item</code>（通过组合或聚合）。</p>
<p>因此，<code>DecoratedItem</code>作为一个包装器围绕每个项目，可能自身也能扩展功能。正因为如此，它为层级应用调整器提供了基础。两个可能的调整器由<code>Discounted</code>类表示，它代表特定项目的折扣，以及<code>Taxed</code>类，它代表某种税收。</p>
<p>通过引入<code>DecoratedItem</code>类并分离需要改变的部分，你遵循了单一职责原则（SRP）。通过分离这一关注点，从而允许轻松添加新的价格调整器，你也遵循了开闭原则（OCP）。由于<code>DecoratedItem</code>类的层级递归性质，以及获得的易于重用和组合不同调整器的能力，你也遵循了不要重复自己（DRY）原则。最后但并非最不重要的是，由于装饰器的包装器方法，不需要以空对象的形式定义任何默认行为。任何不需要调整器的<code>Item</code>都可以直接使用。</p>
<p>图9-6说明了装饰器设计模式的依赖关系图。在这张图中，<code>Item</code>类位于架构的最高层。所有其他类都依赖于它，包括位于下一层的<code>DecoratedItem</code>类。当然，这不是必须的：如果<code>Item</code>和<code>DecoratedItem</code>在同一架构层引入也是完全可以接受的。然而，这个例子展示了总是可以在任何时候、任何地方引入一个新的装饰器而无需修改现有代码的可能性。具体的<code>Item</code>类型实现在架构的最低层。请注意，这些项目之间没有依赖关系：所有的项目，包括像<code>Discounted</code>这样的调整器，可以由任何人随时独立引入，并且由于装饰器的结构，能够灵活且任意地组合。</p>
<p><strong>装饰器设计模式的经典实现</strong></p>
<p>让我们通过给定的<code>Item</code>示例，来看一个完整的、GoF风格的装饰器设计模式实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Item.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">Item</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Item</code>基类代表所有可能项目的抽象。唯一的要求是由纯虚函数<code>price()</code>定义，该函数可用于查询给定项目的价格。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;DecoratedItem.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DecoratedItem</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">DecoratedItem</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">&#34;Invalid item&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">item_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">item_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>DecoratedItem</code>类从<code>Item</code>类派生，但也包含一个<code>item_</code>成员（通过构造函数指定）。这个<code>item_</code>是一个指向另一个<code>Item</code>的<code>std::unique_ptr</code>，并且不能为<code>nullptr</code>。注意，这个<code>DecoratedItem</code>类仍然是抽象的，因为纯虚函数<code>price()</code>尚未定义。<code>DecoratedItem</code>只提供了存储和访问<code>Item</code>的基本功能。</p>
<p><strong>具体项目类实现</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;CppBook.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CppBook</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">CppBook</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">title_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">title</span><span class="p">)),</span> <span class="n">price_</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">title_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title_</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">price_</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;ConferenceTicket.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConferenceTicket</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConferenceTicket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="n">price_</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">price_</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>CppBook</code>和<code>ConferenceTicket</code>类是具体的<code>Item</code>实现。虽然C++书籍由书名表示，而C++会议由会议名称表示，但最重要的是，这两个类都重写了<code>price()</code>函数，返回指定的价格<code>price_</code>。</p>
<p><strong>价格调整器类实现</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Discounted.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;DecoratedItem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Discounted</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DecoratedItem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Discounted</span><span class="p">(</span><span class="kt">double</span> <span class="n">discount</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">DecoratedItem</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)),</span> <span class="n">factor_</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">discount</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">isfinite</span><span class="p">(</span><span class="n">discount</span><span class="p">)</span> <span class="o">||</span> <span class="n">discount</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">||</span> <span class="n">discount</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">&#34;Invalid discount&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">item</span><span class="p">().</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Taxed.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;DecoratedItem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Taxed</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DecoratedItem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Taxed</span><span class="p">(</span><span class="kt">double</span> <span class="n">taxRate</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">DecoratedItem</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)),</span> <span class="n">factor_</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">taxRate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">isfinite</span><span class="p">(</span><span class="n">taxRate</span><span class="p">)</span> <span class="o">||</span> <span class="n">taxRate</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">&#34;Invalid tax&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">item</span><span class="p">().</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Discounted</code>和<code>Taxed</code>类实现了价格调整器。<code>Discounted</code>类接受一个折扣值，并计算一个折扣因子<code>factor_</code>，该因子在<code>price()</code>函数中用于修改给定项目的最终价格。同样地，<code>Taxed</code>类接受一个税率值，并计算一个税因子<code>factor_</code>，该因子也用于修改价格。</p>
<p><strong>主函数示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ConferenceTicket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CppBook.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Discounted.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Taxed.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 7% tax: 19*1.07 = 20.33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item1</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Taxed</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.07</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CppBook</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;Effective C++&#34;</span><span class="p">,</span> <span class="mf">19.0</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 20% discount, 19% tax: (999*0.8)*1.19 = 951.05
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item2</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Taxed</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.19</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Discounted</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConferenceTicket</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;CppCon&#34;</span><span class="p">,</span> <span class="mf">999.0</span><span class="p">))));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice1</span> <span class="o">=</span> <span class="n">item1</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">();</span>  <span class="c1">// 结果为 20.33
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice2</span> <span class="o">=</span> <span class="n">item2</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">();</span>  <span class="c1">// 结果为 951.05
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个主函数示例中，我们创建了两个具体项目：</p>
<ol>
<li><strong>C++书籍</strong>：假设这本书需要缴纳7%的税费，因此我们使用<code>Taxed</code>装饰器包裹它。最终的<code>item1</code>代表一个含税的C++书籍。</li>
<li><strong>C++会议门票</strong>：假设我们获得了早期鸟票，享有20%的折扣。这个折扣通过<code>Discounted</code>类应用到<code>ConferenceTicket</code>实例上。此外，门票还需要缴纳19%的税费，这通过<code>Taxed</code>装饰器再次应用。最终的<code>item2</code>代表一个打折并含税的C++会议门票。</li>
</ol>
<p>通过这种方式，我们可以轻松地组合不同的价格调整器，而无需修改原始项目类的代码。装饰器设计模式不仅提高了代码的灵活性，还减少了维护的工作量。这种方法使得系统可以灵活应对未来的需求变化，而不需要进行大规模的重构。</p>
<p><strong>第二个装饰器示例</strong></p>
<p>另一个展示装饰器设计模式优势的令人印象深刻的例子可以在C++17对STL分配器的重工作中找到。由于分配器的实现基于装饰器，因此可以创建任意复杂的分配器层次结构，以满足最特殊的内存需求。例如，考虑以下使用<code>std::pmr::monotonic_buffer_resource</code>的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="mi">1000</span><span class="o">&gt;</span> <span class="n">raw</span><span class="p">;</span>  <span class="c1">// 注意：未初始化！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span><span class="n">raw</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">raw</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">{</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">strings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;String longer than what SSO can handle&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">strings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Another long string that goes beyond SSO&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">strings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;A third long string that cannot be handled by SSO&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::pmr::monotonic_buffer_resource</code>是<code>std::pmr</code>命名空间中的几个可用分配器之一。在这个例子中，它被配置为每当<code>strings</code>向量请求内存时，只分配给定字节数组<code>raw</code>的块。如果内存请求无法处理（例如因为缓冲区已无内存），则通过抛出<code>std::bad_alloc</code>异常来处理。这种行为通过在构造时传递<code>std::pmr::null_memory_resource</code>来指定。</p>
<p>然而，<code>std::pmr::monotonic_buffer_resource</code>还有许多其他可能的应用。例如，也可以基于动态内存构建，并通过<code>new</code>和<code>delete</code>重新分配额外的内存块，使用<code>std::pmr::new_delete_resource()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">new_delete_resource</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种灵活性和分层配置由装饰器设计模式实现。<code>std::pmr::monotonic_buffer_resource</code>派生自<code>std::pmr::memory_resource</code>基类，但同时也是一个包装器，围绕另一个派生自<code>std::pmr::memory_resource</code>的分配器。上游分配器在缓冲区耗尽内存时使用，在<code>std::pmr::monotonic_buffer_resource</code>的构造中指定。</p>
<p>最令人印象深刻的是，你可以轻松且非侵入地自定义分配策略。例如，这可能使你能够以不同的方式处理大块内存请求和小块内存请求。只需提供自己的自定义分配器即可。考虑以下自定义分配器的草图：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;CustomAllocator.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CustomAllocator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">CustomAllocator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">upstream_</span><span class="p">{</span><span class="n">upstream</span><span class="p">}</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">do_allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">do_deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="na">[[maybe_unused]] size_t bytes, [[maybe_unused]]</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">do_is_equal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream_</span><span class="p">{};</span>   
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了被识别为C++17分配器，<code>CustomAllocator</code>类派生自<code>std::pmr::memory_resource</code>类，后者代表了所有C++17分配器的要求集。巧合的是，<code>CustomAllocator</code>也拥有一个指向<code>std::pmr::memory_resource</code>的指针，通过其构造函数初始化。</p>
<p>C++17分配器的要求集包括虚拟函数<code>do_allocate()</code>、<code>do_deallocate()</code>和<code>do_is_equal()</code>。<code>do_allocate()</code>函数负责获取内存，可能是通过其上游分配器，而<code>do_deallocate()</code>函数在需要释放内存时调用。最后，<code>do_is_equal()</code>函数在需要检查两个分配器是否相等时调用。</p>
<p>只需引入<code>CustomAllocator</code>而无需更改任何其他代码，特别是标准库中的代码，新的分配器类型可以轻松插入到<code>std::pmr::monotonic_buffer_resource</code>和<code>std::pmr::new_delete_resource()</code>之间，从而允许你非侵入地扩展分配行为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CustomAllocator.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CustomAllocator</span> <span class="n">custom_allocator</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">new_delete_resource</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span><span class="o">&amp;</span><span class="n">custom_allocator</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>装饰器、适配器和策略模式的比较</strong></p>
<p>尽管装饰器和适配器这两种设计模式听起来有相似的目的，但在仔细检查后，它们非常不同且几乎不相关。适配器设计模式的意图是适应和改变给定接口以匹配预期接口。它不关心添加任何功能，只关心将一组函数映射到另一组函数。相反，装饰器设计模式保留给定接口，完全不关心改变它。相反，它提供了添加职责和扩展及自定义现有功能集的能力。</p>
<p>策略设计模式与装饰器更相似。两种模式都提供了自定义功能的能力。然而，它们针对不同的应用场景，因此提供了不同的好处。策略设计模式侧重于消除对特定功能实现细节的依赖，并允许从外部定义这些细节。因此，从这个角度来看，它代表了该功能的核心——“核心”。这种形式特别适合表示不同的实现并在这之间切换。相比之下，装饰器设计模式侧重于消除可附加实现部分之间的依赖关系。由于其包装器形式，装饰器代表了功能的“皮肤”。在这种形式下，它特别适合组合不同的实现，从而增强和扩展功能，而不是替换它或在实现之间切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PriceStrategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">PriceStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">update</span><span class="p">(</span><span class="n">Money</span> <span class="n">price</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DecoratedPriceStrategy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PriceStrategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PriceStrategy</span><span class="o">&gt;</span> <span class="n">priceModifier_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DiscountedPriceStrategy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DecoratedPriceStrategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">update</span><span class="p">(</span><span class="n">Money</span> <span class="n">price</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种设计模式的组合在已经有一个策略实现的情况下特别有趣：虽然策略是侵入性的并要求修改类，但总是可以通过添加装饰器如<code>DecoratedPriceStrategy</code>类来非侵入性地扩展。当然，这取决于具体情况：是否这是正确的解决方案需要逐案决定。</p>
<p><strong>分析装饰器设计模式的不足</strong></p>
<p>尽管装饰器设计模式能够层次化地扩展和定制行为，无疑是设计模式目录中最有价值和最灵活的模式之一，但它也有一些缺点。首先，装饰器的灵活性是有代价的：给定层次结构中的每一层都会增加一层间接性。例如，在<code>Item</code>层次结构的对象导向实现中，这种间接性表现为每个装饰器的一个虚函数调用。因此，广泛使用装饰器可能会带来潜在的显著性能开销。这种可能的性能损失是否成为问题取决于具体上下文。你需要通过基准测试逐案决定装饰器的灵活性和结构性是否超过了性能问题。</p>
<p>另一个不足是错误组合装饰器的潜在危险。例如，很容易将一个<code>Taxed</code>装饰器包裹在另一个<code>Taxed</code>装饰器周围，或者在一个已经征税的项目上应用<code>Discounted</code>。这两种情况虽然会让你的政府高兴，但不应该发生，因此应在设计时避免。Scott Meyers 的通用设计原则很好地表达了这一理性：</p>
<p><strong>使接口易于正确使用且难以错误使用。</strong></p>
<p>因此，装饰器的巨大灵活性是卓越的，但也可能是危险的（当然，这取决于场景）。在这种情况下，税收似乎扮演了一个特殊的角色，因此不将其作为装饰器处理而采用其他方式似乎是合理的。由于现实中的税收是一个相当复杂的话题，通过策略设计模式分离这一关注点似乎是合理的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;TaxStrategy.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TaxStrategy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">TaxStrategy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">applyTax</span><span class="p">(</span><span class="n">Money</span> <span class="n">price</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;TaxedItem.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;TaxStrategy.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TaxedItem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">TaxedItem</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TaxStrategy</span><span class="o">&gt;</span> <span class="n">taxer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)),</span> <span class="n">taxer_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">taxer</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查有效的项目和税收策略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">netPrice</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>  <span class="c1">// 不含税的价格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">item_</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">grossPrice</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>  <span class="c1">// 包含税的价格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">taxer_</span><span class="o">-&gt;</span><span class="n">applyTax</span><span class="p">(</span><span class="n">item_</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">item_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TaxStrategy</span><span class="o">&gt;</span> <span class="n">taxer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>TaxStrategy</code>类代表对<code>Item</code>应用税收的多种不同方式。这样的<code>TaxStrategy</code>与<code>Item</code>在<code>TaxedItem</code>类中结合。注意，<code>TaxedItem</code>本身并不是一个<code>Item</code>，因此不能通过另一个<code>Item</code>来装饰它。因此，它充当一种终止装饰器，只能作为最后一个装饰器应用。它也不提供<code>price()</code>函数，而是提供<code>netPrice()</code>和<code>grossPrice()</code>函数，以便查询包含税和原始项目的不含税价格。</p>
<p>唯一可能看到的另一个问题是基于引用语义的装饰器设计模式实现：大量的指针、包括<code>nullptr</code>检查和悬空指针的风险、通过<code>std::unique_ptr</code>和<code>std::make_unique()</code>进行显式的生命周期管理以及许多小的手动内存分配。然而，幸运的是，你还有一个王牌可以展示如何基于值语义实现装饰器（见后续指南）。</p>
<p>总结来说，装饰器设计模式是基本的设计模式之一，尽管有一些缺点，但它仍然是一个非常有价值的工具箱补充。只需确保不要过于热衷于装饰器并开始将其用于一切。毕竟，对于每种模式，都有一个合理使用和过度使用的界限。</p>
<p><strong>本节总结</strong></p>
<ul>
<li><strong>理解继承很少是答案</strong>。</li>
<li><strong>应用装饰器设计模式的意图是非侵入式地、层次化地扩展和定制行为</strong>。</li>
<li><strong>考虑装饰器用于组合和重用独立的行为片段</strong>。</li>
<li><strong>理解装饰器、适配器和策略设计模式之间的差异</strong>。</li>
<li><strong>利用装饰器的极端灵活性，但了解其不足之处</strong>。</li>
<li><strong>避免无意义的装饰器，但更倾向于易于正确使用的良好设计</strong>。</li>
</ul>
<h3 id="准则36理解运行时与编译时抽象之间的权衡">准则36：理解运行时与编译时抽象之间的权衡
</h3><p>在“准则5：使用装饰器层次化地添加自定义”中，我向您介绍了装饰器设计模式，并希望给了您一个强烈的动机将其添加到您的工具箱中。</p>
<p>然而，到目前为止，我只是通过经典的面向对象实现展示了装饰器，并没有遵循“准则22：优先选择值语义而非引用语义”的建议。</p>
<p>由于我假设您急切地想看到如何基于值语义实现装饰器，现在是时候向您展示两种可能的方法了。</p>
<p>是的，两种方法：我将通过演示两个非常不同的实现来弥补这一延迟。这两种实现都牢固地基于值语义，但在比较时，它们几乎位于设计空间的对立面。</p>
<p>第一个方法将基于静态多态性实现，使您能够利用所有可用的编译时信息；</p>
<p>而第二个方法则会利用动态多态性的所有运行时优势。这两种方法都有其优点，当然也有其独特的缺点。</p>
<p>因此，这些示例很好地展示了您可以选择的设计广度。</p>
<p><strong>基于值的编译时装饰器</strong></p>
<p>让我们从基于静态多态性的装饰器实现开始。“我猜这又会大量使用模板，对吧？”您问。</p>
<p>是的，我会使用模板作为主要的抽象机制，并且会使用C++20的概念和转发引用。但是，不会让它特别依赖模板。相反，主要关注点仍然是装饰器设计模式的设计方面以及使其易于添加新类型的装饰器和新的常规项目的目标。其中一个项目就是<code>ConferenceTicket</code>类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;ConferenceTicket.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConferenceTicket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConferenceTicket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="n">price_</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="n">price_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>ConferenceTicket</code>完美符合值类型的期望：没有基类参与，也没有虚函数。这意味着不再通过指向基类的指针装饰项目，而是通过组合或直接非公开继承的方式进行装饰。以下是这种实现的两个例子，分别是<code>Discounted</code>和<code>Taxed</code>类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;PricedItem.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">PricedItem</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">Money</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Discounted.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;PricedItem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">double</span> <span class="n">discount</span><span class="p">,</span> <span class="n">PricedItem</span> <span class="n">Item</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Discounted</span> <span class="p">{</span>  <span class="c1">// 使用组合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Discounted</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">discount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span> <span class="n">item_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Taxed.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;PricedItem.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">double</span> <span class="n">taxRate</span><span class="p">,</span> <span class="n">PricedItem</span> <span class="n">Item</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Taxed</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Item</span> <span class="p">{</span>  <span class="c1">// 使用继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Taxed</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">Item</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Item</span><span class="o">::</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">taxRate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Discounted</code>和<code>Taxed</code>都作为其他类型项目的装饰器：<code>Discounted</code>类表示给定项目的折扣，而<code>Taxed</code>类表示某种税收。这次，两者都是以类模板的形式实现的。第一个模板参数分别指定折扣和税率，第二个模板参数指定被装饰项目的类型。</p>
<p>最值得注意的是第二个模板参数上的<code>PricedItem</code>约束。这个约束代表了一组语义要求，即预期的行为。由于此约束，您只能提供具有<code>price()</code>成员函数的类型。使用任何其他类型都会立即导致编译错误。因此，<code>PricedItem</code>扮演了经典装饰器实现中<code>Item</code>基类的角色。同样，这也体现了基于单一职责原则（SRP）的关注分离。此外，如果该约束由架构中的高层拥有，则您和其他任何人都可以在任何较低层添加新的项目类型和新的装饰器。这一特性完美地满足了开放封闭原则（OCP），并且由于适当的抽象所有权，也满足了依赖倒置原则（DIP）。</p>
<p>下面的三个类到位后，您就可以指定一个带有20%折扣和15%税的<code>ConferenceTicket</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ConferenceTicket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Discounted.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Taxed.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 20%折扣，15%税：(499*0.8)*1.15 = 459.08
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Taxed</span><span class="o">&lt;</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">Discounted</span><span class="o">&lt;</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">{</span> <span class="s">&#34;Core C++&#34;</span><span class="p">,</span> <span class="mf">499.0</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>  <span class="c1">// 结果为459.08
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种编译时方法的最大优势是显著的性能提升：由于没有指针间接寻址，并且由于可以内联，编译器能够最大限度地优化生成的代码。此外，生成的代码明显更短，不包含任何样板代码，因此更容易阅读。</p>
<p>“你能具体一点说明性能结果吗？在C++中，开发者们会对1%的性能差异争论不休并称之为显著。所以，认真地说：编译时方法快多少？”我明白，您似乎熟悉C++社区对性能的热情。好吧，只要您再次答应我，不要认为我的结果是最终答案，而只是一个示例，并且如果我们同意这个比较不会演变成性能研究，我可以给您看一些数据。但是在展示之前，让我快速概述一下我使用的基准：我比较了“指南35：使用装饰器层次化地添加自定义”中的经典面向对象实现和所描述的编译时版本。当然，有任意数量的装饰器组合，但我将自己限制在这四个项目类型上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">DiscountedConferenceTicket</span> <span class="o">=</span> <span class="n">Discounted</span><span class="o">&lt;</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">TaxedConferenceTicket</span> <span class="o">=</span> <span class="n">Taxed</span><span class="o">&lt;</span><span class="mf">0.19</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">TaxedDiscountedConferenceTicket</span> <span class="o">=</span> <span class="n">Taxed</span><span class="o">&lt;</span><span class="mf">0.19</span><span class="p">,</span> <span class="n">Discounted</span><span class="o">&lt;</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">DiscountedTaxedConferenceTicket</span> <span class="o">=</span> <span class="n">Discounted</span><span class="o">&lt;</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">Taxed</span><span class="o">&lt;</span><span class="mf">0.19</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于在编译时解决方案中这四种类型没有共同的基类，我用四个特定的<code>std::vector</code>填充它们。相比之下，对于经典的运行时解决方案，我使用了一个<code>std::vector&lt;std::unique_ptr&lt;Item&gt;&gt;</code>。总共，我为两种方案各创建了10,000个项目，并调用了5,000次<code>std::accumulate()</code>来计算所有项目的总价。</p>
<p>有了这些背景信息，让我们看看性能结果（表9-1）。再次，我对结果进行了归一化处理，这次是相对于运行时实现的性能。</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>编译器</th>
<th>经典装饰器</th>
<th>编译时装饰器</th>
</tr>
</thead>
<tbody>
<tr>
<td>GCC 11.1</td>
<td>1.0</td>
<td>0.078067</td>
</tr>
<tr>
<td>Clang 11.1</td>
<td>1.0</td>
<td>0.080313</td>
</tr>
</tbody>
</table></div>
<p>如前所述，编译时解决方案的性能比运行时解决方案显著更快：对于GCC和Clang来说，它只需要运行时解决方案大约8%的时间，因此快了一个数量级以上。我知道，这听起来很棒。</p>
<p>然而，尽管编译时解决方案的性能非凡，但它也有一些潜在的严重局限性：由于完全依赖模板，没有任何运行时灵活性。</p>
<p>由于甚至折扣和税率也是通过模板参数实现的，每种不同的比率都需要创建一个新的类型。这可能导致编译时间更长，并生成更多代码（即更大的可执行文件）。</p>
<p>此外，有理由认为所有类模板都驻留在头文件中，这再次增加了编译时间，并可能暴露比期望更多的实现细节。更重要的是，对实现细节的更改广泛可见，可能会导致大规模重新编译。</p>
<p>然而，最限制因素似乎是只有在编译时所有信息都可用的情况下才能使用此解决方案。因此，您可能只在少数特殊情况下能达到这种性能水平。</p>
<p><strong>基于值的运行时装饰器</strong></p>
<p>由于编译时装饰器虽然速度快但运行时灵活性非常有限，现在我们将注意力转向第二种基于值的装饰器实现。通过这种实现，我们将回到动态多态性的领域，享受其所有的运行时灵活性。</p>
<p>既然您已经了解了装饰器设计模式，您会意识到我们需要能够轻松添加新类型：新的项目类型以及新的价格修饰符。因此，将“准则35：使用装饰器层次化地添加自定义”中的装饰器实现转换为基于值语义的实现所选择的设计模式是类型擦除。以下<code>Item</code>类实现了我们定价项目的拥有类型擦除包装器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Item.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Money.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Concept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="o">~</span><span class="n">Concept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">Model</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Concept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">explicit</span> <span class="nf">Model</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">explicit</span> <span class="nf">Model</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">T</span> <span class="n">item_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个实现中，<code>Item</code>类在其私有部分定义了一个嵌套的基础<code>Concept</code>类。通常，<code>Concept</code>基础类代表被封装类型的预期行为要求，这些要求通过<code>price()</code>和<code>clone()</code>成员函数表达。这些要求由嵌套的<code>Model</code>类模板实现。<code>Model</code>通过转发调用存储的<code>item_</code>数据成员的<code>price()</code>成员函数来实现<code>price()</code>函数，并通过创建存储项的副本来实现<code>clone()</code>函数。</p>
<p><code>Item</code>类的公共部分应该看起来很熟悉：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Item.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Item</span><span class="p">(</span><span class="n">Item</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Item</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Item</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pimpl_</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Item</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span><span class="p">(</span><span class="n">Item</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Item</span><span class="o">&amp;&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了通常的Rule of 5实现外，该类还配备了一个接受各种项目的模板构造函数。最后但同样重要的是，该类提供了一个<code>price()</code>成员函数，模仿所有项目的预期接口。</p>
<p>有了这个包装类，您可以轻松添加新项目：既不需要侵入性修改现有代码，也不需要使用基类。任何提供<code>price()</code>成员函数并可复制的类都可以工作。幸运的是，这包括我们的编译时装饰器实现中的<code>ConferenceTicket</code>类，它提供了我们需要的一切并且基于值语义。不幸的是，对于<code>Discounted</code>和<code>Taxed</code>类来说并非如此，因为它们期望以模板参数的形式接收装饰项目。因此，我们在类型擦除上下文中重新实现了<code>Discounted</code>和<code>Taxed</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Discounted.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Discounted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Discounted</span><span class="p">(</span><span class="kt">double</span> <span class="n">discount</span><span class="p">,</span> <span class="n">Item</span> <span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)),</span> <span class="n">factor_</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">discount</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span> <span class="n">item_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Taxed.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Item.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Taxed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Taxed</span><span class="p">(</span><span class="kt">double</span> <span class="n">taxRate</span><span class="p">,</span> <span class="n">Item</span> <span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">item_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)),</span> <span class="n">factor_</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">taxRate</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Item</span> <span class="n">item_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">factor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是，这两个类都没有派生自任何基类，但它们都完美实现了装饰器设计模式。一方面，它们实现了<code>Item</code>包装器所需的操作（特别是<code>price()</code>成员函数和拷贝构造函数），另一方面，它们拥有一个<code>Item</code>。因此，两者都允许您任意组合装饰器，如下<code>main()</code>函数所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ConferenceTicket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Discounted.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Taxed.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 20%折扣，15%税：(499*0.8)*1.15 = 459.08 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Item</span> <span class="n">item</span><span class="p">(</span><span class="n">Taxed</span><span class="p">(</span><span class="mf">0.19</span><span class="p">,</span> <span class="n">Discounted</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="p">{</span><span class="s">&#34;Core C++&#34;</span><span class="p">,</span> <span class="mf">499.0</span><span class="p">})));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>“哇，这太棒了：没有指针，没有手动分配，感觉非常自然直观。但同时，它也非常灵活。这好得不像真的——肯定有陷阱。性能怎么样？”您说。好吧，听起来您预期会有完全的性能崩溃。让我们对这个解决方案进行基准测试。当然，我使用与编译时版本相同的基准测试，并添加基于类型擦除的第三个解决方案。性能结果如表9-2所示。</p>
<p><strong>表9-2. 类型擦除装饰器实现的性能结果（归一化性能）</strong></p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>编译器</th>
<th>经典装饰器</th>
<th>编译时装饰器</th>
<th>类型擦除装饰器</th>
</tr>
</thead>
<tbody>
<tr>
<td>GCC 11.1</td>
<td>1.0</td>
<td>0.078067</td>
<td>0.997510</td>
</tr>
<tr>
<td>Clang 11.1</td>
<td>1.0</td>
<td>0.080313</td>
<td>0.971875</td>
</tr>
</tbody>
</table></div>
<p>如您所见，性能并不比其他经典运行时解决方案差。实际上，性能甚至看起来稍好一些，但这只是一个多次运行的平均值，不应过于强调。然而，请记住，正如“指南33：注意类型擦除的优化潜力”所展示的那样，有多种方法可以提高类型擦除解决方案的性能。</p>
<p>虽然性能可能不是运行时解决方案的主要优势（至少与编译时解决方案相比），但在运行时灵活性方面确实表现出色。例如，可以根据用户输入或计算结果在运行时决定是否将任何<code>Item</code>包裹在另一个装饰器中。当然，这将再次生成一个<code>Item</code>，它可以与其他许多<code>Item</code>一起存储在一个容器中。这确实为您提供了巨大的运行时灵活性。</p>
<p>另一个优点是可以更轻松地在源文件中隐藏实现细节。虽然这可能导致运行时性能的损失，但它可能会带来更好的编译时间。最重要的是：对隐藏代码的任何修改都不会影响其他代码，从而节省大量的重新编译，因为实现细节得到了更强的封装。</p>
<p>总结来说，无论是编译时还是运行时解决方案都是基于值的，并导致用户代码更简单、更易理解。然而，它们也有各自的优缺点：尽管运行时方法提供了更大的灵活性，而编译时方法在性能方面占据主导地位。实际上，您很少会得到纯粹的编译时或运行时方法，而是经常发现自己处于这两种极端之间的某个位置。确保您了解自己的选项：权衡它们，找到一个完美的结合两全其美的妥协方案，适合您的具体情况。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>注意Decorator设计模式的运行时和编译时实现。</li>
<li>理解编译时解决方案通常性能更好，但会限制运行时灵活性和封装。</li>
<li>要明白，运行时解决方案更灵活，更善于隐藏细节，但性能更差。</li>
<li>选择值语义解决方案而不是引用语义解决方案。</li>
</ul>
<h2 id="第十章-单例模式">第十章 单例模式
</h2><p>在本章中，我们将探讨（臭名昭著的）单例模式。我知道，您可能已经熟悉单例模式，并且可能已经有了强烈的看法，甚至有可能您认为单例是一种反模式，因此会问自己我是如何鼓起勇气将它包含在这本书中的。</p>
<p>其实，我清楚单例并不特别受欢迎，在许多圈子里有相当不好的名声，尤其是因为单例的全局性质。然而，从这个角度来看，了解到C++标准库中存在一些“单例”实例可能会让您非常惊讶。确实如此！而且，坦率地说，它们工作得非常好！因此，我们应该认真讨论什么是单例模式，何时使用单例模式，以及如何正确处理单例模式。</p>
<p><strong>指南37：将单例视为实现模式而非设计模式</strong></p>
<p>在本节中，我将解释单例模式，并通过一个非常常用的实现——所谓的Meyers&rsquo; Singleton来演示它是如何工作的。然而，我也会强烈建议不要将单例视为设计模式，而应将其视为实现模式。</p>
<p><strong>指南38：为变化和可测试性设计单例</strong></p>
<p>我们接受这样一个事实：有时我们需要一种解决方案来表示代码中的少数全局方面。这正是单例模式常被使用的地方。这也意味着我们会遇到单例通常带来的一些问题：全局状态、许多强耦合的人工依赖关系以及受限的可变性和可测试性。虽然这些听起来像是避免使用单例的绝佳理由，但我会向您展示，通过合理的软件设计，您可以结合单例的优点与出色的可变性和可测试性。</p>
<h3 id="准则37将单例视为实现模式而非设计模式">准则37：将单例视为实现模式而非设计模式
</h3><p>让我们首先解决房间里的大象问题： <strong>单例并不是一种设计模式。</strong></p>
<p>如果您之前没有听说过单例，那么这可能完全没有任何意义，但请耐心听我解释。我会很快解释什么是单例模式。如果您已经听说过单例，那么您要么点头表示同意，并露出同情的“我知道”的表情，要么会感到震惊，最初不知道该说什么。“但是为什么不是呢？”您最终可能会问。“它不是四人组（Gang of Four）书中原始设计模式之一吗？”是的，您说得对：单例是GoF书中记录的23个原始模式之一。在撰写本文时，维基百科称其为设计模式，甚至在Steve McConnell的畅销书《代码大全》中也被列为设计模式。然而，它仍然不是一个设计模式，因为它不具备设计模式的特性。让我来解释一下。</p>
<p><strong>1. 单例模式解释</strong></p>
<p>有时，您可能希望确保某个特定类只有一个且仅有一个实例。换句话说，您有一个“ Highlander”情况：“只能有一个。”这可能适用于系统范围的数据库、唯一的日志记录器、系统时钟、系统配置等，简而言之，任何不应被多次实例化的类，因为它代表的是唯一存在的事物。这就是单例模式的意图。</p>
<p><strong>单例模式</strong></p>
<p><strong>意图：</strong> “确保一个类只有一个实例，并提供一个全局访问点。”</p>
<p>这个意图由四人组用图10-1中的UML图进行了可视化展示，该图引入了<code>instance()</code>函数作为唯一实例的全局访问点。</p>
<p><strong>图10-1. 单例模式的UML表示</strong></p>
<p>有多种方法可以限制实例数量为一个。其中最实用和最常见的单例形式之一是Meyers&rsquo; Singleton。以下是一个实现为Meyers&rsquo; Singleton的<code>Database</code>类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Database.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Database</span> <span class="k">final</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Database</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">Database</span> <span class="n">db</span><span class="p">;</span>  <span class="c1">// The one, unique instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多与数据库相关的功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能包括对数据成员的访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Database</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// 默认构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="p">(</span><span class="n">Database</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// 禁止拷贝构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Database</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// 禁止赋值操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="p">(</span><span class="n">Database</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// 禁止移动构造
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Database</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// 禁止移动赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能包含一些数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Meyers&rsquo; Singleton的核心在于，您只能通过公共静态<code>instance()</code>函数访问<code>Database</code>类的单一实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Database.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第一次访问，创建数据库对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="o">&amp;</span> <span class="n">db1</span> <span class="o">=</span> <span class="n">Database</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第二次访问，返回同一个对象的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="o">&amp;</span> <span class="n">db2</span> <span class="o">=</span> <span class="n">Database</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db1</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">db2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，这个函数是获取<code>Database</code>的唯一途径：所有可能用于创建、拷贝或移动实例的功能都被声明为私有或显式删除。虽然这看起来相当简单，但有一个实现细节特别值得注意：请注意，默认构造函数是显式定义而不是默认生成的。原因是如果它是默认生成的，在C++17之前，可以通过空的大括号初始化一个<code>Database</code>实例，即通过值初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Database</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 如前所述
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Database</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  <span class="c1">// 编译器生成的默认构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 如前所述
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Database</span> <span class="n">db</span><span class="p">;</span>    <span class="c1">// 不编译：默认初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span> <span class="n">db</span><span class="p">{};</span>  <span class="c1">// 工作正常，因为值初始化导致聚合初始化，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 因为Database是一个聚合类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在C++17之前，<code>Database</code>类被视为聚合类型，这意味着值初始化将通过聚合初始化进行。聚合初始化会忽略默认构造函数，包括其私有属性，并简单地执行对象的零初始化。因此，值初始化允许您仍然创建一个实例。然而，如果您提供了默认构造函数，则该类不再被视为聚合类型，从而防止了聚合初始化。</p>
<p><code>instance()</code>函数是基于静态局部变量实现的。这意味着第一次控制流经过声明时，变量会在线程安全的方式下初始化，并在后续调用中跳过初始化。每次调用，无论是第一次还是之后的调用，函数都会返回对静态局部变量的引用。</p>
<p>其余的<code>Database</code>类基本上就是您期望从表示数据库的类中看到的内容：有一些公共的、与数据库相关的函数（例如<code>write()</code>和<code>read()</code>），并且可能有一些数据成员及其访问函数。换句话说，除了<code>instance()</code>成员函数和特殊的成员函数外，<code>Database</code>只是一个普通的类。</p>
<p>通过这种方式，Meyers&rsquo; Singleton不仅保证了单例的唯一性，还避免了许多其他单例实现中常见的复杂性和潜在问题。这种实现方式简单、高效且线程安全，使其成为许多场景下的首选方案。</p>
<p><strong>单例模式并不管理或减少依赖关系</strong></p>
<p>现在，考虑到单例的一种可能实现，让我们回到我的主张：单例并不是一种设计模式。首先，让我们回顾一下我在“准则11：理解设计模式的目的”中定义的设计模式的特性：</p>
<p><strong>设计模式：</strong></p>
<ul>
<li>有一个名称</li>
<li>携带意图</li>
<li>引入抽象</li>
<li>已被证明有效</li>
</ul>
<p>单例模式确实有一个名称，并且确实有其意图。这一点毫无疑问。我也会声称它多年来已经被证明有效（尽管可能有一些怀疑的声音指出单例模式相当臭名昭著）。然而，它并没有引入任何抽象：没有基类，没有模板参数，什么都没有。单例本身不代表抽象，也不引入抽象。实际上，它并不关心代码的结构或实体之间的交互和依赖关系，因此它并不旨在管理和减少依赖。然而，这是我定义为软件设计不可分割的一部分。</p>
<p>相反，单例的重点是将实例的数量限制为恰好一个。因此，单例不是设计模式，而只是一个实现模式。</p>
<p><strong>那么为什么在许多重要资料中它被列为设计模式呢？</strong></p>
<p>这是一个公平且好的问题。对此可能有三个答案：</p>
<ol>
<li><strong>在其他编程语言中，特别是那些每个类都可以自动代表抽象的语言，情况可能不同。</strong> 虽然我承认这一点，但我仍然认为单例模式的主要目标是针对实现细节，而不是依赖性和解耦。尽管如此，在某些编程语言中，单例模式可能会有不同的表现形式和用途。</li>
<li><strong>单例非常常用（尽管经常也被误用），因此它确实是一种模式。</strong> 由于许多不同的编程语言中都有单例，它看起来不仅仅是C++编程语言中的一个惯用法。因此，将其称为设计模式似乎是合理的。这一系列论点听起来可能是有道理的，但我认为它未能区分软件设计和实现细节。这就是为什么在“指南11：理解设计模式的目的”中，我引入了“实现模式”这个术语，以区分像单例这样的语言无关的模式类型。</li>
<li><strong>我相信我们仍在逐步理解软件设计和设计模式。</strong> 对软件设计没有一个共同的定义。正因为如此，我在“指南1：理解软件设计的重要性”中提出了一个定义。对设计模式也没有一个共同的定义。这也是为什么我在“指南11：理解设计模式的目的”中提出一个定义的原因。我坚信我们必须更多地讨论软件设计和模式，以便达成对必要术语的共同理解，特别是在C++中。</li>
</ol>
<p><strong>总结</strong></p>
<p>您不会使用单例来解耦软件实体。因此，尽管它在著名的GoF书中被描述，或者在《代码大全》中提及，甚至在维基百科上被列为设计模式，但它并不符合设计模式的目的。单例只是处理实现细节，因此您应将其视为实现模式。</p>
<ul>
<li><strong>单例的目标不是解耦或管理依赖，因此它不符合设计模式的期望。</strong></li>
<li>应用单例模式时，请记住其目的是将某个特定类的实例数量限制为恰好一个。</li>
</ul>
<h3 id="准则38为变化和可测试性设计单例">准则38：为变化和可测试性设计单例
</h3><p><strong>单例模式确实是一个相当臭名昭著的模式：</strong> 许多人认为单例是代码中的普遍问题，是一种反模式，甚至是危险或邪恶的。因此，有很多建议避免使用这种模式，其中包括核心指南I.3：</p>
<p><strong>避免单例。</strong></p>
<p>人们不喜欢单例的一个主要原因是因为它经常导致人为的依赖关系并阻碍可测试性。因此，它与本书中两个最重要和最通用的指南相悖：“指南2：为变化而设计”和“指南4：为可测试性而设计”。从这个角度来看，单例确实看起来像是代码中的一个问题，应该避免。然而，尽管有这些善意的警告，许多开发者仍然持续使用该模式。原因多种多样，但可能主要与以下两个事实有关：首先，有时（我们同意有时）表达某事物只存在一次并且应可供代码中的许多实体使用是有必要的。其次，有时单例似乎是适当的解决方案，因为需要表示全局方面。</p>
<p><strong>单例代表全局状态</strong></p>
<p>单例主要用于表示在程序中逻辑上和/或物理上仅存在一次且应被许多其他类和函数使用的实体。常见的例子包括系统范围的数据库、日志记录器、时钟或配置。这些例子，包括“系统范围”这个词，表明了这些实体的本质：它们通常代表全局可用的功能或数据，即全局状态。从这个角度来看，单例模式似乎是有意义的：通过防止每个人创建新的实例，并强制每个人都使用唯一的实例，您可以保证所有使用实体对这一全局状态的一致访问。</p>
<p>然而，这种全局状态的表示和引入解释了为什么单例通常被认为是一个问题。正如Michael Feathers所表达的：</p>
<p><strong>单例模式是人们用来创建全局变量的机制之一。</strong> 一般来说，全局变量有几个坏处。其中一个原因是不透明性。</p>
<p>全局变量确实是不好的，特别是因为一个重要的原因：术语“变量”暗示我们在讨论可变的全局状态。这种状态确实会引起很多麻烦。明确地说，可变的全局状态（尤其是在多线程环境中）是令人反感的，因为它难以控制访问并确保正确性。此外，全局（可变）状态很难推理，因为对该状态的读写访问通常在某些函数内部不可见，基于其接口，不会揭示它使用了全局状态的事实。最后但并非最不重要的是，如果您有多个全局变量，它们的生命周期相互依赖并且分布在多个编译单元中，您可能会面临静态初始化顺序灾难（SIOF）。显然，尽量避免全局状态是有益的。</p>
<p>然而，全局状态的问题并不是通过避免单例就能解决的。这是一个普遍存在的问题，与任何特定模式无关。例如，同样的问题也存在于Monostate模式中，它强制单一的全局状态但允许任意数量的实例化。相反，单例可以通过限制对其的访问来帮助处理全局状态。例如，正如Miško Hevery在他的2008年文章中解释的，提供单向数据流到某些全局状态的单例是可以接受的：实现日志记录器的单例只会允许您写入数据但不允许读取。表示系统范围配置或时钟的单例只会允许您读取数据但不允许写入，从而表示全局常量。限制单向数据流有助于避免许多与全局状态相关的问题。用Miško Hevery的话来说（强调部分是我的）：</p>
<p><strong>适当使用“全局”或半全局状态可以大大简化应用程序的设计[&hellip;]。</strong></p>
<p><strong>单例阻碍变化性和可测试性</strong></p>
<p>全局状态是单例固有的问题。然而，即使我们对使用单例表示全局状态感到满意，也会有严重的后果：使用单例的函数依赖于表示的全局数据，因此变得更难改变和更难测试。为了更好地理解这一点，让我们重新审视“指南37：将单例视为实现模式而非设计模式”中的<code>Database</code>单例，现在它被几个任意类（即<code>Widget</code>和<code>Gadget</code>）积极使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Widget.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Database.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">(</span> <span class="cm">/*some arguments*/</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Database</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">read</span><span class="p">(</span> <span class="cm">/*some arguments*/</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//---- &lt;Gadget.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Database.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Gadget</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">(</span> <span class="cm">/*some arguments*/</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Database</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">write</span><span class="p">(</span> <span class="cm">/*some arguments*/</span> <span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Widget</code>和<code>Gadget</code>都需要访问系统范围的<code>Database</code>。因此，它们调用了<code>Database::instance()</code>函数，然后调用了<code>read()</code>和<code>write()</code>函数。</p>
<p>由于它们使用了<code>Database</code>并因此依赖于它，我们希望它们位于架构层次中低于<code>Database</code>单例的层次。这是因为，正如您在“指南2：为变化而设计”中记得的那样，只有当所有依赖箭头都指向高层次时，我们才能称之为正确的架构（参见图10-2）。</p>
<p><strong>图10-2. 实现为单例的Database的期望依赖图</strong></p>
<p>尽管这种依赖结构可能是理想的，但不幸的是它只是一个幻象：<code>Database</code>类不是抽象而是具体实现，代表了对非常具体的数据库的依赖！因此，实际的依赖结构是倒置的，看起来像图10-3。</p>
<p>实际的依赖结构完全违背了依赖倒置原则（DIP）（参见“指南9：注意抽象的所有权”）：所有依赖箭头都指向低层次。换句话说，目前根本没有软件架构！</p>
<p><strong>图10-3. 实现为单例的Database的实际依赖图</strong></p>
<p>由于<code>Database</code>是一个具体的类而不是抽象，整个代码中有强甚至不可见的依赖关系，具体到<code>Database</code>类的具体实现细节和设计选择。这可能——在最坏的情况下——包括对供应商特定细节的依赖，这些细节在整个代码中可见，出现在许多不同的地方，后来使得更改变得极其困难甚至不可能。因此，代码变得更加难以更改。</p>
<p>考虑这种依赖关系如何严重影响测试。所有使用依赖于<code>Database</code>单例的函数的测试本身也依赖于单例。这意味着，例如，对于每个使用<code>Widget::doSomething()</code>函数的测试，您总是必须提供唯一的<code>Database</code>类。不幸的原因也很简单：这些函数没有为您提供替换<code>Database</code>的方法：任何形式的桩、模拟或伪造。它们都将<code>Database</code>单例视为它们珍贵的秘密。因此，可测试性受到严重阻碍，编写测试变得如此困难，以至于您可能会完全放弃编写测试。</p>
<p>这个例子确实展示了单例的常见问题以及它们引入的不幸的人为依赖关系。这些依赖关系使系统更加僵硬，更难以改变和测试。当然，这不应该发生。相反，应该很容易替换一个数据库实现，并且应该很容易测试使用数据库的功能。正是出于这些原因，我们必须确保<code>Database</code>成为适当架构低层次上的真正实现细节。</p>
<p>“但是等一下，您刚才说如果<code>Database</code>是一个实现细节，就没有架构，对吗？” 是的，我确实是这么说的。而且在这种情况下我们无能为力：<code>Database</code>单例不代表任何抽象，也无法帮助我们处理依赖关系。单例根本不是一个设计模式。因此，为了消除对<code>Database</code>类的依赖并使架构起作用，我们必须通过引入抽象并使用真正的设计模式来为变化和可测试性进行设计。为此，让我们看一下一个使用C++标准库中的单例处理全局方面的良好示例。</p>
<p><strong>反转单例上的依赖关系</strong></p>
<p>我回到了一个真正的设计模式宝藏，我已经多次使用它来演示不同的设计模式：C++17的多态内存资源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span> <span class="mi">1000</span><span class="o">&gt;</span> <span class="n">raw</span><span class="p">;</span>  <span class="c1">// 注意：未初始化！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span> <span class="n">raw</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">raw</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()</span> <span class="p">};</span>  
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，我们配置了<code>std::pmr::monotonic_buffer_resource</code>（称为<code>buffer</code>），使其仅与给定的<code>std::array raw</code>中的静态内存一起工作。如果这些内存耗尽，<code>buffer</code>将尝试通过其上游分配器获取新内存，我们指定该分配器为<code>std::pmr::null_memory_resource()</code>。通过这个分配器分配内存永远不会返回任何内存，而总是抛出<code>std::bad_alloc()</code>异常。因此，<code>buffer</code>被限制在由<code>raw</code>提供的1000字节内。</p>
<p>虽然您应该立即记住并识别这是一个装饰器设计模式的例子，但这也可以作为单例模式的一个示例：每次调用<code>std::pmr::null_memory_resource()</code>函数时，它都会返回同一个分配器的指针，并因此充当访问唯一实例的单一入口点。因此，返回的分配器就像一个单例。尽管这个单例不提供单向数据流（毕竟我们可以分配内存并归还它），但单例在这种情况下仍然感觉是一个合理的选择，因为它代表了一种全局状态：内存。</p>
<p>特别值得注意的是，这个单例不会让你依赖于分配器的具体实现细节。恰恰相反：<code>std::pmr::null_memory_resource()</code>函数返回一个指向<code>std::pmr::memory_resource</code>的指针。这个类是所有类型分配器的基类（至少在C++17范围内），因此它作为一个抽象层。然而，<code>std::pmr::null_memory_resource()</code>代表了一个特定的分配器，一个具体的选择，我们现在依赖于它。由于这个功能在标准库中，我们往往不会将其视为依赖项，但从一般意义上讲，它确实是：我们没有机会替换标准特定的实现。</p>
<p>如果我们用<code>std::pmr::get_default_resource()</code>替换对<code>std::pmr::null_memory_resource()</code>的调用，情况就会改变：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span> <span class="n">raw</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">raw</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">get_default_resource</span><span class="p">()</span> <span class="p">};</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>std::pmr::get_default_resource()</code>函数也返回一个指向<code>std::pmr::memory_resource</code>的指针，它代表系统范围默认分配器的抽象。默认情况下，返回的分配器是由<code>std::new_delete_resource()</code>函数返回的。然而，令人惊讶的是，这个默认值可以通过<code>std::pmr::set_default_resource()</code>函数进行自定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">memory_resource</span><span class="o">*</span> <span class="nf">set_default_resource</span><span class="p">(</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace std::pmr
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用这个函数，我们可以将<code>std::pmr::null_memory_resource()</code>定义为新的系统范围默认分配器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">set_default_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">());</span>   
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer</span><span class="p">{</span> <span class="n">raw</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">raw</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">get_default_resource</span><span class="p">()</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过<code>std::pmr::set_default_resource()</code>，您可以自定义系统范围的分配器。换句话说，这个函数为您提供注入对该分配器依赖的能力。这听起来熟悉吗？我希望这能让您想到另一个基本的设计模式……鼓声响起……是的，正确答案：策略设计模式。</p>
<p>确实，这是一个策略。使用这种设计模式是一个极好的选择，因为它对架构产生了惊人的影响。虽然<code>std::pmr::memory_resource</code>代表所有可能分配器的抽象，因此可以位于架构的高层次，但任何具体的分配器实现，包括所有（供应商特定）实现细节，都可以位于架构的最低层次。为了说明这一点，考虑以下<code>CustomAllocator</code>类的草图：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;CustomAllocator.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CustomAllocator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 不需要强制单例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">CustomAllocator</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有显式声明的复制或移动操作 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">do_allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">do_deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">alignment</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">do_is_equal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，<code>CustomAllocator</code>公开继承自<code>std::pmr::memory_resource</code>以符合C++17分配器的要求。因此，您可以使用<code>std::pmr::set_default_resource()</code>函数将<code>CustomAllocator</code>实例设置为新的系统范围默认分配器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;CustomAllocator.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">CustomAllocator</span> <span class="n">custom_allocator</span><span class="p">{</span><span class="cm">/*...*/</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">set_default_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">custom_allocator</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然<code>std::pmr::memory_resource</code>基类位于架构的最高层次，但<code>CustomAllocator</code>逻辑上位于架构的最低层次（参见图10-4）。因此，策略模式导致了依赖关系的反转（参见“指南9：注意抽象的所有权”）：尽管分配器具有单例性，尽管它们表示全局状态，但我们依赖于抽象而不是具体实现细节。</p>
<p><strong>图10-4. 通过<code>std::pmr::memory_resource</code>抽象实现的依赖反转</strong></p>
<p>顺便提一下，值得指出的是，通过这种方法，您可以轻松避免任何对全局初始化顺序的依赖（即SIOF），因为您可以通过在同一编译单元中创建所有单例来显式管理初始化顺序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 系统范围内唯一的时钟没有生命周期依赖。因此首先创建它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SystemClock</span> <span class="n">clock</span><span class="p">{</span><span class="cm">/*...*/</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 系统范围内唯一的配置依赖于时钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SystemConfiguration</span> <span class="n">config</span><span class="p">{</span><span class="o">&amp;</span><span class="n">clock</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>应用策略设计模式</strong></p>
<p>基于前面的例子，您现在应该有一个如何修复我们的数据库示例的想法。提醒一下，目标是保持<code>Database</code>类作为默认数据库实现，但使其成为一个实现细节，即移除对具体实现的所有依赖。您需要做的就是应用策略设计模式，在架构的高层次上引入一个抽象、全局访问点和依赖注入点。这将使任何人（我真的指任何人，因为你也遵循开放封闭原则（OCP）；参见“指南5：为扩展设计”）能够在最低层次引入自定义数据库实现（包括具体的实现以及测试桩、模拟或虚假对象）。因此，让我们引入以下<code>PersistenceInterface</code>抽象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;PersistenceInterface.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PersistenceInterface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">PersistenceInterface</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">do_read</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">write</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">do_write</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多数据库特定的功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">do_read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">do_write</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="nf">get_persistence_interface</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set_persistence_interface</span><span class="p">(</span><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 声明唯一的实例变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">instance</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>PersistenceInterface</code>基类提供了所有可能数据库实现的接口。例如，它引入了<code>read()</code>和<code>write()</code>函数，这些函数分为公共接口部分和私有实现部分，基于<code>std::pmr::memory_resource</code>类的例子。当然，在现实中它会引入一些更多的数据库特定功能，但为了这个例子，让我们假设<code>read()</code>和<code>write()</code>已经足够。</p>
<p>除了<code>PersistenceInterface</code>之外，你还需要引入一个名为<code>get_persistence_interface()</code>的全局访问点（）和一个用于启用依赖注入的函数<code>set_persistence_interface()</code>（）。这两个函数允许你访问和设置全局持久化系统（）。</p>
<p><code>Database</code>类现在继承自<code>PersistenceInterface</code>基类并实现了所需的接口（希望遵守里氏替换原则（LSP）；参见“指南6：遵守抽象的预期行为”）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Database.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Database</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PersistenceInterface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 可能的数据成员访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过删除复制和移动操作使类不可移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Database</span><span class="p">(</span><span class="n">Database</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Database</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Database</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Database</span><span class="p">(</span><span class="n">Database</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Database</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Database</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">do_read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">do_write</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// ... 更多数据库特定的功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... 可能的一些数据成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在我们的特殊设置中，<code>Database</code>类代表默认的数据库实现。我们需要创建一个默认的数据库实例，以防没有其他持久化系统通过<code>set_persistence_interface()</code>函数指定。然而，如果任何其他持久化系统在创建<code>Database</code>之前被设置为系统范围的数据库，我们就不能创建实例，因为这会导致不必要的开销。这种行为通过使用两个静态局部变量和立即调用的lambda表达式（IILE）来实现<code>get_persistence_interface()</code>函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;PersistenceInterface.cpp&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Database.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义唯一的一个实例变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="nf">get_persistence_interface</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 局部对象，由一个&#39;立即调用的lambda表达式(IILE)&#39;初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="kt">bool</span> <span class="n">init</span> <span class="o">=</span> <span class="p">[](){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">static</span> <span class="n">Database</span> <span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// 或者false，实际值并不重要。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}();</span>  <span class="c1">// 注意lambda表达式后的&#39;()&#39;，这会调用lambda。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set_persistence_interface</span><span class="p">(</span><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">instance</span> <span class="o">=</span> <span class="n">persistence</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一次执行流进入<code>get_persistence_interface()</code>函数时，静态局部变量<code>init</code>被初始化。如果此时<code>instance</code>已经被设置，则不会创建<code>Database</code>实例。但如果还没有，<code>Database</code>实例将在lambda内部作为另一个静态局部变量创建，并绑定到<code>instance</code>变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;PersistenceInterface.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第一次访问，创建数据库对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence</span> <span class="o">=</span> <span class="n">get_persistence_interface</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种实现达到了预期的效果：<code>Database</code>成为了一个实现细节，没有任何其他代码依赖于它，并且可以随时被自定义数据库实现替换（参见图10-5）。因此，尽管<code>Database</code>具有单例性质，但它并没有引入依赖关系，并且可以很容易地更改和替换以进行测试。</p>
<p><strong>图10-5. 重构后的非单例数据库的依赖图</strong></p>
<p>“哇，这是一个很棒的解决方案。我敢打赌我可以在自己的代码库中的几个地方使用它！”你带着钦佩的表情说。“但是我看出了一个潜在的问题：由于我必须从一个接口类继承，这是一个侵入性的解决方案。如果我不能修改给定的单例类怎么办？”在这种情况下，你有两种非侵入性的设计模式可以选择。要么你已经有了一个继承层次结构，这种情况下你可以引入一个适配器来包装给定的单例（参见“指南24：使用适配器标准化接口”），要么你还没有建立继承层次结构，这种情况下你可以很好地利用外部多态设计模式（参见“指南31：使用外部多态实现非侵入式的运行时多态性”）。</p>
<p>“好的，但我看到了另一个更严重的问题：这段代码真的线程安全吗？”老实说，不，它不是。举一个可能出现问题的例子：在首次调用<code>get_persistence_interface()</code>时，可能会由于<code>Database</code>实例的设置花费一些时间，而在此期间<code>set_persistence_interface()</code>被调用。在这种情况下，要么<code>Database</code>白费力气创建，要么<code>set_persistence_interface()</code>的调用丢失。然而，也许令人惊讶的是，这不是我们需要解决的问题。原因如下：记住<code>instance</code>表示全局状态。如果我们假设<code>set_persistence_interface()</code>可以从代码中的任何地方随时调用，一般来说我们不能期望在调用<code>set_persistence_interface()</code>之后，对<code>get_persistence_interface()</code>的调用会返回设定的值。因此，从代码中的任意位置调用<code>set_persistence_interface()</code>函数就像在别人脚下抽走地毯。这类似于对任何左值调用<code>std::move()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">T</span> <span class="n">other</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>  <span class="c1">// 非常糟糕的操作（字面意思！）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这个角度来看，<code>set_persistence_interface()</code>函数应在程序开始时或单个测试开始时使用，而不是随意使用。</p>
<p>“我们不应该确保<code>set_persistence_interface()</code>函数只能调用一次吗？”你问。我们当然可以这样做，但这会人为地限制其在测试目的上的使用：我们将无法在每个单独的测试开始时重置持久化系统。</p>
<p><strong>向局部依赖注入迈进</strong></p>
<p>“好的，我明白了。最后一个问题：由于这个解决方案涉及可以更改的全局状态，使用更直接和更局部的依赖注入到低层类中会不会更好？考虑以下对<code>Widget</code>类的修改，它在构造时被赋予了其依赖：”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Widget.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;PersistenceInterface.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Widget</span><span class="p">(</span><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence</span><span class="p">)</span>  <span class="c1">// 依赖注入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">:</span> <span class="n">persistence_</span><span class="p">(</span><span class="n">persistence</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">doSomething</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">persistence_</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence_</span><span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我完全同意你的观点。这可能是解决全局状态问题的下一步。然而，在我们分析这种方法之前，请记住，这个想法之所以成为可能，是因为我们已经反转了依赖关系。通过在架构的高层次引入抽象，我们突然有了选择，并可以讨论替代方案。因此，第一步也是最重要的一步是正确管理依赖关系。但回到你的建议：我真的很喜欢这种方法。<code>Widget</code>类的接口变得更加“诚实”，并清楚地显示了它的所有依赖。而且，由于依赖是通过构造函数参数传递的，依赖注入变得更加直观和自然。</p>
<p>另外，你可以在<code>Widget::doSomething()</code>函数中直接传递依赖：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Widget.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;PersistenceInterface.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">(</span><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">persistence</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然这种方法对于成员函数来说可能不是最佳选择，但对于自由函数来说，这可能是唯一的选择。再次强调，通过显式声明其依赖，函数变得“更加诚实”。</p>
<p>然而，这种直接依赖注入有一个缺点：这种方法在大型调用栈中可能会迅速变得难以处理。通过软件栈的多个层次传递依赖以使其在需要的地方可用，既不方便也不直观。此外，特别是在存在多个单例的情况下，解决方案很快就会变得笨拙：例如，为了能够在最低层次上使用它们，必须通过许多层次的函数调用来传递<code>PersistenceInterface</code>、分配器和系统范围的配置，这确实不是一个最优雅的方法。因此，你可能希望结合提供全局访问点和局部依赖注入的想法，例如通过引入一个包装函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//---- &lt;Widget.h&gt; ---------------- 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;PersistenceInterface.h&gt;</span><span class="cp"> 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">doSomething</span><span class="p">(</span><span class="n">get_persistence_interface</span><span class="p">(),</span> <span class="cm">/* some arguments */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">doSomething</span><span class="p">(</span><span class="n">PersistenceInterface</span><span class="o">*</span> <span class="n">persistence</span><span class="p">,</span> <span class="cm">/* some arguments */</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">persistence</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="cm">/* some arguments */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>尽管我们仍然提供了之前的<code>doSomething()</code>函数，但现在还额外提供了一个接受<code>PersistenceInterface</code>作为函数参数的重载版本。第二个函数完成所有工作，而第一个函数现在仅充当一个包装器，它注入了全局设置的<code>PersistenceInterface</code>。在这种组合中，可以在本地做出决策并在本地注入所需的依赖，同时不需要通过多层函数调用来传递依赖。</p>
<p>然而，说实话，尽管这些解决方案在这个数据库示例以及内存管理的上下文中可能非常有效，但它并不适用于每一个单例问题。因此，不要认为这是唯一的解决方案。毕竟，这取决于具体情况。然而，这是一个很好的软件设计通用过程的例子：识别变化或导致依赖的部分，然后通过提取合适的抽象来分离关注点。根据你的意图，你只是应用了一个设计模式。因此，考虑相应地命名你的解决方案，并通过这种方式留下你的推理痕迹供他人参考。</p>
<p>总结一下，单例模式当然不是最引人注目的模式之一。它带有太多的缺点，最重要的是全局状态通常存在的缺陷。但是，尽管有许多负面方面，如果谨慎使用，单例可以是在某些情况下表示代码中少数全局方面的正确解决方案。如果是这样，请优先选择具有单向数据流的单例，并通过反转依赖关系和启用依赖注入（使用策略设计模式）来设计单例以支持可变性和可测试性。</p>
<p><strong>本节总结</strong></p>
<ul>
<li>注意单例代表全局状态及其所有缺陷。</li>
<li>尽量避免全局状态。</li>
<li>谨慎使用单例，仅用于代码中的少数全局方面。</li>
<li>优先选择具有单向数据流的单例。</li>
<li>使用策略设计模式反转对单例的依赖，以消除通常对可变性和可测试性的阻碍。</li>
</ul>
<h2 id="第十一章-最后的准则">第十一章 最后的准则
</h2><p>只剩下一条指南，一条我可以传授给你的最后建议。这就是它：最后的指南。</p>
<p><strong>准则39：继续学习设计模式</strong></p>
<p>“就这样？这就是你所有的内容？拜托，还有很多设计模式我们还没有触及！”你说。好吧，说实话，你是完全正确的；对此我没有什么可以补充的。但为了辩护自己，我原本计划介绍更多的模式，直到现实给了我一击：一本400页的书只能容纳这么多信息。不过不要担心：在这400页中，我已经带你经历了一段旅程，涵盖了你在软件开发职业生涯中任何设计中最重要、随时需要的建议：</p>
<p><strong>减少依赖</strong></p>
<p>处理依赖是软件设计的核心。无论你编写哪种类型的软件，如果你真的想让它持久存在，你就必须处理依赖关系：必要的依赖和主要的人为依赖。当然，你的主要目标是减少依赖，甚至最小化它们。为了实现这个目标，你不可避免地要使用设计模式。</p>
<p><strong>分离关注点</strong></p>
<p>这可能是你能从这本书中学到的最重要、最核心的设计指南。分离关注点，你的软件结构将变得清晰易懂、易于更改和测试。所有设计模式，无一例外，都为你提供了一种分离关注点的方法。不同模式之间的主要区别在于它们分离关注点的方式和意图。尽管设计模式在结构上可能相似，但它们的意图总是独特的。</p>
<p><strong>优先选择组合而非继承</strong></p>
<p>虽然继承是一个强大的特性，但许多设计模式的真正力量源于基于组合构建。例如，策略设计模式（一个无处不在的模式，并且希望现在这一点已经很明显了）主要基于组合来分离关注点，但也为你提供了使用继承扩展功能的选择。桥接模式、适配器模式、装饰器模式、外部多态模式和类型擦除模式也是如此。</p>
<p><strong>优先选择非侵入式设计</strong></p>
<p>真正的灵活性和可扩展性来自于不必修改现有代码，而只需添加新代码。因此，任何非侵入式设计都优于侵入式修改现有代码的设计。因此，如装饰器模式、适配器模式、外部多态模式和类型擦除模式等设计模式是你设计模式工具箱中的宝贵补充。</p>
<p><strong>优先选择值语义而非引用语义</strong></p>
<p>为了保持代码简单、易懂，并远离诸如空指针、悬挂指针、生命周期依赖等问题，你应该优先使用值而不是指针和引用。C++是一门非常适合这一目的的语言，因为它认真对待值语义。它允许开发者在值语义的世界中过上幸福的生活。令人惊讶的是，正如我们在<code>std::variant</code>和类型擦除中看到的，这种哲学并不一定会对性能产生负面影响，反而可能会提高性能。</p>
<p>除了这些关于软件设计的一般建议外，你还了解了设计模式的目的。现在你知道什么是设计模式：</p>
<ul>
<li><strong>有一个名称</strong></li>
<li><strong>带有意图</strong></li>
<li><strong>引入抽象</strong></li>
<li><strong>经过验证</strong></li>
</ul>
<p>有了这些信息，你将不再会因为某些实现细节被误认为是设计模式（在我的职业生涯中多次遇到这种情况）而受骗，例如声称智能指针（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等）或工厂函数（如<code>std::make_unique()</code>）是设计模式的实现。此外，你现在熟悉了一些最重要和最有用的设计模式，它们将在未来不断证明其价值：</p>
<ul>
<li><strong>访问者模式</strong>：为了扩展对一组封闭类型的操作，选择访问者设计模式（可能通过<code>std::variant</code>实现）。</li>
<li><strong>策略模式</strong>：为了配置行为并从外部“注入”它，选择策略设计模式（也称为基于策略的设计）。</li>
<li><strong>命令模式</strong>：为了抽象不同类型的操作（可能是可撤销的操作），利用命令设计模式。</li>
<li><strong>观察者模式</strong>：为了观察某些实体的状态变化，选择观察者设计模式。</li>
<li><strong>适配器模式</strong>：为了不侵入地适应一个接口到另一个接口，使用适配器设计模式。</li>
<li><strong>CRTP（Curiously Recurring Template Pattern）</strong>：对于静态抽象，避免虚拟函数（并且你不能使用C++20的概念），应用CRTP设计模式。CRTP也可以用于创建编译时混合类。</li>
<li><strong>桥接模式</strong>：为了隐藏实现细节并减少物理依赖，使用桥接设计模式。</li>
<li><strong>原型模式</strong>：为了创建虚拟副本，选择原型设计模式。</li>
<li><strong>外部多态模式</strong>：为了通过外部添加多态行为促进松耦合，记住外部多态设计模式。</li>
<li><strong>类型擦除模式</strong>：为了结合外部多态的力量与值语义的优势，考虑类型擦除设计模式。</li>
<li><strong>装饰器模式</strong>：为了非侵入地向对象添加职责，选择装饰器设计模式的优点。</li>
</ul>
<p>然而，还有更多的设计模式！还有很多重要和有用的设计模式。因此，你应该继续学习设计模式。有两种方法可以做到这一点。首先，了解更多模式：了解它们的意图以及与其他设计模式的相似性和差异。同时，不要忘记设计模式是关于依赖结构，而不是实现细节。其次，你也应该更好地理解每个模式，并体验它们的优点和缺点。为此，请注意你工作代码库中使用的那些设计模式。我向你保证，你会发现很多：任何尝试管理和减少依赖的努力很可能都是设计模式的证明。所以，是的，设计模式无处不在！</p>
<p><strong>本节总结</strong></p>
<ul>
<li>了解更多的设计模式并理解它们的意图。</li>
<li>更深入地了解每个设计模式的优点和缺点。</li>
<li>在实际工作中寻找设计模式，亲身体验它们。</li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            国窖1573 - 
        
        2025 AKaKLya
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.0f4e44504cf40ab34cf124bb8fa71a5615b897b6d3841a1d2857b604319620c7.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
